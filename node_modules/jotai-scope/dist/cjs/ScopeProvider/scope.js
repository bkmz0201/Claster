"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScope = createScope;
const jotai_1 = require("jotai");
const globalScopeKey = {};
if (process.env.NODE_ENV !== 'production') {
    globalScopeKey.name = 'unscoped';
    globalScopeKey.toString = toString;
}
function createScope(atoms, atomFamilies, parentScope, scopeName) {
    const explicit = new WeakMap();
    const implicit = new WeakMap();
    const inherited = new WeakMap();
    const currentScope = {
        getAtom,
        cleanup() { },
        prepareWriteAtom(anAtom, originalAtom, implicitScope) {
            if (originalAtom.read === defaultRead &&
                isWritableAtom(originalAtom) &&
                isWritableAtom(anAtom) &&
                originalAtom.write !== defaultWrite &&
                currentScope !== implicitScope) {
                // atom is writable with init and holds a value
                // we need to preserve the value, so we don't want to copy the atom
                // instead, we need to override write until the write is finished
                const { write } = originalAtom;
                anAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);
                return () => {
                    anAtom.write = write;
                };
            }
            return undefined;
        },
    };
    if (scopeName && process.env.NODE_ENV !== 'production') {
        currentScope.name = scopeName;
        currentScope.toString = toString;
    }
    // populate explicitly scoped atoms
    for (const anAtom of atoms) {
        explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);
    }
    const cleanupFamiliesSet = new Set();
    for (const atomFamily of atomFamilies) {
        for (const param of atomFamily.getParams()) {
            const anAtom = atomFamily(param);
            if (!explicit.has(anAtom)) {
                explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);
            }
        }
        const cleanupFamily = atomFamily.unstable_listen((e) => {
            if (e.type === 'CREATE' && !explicit.has(e.atom)) {
                explicit.set(e.atom, [cloneAtom(e.atom, currentScope), currentScope]);
            }
            else if (!atoms.has(e.atom)) {
                explicit.delete(e.atom);
            }
        });
        cleanupFamiliesSet.add(cleanupFamily);
    }
    currentScope.cleanup = combineVoidFunctions(currentScope.cleanup, ...Array.from(cleanupFamiliesSet));
    /**
     * Returns a scoped atom from the original atom.
     * @param anAtom
     * @param implicitScope the atom is implicitly scoped in the provided scope
     * @returns the scoped atom and the scope of the atom
     */
    function getAtom(anAtom, implicitScope) {
        var _a, _b;
        if (explicit.has(anAtom)) {
            return explicit.get(anAtom);
        }
        if (implicitScope === currentScope) {
            // dependencies of explicitly scoped atoms are implicitly scoped
            // implicitly scoped atoms are only accessed by implicit and explicit scoped atoms
            if (!implicit.has(anAtom)) {
                implicit.set(anAtom, [cloneAtom(anAtom, implicitScope), implicitScope]);
            }
            return implicit.get(anAtom);
        }
        const scopeKey = implicitScope !== null && implicitScope !== void 0 ? implicitScope : globalScopeKey;
        if (parentScope) {
            // inherited atoms are copied so they can access scoped atoms
            // but they are not explicitly scoped
            // dependencies of inherited atoms first check if they are explicitly scoped
            // otherwise they use their original scope's atom
            if (!((_a = inherited.get(scopeKey)) === null || _a === void 0 ? void 0 : _a.has(anAtom))) {
                const [ancestorAtom, explicitScope] = parentScope.getAtom(anAtom, implicitScope);
                setInheritedAtom(inheritAtom(ancestorAtom, anAtom, explicitScope), anAtom, implicitScope, explicitScope);
            }
            return inherited.get(scopeKey).get(anAtom);
        }
        if (!((_b = inherited.get(scopeKey)) === null || _b === void 0 ? void 0 : _b.has(anAtom))) {
            // non-primitive atoms may need to access scoped atoms
            // so we need to create a copy of the atom
            setInheritedAtom(inheritAtom(anAtom, anAtom), anAtom);
        }
        return inherited.get(scopeKey).get(anAtom);
    }
    function setInheritedAtom(scopedAtom, originalAtom, implicitScope, explicitScope) {
        const scopeKey = implicitScope !== null && implicitScope !== void 0 ? implicitScope : globalScopeKey;
        if (!inherited.has(scopeKey)) {
            inherited.set(scopeKey, new WeakMap());
        }
        inherited.get(scopeKey).set(originalAtom, [
            scopedAtom, //
            explicitScope,
        ].filter(Boolean));
    }
    /**
     * @returns a copy of the atom for derived atoms or the original atom for primitive and writable atoms
     */
    function inheritAtom(anAtom, originalAtom, implicitScope) {
        if (originalAtom.read !== defaultRead) {
            return cloneAtom(originalAtom, implicitScope);
        }
        return anAtom;
    }
    /**
     * @returns a scoped copy of the atom
     */
    function cloneAtom(originalAtom, implicitScope) {
        // avoid reading `init` to preserve lazy initialization
        const scopedAtom = Object.create(Object.getPrototypeOf(originalAtom), Object.getOwnPropertyDescriptors(originalAtom));
        if (scopedAtom.read !== defaultRead) {
            scopedAtom.read = createScopedRead(originalAtom.read.bind(originalAtom), implicitScope);
        }
        if (isWritableAtom(scopedAtom) &&
            isWritableAtom(originalAtom) &&
            scopedAtom.write !== defaultWrite) {
            scopedAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);
        }
        return scopedAtom;
    }
    function createScopedRead(read, implicitScope) {
        return function scopedRead(get, opts) {
            return read(function scopedGet(a) {
                const [scopedAtom] = getAtom(a, implicitScope);
                return get(scopedAtom);
            }, //
            opts);
        };
    }
    function createScopedWrite(write, implicitScope) {
        return function scopedWrite(get, set, ...args) {
            return write(function scopedGet(a) {
                const [scopedAtom] = getAtom(a, implicitScope);
                return get(scopedAtom);
            }, function scopedSet(a, ...v) {
                const [scopedAtom] = getAtom(a, implicitScope);
                return set(scopedAtom, ...v);
            }, ...args);
        };
    }
    return currentScope;
}
function isWritableAtom(anAtom) {
    return 'write' in anAtom;
}
const { read: defaultRead, write: defaultWrite } = (0, jotai_1.atom)(null);
function toString() {
    return this.name;
}
function combineVoidFunctions(...fns) {
    return function combinedFunctions() {
        for (const fn of fns) {
            fn();
        }
    };
}
//# sourceMappingURL=scope.js.map