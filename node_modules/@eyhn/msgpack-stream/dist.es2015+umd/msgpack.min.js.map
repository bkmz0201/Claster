{"version":3,"file":"msgpack.min.js","mappings":"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","sources":["webpack://MessagePack/webpack/universalModuleDefinition","webpack://MessagePack/webpack/bootstrap","webpack://MessagePack/webpack/runtime/define property getters","webpack://MessagePack/webpack/runtime/hasOwnProperty shorthand","webpack://MessagePack/webpack/runtime/make namespace object","webpack://MessagePack/./src/utils/int.ts","webpack://MessagePack/./src/utils/utf8.ts","webpack://MessagePack/./src/ExtData.ts","webpack://MessagePack/./src/DecodeError.ts","webpack://MessagePack/./src/timestamp.ts","webpack://MessagePack/./src/ExtensionCodec.ts","webpack://MessagePack/./src/utils/typedArrays.ts","webpack://MessagePack/./src/Encoder.ts","webpack://MessagePack/./src/StreamEncoder.ts","webpack://MessagePack/./src/encode.ts","webpack://MessagePack/./src/utils/prettyByte.ts","webpack://MessagePack/./src/CachedKeyDecoder.ts","webpack://MessagePack/./src/Decoder.ts","webpack://MessagePack/./src/StreamDecoder.ts","webpack://MessagePack/./src/decode.ts","webpack://MessagePack/./src/utils/stream.ts","webpack://MessagePack/./src/decodeAsync.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MessagePack\"] = factory();\n\telse\n\t\troot[\"MessagePack\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n","/* eslint-disable @typescript-eslint/no-unnecessary-condition */\nimport { UINT32_MAX } from \"./int\";\n\nconst TEXT_ENCODING_AVAILABLE =\n  (typeof process === \"undefined\" || process?.env?.[\"TEXT_ENCODING\"] !== \"never\") &&\n  typeof TextEncoder !== \"undefined\" &&\n  typeof TextDecoder !== \"undefined\";\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_ENCODING\"] !== \"force\"\n  ? 200\n  : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE = sharedTextEncoder?.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n  ? UINT32_MAX\n  : typeof process !== \"undefined\" && process?.env?.[\"TEXT_DECODER\"] !== \"force\"\n  ? 200\n  : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder!.decode(stringBytes);\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n","export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError\";\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport class Encoder<ContextType = undefined> {\n  private pos = 0;\n  private view = new DataView(new ArrayBuffer(this.initialBufferSize));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxDepth = DEFAULT_MAX_DEPTH,\n    private readonly initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE,\n    private readonly sortKeys = false,\n    private readonly forceFloat32 = false,\n    private readonly ignoreUndefined = false,\n    private readonly forceIntegerToFloat = false,\n  ) {}\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.bytes.slice(0, this.pos);\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n  private encodeNumber(object: number) {\n    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        this.writeU8(0xca);\n        this.writeF32(object);\n      } else {\n        // float 64\n        this.writeU8(0xcb);\n        this.writeF64(object);\n      }\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeTE(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeJs(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    }\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport type { ExtData } from \"./ExtData\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_BUFFER_SIZE = 2048;\n\nexport class StreamEncoder<ContextType = undefined> {\n  private view = new DataView(new ArrayBuffer(2048));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxDepth = DEFAULT_MAX_DEPTH,\n    private readonly bufferSize = DEFAULT_BUFFER_SIZE,\n    private readonly sortKeys = false,\n    private readonly forceFloat32 = false,\n    private readonly ignoreUndefined = false,\n    private readonly forceIntegerToFloat = false,\n  ) {}\n\n  public *encode(object: unknown): Iterable<Uint8Array> {\n    const buffer = new Uint8Array(this.bufferSize);\n    let pos = 0;\n\n    for (let chunk of this.doEncode(object, 1)) {\n      if (chunk.length >= buffer.length) {\n        if (pos >= 0) {\n          yield buffer.slice(0, pos);\n        }\n        pos = 0;\n        yield chunk.slice();\n      } else {\n        while (chunk.length > 0) {\n          const readSize = Math.min(buffer.length - pos, chunk.length);\n          const read = chunk.subarray(0, readSize);\n          buffer.set(read, pos);\n          pos += read.length;\n          if (pos === buffer.length) {\n            yield buffer.slice();\n            pos = 0;\n          }\n          chunk = chunk.subarray(readSize, chunk.length);\n        }\n      }\n    }\n\n    if (pos >= 0) {\n      yield buffer.subarray(0, pos);\n    }\n  }\n\n  private doEncode(object: unknown, depth: number): Iterable<Uint8Array> {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      return this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      return this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      return this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      return this.encodeString(object);\n    } else {\n      return this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    if (this.view.byteLength < sizeToWrite) {\n      this.resizeBuffer(sizeToWrite * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    return this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      return this.writeU8(0xc2);\n    } else {\n      return this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number) {\n    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          return this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          return this.writeU8U8(0xcc, object);\n        } else if (object < 0x10000) {\n          // uint 16\n          return this.writeU8U16(0xcd, object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          return this.writeU8U32(0xce, object);\n        } else {\n          // uint 64\n          return this.writeU8U64(0xcf, object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          return this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          return this.writeU8I8(0xd0, object);\n        } else if (object >= -0x8000) {\n          // int 16\n          return this.writeU8I16(0xd1, object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          return this.writeU8I32(0xd2, object);\n        } else {\n          // int 64\n          return this.writeU8I64(0xd3, object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        return this.writeU8F32(0xca, object);\n      } else {\n        // float 64\n        return this.writeU8F64(0xcb, object);\n      }\n    }\n  }\n\n  private buildStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      return [0xa0 + byteLength];\n    } else if (byteLength < 0x100) {\n      // str 8\n      return [0xd9, byteLength];\n    } else if (byteLength < 0x10000) {\n      // str 16\n      const bytes = new DataView(new ArrayBuffer(3));\n      bytes.setUint8(0, 0xda);\n      bytes.setUint16(1, byteLength);\n      return new Uint8Array(bytes.buffer);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      const bytes = new DataView(new ArrayBuffer(5));\n      bytes.setUint8(0, 0xdb);\n      bytes.setUint32(1, byteLength);\n      return new Uint8Array(bytes.buffer);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      const header = this.buildStringHeader(byteLength);\n      this.bytes.set(header, 0);\n      utf8EncodeTE(object, this.bytes, header.length);\n      return this.writeBuffer(byteLength + header.length);\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      const header = this.buildStringHeader(byteLength);\n      this.bytes.set(header, 0);\n      utf8EncodeJs(object, this.bytes, header.length);\n      return this.writeBuffer(byteLength + header.length);\n    }\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      return this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      return this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      return this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      return this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private *encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      yield* this.writeU8U8(0xc4, size);\n    } else if (size < 0x10000) {\n      // bin 16\n      yield* this.writeU8U16(0xc5, size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      yield* this.writeU8U32(0xc6, size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    yield* this.writeU8a(bytes);\n  }\n\n  private *encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      yield* this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      yield* this.writeU8U16(0xdc, size);\n    } else if (size < 0x100000000) {\n      // array 32\n      yield* this.writeU8U32(0xdd, size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      yield* this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private *encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      yield* this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      yield* this.writeU8U16(0xde, size);\n    } else if (size < 0x100000000) {\n      // map 32\n      yield* this.writeU8U32(0xdf, size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        yield* this.encodeString(key);\n        yield* this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private *encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      yield* this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      yield* this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      yield* this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      yield* this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      yield* this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      yield* this.writeU8U8(0xc7, size);\n    } else if (size < 0x10000) {\n      // ext 16\n      yield* this.writeU8U16(0xc8, size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      yield* this.writeU8U32(0xc9, size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    yield* this.writeI8(ext.type);\n    yield* this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.view.setUint8(0, value);\n    return this.writeBuffer(1);\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, 0);\n    return this.writeBuffer(size);\n  }\n\n  private writeI8(value: number) {\n    this.view.setInt8(0, value);\n    return this.writeBuffer(1);\n  }\n\n  private writeU16(value: number) {\n    this.view.setUint16(0, value);\n    return this.writeBuffer(2);\n  }\n\n  private writeI16(value: number) {\n    this.view.setInt16(0, value);\n    return this.writeBuffer(2);\n  }\n\n  private writeU32(value: number) {\n    this.view.setUint32(0, value);\n    return this.writeBuffer(4);\n  }\n\n  private writeI32(value: number) {\n    this.view.setInt32(0, value);\n    return this.writeBuffer(4);\n  }\n\n  private writeF32(value: number) {\n    this.view.setFloat32(0, value);\n    return this.writeBuffer(4);\n  }\n\n  private writeF64(value: number) {\n    this.view.setFloat64(0, value);\n    return this.writeBuffer(8);\n  }\n\n  private writeU64(value: number) {\n    setUint64(this.view, 0, value);\n    return this.writeBuffer(8);\n  }\n\n  private writeI64(value: number) {\n    setInt64(this.view, 0, value);\n    return this.writeBuffer(8);\n  }\n\n  private writeU8U8(value: number, value2: number) {\n    this.view.setUint8(0, value);\n    this.view.setUint8(1, value2);\n    return this.writeBuffer(2);\n  }\n\n  private writeU8U16(u8: number, u16: number) {\n    this.view.setUint8(0, u8);\n    this.view.setUint16(1, u16);\n    return this.writeBuffer(3);\n  }\n\n  private writeU8U32(u8: number, u32: number) {\n    this.view.setUint8(0, u8);\n    this.view.setUint32(1, u32);\n    return this.writeBuffer(5);\n  }\n\n  private writeU8U64(u8: number, u64: number) {\n    this.view.setUint8(0, u8);\n    setUint64(this.view, 1, u64);\n    return this.writeBuffer(9);\n  }\n\n  private writeU8I8(value: number, value2: number) {\n    this.view.setUint8(0, value);\n    this.view.setInt8(1, value2);\n    return this.writeBuffer(2);\n  }\n\n  private writeU8I16(u8: number, i16: number) {\n    this.view.setUint8(0, u8);\n    this.view.setInt16(1, i16);\n    return this.writeBuffer(3);\n  }\n\n  private writeU8I32(u8: number, i32: number) {\n    this.view.setUint8(0, u8);\n    this.view.setInt32(1, i32);\n    return this.writeBuffer(5);\n  }\n\n  private writeU8I64(u8: number, i64: number) {\n    this.view.setUint8(0, u8);\n    setInt64(this.view, 1, i64);\n    return this.writeBuffer(9);\n  }\n\n  private writeU8F32(u8: number, f32: number) {\n    this.view.setUint8(0, u8);\n    this.view.setFloat32(1, f32);\n    return this.writeBuffer(5);\n  }\n\n  private writeU8F64(u8: number, f64: number) {\n    this.view.setUint8(0, u8);\n    this.view.setFloat64(1, f64);\n    return this.writeBuffer(9);\n  }\n\n  private *writeBuffer(length: number) {\n    yield this.bytes.subarray(0, length);\n  }\n}\n","import { Encoder } from \"./Encoder\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec\";\nimport type { ContextOf, SplitUndefined } from \"./context\";\nimport { StreamEncoder } from \"./StreamEncoder\";\n\nexport type EncodeOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * The size of the stream buffer.\n     *\n     * Defaults to 2048.\n     */\n    streamBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst defaultEncodeOptions: EncodeOptions = {};\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options: EncodeOptions<SplitUndefined<ContextType>> = defaultEncodeOptions as any,\n): Uint8Array {\n  const encoder = new Encoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxDepth,\n    options.initialBufferSize,\n    options.sortKeys,\n    options.forceFloat32,\n    options.ignoreUndefined,\n    options.forceIntegerToFloat,\n  );\n  return encoder.encodeSharedRef(value);\n}\n\nexport function encodeStream<ContextType = undefined>(\n  value: unknown,\n  options: EncodeOptions<SplitUndefined<ContextType>> = defaultEncodeOptions as any,\n): Iterable<Uint8Array> {\n  const encoder = new StreamEncoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxDepth,\n    options.streamBufferSize,\n    options.sortKeys,\n    options.forceFloat32,\n    options.ignoreUndefined,\n    options.forceIntegerToFloat,\n  );\n  return encoder.encode(value);\n}\n","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n","import { utf8DecodeJs } from \"./utils/utf8\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e: any) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = UINT32_MAX,\n    private readonly maxBinLength = UINT32_MAX,\n    private readonly maxArrayLength = UINT32_MAX,\n    private readonly maxMapLength = UINT32_MAX,\n    private readonly maxExtLength = UINT32_MAX,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | BufferSource): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | BufferSource) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | BufferSource): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    const object = this.doDecodeSync();\n    if (this.hasRemaining(1)) {\n      throw this.createExtraByteError(this.pos);\n    }\n    return object;\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n\n    while (this.hasRemaining(1)) {\n      yield this.doDecodeSync();\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | BufferSource>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createExtraByteError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\nimport { DecodeError } from \"./DecodeError\";\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e: any) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nexport const DEFAULT_BUFFER_SIZE = 2048;\n\nexport class StreamDecoder<ContextType = undefined> {\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n  private readonly readStream: AsyncIterator<Uint8Array, any, number | undefined>;\n  private buffer: Uint8Array | null = null;\n\n  public constructor(\n    private readonly readIterable: AsyncIterable<Uint8Array>,\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = UINT32_MAX,\n    private readonly maxBinLength = UINT32_MAX,\n    private readonly maxArrayLength = UINT32_MAX,\n    private readonly maxMapLength = UINT32_MAX,\n    private readonly maxExtLength = UINT32_MAX,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n    private readonly bufferSize: number = DEFAULT_BUFFER_SIZE,\n  ) {\n    this.readStream = readIterable[Symbol.asyncIterator]();\n  }\n\n  private reinitializeState() {\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.length = 0;\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private createExtraByteError(): Error {\n    return new RangeError(`Extra bytes found`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(): Promise<unknown> {\n    this.reinitializeState();\n\n    return this.doDecodeSync();\n  }\n\n  public async *decodeMulti(): AsyncGenerator<unknown> {\n    this.reinitializeState();\n\n    while (true) {\n      yield await this.doDecodeSync();\n    }\n  }\n\n  private async doDecodeSync() {\n    DECODE: while (true) {\n      const headByte = this.readHeadByteFromBuffer() ?? (await this.readHeadByte());\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8StringFromBuffer(byteLength) ?? (await this.decodeUtf8String(byteLength));\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32FromBuffer() ?? (await this.readF32());\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64FromBuffer() ?? (await this.readF64());\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8FromBuffer() ?? (await this.readU8());\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16FromBuffer() ?? (await this.readU16());\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32FromBuffer() ?? (await this.readU32());\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64FromBuffer() ?? (await this.readU64());\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8FromBuffer() ?? (await this.readI8());\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16FromBuffer() ?? (await this.readI16());\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32FromBuffer() ?? (await this.readI32());\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64FromBuffer() ?? (await this.readI64());\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.readU8FromBuffer() ?? (await this.readU8());\n        object = this.decodeUtf8StringFromBuffer(byteLength) ?? (await this.decodeUtf8String(byteLength));\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.readU16FromBuffer() ?? (await this.readU16());\n        object = this.decodeUtf8StringFromBuffer(byteLength) ?? (await this.decodeUtf8String(byteLength));\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.readU32FromBuffer() ?? (await this.readU32());\n        object = this.decodeUtf8StringFromBuffer(byteLength) ?? (await this.decodeUtf8String(byteLength));\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16FromBuffer() ?? (await this.readU16());\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32FromBuffer() ?? (await this.readU32());\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16FromBuffer() ?? (await this.readU16());\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32FromBuffer() ?? (await this.readU32());\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.readU8FromBuffer() ?? (await this.readU8());\n        object = await this.decodeBinary(size);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.readU16FromBuffer() ?? (await this.readU16());\n        object = await this.decodeBinary(size);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.readU32FromBuffer() ?? (await this.readU32());\n        object = await this.decodeBinary(size);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = await this.decodeExtension(1);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = await this.decodeExtension(2);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = await this.decodeExtension(4);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = await this.decodeExtension(8);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = await this.decodeExtension(16);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.readU8FromBuffer() ?? (await this.readU8());\n        object = await this.decodeExtension(size);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.readU16FromBuffer() ?? (await this.readU16());\n        object = await this.decodeExtension(size);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.readU32FromBuffer() ?? (await this.readU32());\n        object = await this.decodeExtension(size);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1]!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new DecodeError(\"The type of key must be string or number but \" + typeof object);\n          }\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = object;\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByteFromBuffer() {\n    const b = this.readU8FromBuffer();\n    if (b === null) {\n      return null;\n    }\n\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = b;\n    }\n\n    return this.headByte;\n  }\n\n  private async readHeadByte() {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = await this.readU8();\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: STATE_ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8StringFromBuffer(byteLength: number) {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    const bytes = this.readBytesFromBuffer(byteLength);\n    if (bytes === null) {\n      return null;\n    }\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(bytes, 0, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(bytes, 0, byteLength);\n    } else {\n      object = utf8DecodeJs(bytes, 0, byteLength);\n    }\n    return object;\n  }\n\n  private async decodeUtf8String(byteLength: number) {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    const bytes = await this.readBytes(byteLength);\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(bytes, 0, byteLength);\n    } else if (byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(bytes, 0, byteLength);\n    } else {\n      object = utf8DecodeJs(bytes, 0, byteLength);\n    }\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1]!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  private async decodeBinary(byteLength: number) {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    const object = await this.readBytes(byteLength);\n    return object;\n  }\n\n  private async decodeExtension(size: number) {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = await this.readI8();\n    const data = await this.decodeBinary(size);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private async readU8() {\n    const data = await this.readBytes(1);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);\n    return value;\n  }\n\n  private async readI8() {\n    const data = await this.readBytes(1);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);\n    return value;\n  }\n\n  private async readU16() {\n    const data = await this.readBytes(2);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);\n    return value;\n  }\n\n  private async readI16() {\n    const data = await this.readBytes(2);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);\n    return value;\n  }\n\n  private async readU32() {\n    const data = await this.readBytes(4);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);\n    return value;\n  }\n\n  private async readI32() {\n    const data = await this.readBytes(4);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);\n    return value;\n  }\n\n  private async readU64() {\n    const data = await this.readBytes(8);\n    const value = getUint64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);\n    return value;\n  }\n\n  private async readI64() {\n    const data = await this.readBytes(8);\n    const value = getInt64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);\n    return value;\n  }\n\n  private async readF32() {\n    const data = await this.readBytes(4);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);\n    return value;\n  }\n\n  private async readF64() {\n    const data = await this.readBytes(8);\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);\n    return value;\n  }\n\n  private readU8FromBuffer() {\n    const data = this.readBytesFromBuffer(1);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);\n    return value;\n  }\n\n  private readI8FromBuffer() {\n    const data = this.readBytesFromBuffer(1);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);\n    return value;\n  }\n\n  private readU16FromBuffer() {\n    const data = this.readBytesFromBuffer(2);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);\n    return value;\n  }\n\n  private readI16FromBuffer() {\n    const data = this.readBytesFromBuffer(2);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);\n    return value;\n  }\n\n  private readU32FromBuffer() {\n    const data = this.readBytesFromBuffer(4);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);\n    return value;\n  }\n\n  private readI32FromBuffer() {\n    const data = this.readBytesFromBuffer(4);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);\n    return value;\n  }\n\n  private readU64FromBuffer() {\n    const data = this.readBytesFromBuffer(8);\n    if (!data) {\n      return null;\n    }\n    const value = getUint64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);\n    return value;\n  }\n\n  private readI64FromBuffer() {\n    const data = this.readBytesFromBuffer(8);\n    if (!data) {\n      return null;\n    }\n    const value = getInt64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);\n    return value;\n  }\n\n  private readF32FromBuffer() {\n    const data = this.readBytesFromBuffer(4);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);\n    return value;\n  }\n\n  private readF64FromBuffer() {\n    const data = this.readBytesFromBuffer(8);\n    if (!data) {\n      return null;\n    }\n    const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);\n    return value;\n  }\n\n  private readBytesFromBuffer(length: number): Uint8Array | null {\n    if (this.buffer && this.buffer.length >= length) {\n      const result = this.buffer.subarray(0, length);\n      this.buffer = this.buffer.subarray(length);\n      return result;\n    }\n    return null;\n  }\n\n  private async readBytes(length: number) {\n    if (this.buffer && length <= this.buffer.length) {\n      const result = this.buffer.subarray(0, length);\n      this.buffer = this.buffer.subarray(length);\n      return result;\n    } else {\n      const hasData = this.buffer?.length ?? 0;\n      const needData = length - hasData;\n      const result = new Uint8Array(length);\n      if (this.buffer) {\n        result.set(this.buffer, 0);\n      }\n      if (needData < this.bufferSize) {\n        const next = await this.readToBuffer(this.bufferSize);\n        if (next.length < needData) {\n          throw MORE_DATA;\n        }\n        result.set(next.subarray(0, needData), hasData);\n        this.buffer = this.buffer!.subarray(needData);\n      } else {\n        const next = await this.readToBuffer(needData);\n        if (next.length < needData) {\n          throw MORE_DATA;\n        }\n        result.set(next.subarray(0, needData), hasData);\n        this.buffer = this.buffer!.subarray(needData);\n      }\n      return result;\n    }\n  }\n\n  private async readToBuffer(length: number) {\n    const bytes: Array<Uint8Array> = [];\n    let size = 0;\n    while (size < length) {\n      const result = await this.readStream.next(this.bufferSize);\n      if (!result.done) {\n        bytes.push(result.value);\n        size += result.value.length;\n      } else {\n        break;\n      }\n    }\n    if (bytes.length == 1) {\n      this.buffer = bytes[0]!;\n      return bytes[0]!;\n    }\n    this.buffer = new Uint8Array(size);\n    let pos = 0;\n    for (const chunk of bytes) {\n      this.buffer.set(chunk, pos);\n      pos += chunk.length;\n    }\n    return this.buffer;\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec\";\nimport type { ContextOf, SplitUndefined } from \"./context\";\nimport { StreamDecoder } from \"./StreamDecoder\";\n\nexport type DecodeOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * The size of the stream buffer.\n     *\n     * Defaults to 2048.\n     */\n    streamBufferSize: number;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport const defaultDecodeOptions: DecodeOptions = {};\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): unknown {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeMulti(buffer);\n}\n\nexport function decodeStream<ContextType = undefined>(\n  read: AsyncIterable<Uint8Array>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Promise<unknown> {\n  const decoder = new StreamDecoder(\n    read,\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decode();\n}\n","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterable<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport { ensureAsyncIterable } from \"./utils/stream\";\nimport { defaultDecodeOptions } from \"./decode\";\nimport type { ReadableStreamLike } from \"./utils/stream\";\nimport type { DecodeOptions } from \"./decode\";\nimport type { SplitUndefined } from \"./context\";\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export async function decodeAsync<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Promise<unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeAsync(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\n export function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeArrayStream(stream);\n}\n\n/**\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMultiStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number> | BufferSource>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): AsyncGenerator<unknown, void, unknown> {\n  const stream = ensureAsyncIterable(streamLike);\n\n  const decoder = new Decoder(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeStream(stream);\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","UINT32_MAX","setUint64","view","offset","high","low","setUint32","setInt64","Math","floor","getInt64","getInt32","getUint32","getUint64","TEXT_ENCODING_AVAILABLE","process","env","TextEncoder","TextDecoder","utf8Count","str","strLength","length","byteLength","pos","charCodeAt","extra","utf8EncodeJs","output","outputOffset","sharedTextEncoder","undefined","TEXT_ENCODER_THRESHOLD","utf8EncodeTE","encodeInto","subarray","set","encode","utf8DecodeJs","bytes","inputOffset","end","units","result","byte1","push","byte2","byte3","unit","String","fromCharCode","sharedTextDecoder","TEXT_DECODER_THRESHOLD","utf8DecodeTD","stringBytes","decode","ExtData","constructor","type","data","DecodeError","Error","message","super","proto","create","setPrototypeOf","configurable","name","EXT_TIMESTAMP","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","object","Date","decodeTimestampToTimeSpec","byteOffset","nsec30AndSecHigh2","decodeTimestampExtension","timeSpec","timestampExtension","ExtensionCodec","builtInEncoders","builtInDecoders","encoders","decoders","register","index","tryToEncode","context","i","encodeExt","decodeExt","ensureUint8Array","ArrayBuffer","isView","from","defaultCodec","Encoder","extensionCodec","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","reinitializeState","encodeSharedRef","doEncode","slice","depth","encodeNil","encodeBoolean","encodeNumber","encodeString","encodeObject","ensureBufferSizeToWrite","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","writeU8","Number","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeStringHeader","ext","encodeExtension","Array","isArray","encodeArray","encodeBinary","toString","apply","encodeMap","size","writeU8a","item","countWithoutUndefined","keys","count","sort","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","StreamEncoder","bufferSize","chunk","readSize","min","read","writeU8U8","writeU8U16","writeU8U32","writeU8U64","writeU8I8","writeU8I16","writeU8I32","writeU8I64","writeU8F32","writeU8F64","buildStringHeader","header","writeBuffer","value2","u8","u16","u32","u64","i16","i32","i64","f32","f64","defaultEncodeOptions","options","encodeStream","streamBufferSize","prettyByte","byte","abs","padStart","CachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","canBeCached","find","records","FIND_CHUNK","record","recordBytes","j","store","random","cachedValue","slicedCopyOfBytes","STATE_ARRAY","STATE_MAP_KEY","isValidMapKeyType","keyType","EMPTY_VIEW","EMPTY_BYTES","DataViewIndexOutOfBoundsError","getInt8","e","MORE_DATA","sharedCachedKeyDecoder","Decoder","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","totalPos","headByte","stack","setBuffer","bufferView","createDataView","appendBuffer","hasRemaining","remainingData","newData","createExtraByteError","posToShow","RangeError","doDecodeSync","decodeAsync","stream","decoded","decodeArrayStream","decodeMultiAsync","decodeStream","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","state","array","position","pop","map","readCount","headerOffset","stateIsMapKey","headOffset","extType","getUint8","getUint16","getInt16","getFloat32","getFloat64","StreamDecoder","readIterable","readStream","asyncIterator","decodeMulti","readHeadByteFromBuffer","decodeUtf8StringFromBuffer","readF32FromBuffer","readF64FromBuffer","readU8FromBuffer","readU16FromBuffer","readU32FromBuffer","readU64FromBuffer","readI8FromBuffer","readI16FromBuffer","readI32FromBuffer","readI64FromBuffer","b","readBytesFromBuffer","readBytes","hasData","needData","next","readToBuffer","done","defaultDecodeOptions","assertNonNull","ensureAsyncIterable","streamLike","reader","getReader","releaseLock","asyncIterableFromStream","decodeMultiStream"],"sourceRoot":""}