"use strict";
/*
Copyright 2022 ByteDance and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerfseePlugin = void 0;
const tslib_1 = require("tslib");
const path_1 = require("path");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const bundle_analyzer_1 = require("@perfsee/bundle-analyzer");
const plugin_utils_1 = require("@perfsee/plugin-utils");
let version = 'unknown';
try {
    version = require('../package.json').version;
}
catch (e) {
    console.error('Read self version failed', e);
}
const webpackStatsToJsonOptions = {
    hash: true,
    publicPath: true,
    assets: true,
    chunks: true,
    chunkModules: true,
    chunkGroups: false,
    chunkOrigins: false,
    depth: false,
    modules: false,
    source: false,
    timings: false,
    warnings: false,
    errors: false,
    performance: false,
    timing: false,
};
class PerfseePlugin {
    constructor(options = {}) {
        this.modules = new Map();
        this.apply = (compiler) => {
            // we do not analyze programs for `node` or in development mode which is meanless
            if (!this.isTargetWeb(compiler.options) || compiler.options.mode === 'development') {
                return;
            }
            compiler.hooks.beforeRun.tap(PerfseePlugin.PluginName, (compiler) => {
                this.setOutputPath(compiler.outputPath);
                this.context = compiler.options.context;
            });
            try {
                if (compiler.resolverFactory?.hooks?.resolver) {
                    compiler.resolverFactory.hooks.resolver.for('normal').tap(PerfseePlugin.PluginName, (resolver) => {
                        try {
                            resolver.hooks.result.tap(PerfseePlugin.PluginName, (request) => {
                                (0, plugin_utils_1.catchModuleVersionFromRequest)(request, this.modules, this.context || process.cwd(), (0, plugin_utils_1.getBuildEnv)().pwd);
                            });
                        }
                        catch (e) {
                            console.error('failed when applying module version catcher: ', e);
                        }
                    });
                }
                else {
                    // compatible with rspack, bacause rapack does not support resolverFactory.hook.resolver
                    compiler.hooks.compilation.tap(PerfseePlugin.PluginName, (_compilation, { normalModuleFactory }) => {
                        try {
                            normalModuleFactory.hooks.afterResolve.tap(PerfseePlugin.PluginName, (resolveData) => {
                                (0, plugin_utils_1.catchModuleVersionFromRequest)(resolveData.createData?.resourceResolveData || {
                                    path: resolveData.createData?.resource || resolveData.context,
                                }, this.modules, this.context || process.cwd(), (0, plugin_utils_1.getBuildEnv)().pwd);
                            });
                        }
                        catch (e) {
                            console.error('failed when applying module version catcher: ', e);
                        }
                    });
                }
            }
            catch (e) {
                console.error('failed when applying module version catcher: ', e);
            }
            compiler.hooks.emit.tap(PerfseePlugin.PluginName, this.handleEmit);
            compiler.hooks.afterEmit.tapPromise(PerfseePlugin.PluginName, this.afterEmit);
        };
        this.collectModuleSources = (compilation) => {
            try {
                const reasonsMap = bundle_analyzer_1.StatsParser.FromStats(this.stats, this.outputPath).parseReasons();
                compilation.modules.forEach((module) => this.parseModuleSource(compilation, module, reasonsMap));
            }
            catch (e) {
                console.error(chalk_1.default.red(`Collect module sources failed, due to: ${e.message}`));
            }
        };
        this.handleEmit = (compilation) => {
            if (!this.outputPath) {
                return;
            }
            try {
                this.setStats(compilation.getStats());
                // @ts-expect-error
                if (webpackStatsToJsonOptions?.reasons !== false && webpackStatsToJsonOptions?.source !== false) {
                    this.collectModuleSources(compilation);
                }
            }
            catch (e) {
                console.error(chalk_1.default.red(`Parse webpack stats failed, due to: ${e.message}`));
            }
        };
        this.afterEmit = async () => {
            if (!this.outputPath) {
                return;
            }
            await this.reportStats();
        };
        this.options = (0, plugin_utils_1.initOptions)(options);
    }
    // @internal
    isTargetWeb(options) {
        const targetSetting = options.target;
        const targets = typeof targetSetting === 'string' ? [targetSetting] : Array.isArray(targetSetting) ? targetSetting : undefined;
        return !targets || targets.includes('web');
    }
    // @internal
    setOutputPath(outputPath) {
        this.outputPath = outputPath.endsWith(path_1.sep) ? outputPath : outputPath + path_1.sep;
        return this;
    }
    // @internal
    setStats(stats) {
        this.stats = stats.toJson(webpackStatsToJsonOptions);
        this.stats.packageVersions = (0, plugin_utils_1.getAllPackagesVersions)((0, plugin_utils_1.getBuildEnv)().pwd, this.modules);
        this.stats.repoPath = (0, plugin_utils_1.getBuildEnv)().pwd;
        this.stats.buildPath = this.context || process.cwd();
        // @ts-expect-error
        this.stats.buildTool = this.stats.rspackVersion ? bundle_analyzer_1.BundleToolkit.Rspack : bundle_analyzer_1.BundleToolkit.Webpack;
        return this;
    }
    // @internal
    async reportStats() {
        const client = new plugin_utils_1.BuildUploadClient(this.options, this.outputPath, version);
        await client.uploadBuild(this.stats);
        await (0, plugin_utils_1.generateReports)(this.stats, this.outputPath, this.options);
    }
    parseModuleSource(compilation, module, reasonsMap, visited = new Set()) {
        var _a;
        if (visited.has(module.id)) {
            return;
        }
        visited.add(module.id);
        // @ts-expect-error
        module.modules?.forEach((module) => this.parseModuleSource(compilation, module, reasonsMap, visited));
        // @ts-expect-error
        const source = module.originalSource?.()?.source() ?? module._source?.source();
        if (!source) {
            return;
        }
        const path = module.nameForCondition() || (0, bundle_analyzer_1.trimModuleName)(module.resource || '');
        if (!path) {
            return;
        }
        const relativePath = (0, path_1.relative)(this.stats.buildPath, path);
        const id = (0, bundle_analyzer_1.hashCode)(relativePath.startsWith('.') ? relativePath : `./${relativePath}`);
        if (source instanceof Buffer || !source || !id) {
            return;
        }
        const reasons = reasonsMap.get(id);
        if (!reasons?.length) {
            return;
        }
        const lines = reasons
            .map((r) => r[1]?.split(':'))
            .filter(Boolean)
            .map(([l, col]) => [Number(l) - 1, col]);
        const sourceFiltered = source
            .split('\n')
            .map((lineSource, lineNum) => {
            if (lines.some(([l]) => Math.abs(l - lineNum) <= 1)) {
                const sourceLines = lines.filter(([l]) => l === lineNum);
                if (sourceLines.length) {
                    const colStart = sourceLines
                        .map((l) => l[1])
                        .reduce((min, cur) => Math.min(min, Number(cur.split('-')[0])), Infinity);
                    let colEnd = sourceLines.map((l) => l[1]).reduce((max, cur) => Math.max(max, Number(cur.split('-')[1])), 0);
                    colEnd = Math.min(colEnd, colStart + 100);
                    const start = Math.max(0, Number(colStart) - 50);
                    const end = Math.min(lineSource.length, Number(colEnd) + 50);
                    if (colStart >= 0 && colStart < Infinity && colEnd <= lineSource.length && colEnd > 0) {
                        return lineSource.length > end ? ' '.repeat(start) + lineSource.slice(start, end) + ' // ...' : lineSource;
                    }
                    return lineSource.length > 500 ? lineSource.slice(0, 500) + ' ...' : lineSource;
                }
                else {
                    return lineSource.length > 100 ? lineSource.slice(0, 100) + ' ...' : lineSource;
                }
            }
            return '';
        })
            .join('\n');
        (_a = this.stats).moduleReasons || (_a.moduleReasons = {
            moduleSource: {},
        });
        this.stats.moduleReasons.moduleSource[id] = [relativePath, sourceFiltered];
    }
}
exports.PerfseePlugin = PerfseePlugin;
PerfseePlugin.PluginName = 'perfsee-plugin';
//# sourceMappingURL=index.js.map