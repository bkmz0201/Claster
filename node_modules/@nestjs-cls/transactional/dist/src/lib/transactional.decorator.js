"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactional = Transactional;
/* eslint-disable @typescript-eslint/no-unused-vars */
const nestjs_cls_1 = require("nestjs-cls");
const propagation_1 = require("./propagation");
const transaction_host_1 = require("./transaction-host");
function Transactional(firstParam, secondParam, thirdParam) {
    let connectionName;
    let options;
    let propagation;
    if (thirdParam) {
        connectionName = firstParam;
        propagation = secondParam;
        options = thirdParam;
    }
    else if (secondParam) {
        if (paramIsPropagationMode(firstParam)) {
            propagation = firstParam;
        }
        else {
            connectionName = firstParam;
        }
        options = secondParam;
    }
    else {
        if (paramIsPropagationMode(firstParam)) {
            propagation = firstParam;
        }
        else if (typeof firstParam === 'string') {
            connectionName = firstParam;
        }
        else {
            options = firstParam;
        }
    }
    return ((target, propertyKey, descriptor) => {
        const original = descriptor.value;
        if (typeof original !== 'function') {
            throw new Error(`The @Transactional decorator can be only used on functions, but ${propertyKey.toString()} is not a function.`);
        }
        descriptor.value = new Proxy(original, {
            apply: function (_, outerThis, args) {
                const transactionHost = transaction_host_1.TransactionHost.getInstance(connectionName);
                return transactionHost.withTransaction(propagation, options, original.bind(outerThis, ...args));
            },
        });
        (0, nestjs_cls_1.copyMethodMetadata)(original, descriptor.value);
    });
}
function paramIsPropagationMode(param) {
    return (typeof param === 'string' &&
        Object.values(propagation_1.Propagation).includes(param));
}
//# sourceMappingURL=transactional.decorator.js.map