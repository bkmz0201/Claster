import { readFileSync } from 'node:fs';
import { createRequire } from 'node:module';
import ts from 'typescript';
const { factory, isPropertySignature, isTypeLiteralNode } = ts;
export const printer = ts.createPrinter({
    newLine: ts.NewLineKind.LineFeed,
    removeComments: false,
});
export const STRING_TYPE = factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
export const NUMBER_TYPE = factory.createUnionTypeNode([
    STRING_TYPE,
    factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
    factory.createKeywordTypeNode(ts.SyntaxKind.BigIntKeyword),
]);
export const DATE_TYPE = factory.createTypeReferenceNode('Date');
export function createPropertyName(x) {
    if (isIdent(x))
        return x;
    return factory.createComputedPropertyName(factory.createStringLiteral(x));
}
const scanner = ts.createScanner(ts.ScriptTarget.ESNext, false, ts.LanguageVariant.Standard, '');
const isIdentCache = new Map();
export function isIdent(text) {
    if (isIdentCache.has(text))
        return isIdentCache.get(text);
    scanner.setText(text, 0);
    const result = scanner.scan() === ts.SyntaxKind.Identifier && scanner.scan() === ts.SyntaxKind.EndOfFileToken;
    isIdentCache.set(text, result);
    return result;
}
export function createReadonlyType(x) {
    // emit `readonly x` in this case will make it easier to read.
    if (isTypeLiteralNode(x) && x.members.length === 1 && isPropertySignature(x.members[0])) {
        return factory.createTypeLiteralNode([
            factory.createPropertySignature(factory.createModifiersFromModifierFlags(ts.ModifierFlags.Readonly), x.members[0].name, undefined, x.members[0].type),
        ]);
    }
    return factory.createTypeReferenceNode('Readonly', [x]);
}
function getAST(source) {
    const sourceFile = ts.createSourceFile('index.ts', source, ts.ScriptTarget.ESNext, false);
    ts.forEachChild(sourceFile, function visitor(node) {
        ;
        node.flags |= ts.NodeFlags.Synthesized;
        ts.forEachChild(node, visitor);
    });
    return sourceFile.statements;
}
export function castStatement(source, ...args) {
    const ast = getAST(String.raw(source, ...args));
    const functionDeclaration = ast[0];
    return functionDeclaration;
}
export function castExpression(source, ...args) {
    const ast = castStatement(source, ...args);
    return ast.expression;
}
export function pureAnnotate(node) {
    return ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, '#__PURE__', false);
}
const stdlibs = new Map();
export function stdlib(libName) {
    if (stdlibs.has(libName))
        return stdlibs.get(libName);
    const sourceFile = ts.createSourceFile(libName, getLibDTS(libName), ts.ScriptTarget.ESNext, true, ts.ScriptKind.TS);
    stdlibs.set(libName, sourceFile);
    return sourceFile;
}
function getLibDTS(libName) {
    let lib = libName;
    if (libName.startsWith('ES'))
        lib = `lib.${libName.toLowerCase()}`;
    if (lib === 'lib.jsx.d.ts')
        return 'declare module "react" { namespace JSX { export interface Element {} } }';
    const require = createRequire(import.meta.url);
    const target = `typescript/lib/${lib}`;
    if (!target.endsWith('.d.ts'))
        throw new Error('lib.d.ts failed to reach');
    const text = readFileSync(require.resolve(target), 'utf-8');
    return text;
}
//# sourceMappingURL=typescript.js.map