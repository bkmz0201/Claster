"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeProvider = ScopeProvider;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("jotai/react");
const patchedStore_1 = require("./patchedStore.js");
const scope_1 = require("./scope.js");
const ScopeContext = (0, react_1.createContext)({ scope: undefined, baseStore: undefined });
function ScopeProvider({ atoms, atomFamilies, children, debugName, }) {
    var _a;
    const parentStore = (0, react_2.useStore)();
    let { scope: parentScope, baseStore = parentStore } = (0, react_1.useContext)(ScopeContext);
    // if this ScopeProvider is the first descendant scope under Provider then it is the top level scope
    // https://github.com/jotaijs/jotai-scope/pull/33#discussion_r1604268003
    if ((0, patchedStore_1.isTopLevelScope)(parentStore)) {
        parentScope = undefined;
        baseStore = parentStore;
    }
    // atomSet is used to detect if the atoms prop has changed.
    const atomSet = new Set(atoms);
    const atomFamilySet = new Set(atomFamilies);
    function initialize() {
        const scope = (0, scope_1.createScope)(atomSet, atomFamilySet, parentScope, debugName);
        return {
            patchedStore: (0, patchedStore_1.createPatchedStore)(baseStore, scope),
            scopeContext: { scope, baseStore },
            hasChanged(current) {
                return (parentScope !== current.parentScope ||
                    baseStore !== current.baseStore ||
                    !isEqualSet(atomSet, current.atomSet) ||
                    !isEqualSet(atomFamilySet, current.atomFamilySet));
            },
        };
    }
    const [state, setState] = (0, react_1.useState)(initialize);
    const { hasChanged, scopeContext, patchedStore } = state;
    if (hasChanged({ parentScope, atomSet, atomFamilySet, baseStore })) {
        (_a = scopeContext.scope) === null || _a === void 0 ? void 0 : _a.cleanup();
        setState(initialize);
    }
    const { cleanup } = scopeContext.scope;
    useEvent(() => cleanup, []);
    return ((0, jsx_runtime_1.jsx)(ScopeContext.Provider, { value: scopeContext, children: (0, jsx_runtime_1.jsx)(react_2.Provider, { store: patchedStore, children: children }) }));
}
function isEqualSet(a, b) {
    return a === b || (a.size === b.size && Array.from(a).every((v) => b.has(v)));
}
function useEvent(fn, deps) {
    const ref = (0, react_1.useRef)(fn);
    ref.current = fn;
    (0, react_1.useEffect)(() => ref.current(), deps);
}
//# sourceMappingURL=ScopeProvider.js.map