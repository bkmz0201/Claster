var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
import { prettyByte } from "./utils/prettyByte.mjs";
import { ExtensionCodec } from "./ExtensionCodec.mjs";
import { getInt64, getUint64, UINT32_MAX } from "./utils/int.mjs";
import { utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from "./utils/utf8.mjs";
import { CachedKeyDecoder } from "./CachedKeyDecoder.mjs";
import { DecodeError } from "./DecodeError.mjs";
const STATE_ARRAY = "array";
const STATE_MAP_KEY = "map_key";
const STATE_MAP_VALUE = "map_value";
const isValidMapKeyType = (key) => {
    const keyType = typeof key;
    return keyType === "string" || keyType === "number";
};
const HEAD_BYTE_REQUIRED = -1;
const EMPTY_VIEW = new DataView(new ArrayBuffer(0));
// IE11: Hack to support IE11.
// IE11: Drop this hack and just use RangeError when IE11 is obsolete.
export const DataViewIndexOutOfBoundsError = (() => {
    try {
        // IE11: The spec says it should throw RangeError,
        // IE11: but in IE11 it throws TypeError.
        EMPTY_VIEW.getInt8(0);
    }
    catch (e) {
        return e.constructor;
    }
    throw new Error("never reached");
})();
const sharedCachedKeyDecoder = new CachedKeyDecoder();
const MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
export const DEFAULT_BUFFER_SIZE = 2048;
export class StreamDecoder {
    constructor(readIterable, extensionCodec = ExtensionCodec.defaultCodec, context = undefined, maxStrLength = UINT32_MAX, maxBinLength = UINT32_MAX, maxArrayLength = UINT32_MAX, maxMapLength = UINT32_MAX, maxExtLength = UINT32_MAX, keyDecoder = sharedCachedKeyDecoder, bufferSize = DEFAULT_BUFFER_SIZE) {
        this.readIterable = readIterable;
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.bufferSize = bufferSize;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
        this.buffer = null;
        this.readStream = readIterable[Symbol.asyncIterator]();
    }
    reinitializeState() {
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
        // view, bytes, and pos will be re-initialized in setBuffer()
    }
    createExtraByteError() {
        return new RangeError(`Extra bytes found`);
    }
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */
    decode() {
        this.reinitializeState();
        return this.doDecodeSync();
    }
    decodeMulti() {
        return __asyncGenerator(this, arguments, function* decodeMulti_1() {
            this.reinitializeState();
            while (true) {
                yield yield __await(yield __await(this.doDecodeSync()));
            }
        });
    }
    doDecodeSync() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
        return __awaiter(this, void 0, void 0, function* () {
            DECODE: while (true) {
                const headByte = (_a = this.readHeadByteFromBuffer()) !== null && _a !== void 0 ? _a : (yield this.readHeadByte());
                let object;
                if (headByte >= 0xe0) {
                    // negative fixint (111x xxxx) 0xe0 - 0xff
                    object = headByte - 0x100;
                }
                else if (headByte < 0xc0) {
                    if (headByte < 0x80) {
                        // positive fixint (0xxx xxxx) 0x00 - 0x7f
                        object = headByte;
                    }
                    else if (headByte < 0x90) {
                        // fixmap (1000 xxxx) 0x80 - 0x8f
                        const size = headByte - 0x80;
                        if (size !== 0) {
                            this.pushMapState(size);
                            this.complete();
                            continue DECODE;
                        }
                        else {
                            object = {};
                        }
                    }
                    else if (headByte < 0xa0) {
                        // fixarray (1001 xxxx) 0x90 - 0x9f
                        const size = headByte - 0x90;
                        if (size !== 0) {
                            this.pushArrayState(size);
                            this.complete();
                            continue DECODE;
                        }
                        else {
                            object = [];
                        }
                    }
                    else {
                        // fixstr (101x xxxx) 0xa0 - 0xbf
                        const byteLength = headByte - 0xa0;
                        object = (_b = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _b !== void 0 ? _b : (yield this.decodeUtf8String(byteLength));
                    }
                }
                else if (headByte === 0xc0) {
                    // nil
                    object = null;
                }
                else if (headByte === 0xc2) {
                    // false
                    object = false;
                }
                else if (headByte === 0xc3) {
                    // true
                    object = true;
                }
                else if (headByte === 0xca) {
                    // float 32
                    object = (_c = this.readF32FromBuffer()) !== null && _c !== void 0 ? _c : (yield this.readF32());
                }
                else if (headByte === 0xcb) {
                    // float 64
                    object = (_d = this.readF64FromBuffer()) !== null && _d !== void 0 ? _d : (yield this.readF64());
                }
                else if (headByte === 0xcc) {
                    // uint 8
                    object = (_e = this.readU8FromBuffer()) !== null && _e !== void 0 ? _e : (yield this.readU8());
                }
                else if (headByte === 0xcd) {
                    // uint 16
                    object = (_f = this.readU16FromBuffer()) !== null && _f !== void 0 ? _f : (yield this.readU16());
                }
                else if (headByte === 0xce) {
                    // uint 32
                    object = (_g = this.readU32FromBuffer()) !== null && _g !== void 0 ? _g : (yield this.readU32());
                }
                else if (headByte === 0xcf) {
                    // uint 64
                    object = (_h = this.readU64FromBuffer()) !== null && _h !== void 0 ? _h : (yield this.readU64());
                }
                else if (headByte === 0xd0) {
                    // int 8
                    object = (_j = this.readI8FromBuffer()) !== null && _j !== void 0 ? _j : (yield this.readI8());
                }
                else if (headByte === 0xd1) {
                    // int 16
                    object = (_k = this.readI16FromBuffer()) !== null && _k !== void 0 ? _k : (yield this.readI16());
                }
                else if (headByte === 0xd2) {
                    // int 32
                    object = (_l = this.readI32FromBuffer()) !== null && _l !== void 0 ? _l : (yield this.readI32());
                }
                else if (headByte === 0xd3) {
                    // int 64
                    object = (_m = this.readI64FromBuffer()) !== null && _m !== void 0 ? _m : (yield this.readI64());
                }
                else if (headByte === 0xd9) {
                    // str 8
                    const byteLength = (_o = this.readU8FromBuffer()) !== null && _o !== void 0 ? _o : (yield this.readU8());
                    object = (_p = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _p !== void 0 ? _p : (yield this.decodeUtf8String(byteLength));
                }
                else if (headByte === 0xda) {
                    // str 16
                    const byteLength = (_q = this.readU16FromBuffer()) !== null && _q !== void 0 ? _q : (yield this.readU16());
                    object = (_r = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _r !== void 0 ? _r : (yield this.decodeUtf8String(byteLength));
                }
                else if (headByte === 0xdb) {
                    // str 32
                    const byteLength = (_s = this.readU32FromBuffer()) !== null && _s !== void 0 ? _s : (yield this.readU32());
                    object = (_t = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _t !== void 0 ? _t : (yield this.decodeUtf8String(byteLength));
                }
                else if (headByte === 0xdc) {
                    // array 16
                    const size = (_u = this.readU16FromBuffer()) !== null && _u !== void 0 ? _u : (yield this.readU16());
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = [];
                    }
                }
                else if (headByte === 0xdd) {
                    // array 32
                    const size = (_v = this.readU32FromBuffer()) !== null && _v !== void 0 ? _v : (yield this.readU32());
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = [];
                    }
                }
                else if (headByte === 0xde) {
                    // map 16
                    const size = (_w = this.readU16FromBuffer()) !== null && _w !== void 0 ? _w : (yield this.readU16());
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = {};
                    }
                }
                else if (headByte === 0xdf) {
                    // map 32
                    const size = (_x = this.readU32FromBuffer()) !== null && _x !== void 0 ? _x : (yield this.readU32());
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = {};
                    }
                }
                else if (headByte === 0xc4) {
                    // bin 8
                    const size = (_y = this.readU8FromBuffer()) !== null && _y !== void 0 ? _y : (yield this.readU8());
                    object = yield this.decodeBinary(size);
                }
                else if (headByte === 0xc5) {
                    // bin 16
                    const size = (_z = this.readU16FromBuffer()) !== null && _z !== void 0 ? _z : (yield this.readU16());
                    object = yield this.decodeBinary(size);
                }
                else if (headByte === 0xc6) {
                    // bin 32
                    const size = (_0 = this.readU32FromBuffer()) !== null && _0 !== void 0 ? _0 : (yield this.readU32());
                    object = yield this.decodeBinary(size);
                }
                else if (headByte === 0xd4) {
                    // fixext 1
                    object = yield this.decodeExtension(1);
                }
                else if (headByte === 0xd5) {
                    // fixext 2
                    object = yield this.decodeExtension(2);
                }
                else if (headByte === 0xd6) {
                    // fixext 4
                    object = yield this.decodeExtension(4);
                }
                else if (headByte === 0xd7) {
                    // fixext 8
                    object = yield this.decodeExtension(8);
                }
                else if (headByte === 0xd8) {
                    // fixext 16
                    object = yield this.decodeExtension(16);
                }
                else if (headByte === 0xc7) {
                    // ext 8
                    const size = (_1 = this.readU8FromBuffer()) !== null && _1 !== void 0 ? _1 : (yield this.readU8());
                    object = yield this.decodeExtension(size);
                }
                else if (headByte === 0xc8) {
                    // ext 16
                    const size = (_2 = this.readU16FromBuffer()) !== null && _2 !== void 0 ? _2 : (yield this.readU16());
                    object = yield this.decodeExtension(size);
                }
                else if (headByte === 0xc9) {
                    // ext 32
                    const size = (_3 = this.readU32FromBuffer()) !== null && _3 !== void 0 ? _3 : (yield this.readU32());
                    object = yield this.decodeExtension(size);
                }
                else {
                    throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
                }
                this.complete();
                const stack = this.stack;
                while (stack.length > 0) {
                    // arrays and maps
                    const state = stack[stack.length - 1];
                    if (state.type === STATE_ARRAY) {
                        state.array[state.position] = object;
                        state.position++;
                        if (state.position === state.size) {
                            stack.pop();
                            object = state.array;
                        }
                        else {
                            continue DECODE;
                        }
                    }
                    else if (state.type === STATE_MAP_KEY) {
                        if (!isValidMapKeyType(object)) {
                            throw new DecodeError("The type of key must be string or number but " + typeof object);
                        }
                        if (object === "__proto__") {
                            throw new DecodeError("The key __proto__ is not allowed");
                        }
                        state.key = object;
                        state.type = STATE_MAP_VALUE;
                        continue DECODE;
                    }
                    else {
                        // it must be `state.type === State.MAP_VALUE` here
                        state.map[state.key] = object;
                        state.readCount++;
                        if (state.readCount === state.size) {
                            stack.pop();
                            object = state.map;
                        }
                        else {
                            state.key = null;
                            state.type = STATE_MAP_KEY;
                            continue DECODE;
                        }
                    }
                }
                return object;
            }
        });
    }
    readHeadByteFromBuffer() {
        const b = this.readU8FromBuffer();
        if (b === null) {
            return null;
        }
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = b;
        }
        return this.headByte;
    }
    readHeadByte() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.headByte === HEAD_BYTE_REQUIRED) {
                this.headByte = yield this.readU8();
            }
            return this.headByte;
        });
    }
    complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
    }
    pushMapState(size) {
        if (size > this.maxMapLength) {
            throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
            type: STATE_MAP_KEY,
            size,
            key: null,
            readCount: 0,
            map: {},
        });
    }
    pushArrayState(size) {
        if (size > this.maxArrayLength) {
            throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
            type: STATE_ARRAY,
            size,
            array: new Array(size),
            position: 0,
        });
    }
    decodeUtf8StringFromBuffer(byteLength) {
        var _a;
        if (byteLength > this.maxStrLength) {
            throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        const bytes = this.readBytesFromBuffer(byteLength);
        if (bytes === null) {
            return null;
        }
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(bytes, 0, byteLength);
        }
        else if (byteLength > TEXT_DECODER_THRESHOLD) {
            object = utf8DecodeTD(bytes, 0, byteLength);
        }
        else {
            object = utf8DecodeJs(bytes, 0, byteLength);
        }
        return object;
    }
    decodeUtf8String(byteLength) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (byteLength > this.maxStrLength) {
                throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
            }
            const bytes = yield this.readBytes(byteLength);
            let object;
            if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
                object = this.keyDecoder.decode(bytes, 0, byteLength);
            }
            else if (byteLength > TEXT_DECODER_THRESHOLD) {
                object = utf8DecodeTD(bytes, 0, byteLength);
            }
            else {
                object = utf8DecodeJs(bytes, 0, byteLength);
            }
            return object;
        });
    }
    stateIsMapKey() {
        if (this.stack.length > 0) {
            const state = this.stack[this.stack.length - 1];
            return state.type === STATE_MAP_KEY;
        }
        return false;
    }
    decodeBinary(byteLength) {
        return __awaiter(this, void 0, void 0, function* () {
            if (byteLength > this.maxBinLength) {
                throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
            }
            const object = yield this.readBytes(byteLength);
            return object;
        });
    }
    decodeExtension(size) {
        return __awaiter(this, void 0, void 0, function* () {
            if (size > this.maxExtLength) {
                throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
            }
            const extType = yield this.readI8();
            const data = yield this.decodeBinary(size);
            return this.extensionCodec.decode(data, extType, this.context);
        });
    }
    readU8() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(1);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);
            return value;
        });
    }
    readI8() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(1);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);
            return value;
        });
    }
    readU16() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(2);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);
            return value;
        });
    }
    readI16() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(2);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);
            return value;
        });
    }
    readU32() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(4);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);
            return value;
        });
    }
    readI32() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(4);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);
            return value;
        });
    }
    readU64() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(8);
            const value = getUint64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
            return value;
        });
    }
    readI64() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(8);
            const value = getInt64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
            return value;
        });
    }
    readF32() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(4);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);
            return value;
        });
    }
    readF64() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.readBytes(8);
            const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);
            return value;
        });
    }
    readU8FromBuffer() {
        const data = this.readBytesFromBuffer(1);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);
        return value;
    }
    readI8FromBuffer() {
        const data = this.readBytesFromBuffer(1);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);
        return value;
    }
    readU16FromBuffer() {
        const data = this.readBytesFromBuffer(2);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);
        return value;
    }
    readI16FromBuffer() {
        const data = this.readBytesFromBuffer(2);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);
        return value;
    }
    readU32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);
        return value;
    }
    readI32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);
        return value;
    }
    readU64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = getUint64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    readI64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = getInt64(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    readF32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);
        return value;
    }
    readF64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);
        return value;
    }
    readBytesFromBuffer(length) {
        if (this.buffer && this.buffer.length >= length) {
            const result = this.buffer.subarray(0, length);
            this.buffer = this.buffer.subarray(length);
            return result;
        }
        return null;
    }
    readBytes(length) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.buffer && length <= this.buffer.length) {
                const result = this.buffer.subarray(0, length);
                this.buffer = this.buffer.subarray(length);
                return result;
            }
            else {
                const hasData = (_b = (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
                const needData = length - hasData;
                const result = new Uint8Array(length);
                if (this.buffer) {
                    result.set(this.buffer, 0);
                }
                if (needData < this.bufferSize) {
                    const next = yield this.readToBuffer(this.bufferSize);
                    if (next.length < needData) {
                        throw MORE_DATA;
                    }
                    result.set(next.subarray(0, needData), hasData);
                    this.buffer = this.buffer.subarray(needData);
                }
                else {
                    const next = yield this.readToBuffer(needData);
                    if (next.length < needData) {
                        throw MORE_DATA;
                    }
                    result.set(next.subarray(0, needData), hasData);
                    this.buffer = this.buffer.subarray(needData);
                }
                return result;
            }
        });
    }
    readToBuffer(length) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytes = [];
            let size = 0;
            while (size < length) {
                const result = yield this.readStream.next(this.bufferSize);
                if (!result.done) {
                    bytes.push(result.value);
                    size += result.value.length;
                }
                else {
                    break;
                }
            }
            if (bytes.length == 1) {
                this.buffer = bytes[0];
                return bytes[0];
            }
            this.buffer = new Uint8Array(size);
            let pos = 0;
            for (const chunk of bytes) {
                this.buffer.set(chunk, pos);
                pos += chunk.length;
            }
            return this.buffer;
        });
    }
}
//# sourceMappingURL=StreamDecoder.mjs.map