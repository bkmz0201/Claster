import { TOptionsFromAdapter, MergedTransactionalAdapterOptions, TTxFromAdapter } from './interfaces';
import { Propagation } from './propagation';
export declare class TransactionHost<TAdapter = never> {
    private readonly _options;
    private readonly cls;
    private readonly logger;
    private readonly transactionInstanceSymbol;
    private static _instanceMap;
    /**
     * Get a singleton instance of the TransactionHost outside of DI.
     *
     * @param connectionName The name of the connection. If omitted, the default instance is used.
     */
    static getInstance<TAdapter = never>(connectionName?: string): TransactionHost<TAdapter>;
    constructor(_options: MergedTransactionalAdapterOptions<TTxFromAdapter<TAdapter>, TOptionsFromAdapter<TAdapter>>);
    /**
     * The instance of the transaction object.
     *
     * Depending on the adapter, this may be a transaction reference, a database client, or something else.
     * The type is defined by the adapter.
     *
     * If no transaction is active, this will return the fallback (non-transactional) instance defined by the adapter.
     */
    get tx(): TTxFromAdapter<TAdapter>;
    /**
     * Wrap a function call in a transaction defined by the adapter.
     *
     * The transaction instance will be accessible on the TransactionHost as `tx`.
     *
     * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
     *
     * @param fn The function to run in a transaction.
     * @returns Whatever the passed function returns
     */
    withTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R>;
    /**
     * Wrap a function call in a transaction defined by the adapter.
     *
     * The transaction instance will be accessible on the TransactionHost as `tx`.
     *
     * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
     *
     * @param options Transaction options depending on the adapter.
     * @param fn The function to run in a transaction.
     * @returns Whatever the passed function returns
     */
    withTransaction<R>(options: TOptionsFromAdapter<TAdapter>, fn: (...args: any[]) => Promise<R>): Promise<R>;
    /**
     * Wrap a function call in a transaction defined by the adapter.
     *
     * The transaction instance will be accessible on the TransactionHost as `tx`.
     *
     * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
     *
     * @param propagation The propagation mode to use, @see{Propagation}.
     * @param fn The function to run in a transaction.
     * @returns Whatever the passed function returns
     */
    withTransaction<R>(propagation: Propagation, fn: (...args: any[]) => Promise<R>): Promise<R>;
    /**
     * Wrap a function call in a transaction defined by the adapter.
     *
     * The transaction instance will be accessible on the TransactionHost as `tx`.
     *
     * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
     *
     * @param propagation The propagation mode to use, @see{Propagation}.
     * @param options Transaction options depending on the adapter.
     * @param fn The function to run in a transaction.
     * @returns Whatever the passed function returns
     */
    withTransaction<R>(propagation: Propagation, options: TOptionsFromAdapter<TAdapter>, fn: (...args: any[]) => Promise<R>): Promise<R>;
    private decidePropagationAndRun;
    private runWithTransaction;
    /**
     * Wrap a function call to run outside of a transaction.
     *
     * @param fn The function to run outside of a transaction.
     * @returns Whatever the passed function returns
     */
    withoutTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R>;
    /**
     * @returns `true` if a transaction is currently active, `false` otherwise.
     */
    isTransactionActive(): boolean;
    private setTxInstance;
}
/**
 * Get the injection token for a TransactionHost for a named connection.
 * If name is omitted, the default instance is used.
 */
export declare function getTransactionHostToken(connectionName?: string): symbol | typeof TransactionHost;
/**
 * Inject a TransactionHost for a named connection. Only needed if you want to inject a named instance.
 *
 * A shorthand for `Inject(getTransactionHostToken(connectionName))`
 */
export declare function InjectTransactionHost(connectionName?: string): PropertyDecorator & ParameterDecorator;
//# sourceMappingURL=transaction-host.d.ts.map