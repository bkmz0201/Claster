"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamDecoder = exports.DEFAULT_BUFFER_SIZE = exports.DataViewIndexOutOfBoundsError = void 0;
const prettyByte_1 = require("./utils/prettyByte");
const ExtensionCodec_1 = require("./ExtensionCodec");
const int_1 = require("./utils/int");
const utf8_1 = require("./utils/utf8");
const CachedKeyDecoder_1 = require("./CachedKeyDecoder");
const DecodeError_1 = require("./DecodeError");
const STATE_ARRAY = "array";
const STATE_MAP_KEY = "map_key";
const STATE_MAP_VALUE = "map_value";
const isValidMapKeyType = (key) => {
    const keyType = typeof key;
    return keyType === "string" || keyType === "number";
};
const HEAD_BYTE_REQUIRED = -1;
const EMPTY_VIEW = new DataView(new ArrayBuffer(0));
// IE11: Hack to support IE11.
// IE11: Drop this hack and just use RangeError when IE11 is obsolete.
exports.DataViewIndexOutOfBoundsError = (() => {
    try {
        // IE11: The spec says it should throw RangeError,
        // IE11: but in IE11 it throws TypeError.
        EMPTY_VIEW.getInt8(0);
    }
    catch (e) {
        return e.constructor;
    }
    throw new Error("never reached");
})();
const sharedCachedKeyDecoder = new CachedKeyDecoder_1.CachedKeyDecoder();
const MORE_DATA = new exports.DataViewIndexOutOfBoundsError("Insufficient data");
exports.DEFAULT_BUFFER_SIZE = 2048;
class StreamDecoder {
    constructor(readIterable, extensionCodec = ExtensionCodec_1.ExtensionCodec.defaultCodec, context = undefined, maxStrLength = int_1.UINT32_MAX, maxBinLength = int_1.UINT32_MAX, maxArrayLength = int_1.UINT32_MAX, maxMapLength = int_1.UINT32_MAX, maxExtLength = int_1.UINT32_MAX, keyDecoder = sharedCachedKeyDecoder, bufferSize = exports.DEFAULT_BUFFER_SIZE) {
        this.readIterable = readIterable;
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.bufferSize = bufferSize;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
        this.buffer = null;
        this.readStream = readIterable[Symbol.asyncIterator]();
    }
    reinitializeState() {
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
        // view, bytes, and pos will be re-initialized in setBuffer()
    }
    createExtraByteError() {
        return new RangeError(`Extra bytes found`);
    }
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */
    decode() {
        this.reinitializeState();
        return this.doDecodeSync();
    }
    async *decodeMulti() {
        this.reinitializeState();
        while (true) {
            yield await this.doDecodeSync();
        }
    }
    async doDecodeSync() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
        DECODE: while (true) {
            const headByte = (_a = this.readHeadByteFromBuffer()) !== null && _a !== void 0 ? _a : (await this.readHeadByte());
            let object;
            if (headByte >= 0xe0) {
                // negative fixint (111x xxxx) 0xe0 - 0xff
                object = headByte - 0x100;
            }
            else if (headByte < 0xc0) {
                if (headByte < 0x80) {
                    // positive fixint (0xxx xxxx) 0x00 - 0x7f
                    object = headByte;
                }
                else if (headByte < 0x90) {
                    // fixmap (1000 xxxx) 0x80 - 0x8f
                    const size = headByte - 0x80;
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = {};
                    }
                }
                else if (headByte < 0xa0) {
                    // fixarray (1001 xxxx) 0x90 - 0x9f
                    const size = headByte - 0x90;
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    }
                    else {
                        object = [];
                    }
                }
                else {
                    // fixstr (101x xxxx) 0xa0 - 0xbf
                    const byteLength = headByte - 0xa0;
                    object = (_b = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _b !== void 0 ? _b : (await this.decodeUtf8String(byteLength));
                }
            }
            else if (headByte === 0xc0) {
                // nil
                object = null;
            }
            else if (headByte === 0xc2) {
                // false
                object = false;
            }
            else if (headByte === 0xc3) {
                // true
                object = true;
            }
            else if (headByte === 0xca) {
                // float 32
                object = (_c = this.readF32FromBuffer()) !== null && _c !== void 0 ? _c : (await this.readF32());
            }
            else if (headByte === 0xcb) {
                // float 64
                object = (_d = this.readF64FromBuffer()) !== null && _d !== void 0 ? _d : (await this.readF64());
            }
            else if (headByte === 0xcc) {
                // uint 8
                object = (_e = this.readU8FromBuffer()) !== null && _e !== void 0 ? _e : (await this.readU8());
            }
            else if (headByte === 0xcd) {
                // uint 16
                object = (_f = this.readU16FromBuffer()) !== null && _f !== void 0 ? _f : (await this.readU16());
            }
            else if (headByte === 0xce) {
                // uint 32
                object = (_g = this.readU32FromBuffer()) !== null && _g !== void 0 ? _g : (await this.readU32());
            }
            else if (headByte === 0xcf) {
                // uint 64
                object = (_h = this.readU64FromBuffer()) !== null && _h !== void 0 ? _h : (await this.readU64());
            }
            else if (headByte === 0xd0) {
                // int 8
                object = (_j = this.readI8FromBuffer()) !== null && _j !== void 0 ? _j : (await this.readI8());
            }
            else if (headByte === 0xd1) {
                // int 16
                object = (_k = this.readI16FromBuffer()) !== null && _k !== void 0 ? _k : (await this.readI16());
            }
            else if (headByte === 0xd2) {
                // int 32
                object = (_l = this.readI32FromBuffer()) !== null && _l !== void 0 ? _l : (await this.readI32());
            }
            else if (headByte === 0xd3) {
                // int 64
                object = (_m = this.readI64FromBuffer()) !== null && _m !== void 0 ? _m : (await this.readI64());
            }
            else if (headByte === 0xd9) {
                // str 8
                const byteLength = (_o = this.readU8FromBuffer()) !== null && _o !== void 0 ? _o : (await this.readU8());
                object = (_p = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _p !== void 0 ? _p : (await this.decodeUtf8String(byteLength));
            }
            else if (headByte === 0xda) {
                // str 16
                const byteLength = (_q = this.readU16FromBuffer()) !== null && _q !== void 0 ? _q : (await this.readU16());
                object = (_r = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _r !== void 0 ? _r : (await this.decodeUtf8String(byteLength));
            }
            else if (headByte === 0xdb) {
                // str 32
                const byteLength = (_s = this.readU32FromBuffer()) !== null && _s !== void 0 ? _s : (await this.readU32());
                object = (_t = this.decodeUtf8StringFromBuffer(byteLength)) !== null && _t !== void 0 ? _t : (await this.decodeUtf8String(byteLength));
            }
            else if (headByte === 0xdc) {
                // array 16
                const size = (_u = this.readU16FromBuffer()) !== null && _u !== void 0 ? _u : (await this.readU16());
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xdd) {
                // array 32
                const size = (_v = this.readU32FromBuffer()) !== null && _v !== void 0 ? _v : (await this.readU32());
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = [];
                }
            }
            else if (headByte === 0xde) {
                // map 16
                const size = (_w = this.readU16FromBuffer()) !== null && _w !== void 0 ? _w : (await this.readU16());
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xdf) {
                // map 32
                const size = (_x = this.readU32FromBuffer()) !== null && _x !== void 0 ? _x : (await this.readU32());
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                }
                else {
                    object = {};
                }
            }
            else if (headByte === 0xc4) {
                // bin 8
                const size = (_y = this.readU8FromBuffer()) !== null && _y !== void 0 ? _y : (await this.readU8());
                object = await this.decodeBinary(size);
            }
            else if (headByte === 0xc5) {
                // bin 16
                const size = (_z = this.readU16FromBuffer()) !== null && _z !== void 0 ? _z : (await this.readU16());
                object = await this.decodeBinary(size);
            }
            else if (headByte === 0xc6) {
                // bin 32
                const size = (_0 = this.readU32FromBuffer()) !== null && _0 !== void 0 ? _0 : (await this.readU32());
                object = await this.decodeBinary(size);
            }
            else if (headByte === 0xd4) {
                // fixext 1
                object = await this.decodeExtension(1);
            }
            else if (headByte === 0xd5) {
                // fixext 2
                object = await this.decodeExtension(2);
            }
            else if (headByte === 0xd6) {
                // fixext 4
                object = await this.decodeExtension(4);
            }
            else if (headByte === 0xd7) {
                // fixext 8
                object = await this.decodeExtension(8);
            }
            else if (headByte === 0xd8) {
                // fixext 16
                object = await this.decodeExtension(16);
            }
            else if (headByte === 0xc7) {
                // ext 8
                const size = (_1 = this.readU8FromBuffer()) !== null && _1 !== void 0 ? _1 : (await this.readU8());
                object = await this.decodeExtension(size);
            }
            else if (headByte === 0xc8) {
                // ext 16
                const size = (_2 = this.readU16FromBuffer()) !== null && _2 !== void 0 ? _2 : (await this.readU16());
                object = await this.decodeExtension(size);
            }
            else if (headByte === 0xc9) {
                // ext 32
                const size = (_3 = this.readU32FromBuffer()) !== null && _3 !== void 0 ? _3 : (await this.readU32());
                object = await this.decodeExtension(size);
            }
            else {
                throw new DecodeError_1.DecodeError(`Unrecognized type byte: ${(0, prettyByte_1.prettyByte)(headByte)}`);
            }
            this.complete();
            const stack = this.stack;
            while (stack.length > 0) {
                // arrays and maps
                const state = stack[stack.length - 1];
                if (state.type === STATE_ARRAY) {
                    state.array[state.position] = object;
                    state.position++;
                    if (state.position === state.size) {
                        stack.pop();
                        object = state.array;
                    }
                    else {
                        continue DECODE;
                    }
                }
                else if (state.type === STATE_MAP_KEY) {
                    if (!isValidMapKeyType(object)) {
                        throw new DecodeError_1.DecodeError("The type of key must be string or number but " + typeof object);
                    }
                    if (object === "__proto__") {
                        throw new DecodeError_1.DecodeError("The key __proto__ is not allowed");
                    }
                    state.key = object;
                    state.type = STATE_MAP_VALUE;
                    continue DECODE;
                }
                else {
                    // it must be `state.type === State.MAP_VALUE` here
                    state.map[state.key] = object;
                    state.readCount++;
                    if (state.readCount === state.size) {
                        stack.pop();
                        object = state.map;
                    }
                    else {
                        state.key = null;
                        state.type = STATE_MAP_KEY;
                        continue DECODE;
                    }
                }
            }
            return object;
        }
    }
    readHeadByteFromBuffer() {
        const b = this.readU8FromBuffer();
        if (b === null) {
            return null;
        }
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = b;
        }
        return this.headByte;
    }
    async readHeadByte() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = await this.readU8();
        }
        return this.headByte;
    }
    complete() {
        this.headByte = HEAD_BYTE_REQUIRED;
    }
    pushMapState(size) {
        if (size > this.maxMapLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
        }
        this.stack.push({
            type: STATE_MAP_KEY,
            size,
            key: null,
            readCount: 0,
            map: {},
        });
    }
    pushArrayState(size) {
        if (size > this.maxArrayLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
        }
        this.stack.push({
            type: STATE_ARRAY,
            size,
            array: new Array(size),
            position: 0,
        });
    }
    decodeUtf8StringFromBuffer(byteLength) {
        var _a;
        if (byteLength > this.maxStrLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        const bytes = this.readBytesFromBuffer(byteLength);
        if (bytes === null) {
            return null;
        }
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(bytes, 0, byteLength);
        }
        else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
            object = (0, utf8_1.utf8DecodeTD)(bytes, 0, byteLength);
        }
        else {
            object = (0, utf8_1.utf8DecodeJs)(bytes, 0, byteLength);
        }
        return object;
    }
    async decodeUtf8String(byteLength) {
        var _a;
        if (byteLength > this.maxStrLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);
        }
        const bytes = await this.readBytes(byteLength);
        let object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(bytes, 0, byteLength);
        }
        else if (byteLength > utf8_1.TEXT_DECODER_THRESHOLD) {
            object = (0, utf8_1.utf8DecodeTD)(bytes, 0, byteLength);
        }
        else {
            object = (0, utf8_1.utf8DecodeJs)(bytes, 0, byteLength);
        }
        return object;
    }
    stateIsMapKey() {
        if (this.stack.length > 0) {
            const state = this.stack[this.stack.length - 1];
            return state.type === STATE_MAP_KEY;
        }
        return false;
    }
    async decodeBinary(byteLength) {
        if (byteLength > this.maxBinLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
        }
        const object = await this.readBytes(byteLength);
        return object;
    }
    async decodeExtension(size) {
        if (size > this.maxExtLength) {
            throw new DecodeError_1.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
        }
        const extType = await this.readI8();
        const data = await this.decodeBinary(size);
        return this.extensionCodec.decode(data, extType, this.context);
    }
    async readU8() {
        const data = await this.readBytes(1);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);
        return value;
    }
    async readI8() {
        const data = await this.readBytes(1);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);
        return value;
    }
    async readU16() {
        const data = await this.readBytes(2);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);
        return value;
    }
    async readI16() {
        const data = await this.readBytes(2);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);
        return value;
    }
    async readU32() {
        const data = await this.readBytes(4);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);
        return value;
    }
    async readI32() {
        const data = await this.readBytes(4);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);
        return value;
    }
    async readU64() {
        const data = await this.readBytes(8);
        const value = (0, int_1.getUint64)(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    async readI64() {
        const data = await this.readBytes(8);
        const value = (0, int_1.getInt64)(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    async readF32() {
        const data = await this.readBytes(4);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);
        return value;
    }
    async readF64() {
        const data = await this.readBytes(8);
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);
        return value;
    }
    readU8FromBuffer() {
        const data = this.readBytesFromBuffer(1);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint8(0);
        return value;
    }
    readI8FromBuffer() {
        const data = this.readBytesFromBuffer(1);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt8(0);
        return value;
    }
    readU16FromBuffer() {
        const data = this.readBytesFromBuffer(2);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0);
        return value;
    }
    readI16FromBuffer() {
        const data = this.readBytesFromBuffer(2);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt16(0);
        return value;
    }
    readU32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0);
        return value;
    }
    readI32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getInt32(0);
        return value;
    }
    readU64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = (0, int_1.getUint64)(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    readI64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = (0, int_1.getInt64)(new DataView(data.buffer, data.byteOffset, data.byteLength), 0);
        return value;
    }
    readF32FromBuffer() {
        const data = this.readBytesFromBuffer(4);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat32(0);
        return value;
    }
    readF64FromBuffer() {
        const data = this.readBytesFromBuffer(8);
        if (!data) {
            return null;
        }
        const value = new DataView(data.buffer, data.byteOffset, data.byteLength).getFloat64(0);
        return value;
    }
    readBytesFromBuffer(length) {
        if (this.buffer && this.buffer.length >= length) {
            const result = this.buffer.subarray(0, length);
            this.buffer = this.buffer.subarray(length);
            return result;
        }
        return null;
    }
    async readBytes(length) {
        var _a, _b;
        if (this.buffer && length <= this.buffer.length) {
            const result = this.buffer.subarray(0, length);
            this.buffer = this.buffer.subarray(length);
            return result;
        }
        else {
            const hasData = (_b = (_a = this.buffer) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            const needData = length - hasData;
            const result = new Uint8Array(length);
            if (this.buffer) {
                result.set(this.buffer, 0);
            }
            if (needData < this.bufferSize) {
                const next = await this.readToBuffer(this.bufferSize);
                if (next.length < needData) {
                    throw MORE_DATA;
                }
                result.set(next.subarray(0, needData), hasData);
                this.buffer = this.buffer.subarray(needData);
            }
            else {
                const next = await this.readToBuffer(needData);
                if (next.length < needData) {
                    throw MORE_DATA;
                }
                result.set(next.subarray(0, needData), hasData);
                this.buffer = this.buffer.subarray(needData);
            }
            return result;
        }
    }
    async readToBuffer(length) {
        const bytes = [];
        let size = 0;
        while (size < length) {
            const result = await this.readStream.next(this.bufferSize);
            if (!result.done) {
                bytes.push(result.value);
                size += result.value.length;
            }
            else {
                break;
            }
        }
        if (bytes.length == 1) {
            this.buffer = bytes[0];
            return bytes[0];
        }
        this.buffer = new Uint8Array(size);
        let pos = 0;
        for (const chunk of bytes) {
            this.buffer.set(chunk, pos);
            pos += chunk.length;
        }
        return this.buffer;
    }
}
exports.StreamDecoder = StreamDecoder;
//# sourceMappingURL=StreamDecoder.js.map