{"version":3,"file":"full.min.js","sources":["../src/utils/encoder.ts","../src/utils/constants.ts","../src/utils/internalSymbol.ts","../src/core/notify.ts","../src/utils/error.ts","../src/utils/jsonrpc.ts","../src/utils/generateRandomID.ts","../src/utils/normalizeOptions.ts","../src/Async-Call.ts","../src/Async-Call-Generator.ts","../src/utils/serialization.ts","../src/core/batch.ts"],"sourcesContent":["import type { IsomorphicEncoder, Request, Requests, Response, Responses, SuccessResponse } from '../types.ts'\nimport { isArray, undefined } from './constants.ts'\n\n/**\n * @public\n * Options of {@link (JSONEncoder:function)}\n */\nexport interface JSONEncoderOptions {\n    /** Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read. */\n    space?: string | number | undefined\n    /**\n     * How to handle `\"undefined\"` in the result of {@link SuccessResponse}.\n     *\n     * @remarks\n     * If you need a full support of encoding `undefined`, for example, when the result is `{ field: undefined }` and you want to keep it,\n     * you need to find another library to do this.\n     *\n     * If this is not handled properly, `JSON.stringify` will emit an invalid JSON-RPC object (fields with `undefined` value will be omitted).\n     *\n     * Options:\n     * - `\"null\"`(**default**): convert it to `null`.\n     * - `false`: do not do anything, let it break.\n     */\n    keepUndefined?: false | 'null' | undefined\n    /** A function that transforms the results. */\n    replacer?: ((this: any, key: string, value: any) => any) | undefined\n    /** A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is. */\n    reviver?: ((this: any, key: string, value: any) => any) | undefined\n}\n/**\n * Create a encoder by JSON.parse/stringify\n *\n * @public\n * @param options - Options for this encoder.\n * @remarks {@link IsomorphicEncoder}\n */\nexport function JSONEncoder({\n    keepUndefined = 'null',\n    replacer,\n    reviver,\n    space,\n}: JSONEncoderOptions = {}): IsomorphicEncoder {\n    return {\n        encode(data) {\n            if (keepUndefined) {\n                isArray(data) ? data.forEach(undefinedEncode) : undefinedEncode(data)\n            }\n            return JSON.stringify(data, replacer, space)\n        },\n        decode(encoded) {\n            const data: Requests | Responses = JSON.parse(encoded as string, reviver)\n            return data\n        },\n    }\n}\n\nconst undefinedEncode = (i: Response | Request) => {\n    if ('result' in i && i.result === undefined) {\n        i.result = null\n    }\n}\n\n/** @public */\nexport namespace JSONEncoder {\n    export const Default: IsomorphicEncoder<unknown, unknown> = JSONEncoder()\n}\n","export const isString = (x: unknown): x is string => typeof x === 'string'\nexport const isBoolean = (x: unknown): x is boolean => typeof x === 'boolean'\nexport const isFunction = (x: unknown): x is Function => typeof x === 'function'\nexport const isObject = (params: any): params is object => typeof params === 'object' && params !== null\nexport const ERROR = 'Error'\nexport const undefined = void 0\nexport const { setPrototypeOf } = Object\nexport const Promise_resolve = <T>(x: T) => Promise.resolve(x)\nexport const { isArray } = Array as { isArray(arg: any): arg is readonly any[] }\nexport const { apply } = Reflect\n","const i = 'AsyncCall/'\n// ! side effect\nexport const AsyncCallIgnoreResponse = Symbol.for(i + 'ignored')\nexport const AsyncCallNotify = Symbol.for(i + 'notify')\nexport const AsyncCallBatch = Symbol.for(i + 'batch')\n","import { AsyncCallNotify } from '../utils/internalSymbol.ts'\nimport { isFunction } from '../utils/constants.ts'\n\n/**\n * Make the returning type to `Promise<void>`\n * @internal\n * @remarks\n * Due to the limitation of TypeScript, generic signatures cannot be preserved\n * if the function is the top level parameter of this utility type,\n * or the function is not returning `Promise<void>`.\n */\nexport type _IgnoreResponse<T> = T extends (...args: infer Args) => unknown\n    ? (...args: Args) => Promise<void>\n    : {\n          [key in keyof T as T[key] extends Function ? key : never]: T[key] extends (\n              ...args: infer Args\n          ) => infer Return\n              ? Return extends Promise<void>\n                  ? T[key]\n                  : (...args: Args) => Promise<void>\n              : never\n      }\n/**\n * Wrap the AsyncCall instance to send notification.\n * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance\n * @example\n * const notifyOnly = notify(AsyncCall(...))\n * @public\n */\n\nexport function notify<T extends object>(instanceOrFnOnInstance: T): _IgnoreResponse<T> {\n    if (isFunction(instanceOrFnOnInstance)) return (instanceOrFnOnInstance as any)[AsyncCallNotify]\n    return new Proxy(instanceOrFnOnInstance, { get: notifyTrap }) as any\n}\nconst notifyTrap = (target: any, p: string | number | symbol) => {\n    return target[p][AsyncCallNotify]\n}\n","import type { AbortSignalLike } from '../types.ts'\n\nclass CustomError extends Error {\n    // TODO: support cause\n    constructor(\n        public name: string,\n        message: string,\n        public code: number,\n        public stack: string,\n    ) {\n        super(message)\n    }\n}\nexport const Err_Cannot_find_a_running_iterator_with_given_ID: unique symbol = {} as any\nexport const Err_Only_string_can_be_the_RPC_method_name: unique symbol = {} as any\nexport const Err_Cannot_call_method_starts_with_rpc_dot_directly: unique symbol = {} as any\nexport const Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options: unique symbol =\n    {} as any\nconst Messages = [\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n] as const\n// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages\nexport const makeHostedMessage = (id: (typeof Messages)[number], error: Error) => {\n    const n = Messages.indexOf(id)\n    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n\n    return error\n}\n// ! side effect\n/** These Error is defined in ECMAScript spec */\nconst errors: Record<string, typeof EvalError> = {\n    // @ts-expect-error\n    __proto__: null,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n}\nexport const DOMExceptionHeader = 'DOMException:'\n/**\n * AsyncCall support somehow transfer ECMAScript Error\n */\nexport const RecoverError = (type: string, message: string, code: number, stack: string): Error => {\n    try {\n        let E\n        if (type.startsWith(DOMExceptionHeader) && (E = globalDOMException())) {\n            const name = type.slice(DOMExceptionHeader.length)\n            return new E(message, name)\n        } else if (type in errors) {\n            const e = new errors[type]!(message)\n            e.stack = stack\n            // @ts-expect-error\n            e.code = code\n            return e\n        } else {\n            return new CustomError(type, message, code, stack)\n        }\n    } catch {\n        return new Error(`E${code} ${type}: ${message}\\n${stack}`)\n    }\n}\nexport const removeStackHeader = (stack: unknown) => String(stack).replace(/^.+\\n.+\\n/, '')\n// ! side effect\nexport const globalDOMException = (() => {\n    try {\n        // @ts-expect-error\n        return DOMException\n    } catch {}\n}) as () => DOMException | undefined\ntype DOMException = { new (message: string, name: string): any }\nexport function onAbort(signal: AbortSignalLike | undefined, callback: () => void) {\n    signal && signal.addEventListener('abort', callback, { once: true })\n}\n","import { globalDOMException as DOMException, DOMExceptionHeader } from './error.ts'\nimport type { ErrorMapFunction } from '../Async-Call.ts'\nimport { ERROR, isArray, isFunction, isObject, undefined } from './constants.ts'\nimport type { Request, SuccessResponse, ErrorResponse, ID, Response } from '../types.ts'\n\nexport const jsonrpc = '2.0'\nexport const makeRequest = (\n    id: ID,\n    method: string,\n    params: readonly unknown[] | object,\n    remoteStack?: string,\n): Request => {\n    const x: Request = { jsonrpc, id, method, params, remoteStack }\n    deleteUndefined(x, 'id')\n    deleteFalsy(x, 'remoteStack')\n    return x\n}\nexport const makeSuccessResponse = (id: ID, result: unknown): SuccessResponse => {\n    const x: SuccessResponse = { jsonrpc, id, result }\n    deleteUndefined(x, 'id')\n    return x\n}\nexport const makeErrorResponse = <T>(id: ID, code: number, message: string, data?: T): ErrorResponse<T> => {\n    if (id === undefined) id = null\n    code = Math.floor(code)\n    if (Number.isNaN(code)) code = -1\n    const x: ErrorResponse<T> = { jsonrpc, id, error: { code, message, data } }\n    deleteUndefined(x.error, 'data')\n    return x\n}\n// Pre defined error in section 5.1\n// ! side effect\nexport const ErrorResponseParseError = <T>(e: unknown, mapper: ErrorMapFunction<T>): ErrorResponse<T> => {\n    const obj = ErrorResponseMapped({} as any, e, mapper)\n    const o = obj.error as Mutable<ErrorResponse['error']>\n    o.code = -32700\n    o.message = 'Parse error'\n    return obj\n}\n\n// Not using.\n// InvalidParams -32602 'Invalid params'\n// InternalError -32603 'Internal error'\nexport const ErrorResponseInvalidRequest = (id: ID) => makeErrorResponse(id, -32600, 'Invalid Request')\nexport const ErrorResponseMethodNotFound = (id: ID) => makeErrorResponse(id, -32601, 'Method not found')\n\ntype AsyncCallErrorDetail = {\n    stack?: string\n    type?: string\n}\nexport const ErrorResponseMapped = <T>(request: Request, e: unknown, mapper: ErrorMapFunction<T>): ErrorResponse<T> => {\n    const { id } = request\n    const { code, message, data } = mapper(e, request)\n    return makeErrorResponse(id, code, message, data)\n}\n\nexport const defaultErrorMapper =\n    (stack = '', code = -1): ErrorMapFunction<AsyncCallErrorDetail> =>\n    (e) => {\n        let message = toString('', () => (e as any).message)\n        let type = toString(ERROR, (ctor = (e as any).constructor) => isFunction(ctor) && ctor.name)\n        const E = DOMException()\n        if (E && e instanceof E) type = DOMExceptionHeader + e.name\n        const eType = typeof e\n        if (eType == 'string' || eType === 'number' || eType == 'boolean' || eType == 'bigint') {\n            type = ERROR\n            message = String(e)\n        }\n        const data: AsyncCallErrorDetail = stack ? { stack, type } : { type }\n        return { code, message, data }\n    }\n\nexport const isJSONRPCObject = (data: any): data is Response | Request => {\n    if (!isObject(data)) return false\n    if (!('jsonrpc' in data)) return false\n    if (data.jsonrpc !== jsonrpc) return false\n    if ('params' in data) {\n        const params = data.params\n        if (!isArray(params) && !isObject(params)) return false\n    }\n    return true\n}\n\nconst toString = (_default: string, val: () => any) => {\n    try {\n        const v = val()\n        if (v === undefined) return _default\n        return String(v)\n    } catch {\n        return _default\n    }\n}\nconst deleteUndefined = <O>(x: O, key: keyof O) => {\n    if (x[key] === undefined) delete x[key]\n}\nconst deleteFalsy = <T>(x: T, key: keyof T) => {\n    if (!x[key]) delete x[key]\n}\ntype Mutable<T> = { -readonly [key in keyof T]: T[key] }\n","export const generateRandomID = () => Math.random().toString(36).slice(2)\n","import type { AsyncCallOptions } from '../Async-Call.ts'\nimport { isBoolean } from './constants.ts'\nconst undefinedToTrue = (x: undefined | boolean) => (x === void 0 ? true : x)\ntype NormalizedLogOptions = readonly [\n    beCalled: boolean,\n    localError: boolean,\n    remoteError: boolean,\n    isPretty?: boolean,\n    requestReplay?: boolean,\n    sendLocalStack?: boolean,\n]\n\nexport const normalizeLogOptions = (log: NonNullable<AsyncCallOptions['log']>): NormalizedLogOptions | [] => {\n    if (log === 'all') return [true, true, true, true, true, true]\n    if (!isBoolean(log)) {\n        const { beCalled, localError, remoteError, type, requestReplay, sendLocalStack } = log\n        return [\n            undefinedToTrue(beCalled),\n            undefinedToTrue(localError),\n            undefinedToTrue(remoteError),\n            type !== 'basic',\n            requestReplay,\n            sendLocalStack,\n        ]\n    }\n    if (log) return [true, true, true, true] as const\n    return []\n}\n\nexport const normalizeStrictOptions = (strict: NonNullable<AsyncCallOptions['strict']>) => {\n    if (!isBoolean(strict)) {\n        const { methodNotFound, unknownMessage } = strict\n        return [methodNotFound, unknownMessage] as const\n    }\n    return [strict, strict] as const\n}\n","export type * from './types.ts'\nexport type { _IgnoreResponse } from './core/notify.ts'\nexport { JSONSerialization, NoSerialization } from './utils/serialization.ts'\nexport { JSONEncoder, type JSONEncoderOptions } from './utils/encoder.ts'\nexport { notify } from './core/notify.ts'\nexport { batch } from './core/batch.ts'\n\nimport {\n    makeRequest,\n    ErrorResponseMapped,\n    makeSuccessResponse,\n    isJSONRPCObject,\n    defaultErrorMapper,\n    ErrorResponseMethodNotFound,\n    ErrorResponseInvalidRequest,\n    ErrorResponseParseError,\n} from './utils/jsonrpc.ts'\nimport {\n    removeStackHeader,\n    RecoverError,\n    makeHostedMessage,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n    onAbort,\n} from './utils/error.ts'\nimport { generateRandomID } from './utils/generateRandomID.ts'\nimport { normalizeStrictOptions, normalizeLogOptions } from './utils/normalizeOptions.ts'\nimport { AsyncCallIgnoreResponse, AsyncCallNotify, AsyncCallBatch } from './utils/internalSymbol.ts'\nimport type { BatchQueue } from './core/batch.ts'\nimport type {\n    CallbackBasedChannel,\n    EventBasedChannel,\n    AsyncCallOptions,\n    ConsoleInterface,\n    AsyncVersionOf,\n    Request,\n    Response,\n    SuccessResponse,\n    ErrorResponse,\n    IsomorphicEncoderFull,\n    IsomorphicEncoder,\n    Requests,\n    Responses,\n} from './types.ts'\nimport { apply, ERROR, isArray, isFunction, isObject, isString, Promise_resolve, undefined } from './utils/constants.ts'\n\n/**\n * Create a RPC server & client.\n *\n * @remarks\n * See {@link AsyncCallOptions}\n *\n * thisSideImplementation can be a Promise so you can write:\n *\n * ```ts\n * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})\n * ```\n *\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.\n * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called \"then\" are also removed.\n * @public\n */\nexport function AsyncCall<OtherSideImplementedFunctions = {}>(\n    thisSideImplementation: null | undefined | object | Promise<object>,\n    options: AsyncCallOptions,\n): AsyncVersionOf<OtherSideImplementedFunctions> {\n    type Hint = 'request' | 'response' | undefined\n\n    let isThisSideImplementationPending = true\n    let resolvedThisSideImplementationValue: unknown\n    let rejectedThisSideImplementation: unknown\n\n    let resolvedChannel: EventBasedChannel | CallbackBasedChannel | undefined\n    let channelPromise: Promise<EventBasedChannel | CallbackBasedChannel> | undefined\n    // This promise should never fail\n    const awaitThisSideImplementation = async () => {\n        try {\n            resolvedThisSideImplementationValue = await thisSideImplementation\n        } catch (e) {\n            rejectedThisSideImplementation = e\n            console_error('AsyncCall failed to start', e)\n        } finally {\n            isThisSideImplementationPending = false\n        }\n    }\n    const onChannelResolved = (channel: EventBasedChannel | CallbackBasedChannel) => {\n        resolvedChannel = channel\n        if (isCallbackBasedChannel(channel)) {\n            channel.setup(\n                (data, hint) => rawMessageReceiver(data, hint).then(rawMessageSender),\n                (data, hint) => {\n                    let _ = hintedDecode(data, hint)\n\n                    if (isJSONRPCObject(_)) return true\n                    return Promise_resolve(_).then(isJSONRPCObject)\n                },\n            )\n        }\n        if (isEventBasedChannel(channel)) {\n            const m = channel\n            m.on &&\n                m.on((_, hint) =>\n                    rawMessageReceiver(_, hint)\n                        .then(rawMessageSender)\n                        .then((x) => x && m.send!(x)),\n                )\n        }\n        return channel\n    }\n\n    const {\n        serializer,\n        encoder,\n        key: deprecatedName,\n        name,\n        strict = true,\n        log = true,\n        parameterStructures: deprecatedParameterStructures,\n        parameterStructure,\n        preferLocalImplementation = false,\n        idGenerator = generateRandomID,\n        mapError,\n        logger,\n        channel,\n        thenable,\n        signal,\n        forceSignal,\n    } = options\n\n    // Note: we're not shorten this error message because it will be removed in the next major version.\n    if (serializer && encoder) throw new TypeError('Please remove serializer.')\n    if (name && deprecatedName) throw new TypeError('Please remove key.')\n    if (deprecatedParameterStructures && parameterStructure) throw new TypeError('Please remove parameterStructure.')\n    const paramStyle = deprecatedParameterStructures || parameterStructure || 'by-position'\n    const logKey = name || deprecatedName || 'rpc'\n\n    const throwIfAborted = () => {\n        signal && signal.throwIfAborted()\n        forceSignal && forceSignal.throwIfAborted()\n    }\n\n    const {\n        encode: encodeFromOption,\n        encodeRequest: encodeRequestFromOption,\n        encodeResponse: encodeResponseFromOption,\n        decode,\n        decodeRequest,\n        decodeResponse,\n    } = (encoder || {}) as IsomorphicEncoder & IsomorphicEncoderFull\n\n    const encodeRequest: (data: Requests | Responses) => any = encoder\n        ? (data) => apply(encodeRequestFromOption || encodeFromOption, encoder, [data])\n        : serializer\n          ? (data) => serializer.serialization(data)\n          : Object\n\n    const encodeResponse: (data: Requests | Responses) => any = encoder\n        ? (data) => apply(encodeResponseFromOption || encodeFromOption, encoder, [data])\n        : serializer\n          ? (data) => serializer.serialization(data)\n          : Object\n\n    const hintedDecode: (data: unknown, hint: Hint) => unknown = encoder\n        ? (data, hint) =>\n              hint == 'request'\n                  ? apply(decodeRequest || decode, encoder, [data])\n                  : hint == 'response'\n                    ? apply(decodeResponse || decode, encoder, [data])\n                    : apply(decode, encoder, [data])\n        : serializer\n          ? (data) => serializer.deserialization(data)\n          : Object\n\n    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation()\n    else {\n        resolvedThisSideImplementationValue = thisSideImplementation\n        isThisSideImplementationPending = false\n    }\n\n    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict)\n    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] =\n        normalizeLogOptions(log)\n    const {\n        log: console_log,\n        error: console_error = console_log,\n        debug: console_debug = console_log,\n        groupCollapsed: console_groupCollapsed = console_log,\n        groupEnd: console_groupEnd = console_log,\n        warn: console_warn = console_log,\n    } = (logger || console) as ConsoleInterface\n    type PromiseParam = [resolve: (value?: any) => void, reject: (reason?: any) => void, stack?: string]\n    const requestContext = new Map<string | number, PromiseParam>()\n\n    onAbort(forceSignal, () => {\n        requestContext.forEach((x) => x[1](forceSignal!.reason))\n        requestContext.clear()\n    })\n\n    const onRequest = async (data: Request): Promise<Response | undefined> => {\n        if ((signal && signal.aborted) || (forceSignal && forceSignal.aborted))\n            return makeErrorObject((signal && signal.reason) || (forceSignal && forceSignal.reason), '', data)\n        if (isThisSideImplementationPending) await awaitThisSideImplementation()\n        // TODO: in next major version we should not send this message since it might contain sensitive info.\n        else if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data)\n        let frameworkStack: string = ''\n        try {\n            const { params, method, id: req_id, remoteStack } = data\n            // ? We're mapping any method starts with 'rpc.' to a Symbol.for\n            const key = (method.startsWith('rpc.') ? Symbol.for(method) : method) as keyof object\n            const executor: unknown = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key]\n            if (!isFunction(executor)) {\n                if (!banMethodNotFound) {\n                    if (log_localError) console_debug('Missing method', key, data)\n                    return\n                } else return ErrorResponseMethodNotFound(req_id)\n            }\n            const args = isArray(params) ? params : [params]\n            frameworkStack = removeStackHeader(new Error().stack)\n            const promise = new Promise((resolve) =>\n                resolve(apply(executor, resolvedThisSideImplementationValue, args)),\n            )\n            if (log_beCalled) {\n                if (log_pretty) {\n                    const logArgs: unknown[] = [\n                        `${logKey}.%c${method}%c(${args.map(() => '%o').join(', ')}%c)\\n%o %c@${req_id}`,\n                        'color:#d2c057',\n                        '',\n                        ...args,\n                        '',\n                        promise,\n                        'color:gray;font-style:italic;',\n                    ]\n                    if (log_requestReplay) {\n                        const replay = () => {\n                            debugger\n                            return apply(executor, resolvedThisSideImplementationValue, args)\n                        }\n                        // this function will be logged, keep it short.\n                        // Do not inline it, it's hard to keep it in a single line after build step.\n                        logArgs.push(() => replay())\n                    }\n                    if (remoteStack) {\n                        console_groupCollapsed(...logArgs)\n                        console_log(remoteStack)\n                        console_groupEnd()\n                    } else console_log(...logArgs)\n                } else console_log(`${logKey}.${method}(${[...args].toString()}) @${req_id}`)\n            }\n            const result = await promise\n            if (result === AsyncCallIgnoreResponse) return\n            return makeSuccessResponse(req_id, result)\n        } catch (e) {\n            return makeErrorObject(e, frameworkStack, data)\n        }\n    }\n    const onResponse = async (data: Response): Promise<void> => {\n        let errorMessage = '',\n            remoteErrorStack = '',\n            errorCode = 0,\n            errorType = ERROR\n        if ('error' in data) {\n            const e = data.error\n            errorMessage = e.message\n            errorCode = e.code\n            const detail = e.data\n\n            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack\n            else remoteErrorStack = '<remote stack not available>'\n\n            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type\n            else errorType = ERROR\n\n            if (log_remoteError)\n                log_pretty\n                    ? console_error(\n                          `${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\\n%c${remoteErrorStack}`,\n                          'color: gray',\n                          '',\n                      )\n                    : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\\n${remoteErrorStack}`)\n        }\n        const { id } = data\n        if (id === null || id === undefined || !requestContext.has(id)) return\n        const [resolve, reject, localErrorStack = ''] = requestContext.get(id)!\n        requestContext.delete(id)\n        if ('error' in data) {\n            reject(\n                // TODO: add a hook to customize this\n                RecoverError(\n                    errorType,\n                    errorMessage,\n                    errorCode,\n                    // ? We use \\u0430 which looks like \"a\" to prevent browser think \"at AsyncCall\" is a real stack\n                    remoteErrorStack + '\\n    \\u0430t AsyncCall (rpc) \\n' + localErrorStack,\n                ),\n            )\n        } else {\n            resolve(data.result)\n        }\n        return\n    }\n    const rawMessageReceiver = async (\n        _: unknown,\n        hint: Hint,\n    ): Promise<undefined | Response | (Response | undefined)[]> => {\n        let data: unknown\n        let result: Response | undefined = undefined\n        try {\n            data = await hintedDecode(_, hint)\n            if (isJSONRPCObject(data)) {\n                return (result = await handleSingleMessage(data))\n            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {\n                return Promise.all(data.map(handleSingleMessage))\n            } else {\n                if (banUnknownMessage) {\n                    let id = (data as any).id\n                    if (id === undefined) id = null\n                    return ErrorResponseInvalidRequest(id)\n                } else {\n                    // ? Ignore this message. The message channel maybe also used to transfer other message too.\n                    return undefined\n                }\n            }\n        } catch (e) {\n            if (log_localError) console_error(e, data, result)\n            let stack: string | undefined\n            try {\n                stack = '' + (e as any).stack\n            } catch {}\n            return ErrorResponseParseError(e, mapError || defaultErrorMapper(stack))\n        }\n    }\n    const rawMessageSender = async (res: undefined | Response | (Response | undefined)[]) => {\n        if (!res) return\n        if (isArray(res)) {\n            const reply = res.filter((x): x is Response => (x && 'id' in x) as boolean)\n            if (reply.length === 0) return\n            return encodeResponse(reply)\n        } else {\n            return encodeResponse(res)\n        }\n    }\n\n    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved)\n    else onChannelResolved(channel)\n\n    const makeErrorObject = (e: any, frameworkStack: string, data: Request) => {\n        if (isObject(e) && 'stack' in e)\n            e.stack = frameworkStack\n                .split('\\n')\n                .reduce((stack, fstack) => stack.replace(fstack + '\\n', ''), '' + e.stack)\n        if (log_localError) console_error(e)\n        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined))\n    }\n\n    const sendPayload = async (payload: Requests | BatchQueue, removeQueueR?: true) => {\n        if (removeQueueR) payload = [...(payload as BatchQueue)]\n        const data = await encodeRequest(payload)\n        return (resolvedChannel || (await channelPromise))!.send!(data)\n    }\n    const rejectsQueue = (queue: BatchQueue, error: unknown) => {\n        for (const x of queue) {\n            if ('id' in x) {\n                const ctx = requestContext.get(x.id!)\n                ctx && ctx[1](error)\n            }\n        }\n    }\n    const handleSingleMessage = async (\n        data: SuccessResponse | ErrorResponse | Request,\n    ): Promise<SuccessResponse | ErrorResponse | undefined> => {\n        if ('method' in data) {\n            if ('id' in data) {\n                if (!forceSignal) return onRequest(data)\n                return new Promise((resolve, reject) => {\n                    const handleForceAbort = () => resolve(makeErrorObject(forceSignal.reason, '', data))\n                    onRequest(data)\n                        .then(resolve, reject)\n                        .finally(() => forceSignal.removeEventListener('abort', handleForceAbort))\n                    onAbort(forceSignal, handleForceAbort)\n                })\n            }\n            onRequest(data).catch(() => {})\n            return // Skip response for notifications\n        }\n        return onResponse(data) as Promise<undefined>\n    }\n    const call = (method: string | symbol, args: unknown[], stack: string | undefined, notify = false) => {\n        return new Promise<void>((resolve, reject) => {\n            throwIfAborted()\n            let queue: BatchQueue | undefined = undefined\n            if (method === AsyncCallBatch) {\n                queue = args.shift() as any\n                method = args.shift() as any\n            }\n            if (typeof method === 'symbol') {\n                const RPCInternalMethod: string = Symbol.keyFor(method) || (method as any).description\n                if (RPCInternalMethod) {\n                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod\n                    else throw new TypeError('Not start with rpc.')\n                }\n            } else if (method.startsWith('rpc.')) {\n                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError())\n            }\n\n            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {\n                const localImpl: unknown =\n                    resolvedThisSideImplementationValue && (resolvedThisSideImplementationValue as any)[method]\n                if (isFunction(localImpl)) return resolve(localImpl(...args))\n            }\n            const id = idGenerator()\n            stack = removeStackHeader(stack)\n            const param = paramStyle === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args\n            const request = makeRequest(\n                notify ? undefined : id,\n                method as string,\n                param,\n                log_sendLocalStack ? stack : undefined,\n            )\n            if (queue) {\n                queue.push(request)\n                if (!queue.r) queue.r = [() => sendPayload(queue!, true), (e) => rejectsQueue(queue!, e)]\n            } else sendPayload(request).catch(reject)\n            if (notify) return resolve()\n            requestContext.set(id, [resolve, reject, stack])\n        })\n    }\n    const getTrap = (_: any, method: string | symbol) => {\n        const f = {\n            // This function will be logged to the console so it must be 1 line\n            [method]: (..._: unknown[]) => call(method, _, new Error().stack),\n        }[method as any]!\n        const f2 = {\n            [method]: (..._: unknown[]) => call(method, _, new Error().stack, true),\n        }[method as any]!\n        // @ts-expect-error\n        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2\n        isString(method) && Object.defineProperty(methodContainer, method, { value: f, configurable: true })\n        return f\n    }\n    const methodContainer: any = { __proto__: new Proxy({}, { get: getTrap }) }\n    if (thenable === false) methodContainer.then = undefined\n    else if (thenable === undefined) {\n        Object.defineProperty(methodContainer, 'then', {\n            configurable: true,\n            get() {\n                console_warn(\n                    makeHostedMessage(\n                        Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n                        new TypeError('RPC used as Promise: '),\n                    ),\n                )\n            },\n        })\n    }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: () => null,\n        setPrototypeOf: (_, value) => value === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor(_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            return Object.getOwnPropertyDescriptor(methodContainer, method)\n        },\n    }) as AsyncVersionOf<OtherSideImplementedFunctions>\n}\n// Assume a console object in global if there is no custom logger provided\ndeclare const console: ConsoleInterface\n\nconst isEventBasedChannel = (x: EventBasedChannel | CallbackBasedChannel): x is EventBasedChannel =>\n    'send' in x && isFunction(x.send)\nconst isCallbackBasedChannel = (x: EventBasedChannel | CallbackBasedChannel): x is CallbackBasedChannel =>\n    'setup' in x && isFunction(x.setup)\n","/**\n * See the document at https://github.com/Jack-Works/async-call/\n */\nimport type { AsyncCallOptions } from './types.ts'\nimport { AsyncCall } from './Async-Call.ts'\nimport { AsyncCallIgnoreResponse } from './utils/internalSymbol.ts'\nimport { normalizeStrictOptions } from './utils/normalizeOptions.ts'\nimport { generateRandomID } from './utils/generateRandomID.ts'\nimport { isFunction, isString, setPrototypeOf } from './utils/constants.ts'\nimport {\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    makeHostedMessage,\n} from './utils/error.ts'\n\nconst i = 'rpc.async-iterator.'\n// ! side effect\nconst AsyncIteratorStart = Symbol.for(i + 'start')\nconst AsyncIteratorNext = Symbol.for(i + 'next')\nconst AsyncIteratorReturn = Symbol.for(i + 'return')\nconst AsyncIteratorThrow = Symbol.for(i + 'throw')\n\ninterface AsyncGeneratorInternalMethods {\n    [AsyncIteratorStart](method: string, params: unknown[]): Promise<string>\n    [AsyncIteratorNext](id: string, value: unknown): Promise<IteratorResult<unknown>>\n    [AsyncIteratorReturn](id: string, value: unknown): Promise<IteratorResult<unknown>>\n    [AsyncIteratorThrow](id: string, value: unknown): Promise<IteratorResult<unknown>>\n}\n\n/** @internal */\nexport type _IteratorOrIterableFunction = (\n    ...args: any\n) => Iterator<any, any, any> | Iterable<any> | AsyncIterator<any, any, any> | AsyncIterable<any>\n/** @internal */\nexport type _IteratorLikeToAsyncGenerator<T extends _IteratorOrIterableFunction> = T extends (\n    ...args: any\n) => AsyncGenerator<any>\n    ? T // return async generator as-is so generics can be preserved\n    : T extends (\n          ...args: infer Args\n      ) =>\n          | Iterator<infer Yield, infer Return, infer Next>\n          | Iterable<infer Yield>\n          | AsyncIterator<infer Yield, infer Return, infer Next>\n          | AsyncIterable<infer Yield>\n    ? (...args: Args) => AsyncGenerator<Yield, Return, Next>\n    : never\n\n/**\n * Make all generator in the type T becomes AsyncGenerator\n *\n * @remarks\n * Only generics signatures on function that returning an AsyncGenerator<T> will be preserved due to the limitation of TypeScript.\n *\n * Method called `then` are intentionally removed because it is very likely to be a foot gun in promise auto-unwrap.\n * @public\n */\nexport type AsyncGeneratorVersionOf<T> = T extends Record<keyof T, _IteratorOrIterableFunction>\n    ? 'then' extends keyof T\n        ? Omit<Readonly<T>, 'then'>\n        : // in this case we don't want to use Readonly<T>, so it will provide a better experience\n          T\n    : _AsyncGeneratorVersionOf<T>\n/** @internal */\nexport type _AsyncGeneratorVersionOf<T> = {\n    // Omit 'then'\n    [key in keyof T as key extends 'then'\n        ? never\n        : // Omit non-iterator/iterable\n        T[key] extends _IteratorOrIterableFunction\n        ? key\n        : never]: T[key] extends _IteratorOrIterableFunction ? _IteratorLikeToAsyncGenerator<T[key]> : never\n}\n\ntype Iter = Iterator<unknown, unknown, unknown> | AsyncIterator<unknown>\ntype IterResult = IteratorResult<unknown> | Promise<IteratorResult<unknown>>\n/**\n * The async generator version of the AsyncCall\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, AsyncCall will convert it to the Promised type.\n * @remarks\n * Warning: Due to technical limitation, AsyncGeneratorCall will leak memory. Use it at your own risk.\n *\n * To use AsyncGeneratorCall, the server and the client MUST support the following JSON RPC internal methods which is pre ECMAScript async generator semantics:\n *\n * - `rpc.async-iterator.start`\n *\n * - `rpc.async-iterator.next`\n *\n * - `rpc.async-iterator.return`\n *\n * - `rpc.async-iterator.throw`\n *\n * @example\n * ```ts\n * const server = {\n *      async *generator() {\n *          let last = 0\n *          while (true) yield last++\n *      },\n * }\n * type Server = typeof server\n * const serverRPC = AsyncGeneratorCall<Server>({}, { channel })\n * async function main() {\n *      for await (const x of serverRPC.generator()) {\n *          console.log('Server yielded number', x)\n *      }\n * }\n * ```\n * @public\n */\nexport function AsyncGeneratorCall<OtherSideImplementedFunctions = {}>(\n    thisSideImplementation: null | undefined | object | Promise<object>,\n    options: AsyncCallOptions,\n): AsyncGeneratorVersionOf<OtherSideImplementedFunctions> {\n    if (!AsyncGeneratorPrototypeSet) {\n        const EmptyAsyncGenerator = async function* () {}\n        const AsyncGeneratorConstructor = (AsyncGeneratorPrototypeSet = EmptyAsyncGenerator.constructor)\n        const AsyncGeneratorConstructorPrototype = AsyncGeneratorConstructor.prototype\n        setPrototypeOf(_AsyncGenerator, AsyncGeneratorConstructorPrototype)\n        const AsyncGeneratorPrototype = Object.getPrototypeOf(EmptyAsyncGenerator())\n        setPrototypeOf(_AsyncGenerator.prototype, AsyncGeneratorPrototype)\n    }\n    const iterators = new Map<string | number, Iter>()\n    const [methodNotFound] = normalizeStrictOptions(options.strict ?? true)\n    const { idGenerator = generateRandomID } = options\n    const findIterator = (\n        id: string,\n        next: (iterator: Iter) => IterResult | undefined | false,\n    ): false | undefined | IterResult | typeof AsyncCallIgnoreResponse => {\n        const it = iterators.get(id)\n        if (!it) {\n            if (methodNotFound)\n                throw makeHostedMessage(Err_Cannot_find_a_running_iterator_with_given_ID, new Error(`Iterator ${id}, `))\n            else return AsyncCallIgnoreResponse\n        }\n        const result = next(it)\n        isFinished(result, () => iterators.delete(id))\n        return result\n    }\n    const server = {\n        async [AsyncIteratorStart](method, args) {\n            const iteratorGenerator: unknown = ((await thisSideImplementation) as any)[method]\n            if (!isFunction(iteratorGenerator)) {\n                if (methodNotFound) throw new TypeError(method + ' is not a function')\n                else return AsyncCallIgnoreResponse\n            }\n            const iterator = iteratorGenerator(...args)\n            const id = idGenerator()\n            iterators.set(id, iterator)\n            return id\n        },\n        [AsyncIteratorNext](id, val) {\n            return findIterator(id, (it) => it.next(val as any))\n        },\n        [AsyncIteratorReturn](id, val) {\n            return findIterator(id, (it) => isFunction(it.return) && it.return(val))\n        },\n        [AsyncIteratorThrow](id, val) {\n            return findIterator(id, (it) => isFunction(it.throw) && it.throw(val))\n        },\n    } as AsyncGeneratorInternalMethods\n    const remote = AsyncCall<AsyncGeneratorInternalMethods>(server, options)\n\n    const getTrap = (_: any, method: PropertyKey) => {\n        if (!isString(method)) throw makeHostedMessage(Err_Only_string_can_be_the_RPC_method_name, new TypeError(''))\n        const f = {\n            [method]: (..._: unknown[]) => {\n                const id = remote[AsyncIteratorStart](method, _)\n                return new _AsyncGenerator(remote, id)\n            },\n        }[method]!\n        Object.defineProperty(methodContainer, method, { value: f, configurable: true })\n        return f\n    }\n    const methodContainer: any = { __proto__: new Proxy({}, { get: getTrap }) }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: () => null,\n        setPrototypeOf: (_, val) => val === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor(_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            return Object.getOwnPropertyDescriptor(methodContainer, method)\n        },\n    }) as AsyncGeneratorVersionOf<OtherSideImplementedFunctions>\n}\nclass _AsyncGenerator implements AsyncIterableIterator<unknown>, AsyncIterator<unknown, unknown, unknown> {\n    /** done? */\n    private d: boolean = false\n    /** check */\n    private c = async (val: IterResult) => {\n        await isFinished(val, () => (this.d = true))\n        return val\n    }\n    /**\n     * @param r Remote Implementation\n     * @param i id\n     */\n    constructor(\n        private r: AsyncGeneratorInternalMethods,\n        private i: Promise<string>,\n    ) {}\n    async return(val: unknown) {\n        if (this.d) return makeIteratorResult(true, val)\n        return this.c(this.r[AsyncIteratorReturn](await this.i, val))\n    }\n    async next(val?: unknown) {\n        if (this.d) return makeIteratorResult(true)\n        return this.c(this.r[AsyncIteratorNext](await this.i, val))\n    }\n    async throw(val?: unknown) {\n        if (!this.d) return this.c(this.r[AsyncIteratorThrow](await this.i, val))\n        throw val\n    }\n    // Inherited from AsyncGeneratorPrototype\n    declare [Symbol.asyncIterator]: () => this\n}\nlet AsyncGeneratorPrototypeSet: unknown = false\n\nconst isFinished = async (result: IterResult | undefined | false, cb: () => void) => {\n    try {\n        const x = await result\n        x && x.done && cb()\n    } catch {}\n}\n\nconst makeIteratorResult = (done: boolean, value: unknown = undefined): IteratorResult<unknown, unknown> => ({\n    done,\n    value,\n})\n","import { isObject, undefined } from './constants.ts'\nimport type { Serialization } from '../types.ts'\n\n/**\n * Serialization implementation that do nothing\n * @remarks {@link Serialization}\n * @public\n * @deprecated Will be removed in next major version\n */\nexport const NoSerialization: Serialization = {\n    serialization(from) {\n        return from\n    },\n    deserialization(serialized) {\n        return serialized\n    },\n}\n\n/**\n * Create a serialization by JSON.parse/stringify\n *\n * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify\n * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n * @param undefinedKeepingBehavior - How to keep \"undefined\" in result of SuccessResponse?\n *\n * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.\n *\n * Options:\n * - `\"null\"`(**default**): convert it to null.\n * - `\"keep\"`: try to keep it by additional property \"undef\".\n * - `false`: Don't keep it, let it break.\n * @remarks {@link Serialization}\n * @public\n */\nexport const JSONSerialization = (\n    replacerAndReceiver: [((key: string, value: any) => any)?, ((key: string, value: any) => any)?] = [\n        undefined,\n        undefined,\n    ],\n    space?: string | number | undefined,\n    undefinedKeepingBehavior: 'keep' | 'null' | false = 'null',\n): Serialization => ({\n    serialization(from) {\n        if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined) {\n            const alt = { ...from }\n            alt.result = null\n            if (undefinedKeepingBehavior === 'keep') (alt as any).undef = true\n            from = alt\n        }\n        return JSON.stringify(from, replacerAndReceiver[0], space)\n    },\n    deserialization(serialized) {\n        const result = JSON.parse(serialized as string, replacerAndReceiver[1])\n        if (\n            isObject(result) &&\n            'result' in result &&\n            result.result === null &&\n            'undef' in result &&\n            result.undef === true\n        ) {\n            result.result = undefined\n            delete result.undef\n        }\n        return result\n    },\n})\n","import { isString } from '../utils/constants.ts'\nimport { AsyncCallBatch, AsyncCallNotify } from '../utils/internalSymbol.ts'\nimport type { Request } from '../types.ts'\n/**\n * Wrap the AsyncCall instance to use batch call.\n * @param asyncCallInstance - The AsyncCall instance\n * @example\n * const [batched, send, drop] = batch(AsyncCall(...))\n * batched.call1() // pending\n * batched.call2() // pending\n * send() // send all pending requests\n * drop() // drop all pending requests\n * @returns It will return a tuple.\n *\n * The first item is the batched version of AsyncCall instance passed in.\n *\n * The second item is a function to send all pending requests.\n *\n * The third item is a function to drop and reject all pending requests.\n * @public\n */\n// TODO: use private field in the future.\nexport function batch<T extends object>(asyncCallInstance: T): [T, () => void, (error?: unknown) => void] {\n    const queue: BatchQueue = []\n    const getTrap = new Proxy(\n        {},\n        {\n            get(_, p) {\n                // @ts-expect-error\n                const f = (...args: any) => asyncCallInstance[AsyncCallBatch](queue, p, ...args)\n                // @ts-expect-error\n                f[AsyncCallNotify] = (...args: any) =>\n                    // @ts-expect-error\n                    asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args)\n                f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify]\n                isString(p) && Object.defineProperty(methodContainer, p, { value: f, configurable: true })\n                return f\n            },\n        },\n    )\n    const methodContainer = { __proto__: getTrap } as any\n    return [\n        new Proxy(methodContainer, {\n            getPrototypeOf: () => null,\n            setPrototypeOf: (_, value) => value === null,\n        }),\n        () => {\n            queue.length && queue.r![0]()\n            queue.length = 0\n        },\n        (error = new Error('Aborted')) => {\n            queue.length && queue.r![1](error)\n            queue.length = 0\n        },\n    ]\n}\nexport type BatchQueue = Request[] & {\n    /** Request handler */\n    r?: [emit: () => void, reject: (error?: unknown) => void]\n}\n"],"names":["JSONEncoder","isString","x","isBoolean","isFunction","isObject","params","ERROR","undefined","setPrototypeOf","Object","Promise_resolve","Promise","resolve","isArray","Array","apply","Reflect","keepUndefined","replacer","reviver","space","encode","data","forEach","undefinedEncode","JSON","stringify","decode","encoded","parse","i","result","Default","AsyncCallIgnoreResponse","Symbol","for","AsyncCallNotify","AsyncCallBatch","notifyTrap","target","p","CustomError","Error","constructor","name","message","code","stack","Err_Cannot_find_a_running_iterator_with_given_ID","Err_Only_string_can_be_the_RPC_method_name","Err_Cannot_call_method_starts_with_rpc_dot_directly","Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options","Messages","makeHostedMessage","id","error","n","indexOf","errors","__proto__","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","DOMExceptionHeader","RecoverError","type","E","startsWith","globalDOMException","slice","length","e","removeStackHeader","String","replace","DOMException","onAbort","signal","callback","addEventListener","once","makeRequest","method","remoteStack","jsonrpc","deleteUndefined","deleteFalsy","makeSuccessResponse","makeErrorResponse","Number","isNaN","Math","floor","ErrorResponseParseError","mapper","obj","ErrorResponseMapped","o","ErrorResponseInvalidRequest","ErrorResponseMethodNotFound","request","defaultErrorMapper","toString","ctor","eType","isJSONRPCObject","_default","val","v","key","generateRandomID","random","undefinedToTrue","normalizeLogOptions","log","beCalled","localError","remoteError","requestReplay","sendLocalStack","normalizeStrictOptions","strict","methodNotFound","unknownMessage","AsyncCall","thisSideImplementation","options","resolvedThisSideImplementationValue","rejectedThisSideImplementation","resolvedChannel","channelPromise","isThisSideImplementationPending","awaitThisSideImplementation","console_error","onChannelResolved","channel","isCallbackBasedChannel","setup","hint","rawMessageReceiver","then","rawMessageSender","_","hintedDecode","isEventBasedChannel","m","on","send","serializer","encoder","deprecatedName","parameterStructures","deprecatedParameterStructures","parameterStructure","preferLocalImplementation","idGenerator","mapError","logger","thenable","forceSignal","paramStyle","logKey","throwIfAborted","encodeFromOption","encodeRequest","encodeRequestFromOption","encodeResponse","encodeResponseFromOption","decodeRequest","decodeResponse","serialization","deserialization","banMethodNotFound","banUnknownMessage","log_beCalled","log_localError","log_remoteError","log_pretty","log_requestReplay","log_sendLocalStack","console_log","debug","console_debug","groupCollapsed","console_groupCollapsed","groupEnd","console_groupEnd","warn","console_warn","console","requestContext","Map","reason","clear","onRequest","aborted","makeErrorObject","frameworkStack","req_id","executor","args","promise","logArgs","map","join","replay","push","onResponse","errorMessage","remoteErrorStack","errorCode","errorType","detail","has","reject","localErrorStack","get","delete","handleSingleMessage","every","all","res","reply","filter","split","reduce","fstack","sendPayload","payload","removeQueueR","rejectsQueue","queue","ctx","handleForceAbort","finally","removeEventListener","catch","call","notify","shift","RPCInternalMethod","keyFor","description","localImpl","param","r","set","getTrap","f","f2","defineProperty","methodContainer","value","configurable","Proxy","getPrototypeOf","getOwnPropertyDescriptor","_define_property","AsyncIteratorStart","AsyncIteratorNext","AsyncIteratorReturn","AsyncIteratorThrow","_AsyncGenerator","return","d","makeIteratorResult","c","next","throw","isFinished","AsyncGeneratorPrototypeSet","cb","done","EmptyAsyncGenerator","AsyncGeneratorConstructor","prototype","AsyncGeneratorPrototype","iterators","findIterator","it","remote","iteratorGenerator","iterator","replacerAndReceiver","undefinedKeepingBehavior","from","alt","undef","serialized","asyncCallInstance","instanceOrFnOnInstance"],"mappings":"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"}