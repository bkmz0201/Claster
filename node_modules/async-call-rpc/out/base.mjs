/// <reference types="./base.d.ts" />
const isString = (x)=>typeof x === 'string';
const isBoolean = (x)=>typeof x === 'boolean';
const isFunction = (x)=>typeof x === 'function';
const isObject = (params)=>typeof params === 'object' && params !== null;
const ERROR = 'Error';
const undefined$1 = void 0;
const Promise_resolve = (x)=>Promise.resolve(x);
const { isArray } = Array;
const { apply } = Reflect;

/**
 * Serialization implementation that do nothing
 * @remarks {@link Serialization}
 * @public
 * @deprecated Will be removed in next major version
 */ const NoSerialization = {
    serialization (from) {
        return from;
    },
    deserialization (serialized) {
        return serialized;
    }
};
/**
 * Create a serialization by JSON.parse/stringify
 *
 * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify
 * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @param undefinedKeepingBehavior - How to keep "undefined" in result of SuccessResponse?
 *
 * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.
 *
 * Options:
 * - `"null"`(**default**): convert it to null.
 * - `"keep"`: try to keep it by additional property "undef".
 * - `false`: Don't keep it, let it break.
 * @remarks {@link Serialization}
 * @public
 */ const JSONSerialization = (replacerAndReceiver = [
    undefined$1,
    undefined$1
], space, undefinedKeepingBehavior = 'null')=>({
        serialization (from) {
            if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined$1) {
                const alt = {
                    ...from
                };
                alt.result = null;
                if (undefinedKeepingBehavior === 'keep') alt.undef = true;
                from = alt;
            }
            return JSON.stringify(from, replacerAndReceiver[0], space);
        },
        deserialization (serialized) {
            const result = JSON.parse(serialized, replacerAndReceiver[1]);
            if (isObject(result) && 'result' in result && result.result === null && 'undef' in result && result.undef === true) {
                result.result = undefined$1;
                delete result.undef;
            }
            return result;
        }
    });

/**
 * Create a encoder by JSON.parse/stringify
 *
 * @public
 * @param options - Options for this encoder.
 * @remarks {@link IsomorphicEncoder}
 */ function JSONEncoder({ keepUndefined = 'null', replacer, reviver, space } = {}) {
    return {
        encode (data) {
            if (keepUndefined) {
                isArray(data) ? data.forEach(undefinedEncode) : undefinedEncode(data);
            }
            return JSON.stringify(data, replacer, space);
        },
        decode (encoded) {
            const data = JSON.parse(encoded, reviver);
            return data;
        }
    };
}
const undefinedEncode = (i)=>{
    if ('result' in i && i.result === undefined$1) {
        i.result = null;
    }
};
(function(JSONEncoder) {
    JSONEncoder.Default = JSONEncoder();
})(JSONEncoder || (JSONEncoder = {}));

const i = 'AsyncCall/';
// ! side effect
const AsyncCallIgnoreResponse = Symbol.for(i + 'ignored');
const AsyncCallNotify = Symbol.for(i + 'notify');
const AsyncCallBatch = Symbol.for(i + 'batch');

/**
 * Wrap the AsyncCall instance to send notification.
 * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance
 * @example
 * const notifyOnly = notify(AsyncCall(...))
 * @public
 */ function notify(instanceOrFnOnInstance) {
    if (isFunction(instanceOrFnOnInstance)) return instanceOrFnOnInstance[AsyncCallNotify];
    return new Proxy(instanceOrFnOnInstance, {
        get: notifyTrap
    });
}
const notifyTrap = (target, p)=>{
    return target[p][AsyncCallNotify];
};

/**
 * Wrap the AsyncCall instance to use batch call.
 * @param asyncCallInstance - The AsyncCall instance
 * @example
 * const [batched, send, drop] = batch(AsyncCall(...))
 * batched.call1() // pending
 * batched.call2() // pending
 * send() // send all pending requests
 * drop() // drop all pending requests
 * @returns It will return a tuple.
 *
 * The first item is the batched version of AsyncCall instance passed in.
 *
 * The second item is a function to send all pending requests.
 *
 * The third item is a function to drop and reject all pending requests.
 * @public
 */ // TODO: use private field in the future.
function batch(asyncCallInstance) {
    const queue = [];
    const getTrap = new Proxy({}, {
        get (_, p) {
            // @ts-expect-error
            const f = (...args)=>asyncCallInstance[AsyncCallBatch](queue, p, ...args);
            // @ts-expect-error
            f[AsyncCallNotify] = (...args)=>// @ts-expect-error
                asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args);
            f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify];
            isString(p) && Object.defineProperty(methodContainer, p, {
                value: f,
                configurable: true
            });
            return f;
        }
    });
    const methodContainer = {
        __proto__: getTrap
    };
    return [
        new Proxy(methodContainer, {
            getPrototypeOf: ()=>null,
            setPrototypeOf: (_, value)=>value === null
        }),
        ()=>{
            queue.length && queue.r[0]();
            queue.length = 0;
        },
        (error = new Error('Aborted'))=>{
            queue.length && queue.r[1](error);
            queue.length = 0;
        }
    ];
}

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class CustomError extends Error {
    // TODO: support cause
    constructor(name, message, code, stack){
        super(message);
        _define_property(this, "name", void 0);
        _define_property(this, "code", void 0);
        _define_property(this, "stack", void 0);
        this.name = name;
        this.code = code;
        this.stack = stack;
    }
}
const Err_Cannot_find_a_running_iterator_with_given_ID = {};
const Err_Only_string_can_be_the_RPC_method_name = {};
const Err_Cannot_call_method_starts_with_rpc_dot_directly = {};
const Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options = {};
const Messages = [
    Err_Cannot_find_a_running_iterator_with_given_ID,
    Err_Only_string_can_be_the_RPC_method_name,
    Err_Cannot_call_method_starts_with_rpc_dot_directly,
    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options
];
// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages
const makeHostedMessage = (id, error)=>{
    const n = Messages.indexOf(id);
    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n;
    return error;
};
// ! side effect
/** These Error is defined in ECMAScript spec */ const errors = {
    // @ts-expect-error
    __proto__: null,
    Error,
    EvalError,
    RangeError,
    ReferenceError,
    SyntaxError,
    TypeError,
    URIError
};
const DOMExceptionHeader = 'DOMException:';
/**
 * AsyncCall support somehow transfer ECMAScript Error
 */ const RecoverError = (type, message, code, stack)=>{
    try {
        let E;
        if (type.startsWith(DOMExceptionHeader) && (E = globalDOMException())) {
            const name = type.slice(DOMExceptionHeader.length);
            return new E(message, name);
        } else if (type in errors) {
            const e = new errors[type](message);
            e.stack = stack;
            // @ts-expect-error
            e.code = code;
            return e;
        } else {
            return new CustomError(type, message, code, stack);
        }
    } catch (e) {
        return new Error(`E${code} ${type}: ${message}\n${stack}`);
    }
};
const removeStackHeader = (stack)=>String(stack).replace(/^.+\n.+\n/, '');
// ! side effect
const globalDOMException = ()=>{
    try {
        // @ts-expect-error
        return DOMException;
    } catch (e) {}
};
function onAbort(signal, callback) {
    signal && signal.addEventListener('abort', callback, {
        once: true
    });
}

const jsonrpc = '2.0';
const makeRequest = (id, method, params, remoteStack)=>{
    const x = {
        jsonrpc,
        id,
        method,
        params,
        remoteStack
    };
    deleteUndefined(x, 'id');
    deleteFalsy(x, 'remoteStack');
    return x;
};
const makeSuccessResponse = (id, result)=>{
    const x = {
        jsonrpc,
        id,
        result
    };
    deleteUndefined(x, 'id');
    return x;
};
const makeErrorResponse = (id, code, message, data)=>{
    if (id === undefined$1) id = null;
    code = Math.floor(code);
    if (Number.isNaN(code)) code = -1;
    const x = {
        jsonrpc,
        id,
        error: {
            code,
            message,
            data
        }
    };
    deleteUndefined(x.error, 'data');
    return x;
};
// Pre defined error in section 5.1
// ! side effect
const ErrorResponseParseError = (e, mapper)=>{
    const obj = ErrorResponseMapped({}, e, mapper);
    const o = obj.error;
    o.code = -32700;
    o.message = 'Parse error';
    return obj;
};
// Not using.
// InvalidParams -32602 'Invalid params'
// InternalError -32603 'Internal error'
const ErrorResponseInvalidRequest = (id)=>makeErrorResponse(id, -32600, 'Invalid Request');
const ErrorResponseMethodNotFound = (id)=>makeErrorResponse(id, -32601, 'Method not found');
const ErrorResponseMapped = (request, e, mapper)=>{
    const { id } = request;
    const { code, message, data } = mapper(e, request);
    return makeErrorResponse(id, code, message, data);
};
const defaultErrorMapper = (stack = '', code = -1)=>(e)=>{
        let message = toString('', ()=>e.message);
        let type = toString(ERROR, (ctor = e.constructor)=>isFunction(ctor) && ctor.name);
        const E = globalDOMException();
        if (E && e instanceof E) type = DOMExceptionHeader + e.name;
        const eType = typeof e;
        if (eType == 'string' || eType === 'number' || eType == 'boolean' || eType == 'bigint') {
            type = ERROR;
            message = String(e);
        }
        const data = stack ? {
            stack,
            type
        } : {
            type
        };
        return {
            code,
            message,
            data
        };
    };
const isJSONRPCObject = (data)=>{
    if (!isObject(data)) return false;
    if (!('jsonrpc' in data)) return false;
    if (data.jsonrpc !== jsonrpc) return false;
    if ('params' in data) {
        const params = data.params;
        if (!isArray(params) && !isObject(params)) return false;
    }
    return true;
};
const toString = (_default, val)=>{
    try {
        const v = val();
        if (v === undefined$1) return _default;
        return String(v);
    } catch (e) {
        return _default;
    }
};
const deleteUndefined = (x, key)=>{
    if (x[key] === undefined$1) delete x[key];
};
const deleteFalsy = (x, key)=>{
    if (!x[key]) delete x[key];
};

const generateRandomID = ()=>Math.random().toString(36).slice(2);

const undefinedToTrue = (x)=>x === void 0 ? true : x;
const normalizeLogOptions = (log)=>{
    if (log === 'all') return [
        true,
        true,
        true,
        true,
        true,
        true
    ];
    if (!isBoolean(log)) {
        const { beCalled, localError, remoteError, type, requestReplay, sendLocalStack } = log;
        return [
            undefinedToTrue(beCalled),
            undefinedToTrue(localError),
            undefinedToTrue(remoteError),
            type !== 'basic',
            requestReplay,
            sendLocalStack
        ];
    }
    if (log) return [
        true,
        true,
        true,
        true
    ];
    return [];
};
const normalizeStrictOptions = (strict)=>{
    if (!isBoolean(strict)) {
        const { methodNotFound, unknownMessage } = strict;
        return [
            methodNotFound,
            unknownMessage
        ];
    }
    return [
        strict,
        strict
    ];
};

/**
 * Create a RPC server & client.
 *
 * @remarks
 * See {@link AsyncCallOptions}
 *
 * thisSideImplementation can be a Promise so you can write:
 *
 * ```ts
 * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})
 * ```
 *
 * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.
 * @param options - {@link AsyncCallOptions}
 * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.
 * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called "then" are also removed.
 * @public
 */ function AsyncCall(thisSideImplementation, options) {
    let isThisSideImplementationPending = true;
    let resolvedThisSideImplementationValue;
    let rejectedThisSideImplementation;
    let resolvedChannel;
    let channelPromise;
    // This promise should never fail
    const awaitThisSideImplementation = async ()=>{
        try {
            resolvedThisSideImplementationValue = await thisSideImplementation;
        } catch (e) {
            rejectedThisSideImplementation = e;
            console_error('AsyncCall failed to start', e);
        } finally{
            isThisSideImplementationPending = false;
        }
    };
    const onChannelResolved = (channel)=>{
        resolvedChannel = channel;
        if (isCallbackBasedChannel(channel)) {
            channel.setup((data, hint)=>rawMessageReceiver(data, hint).then(rawMessageSender), (data, hint)=>{
                let _ = hintedDecode(data, hint);
                if (isJSONRPCObject(_)) return true;
                return Promise_resolve(_).then(isJSONRPCObject);
            });
        }
        if (isEventBasedChannel(channel)) {
            const m = channel;
            m.on && m.on((_, hint)=>rawMessageReceiver(_, hint).then(rawMessageSender).then((x)=>x && m.send(x)));
        }
        return channel;
    };
    const { serializer, encoder, key: deprecatedName, name, strict = true, log = true, parameterStructures: deprecatedParameterStructures, parameterStructure, preferLocalImplementation = false, idGenerator = generateRandomID, mapError, logger, channel, thenable, signal, forceSignal } = options;
    // Note: we're not shorten this error message because it will be removed in the next major version.
    if (serializer && encoder) throw new TypeError('Please remove serializer.');
    if (name && deprecatedName) throw new TypeError('Please remove key.');
    if (deprecatedParameterStructures && parameterStructure) throw new TypeError('Please remove parameterStructure.');
    const paramStyle = deprecatedParameterStructures || parameterStructure || 'by-position';
    const logKey = name || deprecatedName || 'rpc';
    const throwIfAborted = ()=>{
        signal && signal.throwIfAborted();
        forceSignal && forceSignal.throwIfAborted();
    };
    const { encode: encodeFromOption, encodeRequest: encodeRequestFromOption, encodeResponse: encodeResponseFromOption, decode, decodeRequest, decodeResponse } = encoder || {};
    const encodeRequest = encoder ? (data)=>apply(encodeRequestFromOption || encodeFromOption, encoder, [
            data
        ]) : serializer ? (data)=>serializer.serialization(data) : Object;
    const encodeResponse = encoder ? (data)=>apply(encodeResponseFromOption || encodeFromOption, encoder, [
            data
        ]) : serializer ? (data)=>serializer.serialization(data) : Object;
    const hintedDecode = encoder ? (data, hint)=>hint == 'request' ? apply(decodeRequest || decode, encoder, [
            data
        ]) : hint == 'response' ? apply(decodeResponse || decode, encoder, [
            data
        ]) : apply(decode, encoder, [
            data
        ]) : serializer ? (data)=>serializer.deserialization(data) : Object;
    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation();
    else {
        resolvedThisSideImplementationValue = thisSideImplementation;
        isThisSideImplementationPending = false;
    }
    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict);
    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] = normalizeLogOptions(log);
    const { log: console_log, error: console_error = console_log, debug: console_debug = console_log, groupCollapsed: console_groupCollapsed = console_log, groupEnd: console_groupEnd = console_log, warn: console_warn = console_log } = logger || console;
    const requestContext = new Map();
    onAbort(forceSignal, ()=>{
        requestContext.forEach((x)=>x[1](forceSignal.reason));
        requestContext.clear();
    });
    const onRequest = async (data)=>{
        if (signal && signal.aborted || forceSignal && forceSignal.aborted) return makeErrorObject(signal && signal.reason || forceSignal && forceSignal.reason, '', data);
        if (isThisSideImplementationPending) await awaitThisSideImplementation();
        else if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data);
        let frameworkStack = '';
        try {
            const { params, method, id: req_id, remoteStack } = data;
            // ? We're mapping any method starts with 'rpc.' to a Symbol.for
            const key = method.startsWith('rpc.') ? Symbol.for(method) : method;
            const executor = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key];
            if (!isFunction(executor)) {
                if (!banMethodNotFound) {
                    if (log_localError) console_debug('Missing method', key, data);
                    return;
                } else return ErrorResponseMethodNotFound(req_id);
            }
            const args = isArray(params) ? params : [
                params
            ];
            frameworkStack = removeStackHeader(new Error().stack);
            const promise = new Promise((resolve)=>resolve(apply(executor, resolvedThisSideImplementationValue, args)));
            if (log_beCalled) {
                if (log_pretty) {
                    const logArgs = [
                        `${logKey}.%c${method}%c(${args.map(()=>'%o').join(', ')}%c)\n%o %c@${req_id}`,
                        'color:#d2c057',
                        '',
                        ...args,
                        '',
                        promise,
                        'color:gray;font-style:italic;'
                    ];
                    if (log_requestReplay) {
                        const replay = ()=>{
                            debugger;
                            return apply(executor, resolvedThisSideImplementationValue, args);
                        };
                        // this function will be logged, keep it short.
                        // Do not inline it, it's hard to keep it in a single line after build step.
                        logArgs.push(()=>replay());
                    }
                    if (remoteStack) {
                        console_groupCollapsed(...logArgs);
                        console_log(remoteStack);
                        console_groupEnd();
                    } else console_log(...logArgs);
                } else console_log(`${logKey}.${method}(${[
                    ...args
                ].toString()}) @${req_id}`);
            }
            const result = await promise;
            if (result === AsyncCallIgnoreResponse) return;
            return makeSuccessResponse(req_id, result);
        } catch (e) {
            return makeErrorObject(e, frameworkStack, data);
        }
    };
    const onResponse = async (data)=>{
        let errorMessage = '', remoteErrorStack = '', errorCode = 0, errorType = ERROR;
        if ('error' in data) {
            const e = data.error;
            errorMessage = e.message;
            errorCode = e.code;
            const detail = e.data;
            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack;
            else remoteErrorStack = '<remote stack not available>';
            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type;
            else errorType = ERROR;
            if (log_remoteError) log_pretty ? console_error(`${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\n%c${remoteErrorStack}`, 'color: gray', '') : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\n${remoteErrorStack}`);
        }
        const { id } = data;
        if (id === null || id === undefined$1 || !requestContext.has(id)) return;
        const [resolve, reject, localErrorStack = ''] = requestContext.get(id);
        requestContext.delete(id);
        if ('error' in data) {
            reject(// TODO: add a hook to customize this
            RecoverError(errorType, errorMessage, errorCode, // ? We use \u0430 which looks like "a" to prevent browser think "at AsyncCall" is a real stack
            remoteErrorStack + '\n    \u0430t AsyncCall (rpc) \n' + localErrorStack));
        } else {
            resolve(data.result);
        }
        return;
    };
    const rawMessageReceiver = async (_, hint)=>{
        let data;
        let result = undefined$1;
        try {
            data = await hintedDecode(_, hint);
            if (isJSONRPCObject(data)) {
                return result = await handleSingleMessage(data);
            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {
                return Promise.all(data.map(handleSingleMessage));
            } else {
                if (banUnknownMessage) {
                    let id = data.id;
                    if (id === undefined$1) id = null;
                    return ErrorResponseInvalidRequest(id);
                } else {
                    // ? Ignore this message. The message channel maybe also used to transfer other message too.
                    return undefined$1;
                }
            }
        } catch (e) {
            if (log_localError) console_error(e, data, result);
            let stack;
            try {
                stack = '' + e.stack;
            } catch (e) {}
            return ErrorResponseParseError(e, mapError || defaultErrorMapper(stack));
        }
    };
    const rawMessageSender = async (res)=>{
        if (!res) return;
        if (isArray(res)) {
            const reply = res.filter((x)=>x && 'id' in x);
            if (reply.length === 0) return;
            return encodeResponse(reply);
        } else {
            return encodeResponse(res);
        }
    };
    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved);
    else onChannelResolved(channel);
    const makeErrorObject = (e, frameworkStack, data)=>{
        if (isObject(e) && 'stack' in e) e.stack = frameworkStack.split('\n').reduce((stack, fstack)=>stack.replace(fstack + '\n', ''), '' + e.stack);
        if (log_localError) console_error(e);
        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined$1));
    };
    const sendPayload = async (payload, removeQueueR)=>{
        if (removeQueueR) payload = [
            ...payload
        ];
        const data = await encodeRequest(payload);
        return (resolvedChannel || await channelPromise).send(data);
    };
    const rejectsQueue = (queue, error)=>{
        for (const x of queue){
            if ('id' in x) {
                const ctx = requestContext.get(x.id);
                ctx && ctx[1](error);
            }
        }
    };
    const handleSingleMessage = async (data)=>{
        if ('method' in data) {
            if ('id' in data) {
                if (!forceSignal) return onRequest(data);
                return new Promise((resolve, reject)=>{
                    const handleForceAbort = ()=>resolve(makeErrorObject(forceSignal.reason, '', data));
                    onRequest(data).then(resolve, reject).finally(()=>forceSignal.removeEventListener('abort', handleForceAbort));
                    onAbort(forceSignal, handleForceAbort);
                });
            }
            onRequest(data).catch(()=>{});
            return; // Skip response for notifications
        }
        return onResponse(data);
    };
    const call = (method, args, stack, notify = false)=>{
        return new Promise((resolve, reject)=>{
            throwIfAborted();
            let queue = undefined$1;
            if (method === AsyncCallBatch) {
                queue = args.shift();
                method = args.shift();
            }
            if (typeof method === 'symbol') {
                const RPCInternalMethod = Symbol.keyFor(method) || method.description;
                if (RPCInternalMethod) {
                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod;
                    else throw new TypeError('Not start with rpc.');
                }
            } else if (method.startsWith('rpc.')) {
                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError());
            }
            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {
                const localImpl = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[method];
                if (isFunction(localImpl)) return resolve(localImpl(...args));
            }
            const id = idGenerator();
            stack = removeStackHeader(stack);
            const param = paramStyle === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args;
            const request = makeRequest(notify ? undefined$1 : id, method, param, log_sendLocalStack ? stack : undefined$1);
            if (queue) {
                queue.push(request);
                if (!queue.r) queue.r = [
                    ()=>sendPayload(queue, true),
                    (e)=>rejectsQueue(queue, e)
                ];
            } else sendPayload(request).catch(reject);
            if (notify) return resolve();
            requestContext.set(id, [
                resolve,
                reject,
                stack
            ]);
        });
    };
    const getTrap = (_, method)=>{
        const f = {
            // This function will be logged to the console so it must be 1 line
            [method]: (..._)=>call(method, _, new Error().stack)
        }[method];
        const f2 = {
            [method]: (..._)=>call(method, _, new Error().stack, true)
        }[method];
        // @ts-expect-error
        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2;
        isString(method) && Object.defineProperty(methodContainer, method, {
            value: f,
            configurable: true
        });
        return f;
    };
    const methodContainer = {
        __proto__: new Proxy({}, {
            get: getTrap
        })
    };
    if (thenable === false) methodContainer.then = undefined$1;
    else if (thenable === undefined$1) {
        Object.defineProperty(methodContainer, 'then', {
            configurable: true,
            get () {
                console_warn(makeHostedMessage(Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options, new TypeError('RPC used as Promise: ')));
            }
        });
    }
    return new Proxy(methodContainer, {
        getPrototypeOf: ()=>null,
        setPrototypeOf: (_, value)=>value === null,
        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget
        getOwnPropertyDescriptor (_, method) {
            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]
            ;
            return Object.getOwnPropertyDescriptor(methodContainer, method);
        }
    });
}
const isEventBasedChannel = (x)=>'send' in x && isFunction(x.send);
const isCallbackBasedChannel = (x)=>'setup' in x && isFunction(x.setup);

export { AsyncCall, JSONEncoder, JSONSerialization, NoSerialization, batch, notify };
//# sourceMappingURL=base.mjs.map
