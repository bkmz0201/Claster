"use strict";
/*
Copyright 2022 ByteDance and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildUploadClient = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const stream_1 = require("stream");
const util_1 = require("util");
const zlib_1 = require("zlib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const tar_1 = require("tar");
const uuid_1 = require("uuid");
const jsonr_1 = tslib_1.__importDefault(require("@perfsee/jsonr"));
const utils_1 = require("@perfsee/utils");
const build_env_1 = require("./build-env");
const filteredFields = [
    'identifier',
    'issuerPath',
    'issuer',
    'moduleIdentifier',
    'resolvedModuleIdentifier',
    'parents',
    'siblings',
    'origins',
    'module',
];
function filterOptimizationBailout(optimizationBailout) {
    // ignore commonjs
    if (optimizationBailout?.some((o) => o.includes('CommonJS bailout'))) {
        return;
    }
    const filtered = optimizationBailout?.filter((o) => o.includes('with side effects in source code at'));
    return filtered?.length ? filtered : undefined;
}
function encodeStatsJson(stats) {
    return jsonr_1.default.stringifyStream(stats, (key, v) => filteredFields.includes(key) ? undefined : key === 'optimizationBailout' ? filterOptimizationBailout(v) : v);
}
class BuildUploadClient {
    constructor(options, outputPath, appVersion) {
        this.options = options;
        this.outputPath = outputPath;
        this.appVersion = appVersion;
    }
    async uploadBuild(stats) {
        if (!(0, build_env_1.getBuildEnv)().upload) {
            console.info(chalk_1.default.yellow('[perfsee] found no upload flag, skip uploading build.'));
            return;
        }
        if (!this.options.project) {
            console.info(chalk_1.default.yellow('[perfsee] no project id provided, skip uploading build.'));
            return;
        }
        if (this.options.processStats) {
            const processedStats = this.options.processStats(stats);
            if (processedStats) {
                stats = processedStats;
            }
            else {
                console.info(chalk_1.default.yellow('[perfsee] skip uploading since stats json is empty after process.'));
                return;
            }
        }
        let statsPath;
        try {
            // firstly write stats json down to disk in output path.
            statsPath = await this.writeStats(stats);
            // then pack the assets in output path
            const packPath = await this.pack(statsPath, stats);
            // then upload the pack to platform
            await this.uploadPack(packPath, stats);
        }
        catch (e) {
            console.error(chalk_1.default.red('[perfsee] Failed to upload build'));
            console.error(chalk_1.default.red(String(e)));
        }
        finally {
            if (!process.env.KEEP_STATS && statsPath) {
                try {
                    (0, fs_1.unlinkSync)(statsPath);
                }
                catch (e) {
                    console.error(chalk_1.default.red('[perfsee] Failed to remove stats file'));
                    console.error(chalk_1.default.red(String(e)));
                }
            }
        }
    }
    async writeStats(stats) {
        const statsFile = (0, path_1.join)(this.outputPath, `webpack-stats-${(0, uuid_1.v4)()}.jsonr.gz`);
        return new Promise((resolve, reject) => {
            stats.rules = this.options.rules?.filter((rule) => typeof rule === 'string');
            stats.includeAuxiliary = this.options.includeAuxiliary;
            stats.htmlExclusive = this.options.htmlExclusive;
            stats.strictChunkRelations = this.options.strictChunkRelations;
            (0, stream_1.pipeline)(stream_1.Readable.from(encodeStatsJson(stats)), (0, zlib_1.createGzip)(), (0, fs_1.createWriteStream)(statsFile), (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(statsFile);
                }
            });
        });
    }
    async pack(statsPath, stats) {
        return new Promise((resolve, reject) => {
            const packPath = `${(0, os_1.tmpdir)()}/build-${(0, uuid_1.v4)()}.tar.gz`;
            const includedAssets = new Set([statsPath]);
            stats.assets?.forEach((a) => {
                const asset = (0, path_1.join)(this.outputPath, a.name);
                includedAssets.add(asset);
                if (/\.m?js$/i.test(asset) || /\.css$/i.test(asset)) {
                    includedAssets.add(`${asset}.map`);
                }
            });
            const realOutputPath = this.getRealOutputPath(this.outputPath, stats);
            (0, tar_1.create)({
                cwd: realOutputPath,
                filter: (path) => {
                    path = (0, path_1.join)(realOutputPath, path);
                    if ((0, fs_1.statSync)(path).isDirectory()) {
                        return true;
                    }
                    // ignore media files to reduce artifact size
                    return includedAssets.has(path) && !/\.(mp4|webm|mkv|flv|avi|wmv)$/i.test(path);
                },
            }, ['./'])
                .pipe((0, zlib_1.createGzip)(this.options.zlibOptions))
                .pipe((0, fs_1.createWriteStream)(packPath))
                .on('finish', () => {
                resolve(packPath);
            })
                .on('error', (err) => {
                reject(err);
            });
        });
    }
    async uploadPack(packPath, stats) {
        const git = await (0, build_env_1.getBuildEnv)().git;
        if (!git?.host) {
            console.error(chalk_1.default.red('[perfsee] Did not find relative codebase host for current project.'));
            return;
        }
        const artifactName = typeof this.options.artifactName === 'function'
            ? this.options.artifactName(stats)
            : this.options.artifactName ?? 'test';
        const params = {
            ...git,
            projectId: this.options.project,
            commitHash: git.commit,
            commitMessage: git.commitMessage,
            pr: git.pr,
            artifactName,
            nodeVersion: process.version,
            appVersion: this.appVersion,
            toolkit: this.options.toolkit ?? 'webpack',
        };
        console.info(chalk_1.default.green('[perfsee] start uploading build'), {
            size: utils_1.PrettyBytes.stringify((0, fs_1.statSync)(packPath).size),
            params,
        });
        const query = Object.keys(params)
            .map((key) => {
            return `${key}=${params[key] ? encodeURIComponent(params[key]) : ''}`;
        })
            .join('&');
        const platform = this.options.platform ?? (0, build_env_1.getBuildEnv)().platform;
        let res;
        for (const tryTime of Array.from({ length: (this.options.maxRetries || 0) + 1 }, (_, i) => i)) {
            if (tryTime !== 0) {
                console.error(`[perfsee] uploading failed! ${res?.statusText}. Retrying...`);
            }
            const stream = (0, fs_1.createReadStream)(packPath);
            res = await (0, node_fetch_1.default)(`${platform}/api/v1/artifacts?${query}`, {
                method: 'POST',
                body: stream,
                headers: {
                    authorization: `Bearer ${this.options.token}`,
                    'content-type': 'application/octet-stream',
                },
            });
            if (res.ok) {
                const { url } = await res.json();
                console.info(chalk_1.default.green(`[perfsee] uploading succeed! The analyze result would be available at ${url} soon!`));
                return;
            }
            await (0, util_1.promisify)(setTimeout)(this.options.retryDelay || 100);
        }
        throw new Error(`[perfsee] uploading failed! ${res?.statusText}. Response: ${await res?.text()}`);
    }
    /**
     * find the topest level of all the assets
     */
    getRealOutputPath(outputPath, stats) {
        // may put asset outsize output path
        const maxParentAccess = stats.assets?.reduce((max, asset) => {
            // normal assets
            if (!asset.name.startsWith('..')) {
                return max;
            }
            return Math.max(asset.name.split(/[\\/]/).filter((part) => part === '..').length, max);
        }, 0);
        return maxParentAccess ? (0, path_1.join)(outputPath, '../'.repeat(maxParentAccess)) : outputPath;
    }
}
exports.BuildUploadClient = BuildUploadClient;
//# sourceMappingURL=build-upload-client.js.map