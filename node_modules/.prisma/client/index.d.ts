
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ConnectedAccount
 * 
 */
export type ConnectedAccount = $Result.DefaultSelection<Prisma.$ConnectedAccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceDoc
 * 
 */
export type WorkspaceDoc = $Result.DefaultSelection<Prisma.$WorkspaceDocPayload>
/**
 * Model WorkspaceUserRole
 * 
 */
export type WorkspaceUserRole = $Result.DefaultSelection<Prisma.$WorkspaceUserRolePayload>
/**
 * Model WorkspaceDocUserRole
 * 
 */
export type WorkspaceDocUserRole = $Result.DefaultSelection<Prisma.$WorkspaceDocUserRolePayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model UserFeature
 * 
 */
export type UserFeature = $Result.DefaultSelection<Prisma.$UserFeaturePayload>
/**
 * Model WorkspaceFeature
 * 
 */
export type WorkspaceFeature = $Result.DefaultSelection<Prisma.$WorkspaceFeaturePayload>
/**
 * Model Snapshot
 * 
 */
export type Snapshot = $Result.DefaultSelection<Prisma.$SnapshotPayload>
/**
 * Model UserSnapshot
 * 
 */
export type UserSnapshot = $Result.DefaultSelection<Prisma.$UserSnapshotPayload>
/**
 * Model Update
 * 
 */
export type Update = $Result.DefaultSelection<Prisma.$UpdatePayload>
/**
 * Model SnapshotHistory
 * 
 */
export type SnapshotHistory = $Result.DefaultSelection<Prisma.$SnapshotHistoryPayload>
/**
 * Model AiPromptMessage
 * 
 */
export type AiPromptMessage = $Result.DefaultSelection<Prisma.$AiPromptMessagePayload>
/**
 * Model AiPrompt
 * 
 */
export type AiPrompt = $Result.DefaultSelection<Prisma.$AiPromptPayload>
/**
 * Model AiSessionMessage
 * 
 */
export type AiSessionMessage = $Result.DefaultSelection<Prisma.$AiSessionMessagePayload>
/**
 * Model AiSession
 * 
 */
export type AiSession = $Result.DefaultSelection<Prisma.$AiSessionPayload>
/**
 * Model AiContext
 * 
 */
export type AiContext = $Result.DefaultSelection<Prisma.$AiContextPayload>
/**
 * Model AiContextEmbedding
 * 
 */
export type AiContextEmbedding = $Result.DefaultSelection<Prisma.$AiContextEmbeddingPayload>
/**
 * Model AiWorkspaceEmbedding
 * 
 */
export type AiWorkspaceEmbedding = $Result.DefaultSelection<Prisma.$AiWorkspaceEmbeddingPayload>
/**
 * Model AiWorkspaceIgnoredDocs
 * 
 */
export type AiWorkspaceIgnoredDocs = $Result.DefaultSelection<Prisma.$AiWorkspaceIgnoredDocsPayload>
/**
 * Model AiWorkspaceFiles
 * 
 */
export type AiWorkspaceFiles = $Result.DefaultSelection<Prisma.$AiWorkspaceFilesPayload>
/**
 * Model AiWorkspaceFileEmbedding
 * 
 */
export type AiWorkspaceFileEmbedding = $Result.DefaultSelection<Prisma.$AiWorkspaceFileEmbeddingPayload>
/**
 * Model AiWorkspaceBlobEmbedding
 * 
 */
export type AiWorkspaceBlobEmbedding = $Result.DefaultSelection<Prisma.$AiWorkspaceBlobEmbeddingPayload>
/**
 * Model AiJobs
 * 
 */
export type AiJobs = $Result.DefaultSelection<Prisma.$AiJobsPayload>
/**
 * Model DataMigration
 * 
 */
export type DataMigration = $Result.DefaultSelection<Prisma.$DataMigrationPayload>
/**
 * Model DeprecatedAppRuntimeSettings
 * @deprecated use AppConfig instead
 */
export type DeprecatedAppRuntimeSettings = $Result.DefaultSelection<Prisma.$DeprecatedAppRuntimeSettingsPayload>
/**
 * Model AppConfig
 * 
 */
export type AppConfig = $Result.DefaultSelection<Prisma.$AppConfigPayload>
/**
 * Model DeprecatedUserSubscription
 * 
 */
export type DeprecatedUserSubscription = $Result.DefaultSelection<Prisma.$DeprecatedUserSubscriptionPayload>
/**
 * Model DeprecatedUserInvoice
 * 
 */
export type DeprecatedUserInvoice = $Result.DefaultSelection<Prisma.$DeprecatedUserInvoicePayload>
/**
 * Model UserStripeCustomer
 * 
 */
export type UserStripeCustomer = $Result.DefaultSelection<Prisma.$UserStripeCustomerPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model InstalledLicense
 * 
 */
export type InstalledLicense = $Result.DefaultSelection<Prisma.$InstalledLicensePayload>
/**
 * Model Blob
 * 
 */
export type Blob = $Result.DefaultSelection<Prisma.$BlobPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Reply
 * 
 */
export type Reply = $Result.DefaultSelection<Prisma.$ReplyPayload>
/**
 * Model CommentAttachment
 * 
 */
export type CommentAttachment = $Result.DefaultSelection<Prisma.$CommentAttachmentPayload>
/**
 * Model AccessToken
 * 
 */
export type AccessToken = $Result.DefaultSelection<Prisma.$AccessTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WorkspaceMemberStatus: {
  Pending: 'Pending',
  UnderReview: 'UnderReview',
  AllocatingSeat: 'AllocatingSeat',
  NeedMoreSeat: 'NeedMoreSeat',
  Accepted: 'Accepted',
  NeedMoreSeatAndReview: 'NeedMoreSeatAndReview'
};

export type WorkspaceMemberStatus = (typeof WorkspaceMemberStatus)[keyof typeof WorkspaceMemberStatus]


export const WorkspaceMemberSource: {
  Email: 'Email',
  Link: 'Link'
};

export type WorkspaceMemberSource = (typeof WorkspaceMemberSource)[keyof typeof WorkspaceMemberSource]


export const AiPromptRole: {
  system: 'system',
  assistant: 'assistant',
  user: 'user'
};

export type AiPromptRole = (typeof AiPromptRole)[keyof typeof AiPromptRole]


export const AiJobStatus: {
  pending: 'pending',
  running: 'running',
  finished: 'finished',
  claimed: 'claimed',
  failed: 'failed'
};

export type AiJobStatus = (typeof AiJobStatus)[keyof typeof AiJobStatus]


export const AiJobType: {
  transcription: 'transcription'
};

export type AiJobType = (typeof AiJobType)[keyof typeof AiJobType]


export const RuntimeConfigType: {
  String: 'String',
  Number: 'Number',
  Boolean: 'Boolean',
  Object: 'Object',
  Array: 'Array'
};

export type RuntimeConfigType = (typeof RuntimeConfigType)[keyof typeof RuntimeConfigType]


export const Provider: {
  stripe: 'stripe',
  revenuecat: 'revenuecat'
};

export type Provider = (typeof Provider)[keyof typeof Provider]


export const IapStore: {
  app_store: 'app_store',
  play_store: 'play_store'
};

export type IapStore = (typeof IapStore)[keyof typeof IapStore]


export const NotificationType: {
  Mention: 'Mention',
  Invitation: 'Invitation',
  InvitationAccepted: 'InvitationAccepted',
  InvitationBlocked: 'InvitationBlocked',
  InvitationRejected: 'InvitationRejected',
  InvitationReviewRequest: 'InvitationReviewRequest',
  InvitationReviewApproved: 'InvitationReviewApproved',
  InvitationReviewDeclined: 'InvitationReviewDeclined',
  Comment: 'Comment',
  CommentMention: 'CommentMention',
  System: 'System'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationLevel: {
  High: 'High',
  Default: 'Default',
  Low: 'Low',
  Min: 'Min',
  None: 'None'
};

export type NotificationLevel = (typeof NotificationLevel)[keyof typeof NotificationLevel]

}

export type WorkspaceMemberStatus = $Enums.WorkspaceMemberStatus

export const WorkspaceMemberStatus: typeof $Enums.WorkspaceMemberStatus

export type WorkspaceMemberSource = $Enums.WorkspaceMemberSource

export const WorkspaceMemberSource: typeof $Enums.WorkspaceMemberSource

export type AiPromptRole = $Enums.AiPromptRole

export const AiPromptRole: typeof $Enums.AiPromptRole

export type AiJobStatus = $Enums.AiJobStatus

export const AiJobStatus: typeof $Enums.AiJobStatus

export type AiJobType = $Enums.AiJobType

export const AiJobType: typeof $Enums.AiJobType

export type RuntimeConfigType = $Enums.RuntimeConfigType

export const RuntimeConfigType: typeof $Enums.RuntimeConfigType

export type Provider = $Enums.Provider

export const Provider: typeof $Enums.Provider

export type IapStore = $Enums.IapStore

export const IapStore: typeof $Enums.IapStore

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationLevel = $Enums.NotificationLevel

export const NotificationLevel: typeof $Enums.NotificationLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  /**
   * Gives access to the client metrics in json or prometheus format.
   * 
   * @example
   * ```
   * const metrics = await prisma.$metrics.json()
   * // or
   * const metrics = await prisma.$metrics.prometheus()
   * ```
   */
  readonly $metrics: runtime.MetricsClient
  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connectedAccount`: Exposes CRUD operations for the **ConnectedAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectedAccounts
    * const connectedAccounts = await prisma.connectedAccount.findMany()
    * ```
    */
  get connectedAccount(): Prisma.ConnectedAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceDoc`: Exposes CRUD operations for the **WorkspaceDoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceDocs
    * const workspaceDocs = await prisma.workspaceDoc.findMany()
    * ```
    */
  get workspaceDoc(): Prisma.WorkspaceDocDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceUserRole`: Exposes CRUD operations for the **WorkspaceUserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceUserRoles
    * const workspaceUserRoles = await prisma.workspaceUserRole.findMany()
    * ```
    */
  get workspaceUserRole(): Prisma.WorkspaceUserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceDocUserRole`: Exposes CRUD operations for the **WorkspaceDocUserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceDocUserRoles
    * const workspaceDocUserRoles = await prisma.workspaceDocUserRole.findMany()
    * ```
    */
  get workspaceDocUserRole(): Prisma.WorkspaceDocUserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFeature`: Exposes CRUD operations for the **UserFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeatures
    * const userFeatures = await prisma.userFeature.findMany()
    * ```
    */
  get userFeature(): Prisma.UserFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceFeature`: Exposes CRUD operations for the **WorkspaceFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceFeatures
    * const workspaceFeatures = await prisma.workspaceFeature.findMany()
    * ```
    */
  get workspaceFeature(): Prisma.WorkspaceFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.snapshot`: Exposes CRUD operations for the **Snapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snapshots
    * const snapshots = await prisma.snapshot.findMany()
    * ```
    */
  get snapshot(): Prisma.SnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSnapshot`: Exposes CRUD operations for the **UserSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSnapshots
    * const userSnapshots = await prisma.userSnapshot.findMany()
    * ```
    */
  get userSnapshot(): Prisma.UserSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.update`: Exposes CRUD operations for the **Update** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Updates
    * const updates = await prisma.update.findMany()
    * ```
    */
  get update(): Prisma.UpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.snapshotHistory`: Exposes CRUD operations for the **SnapshotHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SnapshotHistories
    * const snapshotHistories = await prisma.snapshotHistory.findMany()
    * ```
    */
  get snapshotHistory(): Prisma.SnapshotHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiPromptMessage`: Exposes CRUD operations for the **AiPromptMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiPromptMessages
    * const aiPromptMessages = await prisma.aiPromptMessage.findMany()
    * ```
    */
  get aiPromptMessage(): Prisma.AiPromptMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiPrompt`: Exposes CRUD operations for the **AiPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiPrompts
    * const aiPrompts = await prisma.aiPrompt.findMany()
    * ```
    */
  get aiPrompt(): Prisma.AiPromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiSessionMessage`: Exposes CRUD operations for the **AiSessionMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiSessionMessages
    * const aiSessionMessages = await prisma.aiSessionMessage.findMany()
    * ```
    */
  get aiSessionMessage(): Prisma.AiSessionMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiSession`: Exposes CRUD operations for the **AiSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiSessions
    * const aiSessions = await prisma.aiSession.findMany()
    * ```
    */
  get aiSession(): Prisma.AiSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiContext`: Exposes CRUD operations for the **AiContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiContexts
    * const aiContexts = await prisma.aiContext.findMany()
    * ```
    */
  get aiContext(): Prisma.AiContextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiContextEmbedding`: Exposes CRUD operations for the **AiContextEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiContextEmbeddings
    * const aiContextEmbeddings = await prisma.aiContextEmbedding.findMany()
    * ```
    */
  get aiContextEmbedding(): Prisma.AiContextEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiWorkspaceEmbedding`: Exposes CRUD operations for the **AiWorkspaceEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiWorkspaceEmbeddings
    * const aiWorkspaceEmbeddings = await prisma.aiWorkspaceEmbedding.findMany()
    * ```
    */
  get aiWorkspaceEmbedding(): Prisma.AiWorkspaceEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiWorkspaceIgnoredDocs`: Exposes CRUD operations for the **AiWorkspaceIgnoredDocs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiWorkspaceIgnoredDocs
    * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findMany()
    * ```
    */
  get aiWorkspaceIgnoredDocs(): Prisma.AiWorkspaceIgnoredDocsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiWorkspaceFiles`: Exposes CRUD operations for the **AiWorkspaceFiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiWorkspaceFiles
    * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findMany()
    * ```
    */
  get aiWorkspaceFiles(): Prisma.AiWorkspaceFilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiWorkspaceFileEmbedding`: Exposes CRUD operations for the **AiWorkspaceFileEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiWorkspaceFileEmbeddings
    * const aiWorkspaceFileEmbeddings = await prisma.aiWorkspaceFileEmbedding.findMany()
    * ```
    */
  get aiWorkspaceFileEmbedding(): Prisma.AiWorkspaceFileEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiWorkspaceBlobEmbedding`: Exposes CRUD operations for the **AiWorkspaceBlobEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiWorkspaceBlobEmbeddings
    * const aiWorkspaceBlobEmbeddings = await prisma.aiWorkspaceBlobEmbedding.findMany()
    * ```
    */
  get aiWorkspaceBlobEmbedding(): Prisma.AiWorkspaceBlobEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiJobs`: Exposes CRUD operations for the **AiJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiJobs
    * const aiJobs = await prisma.aiJobs.findMany()
    * ```
    */
  get aiJobs(): Prisma.AiJobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataMigration`: Exposes CRUD operations for the **DataMigration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataMigrations
    * const dataMigrations = await prisma.dataMigration.findMany()
    * ```
    */
  get dataMigration(): Prisma.DataMigrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deprecatedAppRuntimeSettings`: Exposes CRUD operations for the **DeprecatedAppRuntimeSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeprecatedAppRuntimeSettings
    * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findMany()
    * ```
    */
  get deprecatedAppRuntimeSettings(): Prisma.DeprecatedAppRuntimeSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appConfig`: Exposes CRUD operations for the **AppConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigs
    * const appConfigs = await prisma.appConfig.findMany()
    * ```
    */
  get appConfig(): Prisma.AppConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deprecatedUserSubscription`: Exposes CRUD operations for the **DeprecatedUserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeprecatedUserSubscriptions
    * const deprecatedUserSubscriptions = await prisma.deprecatedUserSubscription.findMany()
    * ```
    */
  get deprecatedUserSubscription(): Prisma.DeprecatedUserSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deprecatedUserInvoice`: Exposes CRUD operations for the **DeprecatedUserInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeprecatedUserInvoices
    * const deprecatedUserInvoices = await prisma.deprecatedUserInvoice.findMany()
    * ```
    */
  get deprecatedUserInvoice(): Prisma.DeprecatedUserInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStripeCustomer`: Exposes CRUD operations for the **UserStripeCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStripeCustomers
    * const userStripeCustomers = await prisma.userStripeCustomer.findMany()
    * ```
    */
  get userStripeCustomer(): Prisma.UserStripeCustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.installedLicense`: Exposes CRUD operations for the **InstalledLicense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstalledLicenses
    * const installedLicenses = await prisma.installedLicense.findMany()
    * ```
    */
  get installedLicense(): Prisma.InstalledLicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blob`: Exposes CRUD operations for the **Blob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blobs
    * const blobs = await prisma.blob.findMany()
    * ```
    */
  get blob(): Prisma.BlobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reply`: Exposes CRUD operations for the **Reply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Replies
    * const replies = await prisma.reply.findMany()
    * ```
    */
  get reply(): Prisma.ReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentAttachment`: Exposes CRUD operations for the **CommentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentAttachments
    * const commentAttachments = await prisma.commentAttachment.findMany()
    * ```
    */
  get commentAttachment(): Prisma.CommentAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessToken`: Exposes CRUD operations for the **AccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessTokens
    * const accessTokens = await prisma.accessToken.findMany()
    * ```
    */
  get accessToken(): Prisma.AccessTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ConnectedAccount: 'ConnectedAccount',
    Session: 'Session',
    UserSession: 'UserSession',
    VerificationToken: 'VerificationToken',
    Workspace: 'Workspace',
    WorkspaceDoc: 'WorkspaceDoc',
    WorkspaceUserRole: 'WorkspaceUserRole',
    WorkspaceDocUserRole: 'WorkspaceDocUserRole',
    Feature: 'Feature',
    UserFeature: 'UserFeature',
    WorkspaceFeature: 'WorkspaceFeature',
    Snapshot: 'Snapshot',
    UserSnapshot: 'UserSnapshot',
    Update: 'Update',
    SnapshotHistory: 'SnapshotHistory',
    AiPromptMessage: 'AiPromptMessage',
    AiPrompt: 'AiPrompt',
    AiSessionMessage: 'AiSessionMessage',
    AiSession: 'AiSession',
    AiContext: 'AiContext',
    AiContextEmbedding: 'AiContextEmbedding',
    AiWorkspaceEmbedding: 'AiWorkspaceEmbedding',
    AiWorkspaceIgnoredDocs: 'AiWorkspaceIgnoredDocs',
    AiWorkspaceFiles: 'AiWorkspaceFiles',
    AiWorkspaceFileEmbedding: 'AiWorkspaceFileEmbedding',
    AiWorkspaceBlobEmbedding: 'AiWorkspaceBlobEmbedding',
    AiJobs: 'AiJobs',
    DataMigration: 'DataMigration',
    DeprecatedAppRuntimeSettings: 'DeprecatedAppRuntimeSettings',
    AppConfig: 'AppConfig',
    DeprecatedUserSubscription: 'DeprecatedUserSubscription',
    DeprecatedUserInvoice: 'DeprecatedUserInvoice',
    UserStripeCustomer: 'UserStripeCustomer',
    Subscription: 'Subscription',
    Invoice: 'Invoice',
    License: 'License',
    InstalledLicense: 'InstalledLicense',
    Blob: 'Blob',
    Notification: 'Notification',
    UserSettings: 'UserSettings',
    Comment: 'Comment',
    Reply: 'Reply',
    CommentAttachment: 'CommentAttachment',
    AccessToken: 'AccessToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "connectedAccount" | "session" | "userSession" | "verificationToken" | "workspace" | "workspaceDoc" | "workspaceUserRole" | "workspaceDocUserRole" | "feature" | "userFeature" | "workspaceFeature" | "snapshot" | "userSnapshot" | "update" | "snapshotHistory" | "aiPromptMessage" | "aiPrompt" | "aiSessionMessage" | "aiSession" | "aiContext" | "aiContextEmbedding" | "aiWorkspaceEmbedding" | "aiWorkspaceIgnoredDocs" | "aiWorkspaceFiles" | "aiWorkspaceFileEmbedding" | "aiWorkspaceBlobEmbedding" | "aiJobs" | "dataMigration" | "deprecatedAppRuntimeSettings" | "appConfig" | "deprecatedUserSubscription" | "deprecatedUserInvoice" | "userStripeCustomer" | "subscription" | "invoice" | "license" | "installedLicense" | "blob" | "notification" | "userSettings" | "comment" | "reply" | "commentAttachment" | "accessToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ConnectedAccount: {
        payload: Prisma.$ConnectedAccountPayload<ExtArgs>
        fields: Prisma.ConnectedAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectedAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectedAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          findFirst: {
            args: Prisma.ConnectedAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectedAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          findMany: {
            args: Prisma.ConnectedAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>[]
          }
          create: {
            args: Prisma.ConnectedAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          createMany: {
            args: Prisma.ConnectedAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectedAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>[]
          }
          delete: {
            args: Prisma.ConnectedAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          update: {
            args: Prisma.ConnectedAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          deleteMany: {
            args: Prisma.ConnectedAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectedAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectedAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>[]
          }
          upsert: {
            args: Prisma.ConnectedAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectedAccountPayload>
          }
          aggregate: {
            args: Prisma.ConnectedAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectedAccount>
          }
          groupBy: {
            args: Prisma.ConnectedAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectedAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectedAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectedAccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceDoc: {
        payload: Prisma.$WorkspaceDocPayload<ExtArgs>
        fields: Prisma.WorkspaceDocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceDocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceDocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceDocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceDocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          findMany: {
            args: Prisma.WorkspaceDocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>[]
          }
          create: {
            args: Prisma.WorkspaceDocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          createMany: {
            args: Prisma.WorkspaceDocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceDocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          update: {
            args: Prisma.WorkspaceDocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceDocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceDocUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceDocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceDocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceDoc>
          }
          groupBy: {
            args: Prisma.WorkspaceDocGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceDocGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceDocCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceDocCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceUserRole: {
        payload: Prisma.$WorkspaceUserRolePayload<ExtArgs>
        fields: Prisma.WorkspaceUserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceUserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceUserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceUserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceUserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          findMany: {
            args: Prisma.WorkspaceUserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>[]
          }
          create: {
            args: Prisma.WorkspaceUserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          createMany: {
            args: Prisma.WorkspaceUserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceUserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceUserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          update: {
            args: Prisma.WorkspaceUserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceUserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceUserRolePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceUserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceUserRole>
          }
          groupBy: {
            args: Prisma.WorkspaceUserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceUserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceUserRoleCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceDocUserRole: {
        payload: Prisma.$WorkspaceDocUserRolePayload<ExtArgs>
        fields: Prisma.WorkspaceDocUserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceDocUserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceDocUserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceDocUserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceDocUserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          findMany: {
            args: Prisma.WorkspaceDocUserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>[]
          }
          create: {
            args: Prisma.WorkspaceDocUserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          createMany: {
            args: Prisma.WorkspaceDocUserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceDocUserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDocUserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          update: {
            args: Prisma.WorkspaceDocUserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDocUserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceDocUserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceDocUserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceDocUserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceDocUserRolePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceDocUserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceDocUserRole>
          }
          groupBy: {
            args: Prisma.WorkspaceDocUserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceDocUserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceDocUserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceDocUserRoleCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      UserFeature: {
        payload: Prisma.$UserFeaturePayload<ExtArgs>
        fields: Prisma.UserFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          findFirst: {
            args: Prisma.UserFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          findMany: {
            args: Prisma.UserFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>[]
          }
          create: {
            args: Prisma.UserFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          createMany: {
            args: Prisma.UserFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>[]
          }
          delete: {
            args: Prisma.UserFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          update: {
            args: Prisma.UserFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          deleteMany: {
            args: Prisma.UserFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>[]
          }
          upsert: {
            args: Prisma.UserFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeaturePayload>
          }
          aggregate: {
            args: Prisma.UserFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeature>
          }
          groupBy: {
            args: Prisma.UserFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceFeature: {
        payload: Prisma.$WorkspaceFeaturePayload<ExtArgs>
        fields: Prisma.WorkspaceFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>[]
          }
          create: {
            args: Prisma.WorkspaceFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          createMany: {
            args: Prisma.WorkspaceFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceFeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          update: {
            args: Prisma.WorkspaceFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceFeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceFeaturePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceFeature>
          }
          groupBy: {
            args: Prisma.WorkspaceFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceFeatureCountAggregateOutputType> | number
          }
        }
      }
      Snapshot: {
        payload: Prisma.$SnapshotPayload<ExtArgs>
        fields: Prisma.SnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          findFirst: {
            args: Prisma.SnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          findMany: {
            args: Prisma.SnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>[]
          }
          create: {
            args: Prisma.SnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          createMany: {
            args: Prisma.SnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>[]
          }
          delete: {
            args: Prisma.SnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          update: {
            args: Prisma.SnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          deleteMany: {
            args: Prisma.SnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>[]
          }
          upsert: {
            args: Prisma.SnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotPayload>
          }
          aggregate: {
            args: Prisma.SnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnapshot>
          }
          groupBy: {
            args: Prisma.SnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<SnapshotCountAggregateOutputType> | number
          }
        }
      }
      UserSnapshot: {
        payload: Prisma.$UserSnapshotPayload<ExtArgs>
        fields: Prisma.UserSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          findFirst: {
            args: Prisma.UserSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          findMany: {
            args: Prisma.UserSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>[]
          }
          create: {
            args: Prisma.UserSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          createMany: {
            args: Prisma.UserSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>[]
          }
          delete: {
            args: Prisma.UserSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          update: {
            args: Prisma.UserSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.UserSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.UserSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSnapshotPayload>
          }
          aggregate: {
            args: Prisma.UserSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSnapshot>
          }
          groupBy: {
            args: Prisma.UserSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<UserSnapshotCountAggregateOutputType> | number
          }
        }
      }
      Update: {
        payload: Prisma.$UpdatePayload<ExtArgs>
        fields: Prisma.UpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          findFirst: {
            args: Prisma.UpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          findMany: {
            args: Prisma.UpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>[]
          }
          create: {
            args: Prisma.UpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          createMany: {
            args: Prisma.UpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>[]
          }
          delete: {
            args: Prisma.UpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          update: {
            args: Prisma.UpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          deleteMany: {
            args: Prisma.UpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>[]
          }
          upsert: {
            args: Prisma.UpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UpdatePayload>
          }
          aggregate: {
            args: Prisma.UpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpdate>
          }
          groupBy: {
            args: Prisma.UpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UpdateCountArgs<ExtArgs>
            result: $Utils.Optional<UpdateCountAggregateOutputType> | number
          }
        }
      }
      SnapshotHistory: {
        payload: Prisma.$SnapshotHistoryPayload<ExtArgs>
        fields: Prisma.SnapshotHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnapshotHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnapshotHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          findFirst: {
            args: Prisma.SnapshotHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnapshotHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          findMany: {
            args: Prisma.SnapshotHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>[]
          }
          create: {
            args: Prisma.SnapshotHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          createMany: {
            args: Prisma.SnapshotHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnapshotHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>[]
          }
          delete: {
            args: Prisma.SnapshotHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          update: {
            args: Prisma.SnapshotHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SnapshotHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnapshotHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SnapshotHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SnapshotHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnapshotHistoryPayload>
          }
          aggregate: {
            args: Prisma.SnapshotHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnapshotHistory>
          }
          groupBy: {
            args: Prisma.SnapshotHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnapshotHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnapshotHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SnapshotHistoryCountAggregateOutputType> | number
          }
        }
      }
      AiPromptMessage: {
        payload: Prisma.$AiPromptMessagePayload<ExtArgs>
        fields: Prisma.AiPromptMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiPromptMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiPromptMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          findFirst: {
            args: Prisma.AiPromptMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiPromptMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          findMany: {
            args: Prisma.AiPromptMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>[]
          }
          create: {
            args: Prisma.AiPromptMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          createMany: {
            args: Prisma.AiPromptMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiPromptMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>[]
          }
          delete: {
            args: Prisma.AiPromptMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          update: {
            args: Prisma.AiPromptMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          deleteMany: {
            args: Prisma.AiPromptMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiPromptMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiPromptMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>[]
          }
          upsert: {
            args: Prisma.AiPromptMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptMessagePayload>
          }
          aggregate: {
            args: Prisma.AiPromptMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiPromptMessage>
          }
          groupBy: {
            args: Prisma.AiPromptMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiPromptMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiPromptMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AiPromptMessageCountAggregateOutputType> | number
          }
        }
      }
      AiPrompt: {
        payload: Prisma.$AiPromptPayload<ExtArgs>
        fields: Prisma.AiPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          findFirst: {
            args: Prisma.AiPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          findMany: {
            args: Prisma.AiPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>[]
          }
          create: {
            args: Prisma.AiPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          createMany: {
            args: Prisma.AiPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>[]
          }
          delete: {
            args: Prisma.AiPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          update: {
            args: Prisma.AiPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          deleteMany: {
            args: Prisma.AiPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiPromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>[]
          }
          upsert: {
            args: Prisma.AiPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiPromptPayload>
          }
          aggregate: {
            args: Prisma.AiPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiPrompt>
          }
          groupBy: {
            args: Prisma.AiPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiPromptCountArgs<ExtArgs>
            result: $Utils.Optional<AiPromptCountAggregateOutputType> | number
          }
        }
      }
      AiSessionMessage: {
        payload: Prisma.$AiSessionMessagePayload<ExtArgs>
        fields: Prisma.AiSessionMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiSessionMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiSessionMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          findFirst: {
            args: Prisma.AiSessionMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiSessionMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          findMany: {
            args: Prisma.AiSessionMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>[]
          }
          create: {
            args: Prisma.AiSessionMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          createMany: {
            args: Prisma.AiSessionMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiSessionMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>[]
          }
          delete: {
            args: Prisma.AiSessionMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          update: {
            args: Prisma.AiSessionMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          deleteMany: {
            args: Prisma.AiSessionMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiSessionMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiSessionMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>[]
          }
          upsert: {
            args: Prisma.AiSessionMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionMessagePayload>
          }
          aggregate: {
            args: Prisma.AiSessionMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiSessionMessage>
          }
          groupBy: {
            args: Prisma.AiSessionMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiSessionMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiSessionMessageCountArgs<ExtArgs>
            result: $Utils.Optional<AiSessionMessageCountAggregateOutputType> | number
          }
        }
      }
      AiSession: {
        payload: Prisma.$AiSessionPayload<ExtArgs>
        fields: Prisma.AiSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          findFirst: {
            args: Prisma.AiSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          findMany: {
            args: Prisma.AiSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>[]
          }
          create: {
            args: Prisma.AiSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          createMany: {
            args: Prisma.AiSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>[]
          }
          delete: {
            args: Prisma.AiSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          update: {
            args: Prisma.AiSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          deleteMany: {
            args: Prisma.AiSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>[]
          }
          upsert: {
            args: Prisma.AiSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiSessionPayload>
          }
          aggregate: {
            args: Prisma.AiSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiSession>
          }
          groupBy: {
            args: Prisma.AiSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AiSessionCountAggregateOutputType> | number
          }
        }
      }
      AiContext: {
        payload: Prisma.$AiContextPayload<ExtArgs>
        fields: Prisma.AiContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          findFirst: {
            args: Prisma.AiContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          findMany: {
            args: Prisma.AiContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>[]
          }
          create: {
            args: Prisma.AiContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          createMany: {
            args: Prisma.AiContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>[]
          }
          delete: {
            args: Prisma.AiContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          update: {
            args: Prisma.AiContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          deleteMany: {
            args: Prisma.AiContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiContextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>[]
          }
          upsert: {
            args: Prisma.AiContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextPayload>
          }
          aggregate: {
            args: Prisma.AiContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiContext>
          }
          groupBy: {
            args: Prisma.AiContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiContextCountArgs<ExtArgs>
            result: $Utils.Optional<AiContextCountAggregateOutputType> | number
          }
        }
      }
      AiContextEmbedding: {
        payload: Prisma.$AiContextEmbeddingPayload<ExtArgs>
        fields: Prisma.AiContextEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiContextEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiContextEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.AiContextEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiContextEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>
          }
          findMany: {
            args: Prisma.AiContextEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.AiContextEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>
          }
          update: {
            args: Prisma.AiContextEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.AiContextEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiContextEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiContextEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiContextEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.AiContextEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiContextEmbedding>
          }
          groupBy: {
            args: Prisma.AiContextEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiContextEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiContextEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<AiContextEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      AiWorkspaceEmbedding: {
        payload: Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>
        fields: Prisma.AiWorkspaceEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiWorkspaceEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiWorkspaceEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.AiWorkspaceEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiWorkspaceEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>
          }
          findMany: {
            args: Prisma.AiWorkspaceEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.AiWorkspaceEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>
          }
          update: {
            args: Prisma.AiWorkspaceEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.AiWorkspaceEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiWorkspaceEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiWorkspaceEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.AiWorkspaceEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiWorkspaceEmbedding>
          }
          groupBy: {
            args: Prisma.AiWorkspaceEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiWorkspaceEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      AiWorkspaceIgnoredDocs: {
        payload: Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>
        fields: Prisma.AiWorkspaceIgnoredDocsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiWorkspaceIgnoredDocsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiWorkspaceIgnoredDocsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          findFirst: {
            args: Prisma.AiWorkspaceIgnoredDocsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiWorkspaceIgnoredDocsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          findMany: {
            args: Prisma.AiWorkspaceIgnoredDocsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>[]
          }
          create: {
            args: Prisma.AiWorkspaceIgnoredDocsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          createMany: {
            args: Prisma.AiWorkspaceIgnoredDocsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiWorkspaceIgnoredDocsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>[]
          }
          delete: {
            args: Prisma.AiWorkspaceIgnoredDocsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          update: {
            args: Prisma.AiWorkspaceIgnoredDocsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          deleteMany: {
            args: Prisma.AiWorkspaceIgnoredDocsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiWorkspaceIgnoredDocsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiWorkspaceIgnoredDocsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>[]
          }
          upsert: {
            args: Prisma.AiWorkspaceIgnoredDocsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceIgnoredDocsPayload>
          }
          aggregate: {
            args: Prisma.AiWorkspaceIgnoredDocsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiWorkspaceIgnoredDocs>
          }
          groupBy: {
            args: Prisma.AiWorkspaceIgnoredDocsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceIgnoredDocsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiWorkspaceIgnoredDocsCountArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceIgnoredDocsCountAggregateOutputType> | number
          }
        }
      }
      AiWorkspaceFiles: {
        payload: Prisma.$AiWorkspaceFilesPayload<ExtArgs>
        fields: Prisma.AiWorkspaceFilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiWorkspaceFilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiWorkspaceFilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          findFirst: {
            args: Prisma.AiWorkspaceFilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiWorkspaceFilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          findMany: {
            args: Prisma.AiWorkspaceFilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>[]
          }
          create: {
            args: Prisma.AiWorkspaceFilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          createMany: {
            args: Prisma.AiWorkspaceFilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiWorkspaceFilesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>[]
          }
          delete: {
            args: Prisma.AiWorkspaceFilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          update: {
            args: Prisma.AiWorkspaceFilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          deleteMany: {
            args: Prisma.AiWorkspaceFilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiWorkspaceFilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiWorkspaceFilesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>[]
          }
          upsert: {
            args: Prisma.AiWorkspaceFilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFilesPayload>
          }
          aggregate: {
            args: Prisma.AiWorkspaceFilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiWorkspaceFiles>
          }
          groupBy: {
            args: Prisma.AiWorkspaceFilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceFilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiWorkspaceFilesCountArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceFilesCountAggregateOutputType> | number
          }
        }
      }
      AiWorkspaceFileEmbedding: {
        payload: Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>
        fields: Prisma.AiWorkspaceFileEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiWorkspaceFileEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiWorkspaceFileEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.AiWorkspaceFileEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiWorkspaceFileEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>
          }
          findMany: {
            args: Prisma.AiWorkspaceFileEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.AiWorkspaceFileEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>
          }
          update: {
            args: Prisma.AiWorkspaceFileEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.AiWorkspaceFileEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiWorkspaceFileEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiWorkspaceFileEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceFileEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.AiWorkspaceFileEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiWorkspaceFileEmbedding>
          }
          groupBy: {
            args: Prisma.AiWorkspaceFileEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceFileEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiWorkspaceFileEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceFileEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      AiWorkspaceBlobEmbedding: {
        payload: Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>
        fields: Prisma.AiWorkspaceBlobEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiWorkspaceBlobEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiWorkspaceBlobEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.AiWorkspaceBlobEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiWorkspaceBlobEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>
          }
          findMany: {
            args: Prisma.AiWorkspaceBlobEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.AiWorkspaceBlobEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>
          }
          update: {
            args: Prisma.AiWorkspaceBlobEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.AiWorkspaceBlobEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiWorkspaceBlobEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiWorkspaceBlobEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiWorkspaceBlobEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.AiWorkspaceBlobEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiWorkspaceBlobEmbedding>
          }
          groupBy: {
            args: Prisma.AiWorkspaceBlobEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceBlobEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiWorkspaceBlobEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<AiWorkspaceBlobEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      AiJobs: {
        payload: Prisma.$AiJobsPayload<ExtArgs>
        fields: Prisma.AiJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          findFirst: {
            args: Prisma.AiJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          findMany: {
            args: Prisma.AiJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>[]
          }
          create: {
            args: Prisma.AiJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          createMany: {
            args: Prisma.AiJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>[]
          }
          delete: {
            args: Prisma.AiJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          update: {
            args: Prisma.AiJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          deleteMany: {
            args: Prisma.AiJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AiJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>[]
          }
          upsert: {
            args: Prisma.AiJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiJobsPayload>
          }
          aggregate: {
            args: Prisma.AiJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiJobs>
          }
          groupBy: {
            args: Prisma.AiJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiJobsCountArgs<ExtArgs>
            result: $Utils.Optional<AiJobsCountAggregateOutputType> | number
          }
        }
      }
      DataMigration: {
        payload: Prisma.$DataMigrationPayload<ExtArgs>
        fields: Prisma.DataMigrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataMigrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataMigrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          findFirst: {
            args: Prisma.DataMigrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataMigrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          findMany: {
            args: Prisma.DataMigrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>[]
          }
          create: {
            args: Prisma.DataMigrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          createMany: {
            args: Prisma.DataMigrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataMigrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>[]
          }
          delete: {
            args: Prisma.DataMigrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          update: {
            args: Prisma.DataMigrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          deleteMany: {
            args: Prisma.DataMigrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataMigrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DataMigrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>[]
          }
          upsert: {
            args: Prisma.DataMigrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataMigrationPayload>
          }
          aggregate: {
            args: Prisma.DataMigrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataMigration>
          }
          groupBy: {
            args: Prisma.DataMigrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataMigrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataMigrationCountArgs<ExtArgs>
            result: $Utils.Optional<DataMigrationCountAggregateOutputType> | number
          }
        }
      }
      DeprecatedAppRuntimeSettings: {
        payload: Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>
        fields: Prisma.DeprecatedAppRuntimeSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeprecatedAppRuntimeSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeprecatedAppRuntimeSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          findFirst: {
            args: Prisma.DeprecatedAppRuntimeSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeprecatedAppRuntimeSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          findMany: {
            args: Prisma.DeprecatedAppRuntimeSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>[]
          }
          create: {
            args: Prisma.DeprecatedAppRuntimeSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          createMany: {
            args: Prisma.DeprecatedAppRuntimeSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeprecatedAppRuntimeSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>[]
          }
          delete: {
            args: Prisma.DeprecatedAppRuntimeSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          update: {
            args: Prisma.DeprecatedAppRuntimeSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          deleteMany: {
            args: Prisma.DeprecatedAppRuntimeSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeprecatedAppRuntimeSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeprecatedAppRuntimeSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>[]
          }
          upsert: {
            args: Prisma.DeprecatedAppRuntimeSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedAppRuntimeSettingsPayload>
          }
          aggregate: {
            args: Prisma.DeprecatedAppRuntimeSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeprecatedAppRuntimeSettings>
          }
          groupBy: {
            args: Prisma.DeprecatedAppRuntimeSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedAppRuntimeSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeprecatedAppRuntimeSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedAppRuntimeSettingsCountAggregateOutputType> | number
          }
        }
      }
      AppConfig: {
        payload: Prisma.$AppConfigPayload<ExtArgs>
        fields: Prisma.AppConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findFirst: {
            args: Prisma.AppConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findMany: {
            args: Prisma.AppConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          create: {
            args: Prisma.AppConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          createMany: {
            args: Prisma.AppConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          delete: {
            args: Prisma.AppConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          update: {
            args: Prisma.AppConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          deleteMany: {
            args: Prisma.AppConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          upsert: {
            args: Prisma.AppConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          aggregate: {
            args: Prisma.AppConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppConfig>
          }
          groupBy: {
            args: Prisma.AppConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AppConfigCountAggregateOutputType> | number
          }
        }
      }
      DeprecatedUserSubscription: {
        payload: Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>
        fields: Prisma.DeprecatedUserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeprecatedUserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeprecatedUserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.DeprecatedUserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeprecatedUserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.DeprecatedUserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.DeprecatedUserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.DeprecatedUserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeprecatedUserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.DeprecatedUserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          update: {
            args: Prisma.DeprecatedUserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.DeprecatedUserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeprecatedUserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeprecatedUserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.DeprecatedUserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.DeprecatedUserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeprecatedUserSubscription>
          }
          groupBy: {
            args: Prisma.DeprecatedUserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedUserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeprecatedUserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedUserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      DeprecatedUserInvoice: {
        payload: Prisma.$DeprecatedUserInvoicePayload<ExtArgs>
        fields: Prisma.DeprecatedUserInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeprecatedUserInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeprecatedUserInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          findFirst: {
            args: Prisma.DeprecatedUserInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeprecatedUserInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          findMany: {
            args: Prisma.DeprecatedUserInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>[]
          }
          create: {
            args: Prisma.DeprecatedUserInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          createMany: {
            args: Prisma.DeprecatedUserInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeprecatedUserInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>[]
          }
          delete: {
            args: Prisma.DeprecatedUserInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          update: {
            args: Prisma.DeprecatedUserInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          deleteMany: {
            args: Prisma.DeprecatedUserInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeprecatedUserInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeprecatedUserInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>[]
          }
          upsert: {
            args: Prisma.DeprecatedUserInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeprecatedUserInvoicePayload>
          }
          aggregate: {
            args: Prisma.DeprecatedUserInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeprecatedUserInvoice>
          }
          groupBy: {
            args: Prisma.DeprecatedUserInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedUserInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeprecatedUserInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<DeprecatedUserInvoiceCountAggregateOutputType> | number
          }
        }
      }
      UserStripeCustomer: {
        payload: Prisma.$UserStripeCustomerPayload<ExtArgs>
        fields: Prisma.UserStripeCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStripeCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStripeCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          findFirst: {
            args: Prisma.UserStripeCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStripeCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          findMany: {
            args: Prisma.UserStripeCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>[]
          }
          create: {
            args: Prisma.UserStripeCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          createMany: {
            args: Prisma.UserStripeCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStripeCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>[]
          }
          delete: {
            args: Prisma.UserStripeCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          update: {
            args: Prisma.UserStripeCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          deleteMany: {
            args: Prisma.UserStripeCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStripeCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStripeCustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>[]
          }
          upsert: {
            args: Prisma.UserStripeCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStripeCustomerPayload>
          }
          aggregate: {
            args: Prisma.UserStripeCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStripeCustomer>
          }
          groupBy: {
            args: Prisma.UserStripeCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStripeCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStripeCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<UserStripeCustomerCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      InstalledLicense: {
        payload: Prisma.$InstalledLicensePayload<ExtArgs>
        fields: Prisma.InstalledLicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalledLicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalledLicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          findFirst: {
            args: Prisma.InstalledLicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalledLicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          findMany: {
            args: Prisma.InstalledLicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>[]
          }
          create: {
            args: Prisma.InstalledLicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          createMany: {
            args: Prisma.InstalledLicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalledLicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>[]
          }
          delete: {
            args: Prisma.InstalledLicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          update: {
            args: Prisma.InstalledLicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          deleteMany: {
            args: Prisma.InstalledLicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalledLicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstalledLicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>[]
          }
          upsert: {
            args: Prisma.InstalledLicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalledLicensePayload>
          }
          aggregate: {
            args: Prisma.InstalledLicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalledLicense>
          }
          groupBy: {
            args: Prisma.InstalledLicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalledLicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalledLicenseCountArgs<ExtArgs>
            result: $Utils.Optional<InstalledLicenseCountAggregateOutputType> | number
          }
        }
      }
      Blob: {
        payload: Prisma.$BlobPayload<ExtArgs>
        fields: Prisma.BlobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          findFirst: {
            args: Prisma.BlobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          findMany: {
            args: Prisma.BlobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>[]
          }
          create: {
            args: Prisma.BlobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          createMany: {
            args: Prisma.BlobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>[]
          }
          delete: {
            args: Prisma.BlobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          update: {
            args: Prisma.BlobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          deleteMany: {
            args: Prisma.BlobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>[]
          }
          upsert: {
            args: Prisma.BlobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlobPayload>
          }
          aggregate: {
            args: Prisma.BlobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlob>
          }
          groupBy: {
            args: Prisma.BlobGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlobGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlobCountArgs<ExtArgs>
            result: $Utils.Optional<BlobCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Reply: {
        payload: Prisma.$ReplyPayload<ExtArgs>
        fields: Prisma.ReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findFirst: {
            args: Prisma.ReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          findMany: {
            args: Prisma.ReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>[]
          }
          create: {
            args: Prisma.ReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          createMany: {
            args: Prisma.ReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>[]
          }
          delete: {
            args: Prisma.ReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          update: {
            args: Prisma.ReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          deleteMany: {
            args: Prisma.ReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>[]
          }
          upsert: {
            args: Prisma.ReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyPayload>
          }
          aggregate: {
            args: Prisma.ReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReply>
          }
          groupBy: {
            args: Prisma.ReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ReplyCountAggregateOutputType> | number
          }
        }
      }
      CommentAttachment: {
        payload: Prisma.$CommentAttachmentPayload<ExtArgs>
        fields: Prisma.CommentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.CommentAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          findMany: {
            args: Prisma.CommentAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>[]
          }
          create: {
            args: Prisma.CommentAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          createMany: {
            args: Prisma.CommentAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>[]
          }
          delete: {
            args: Prisma.CommentAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          update: {
            args: Prisma.CommentAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.CommentAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.CommentAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.CommentAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentAttachment>
          }
          groupBy: {
            args: Prisma.CommentAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentAttachmentCountAggregateOutputType> | number
          }
        }
      }
      AccessToken: {
        payload: Prisma.$AccessTokenPayload<ExtArgs>
        fields: Prisma.AccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findFirst: {
            args: Prisma.AccessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findMany: {
            args: Prisma.AccessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          create: {
            args: Prisma.AccessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          createMany: {
            args: Prisma.AccessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          delete: {
            args: Prisma.AccessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          update: {
            args: Prisma.AccessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.AccessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          upsert: {
            args: Prisma.AccessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          aggregate: {
            args: Prisma.AccessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessToken>
          }
          groupBy: {
            args: Prisma.AccessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    connectedAccount?: ConnectedAccountOmit
    session?: SessionOmit
    userSession?: UserSessionOmit
    verificationToken?: VerificationTokenOmit
    workspace?: WorkspaceOmit
    workspaceDoc?: WorkspaceDocOmit
    workspaceUserRole?: WorkspaceUserRoleOmit
    workspaceDocUserRole?: WorkspaceDocUserRoleOmit
    feature?: FeatureOmit
    userFeature?: UserFeatureOmit
    workspaceFeature?: WorkspaceFeatureOmit
    snapshot?: SnapshotOmit
    userSnapshot?: UserSnapshotOmit
    update?: UpdateOmit
    snapshotHistory?: SnapshotHistoryOmit
    aiPromptMessage?: AiPromptMessageOmit
    aiPrompt?: AiPromptOmit
    aiSessionMessage?: AiSessionMessageOmit
    aiSession?: AiSessionOmit
    aiContext?: AiContextOmit
    aiContextEmbedding?: AiContextEmbeddingOmit
    aiWorkspaceEmbedding?: AiWorkspaceEmbeddingOmit
    aiWorkspaceIgnoredDocs?: AiWorkspaceIgnoredDocsOmit
    aiWorkspaceFiles?: AiWorkspaceFilesOmit
    aiWorkspaceFileEmbedding?: AiWorkspaceFileEmbeddingOmit
    aiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingOmit
    aiJobs?: AiJobsOmit
    dataMigration?: DataMigrationOmit
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsOmit
    appConfig?: AppConfigOmit
    deprecatedUserSubscription?: DeprecatedUserSubscriptionOmit
    deprecatedUserInvoice?: DeprecatedUserInvoiceOmit
    userStripeCustomer?: UserStripeCustomerOmit
    subscription?: SubscriptionOmit
    invoice?: InvoiceOmit
    license?: LicenseOmit
    installedLicense?: InstalledLicenseOmit
    blob?: BlobOmit
    notification?: NotificationOmit
    userSettings?: UserSettingsOmit
    comment?: CommentOmit
    reply?: ReplyOmit
    commentAttachment?: CommentAttachmentOmit
    accessToken?: AccessTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    features: number
    workspaces: number
    WorkspaceInvitations: number
    docPermissions: number
    connectedAccounts: number
    sessions: number
    aiSessions: number
    deprecatedAppRuntimeSettings: number
    appConfigs: number
    userSnapshots: number
    createdSnapshot: number
    updatedSnapshot: number
    createdUpdate: number
    createdHistory: number
    createdAiJobs: number
    notifications: number
    comments: number
    replies: number
    commentAttachments: number
    AccessToken: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | UserCountOutputTypeCountFeaturesArgs
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    WorkspaceInvitations?: boolean | UserCountOutputTypeCountWorkspaceInvitationsArgs
    docPermissions?: boolean | UserCountOutputTypeCountDocPermissionsArgs
    connectedAccounts?: boolean | UserCountOutputTypeCountConnectedAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    aiSessions?: boolean | UserCountOutputTypeCountAiSessionsArgs
    deprecatedAppRuntimeSettings?: boolean | UserCountOutputTypeCountDeprecatedAppRuntimeSettingsArgs
    appConfigs?: boolean | UserCountOutputTypeCountAppConfigsArgs
    userSnapshots?: boolean | UserCountOutputTypeCountUserSnapshotsArgs
    createdSnapshot?: boolean | UserCountOutputTypeCountCreatedSnapshotArgs
    updatedSnapshot?: boolean | UserCountOutputTypeCountUpdatedSnapshotArgs
    createdUpdate?: boolean | UserCountOutputTypeCountCreatedUpdateArgs
    createdHistory?: boolean | UserCountOutputTypeCountCreatedHistoryArgs
    createdAiJobs?: boolean | UserCountOutputTypeCountCreatedAiJobsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    replies?: boolean | UserCountOutputTypeCountRepliesArgs
    commentAttachments?: boolean | UserCountOutputTypeCountCommentAttachmentsArgs
    AccessToken?: boolean | UserCountOutputTypeCountAccessTokenArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspaceInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceDocUserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectedAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeprecatedAppRuntimeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeprecatedAppRuntimeSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnapshotHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedAiJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiJobsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccessTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    userSessions: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSessions?: boolean | SessionCountOutputTypeCountUserSessionsArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    features: number
    docs: number
    permissions: number
    docPermissions: number
    blobs: number
    ignoredDocs: number
    embedFiles: number
    comments: number
    commentAttachments: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | WorkspaceCountOutputTypeCountFeaturesArgs
    docs?: boolean | WorkspaceCountOutputTypeCountDocsArgs
    permissions?: boolean | WorkspaceCountOutputTypeCountPermissionsArgs
    docPermissions?: boolean | WorkspaceCountOutputTypeCountDocPermissionsArgs
    blobs?: boolean | WorkspaceCountOutputTypeCountBlobsArgs
    ignoredDocs?: boolean | WorkspaceCountOutputTypeCountIgnoredDocsArgs
    embedFiles?: boolean | WorkspaceCountOutputTypeCountEmbedFilesArgs
    comments?: boolean | WorkspaceCountOutputTypeCountCommentsArgs
    commentAttachments?: boolean | WorkspaceCountOutputTypeCountCommentAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceFeatureWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceDocWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserRoleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDocPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceDocUserRoleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountBlobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlobWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountIgnoredDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceIgnoredDocsWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountEmbedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceFilesWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountCommentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentAttachmentWhereInput
  }


  /**
   * Count Type FeatureCountOutputType
   */

  export type FeatureCountOutputType = {
    userFeatures: number
    workspaceFeatures: number
  }

  export type FeatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFeatures?: boolean | FeatureCountOutputTypeCountUserFeaturesArgs
    workspaceFeatures?: boolean | FeatureCountOutputTypeCountWorkspaceFeaturesArgs
  }

  // Custom InputTypes
  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureCountOutputType
     */
    select?: FeatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountUserFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureWhereInput
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountWorkspaceFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceFeatureWhereInput
  }


  /**
   * Count Type SnapshotCountOutputType
   */

  export type SnapshotCountOutputType = {
    embedding: number
  }

  export type SnapshotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embedding?: boolean | SnapshotCountOutputTypeCountEmbeddingArgs
  }

  // Custom InputTypes
  /**
   * SnapshotCountOutputType without action
   */
  export type SnapshotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotCountOutputType
     */
    select?: SnapshotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SnapshotCountOutputType without action
   */
  export type SnapshotCountOutputTypeCountEmbeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceEmbeddingWhereInput
  }


  /**
   * Count Type AiPromptCountOutputType
   */

  export type AiPromptCountOutputType = {
    messages: number
    sessions: number
  }

  export type AiPromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiPromptCountOutputTypeCountMessagesArgs
    sessions?: boolean | AiPromptCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * AiPromptCountOutputType without action
   */
  export type AiPromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptCountOutputType
     */
    select?: AiPromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiPromptCountOutputType without action
   */
  export type AiPromptCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiPromptMessageWhereInput
  }

  /**
   * AiPromptCountOutputType without action
   */
  export type AiPromptCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSessionWhereInput
  }


  /**
   * Count Type AiSessionCountOutputType
   */

  export type AiSessionCountOutputType = {
    messages: number
    context: number
  }

  export type AiSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiSessionCountOutputTypeCountMessagesArgs
    context?: boolean | AiSessionCountOutputTypeCountContextArgs
  }

  // Custom InputTypes
  /**
   * AiSessionCountOutputType without action
   */
  export type AiSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionCountOutputType
     */
    select?: AiSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiSessionCountOutputType without action
   */
  export type AiSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSessionMessageWhereInput
  }

  /**
   * AiSessionCountOutputType without action
   */
  export type AiSessionCountOutputTypeCountContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiContextWhereInput
  }


  /**
   * Count Type AiContextCountOutputType
   */

  export type AiContextCountOutputType = {
    embeddings: number
  }

  export type AiContextCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | AiContextCountOutputTypeCountEmbeddingsArgs
  }

  // Custom InputTypes
  /**
   * AiContextCountOutputType without action
   */
  export type AiContextCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextCountOutputType
     */
    select?: AiContextCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiContextCountOutputType without action
   */
  export type AiContextCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiContextEmbeddingWhereInput
  }


  /**
   * Count Type AiWorkspaceFilesCountOutputType
   */

  export type AiWorkspaceFilesCountOutputType = {
    embeddings: number
  }

  export type AiWorkspaceFilesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | AiWorkspaceFilesCountOutputTypeCountEmbeddingsArgs
  }

  // Custom InputTypes
  /**
   * AiWorkspaceFilesCountOutputType without action
   */
  export type AiWorkspaceFilesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFilesCountOutputType
     */
    select?: AiWorkspaceFilesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AiWorkspaceFilesCountOutputType without action
   */
  export type AiWorkspaceFilesCountOutputTypeCountEmbeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceFileEmbeddingWhereInput
  }


  /**
   * Count Type BlobCountOutputType
   */

  export type BlobCountOutputType = {
    AiWorkspaceBlobEmbedding: number
  }

  export type BlobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AiWorkspaceBlobEmbedding?: boolean | BlobCountOutputTypeCountAiWorkspaceBlobEmbeddingArgs
  }

  // Custom InputTypes
  /**
   * BlobCountOutputType without action
   */
  export type BlobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlobCountOutputType
     */
    select?: BlobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlobCountOutputType without action
   */
  export type BlobCountOutputTypeCountAiWorkspaceBlobEmbeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceBlobEmbeddingWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerifiedAt: Date | null
    avatarUrl: string | null
    createdAt: Date | null
    password: string | null
    registered: boolean | null
    disabled: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerifiedAt: Date | null
    avatarUrl: string | null
    createdAt: Date | null
    password: string | null
    registered: boolean | null
    disabled: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerifiedAt: number
    avatarUrl: number
    createdAt: number
    password: number
    registered: number
    disabled: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerifiedAt?: true
    avatarUrl?: true
    createdAt?: true
    password?: true
    registered?: true
    disabled?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerifiedAt?: true
    avatarUrl?: true
    createdAt?: true
    password?: true
    registered?: true
    disabled?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerifiedAt?: true
    avatarUrl?: true
    createdAt?: true
    password?: true
    registered?: true
    disabled?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerifiedAt: Date | null
    avatarUrl: string | null
    createdAt: Date
    password: string | null
    registered: boolean
    disabled: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    password?: boolean
    registered?: boolean
    disabled?: boolean
    features?: boolean | User$featuresArgs<ExtArgs>
    userStripeCustomer?: boolean | User$userStripeCustomerArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    WorkspaceInvitations?: boolean | User$WorkspaceInvitationsArgs<ExtArgs>
    docPermissions?: boolean | User$docPermissionsArgs<ExtArgs>
    connectedAccounts?: boolean | User$connectedAccountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    aiSessions?: boolean | User$aiSessionsArgs<ExtArgs>
    deprecatedAppRuntimeSettings?: boolean | User$deprecatedAppRuntimeSettingsArgs<ExtArgs>
    appConfigs?: boolean | User$appConfigsArgs<ExtArgs>
    userSnapshots?: boolean | User$userSnapshotsArgs<ExtArgs>
    createdSnapshot?: boolean | User$createdSnapshotArgs<ExtArgs>
    updatedSnapshot?: boolean | User$updatedSnapshotArgs<ExtArgs>
    createdUpdate?: boolean | User$createdUpdateArgs<ExtArgs>
    createdHistory?: boolean | User$createdHistoryArgs<ExtArgs>
    createdAiJobs?: boolean | User$createdAiJobsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    replies?: boolean | User$repliesArgs<ExtArgs>
    commentAttachments?: boolean | User$commentAttachmentsArgs<ExtArgs>
    AccessToken?: boolean | User$AccessTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    password?: boolean
    registered?: boolean
    disabled?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    password?: boolean
    registered?: boolean
    disabled?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerifiedAt?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    password?: boolean
    registered?: boolean
    disabled?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerifiedAt" | "avatarUrl" | "createdAt" | "password" | "registered" | "disabled", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | User$featuresArgs<ExtArgs>
    userStripeCustomer?: boolean | User$userStripeCustomerArgs<ExtArgs>
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    WorkspaceInvitations?: boolean | User$WorkspaceInvitationsArgs<ExtArgs>
    docPermissions?: boolean | User$docPermissionsArgs<ExtArgs>
    connectedAccounts?: boolean | User$connectedAccountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    aiSessions?: boolean | User$aiSessionsArgs<ExtArgs>
    deprecatedAppRuntimeSettings?: boolean | User$deprecatedAppRuntimeSettingsArgs<ExtArgs>
    appConfigs?: boolean | User$appConfigsArgs<ExtArgs>
    userSnapshots?: boolean | User$userSnapshotsArgs<ExtArgs>
    createdSnapshot?: boolean | User$createdSnapshotArgs<ExtArgs>
    updatedSnapshot?: boolean | User$updatedSnapshotArgs<ExtArgs>
    createdUpdate?: boolean | User$createdUpdateArgs<ExtArgs>
    createdHistory?: boolean | User$createdHistoryArgs<ExtArgs>
    createdAiJobs?: boolean | User$createdAiJobsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    settings?: boolean | User$settingsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    replies?: boolean | User$repliesArgs<ExtArgs>
    commentAttachments?: boolean | User$commentAttachmentsArgs<ExtArgs>
    AccessToken?: boolean | User$AccessTokenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      features: Prisma.$UserFeaturePayload<ExtArgs>[]
      userStripeCustomer: Prisma.$UserStripeCustomerPayload<ExtArgs> | null
      workspaces: Prisma.$WorkspaceUserRolePayload<ExtArgs>[]
      WorkspaceInvitations: Prisma.$WorkspaceUserRolePayload<ExtArgs>[]
      docPermissions: Prisma.$WorkspaceDocUserRolePayload<ExtArgs>[]
      connectedAccounts: Prisma.$ConnectedAccountPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      aiSessions: Prisma.$AiSessionPayload<ExtArgs>[]
      /**
       * @deprecated
       */
      deprecatedAppRuntimeSettings: Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>[]
      appConfigs: Prisma.$AppConfigPayload<ExtArgs>[]
      userSnapshots: Prisma.$UserSnapshotPayload<ExtArgs>[]
      createdSnapshot: Prisma.$SnapshotPayload<ExtArgs>[]
      updatedSnapshot: Prisma.$SnapshotPayload<ExtArgs>[]
      createdUpdate: Prisma.$UpdatePayload<ExtArgs>[]
      createdHistory: Prisma.$SnapshotHistoryPayload<ExtArgs>[]
      createdAiJobs: Prisma.$AiJobsPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      replies: Prisma.$ReplyPayload<ExtArgs>[]
      commentAttachments: Prisma.$CommentAttachmentPayload<ExtArgs>[]
      AccessToken: Prisma.$AccessTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerifiedAt: Date | null
      avatarUrl: string | null
      createdAt: Date
      /**
       * Not available if user signed up through OAuth providers
       */
      password: string | null
      /**
       * Indicate whether the user finished the signup progress.
       * for example, the value will be false if user never registered and invited into a workspace by others.
       */
      registered: boolean
      disabled: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends User$featuresArgs<ExtArgs> = {}>(args?: Subset<T, User$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userStripeCustomer<T extends User$userStripeCustomerArgs<ExtArgs> = {}>(args?: Subset<T, User$userStripeCustomerArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkspaceInvitations<T extends User$WorkspaceInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$WorkspaceInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    docPermissions<T extends User$docPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$docPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connectedAccounts<T extends User$connectedAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$connectedAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aiSessions<T extends User$aiSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deprecatedAppRuntimeSettings<T extends User$deprecatedAppRuntimeSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$deprecatedAppRuntimeSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appConfigs<T extends User$appConfigsArgs<ExtArgs> = {}>(args?: Subset<T, User$appConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSnapshots<T extends User$userSnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSnapshot<T extends User$createdSnapshotArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSnapshotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedSnapshot<T extends User$updatedSnapshotArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedSnapshotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdUpdate<T extends User$createdUpdateArgs<ExtArgs> = {}>(args?: Subset<T, User$createdUpdateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdHistory<T extends User$createdHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$createdHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdAiJobs<T extends User$createdAiJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdAiJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    replies<T extends User$repliesArgs<ExtArgs> = {}>(args?: Subset<T, User$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentAttachments<T extends User$commentAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AccessToken<T extends User$AccessTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$AccessTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly registered: FieldRef<"User", 'Boolean'>
    readonly disabled: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.features
   */
  export type User$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    where?: UserFeatureWhereInput
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    cursor?: UserFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeatureScalarFieldEnum | UserFeatureScalarFieldEnum[]
  }

  /**
   * User.userStripeCustomer
   */
  export type User$userStripeCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    where?: UserStripeCustomerWhereInput
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    where?: WorkspaceUserRoleWhereInput
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    cursor?: WorkspaceUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
  }

  /**
   * User.WorkspaceInvitations
   */
  export type User$WorkspaceInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    where?: WorkspaceUserRoleWhereInput
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    cursor?: WorkspaceUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
  }

  /**
   * User.docPermissions
   */
  export type User$docPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    where?: WorkspaceDocUserRoleWhereInput
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceDocUserRoleScalarFieldEnum | WorkspaceDocUserRoleScalarFieldEnum[]
  }

  /**
   * User.connectedAccounts
   */
  export type User$connectedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    where?: ConnectedAccountWhereInput
    orderBy?: ConnectedAccountOrderByWithRelationInput | ConnectedAccountOrderByWithRelationInput[]
    cursor?: ConnectedAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectedAccountScalarFieldEnum | ConnectedAccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.aiSessions
   */
  export type User$aiSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    where?: AiSessionWhereInput
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    cursor?: AiSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiSessionScalarFieldEnum | AiSessionScalarFieldEnum[]
  }

  /**
   * User.deprecatedAppRuntimeSettings
   */
  export type User$deprecatedAppRuntimeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    where?: DeprecatedAppRuntimeSettingsWhereInput
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithRelationInput | DeprecatedAppRuntimeSettingsOrderByWithRelationInput[]
    cursor?: DeprecatedAppRuntimeSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeprecatedAppRuntimeSettingsScalarFieldEnum | DeprecatedAppRuntimeSettingsScalarFieldEnum[]
  }

  /**
   * User.appConfigs
   */
  export type User$appConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    cursor?: AppConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * User.userSnapshots
   */
  export type User$userSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    where?: UserSnapshotWhereInput
    orderBy?: UserSnapshotOrderByWithRelationInput | UserSnapshotOrderByWithRelationInput[]
    cursor?: UserSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSnapshotScalarFieldEnum | UserSnapshotScalarFieldEnum[]
  }

  /**
   * User.createdSnapshot
   */
  export type User$createdSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    where?: SnapshotWhereInput
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    cursor?: SnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnapshotScalarFieldEnum | SnapshotScalarFieldEnum[]
  }

  /**
   * User.updatedSnapshot
   */
  export type User$updatedSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    where?: SnapshotWhereInput
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    cursor?: SnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnapshotScalarFieldEnum | SnapshotScalarFieldEnum[]
  }

  /**
   * User.createdUpdate
   */
  export type User$createdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    where?: UpdateWhereInput
    orderBy?: UpdateOrderByWithRelationInput | UpdateOrderByWithRelationInput[]
    cursor?: UpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UpdateScalarFieldEnum | UpdateScalarFieldEnum[]
  }

  /**
   * User.createdHistory
   */
  export type User$createdHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    where?: SnapshotHistoryWhereInput
    orderBy?: SnapshotHistoryOrderByWithRelationInput | SnapshotHistoryOrderByWithRelationInput[]
    cursor?: SnapshotHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnapshotHistoryScalarFieldEnum | SnapshotHistoryScalarFieldEnum[]
  }

  /**
   * User.createdAiJobs
   */
  export type User$createdAiJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    where?: AiJobsWhereInput
    orderBy?: AiJobsOrderByWithRelationInput | AiJobsOrderByWithRelationInput[]
    cursor?: AiJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiJobsScalarFieldEnum | AiJobsScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.replies
   */
  export type User$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * User.commentAttachments
   */
  export type User$commentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    where?: CommentAttachmentWhereInput
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    cursor?: CommentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentAttachmentScalarFieldEnum | CommentAttachmentScalarFieldEnum[]
  }

  /**
   * User.AccessToken
   */
  export type User$AccessTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    cursor?: AccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ConnectedAccount
   */

  export type AggregateConnectedAccount = {
    _count: ConnectedAccountCountAggregateOutputType | null
    _min: ConnectedAccountMinAggregateOutputType | null
    _max: ConnectedAccountMaxAggregateOutputType | null
  }

  export type ConnectedAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    scope: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectedAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    scope: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConnectedAccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    scope: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConnectedAccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    scope?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectedAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    scope?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConnectedAccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    scope?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConnectedAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectedAccount to aggregate.
     */
    where?: ConnectedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedAccounts to fetch.
     */
    orderBy?: ConnectedAccountOrderByWithRelationInput | ConnectedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectedAccounts
    **/
    _count?: true | ConnectedAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectedAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectedAccountMaxAggregateInputType
  }

  export type GetConnectedAccountAggregateType<T extends ConnectedAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectedAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectedAccount[P]>
      : GetScalarType<T[P], AggregateConnectedAccount[P]>
  }




  export type ConnectedAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectedAccountWhereInput
    orderBy?: ConnectedAccountOrderByWithAggregationInput | ConnectedAccountOrderByWithAggregationInput[]
    by: ConnectedAccountScalarFieldEnum[] | ConnectedAccountScalarFieldEnum
    having?: ConnectedAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectedAccountCountAggregateInputType | true
    _min?: ConnectedAccountMinAggregateInputType
    _max?: ConnectedAccountMaxAggregateInputType
  }

  export type ConnectedAccountGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerAccountId: string
    scope: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ConnectedAccountCountAggregateOutputType | null
    _min: ConnectedAccountMinAggregateOutputType | null
    _max: ConnectedAccountMaxAggregateOutputType | null
  }

  type GetConnectedAccountGroupByPayload<T extends ConnectedAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectedAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectedAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectedAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectedAccountGroupByOutputType[P]>
        }
      >
    >


  export type ConnectedAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    scope?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectedAccount"]>

  export type ConnectedAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    scope?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectedAccount"]>

  export type ConnectedAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    scope?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectedAccount"]>

  export type ConnectedAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    scope?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConnectedAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerAccountId" | "scope" | "accessToken" | "refreshToken" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["connectedAccount"]>
  export type ConnectedAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConnectedAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConnectedAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConnectedAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectedAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerAccountId: string
      scope: string | null
      accessToken: string | null
      refreshToken: string | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["connectedAccount"]>
    composites: {}
  }

  type ConnectedAccountGetPayload<S extends boolean | null | undefined | ConnectedAccountDefaultArgs> = $Result.GetResult<Prisma.$ConnectedAccountPayload, S>

  type ConnectedAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectedAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ConnectedAccountCountAggregateInputType | true
    }

  export interface ConnectedAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectedAccount'], meta: { name: 'ConnectedAccount' } }
    /**
     * Find zero or one ConnectedAccount that matches the filter.
     * @param {ConnectedAccountFindUniqueArgs} args - Arguments to find a ConnectedAccount
     * @example
     * // Get one ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectedAccountFindUniqueArgs>(args: SelectSubset<T, ConnectedAccountFindUniqueArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConnectedAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectedAccountFindUniqueOrThrowArgs} args - Arguments to find a ConnectedAccount
     * @example
     * // Get one ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectedAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectedAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectedAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountFindFirstArgs} args - Arguments to find a ConnectedAccount
     * @example
     * // Get one ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectedAccountFindFirstArgs>(args?: SelectSubset<T, ConnectedAccountFindFirstArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectedAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountFindFirstOrThrowArgs} args - Arguments to find a ConnectedAccount
     * @example
     * // Get one ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectedAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectedAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConnectedAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectedAccounts
     * const connectedAccounts = await prisma.connectedAccount.findMany()
     * 
     * // Get first 10 ConnectedAccounts
     * const connectedAccounts = await prisma.connectedAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectedAccountWithIdOnly = await prisma.connectedAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectedAccountFindManyArgs>(args?: SelectSubset<T, ConnectedAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConnectedAccount.
     * @param {ConnectedAccountCreateArgs} args - Arguments to create a ConnectedAccount.
     * @example
     * // Create one ConnectedAccount
     * const ConnectedAccount = await prisma.connectedAccount.create({
     *   data: {
     *     // ... data to create a ConnectedAccount
     *   }
     * })
     * 
     */
    create<T extends ConnectedAccountCreateArgs>(args: SelectSubset<T, ConnectedAccountCreateArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConnectedAccounts.
     * @param {ConnectedAccountCreateManyArgs} args - Arguments to create many ConnectedAccounts.
     * @example
     * // Create many ConnectedAccounts
     * const connectedAccount = await prisma.connectedAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectedAccountCreateManyArgs>(args?: SelectSubset<T, ConnectedAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectedAccounts and returns the data saved in the database.
     * @param {ConnectedAccountCreateManyAndReturnArgs} args - Arguments to create many ConnectedAccounts.
     * @example
     * // Create many ConnectedAccounts
     * const connectedAccount = await prisma.connectedAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectedAccounts and only return the `id`
     * const connectedAccountWithIdOnly = await prisma.connectedAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectedAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectedAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConnectedAccount.
     * @param {ConnectedAccountDeleteArgs} args - Arguments to delete one ConnectedAccount.
     * @example
     * // Delete one ConnectedAccount
     * const ConnectedAccount = await prisma.connectedAccount.delete({
     *   where: {
     *     // ... filter to delete one ConnectedAccount
     *   }
     * })
     * 
     */
    delete<T extends ConnectedAccountDeleteArgs>(args: SelectSubset<T, ConnectedAccountDeleteArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConnectedAccount.
     * @param {ConnectedAccountUpdateArgs} args - Arguments to update one ConnectedAccount.
     * @example
     * // Update one ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectedAccountUpdateArgs>(args: SelectSubset<T, ConnectedAccountUpdateArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConnectedAccounts.
     * @param {ConnectedAccountDeleteManyArgs} args - Arguments to filter ConnectedAccounts to delete.
     * @example
     * // Delete a few ConnectedAccounts
     * const { count } = await prisma.connectedAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectedAccountDeleteManyArgs>(args?: SelectSubset<T, ConnectedAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectedAccounts
     * const connectedAccount = await prisma.connectedAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectedAccountUpdateManyArgs>(args: SelectSubset<T, ConnectedAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectedAccounts and returns the data updated in the database.
     * @param {ConnectedAccountUpdateManyAndReturnArgs} args - Arguments to update many ConnectedAccounts.
     * @example
     * // Update many ConnectedAccounts
     * const connectedAccount = await prisma.connectedAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConnectedAccounts and only return the `id`
     * const connectedAccountWithIdOnly = await prisma.connectedAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectedAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectedAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConnectedAccount.
     * @param {ConnectedAccountUpsertArgs} args - Arguments to update or create a ConnectedAccount.
     * @example
     * // Update or create a ConnectedAccount
     * const connectedAccount = await prisma.connectedAccount.upsert({
     *   create: {
     *     // ... data to create a ConnectedAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectedAccount we want to update
     *   }
     * })
     */
    upsert<T extends ConnectedAccountUpsertArgs>(args: SelectSubset<T, ConnectedAccountUpsertArgs<ExtArgs>>): Prisma__ConnectedAccountClient<$Result.GetResult<Prisma.$ConnectedAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConnectedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountCountArgs} args - Arguments to filter ConnectedAccounts to count.
     * @example
     * // Count the number of ConnectedAccounts
     * const count = await prisma.connectedAccount.count({
     *   where: {
     *     // ... the filter for the ConnectedAccounts we want to count
     *   }
     * })
    **/
    count<T extends ConnectedAccountCountArgs>(
      args?: Subset<T, ConnectedAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectedAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectedAccountAggregateArgs>(args: Subset<T, ConnectedAccountAggregateArgs>): Prisma.PrismaPromise<GetConnectedAccountAggregateType<T>>

    /**
     * Group by ConnectedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectedAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectedAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectedAccountGroupByArgs['orderBy'] }
        : { orderBy?: ConnectedAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectedAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectedAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectedAccount model
   */
  readonly fields: ConnectedAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectedAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectedAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectedAccount model
   */
  interface ConnectedAccountFieldRefs {
    readonly id: FieldRef<"ConnectedAccount", 'String'>
    readonly userId: FieldRef<"ConnectedAccount", 'String'>
    readonly provider: FieldRef<"ConnectedAccount", 'String'>
    readonly providerAccountId: FieldRef<"ConnectedAccount", 'String'>
    readonly scope: FieldRef<"ConnectedAccount", 'String'>
    readonly accessToken: FieldRef<"ConnectedAccount", 'String'>
    readonly refreshToken: FieldRef<"ConnectedAccount", 'String'>
    readonly expiresAt: FieldRef<"ConnectedAccount", 'DateTime'>
    readonly createdAt: FieldRef<"ConnectedAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"ConnectedAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConnectedAccount findUnique
   */
  export type ConnectedAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedAccount to fetch.
     */
    where: ConnectedAccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount findUniqueOrThrow
   */
  export type ConnectedAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedAccount to fetch.
     */
    where: ConnectedAccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount findFirst
   */
  export type ConnectedAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedAccount to fetch.
     */
    where?: ConnectedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedAccounts to fetch.
     */
    orderBy?: ConnectedAccountOrderByWithRelationInput | ConnectedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectedAccounts.
     */
    cursor?: ConnectedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectedAccounts.
     */
    distinct?: ConnectedAccountScalarFieldEnum | ConnectedAccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount findFirstOrThrow
   */
  export type ConnectedAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedAccount to fetch.
     */
    where?: ConnectedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedAccounts to fetch.
     */
    orderBy?: ConnectedAccountOrderByWithRelationInput | ConnectedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectedAccounts.
     */
    cursor?: ConnectedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectedAccounts.
     */
    distinct?: ConnectedAccountScalarFieldEnum | ConnectedAccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount findMany
   */
  export type ConnectedAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter, which ConnectedAccounts to fetch.
     */
    where?: ConnectedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectedAccounts to fetch.
     */
    orderBy?: ConnectedAccountOrderByWithRelationInput | ConnectedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectedAccounts.
     */
    cursor?: ConnectedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectedAccounts.
     */
    skip?: number
    distinct?: ConnectedAccountScalarFieldEnum | ConnectedAccountScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount create
   */
  export type ConnectedAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectedAccount.
     */
    data: XOR<ConnectedAccountCreateInput, ConnectedAccountUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount createMany
   */
  export type ConnectedAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectedAccounts.
     */
    data: ConnectedAccountCreateManyInput | ConnectedAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConnectedAccount createManyAndReturn
   */
  export type ConnectedAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * The data used to create many ConnectedAccounts.
     */
    data: ConnectedAccountCreateManyInput | ConnectedAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectedAccount update
   */
  export type ConnectedAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectedAccount.
     */
    data: XOR<ConnectedAccountUpdateInput, ConnectedAccountUncheckedUpdateInput>
    /**
     * Choose, which ConnectedAccount to update.
     */
    where: ConnectedAccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount updateMany
   */
  export type ConnectedAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectedAccounts.
     */
    data: XOR<ConnectedAccountUpdateManyMutationInput, ConnectedAccountUncheckedUpdateManyInput>
    /**
     * Filter which ConnectedAccounts to update
     */
    where?: ConnectedAccountWhereInput
    /**
     * Limit how many ConnectedAccounts to update.
     */
    limit?: number
  }

  /**
   * ConnectedAccount updateManyAndReturn
   */
  export type ConnectedAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * The data used to update ConnectedAccounts.
     */
    data: XOR<ConnectedAccountUpdateManyMutationInput, ConnectedAccountUncheckedUpdateManyInput>
    /**
     * Filter which ConnectedAccounts to update
     */
    where?: ConnectedAccountWhereInput
    /**
     * Limit how many ConnectedAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectedAccount upsert
   */
  export type ConnectedAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectedAccount to update in case it exists.
     */
    where: ConnectedAccountWhereUniqueInput
    /**
     * In case the ConnectedAccount found by the `where` argument doesn't exist, create a new ConnectedAccount with this data.
     */
    create: XOR<ConnectedAccountCreateInput, ConnectedAccountUncheckedCreateInput>
    /**
     * In case the ConnectedAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectedAccountUpdateInput, ConnectedAccountUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount delete
   */
  export type ConnectedAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
    /**
     * Filter which ConnectedAccount to delete.
     */
    where: ConnectedAccountWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConnectedAccount deleteMany
   */
  export type ConnectedAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectedAccounts to delete
     */
    where?: ConnectedAccountWhereInput
    /**
     * Limit how many ConnectedAccounts to delete.
     */
    limit?: number
  }

  /**
   * ConnectedAccount without action
   */
  export type ConnectedAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectedAccount
     */
    select?: ConnectedAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectedAccount
     */
    omit?: ConnectedAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectedAccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    deprecated_expiresAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    deprecated_expiresAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    deprecated_expiresAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    deprecated_expiresAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    deprecated_expiresAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    deprecated_expiresAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    createdAt: Date
    deprecated_expiresAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    deprecated_expiresAt?: boolean
    userSessions?: boolean | Session$userSessionsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    deprecated_expiresAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    deprecated_expiresAt?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    deprecated_expiresAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "deprecated_expiresAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userSessions?: boolean | Session$userSessionsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      deprecated_expiresAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userSessions<T extends Session$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Session$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly deprecated_expiresAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data?: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.userSessions
   */
  export type Session$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    expiresAt: Date | null
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly sessionId: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _avg: VerificationTokenAvgAggregateOutputType | null
    _sum: VerificationTokenSumAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenAvgAggregateOutputType = {
    type: number | null
  }

  export type VerificationTokenSumAggregateOutputType = {
    type: number | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    token: string | null
    type: number | null
    credential: string | null
    expiresAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    token: string | null
    type: number | null
    credential: string | null
    expiresAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    token: number
    type: number
    credential: number
    expiresAt: number
    _all: number
  }


  export type VerificationTokenAvgAggregateInputType = {
    type?: true
  }

  export type VerificationTokenSumAggregateInputType = {
    type?: true
  }

  export type VerificationTokenMinAggregateInputType = {
    token?: true
    type?: true
    credential?: true
    expiresAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    token?: true
    type?: true
    credential?: true
    expiresAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    token?: true
    type?: true
    credential?: true
    expiresAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _avg?: VerificationTokenAvgAggregateInputType
    _sum?: VerificationTokenSumAggregateInputType
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    token: string
    type: number
    credential: string | null
    expiresAt: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _avg: VerificationTokenAvgAggregateOutputType | null
    _sum: VerificationTokenSumAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    type?: boolean
    credential?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    type?: boolean
    credential?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    type?: boolean
    credential?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    token?: boolean
    type?: boolean
    credential?: boolean
    expiresAt?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"token" | "type" | "credential" | "expiresAt", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      token: string
      type: number
      credential: string | null
      expiresAt: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const verificationTokenWithTokenOnly = await prisma.verificationToken.findMany({ select: { token: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `token`
     * const verificationTokenWithTokenOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { token: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `token`
     * const verificationTokenWithTokenOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { token: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly type: FieldRef<"VerificationToken", 'Int'>
    readonly credential: FieldRef<"VerificationToken", 'String'>
    readonly expiresAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _avg: WorkspaceAvgAggregateOutputType | null
    _sum: WorkspaceSumAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceAvgAggregateOutputType = {
    sid: number | null
  }

  export type WorkspaceSumAggregateOutputType = {
    sid: number | null
  }

  export type WorkspaceMinAggregateOutputType = {
    sid: number | null
    id: string | null
    public: boolean | null
    createdAt: Date | null
    enableAi: boolean | null
    enableUrlPreview: boolean | null
    enableDocEmbedding: boolean | null
    name: string | null
    avatarKey: string | null
    indexed: boolean | null
    lastCheckEmbeddings: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    sid: number | null
    id: string | null
    public: boolean | null
    createdAt: Date | null
    enableAi: boolean | null
    enableUrlPreview: boolean | null
    enableDocEmbedding: boolean | null
    name: string | null
    avatarKey: string | null
    indexed: boolean | null
    lastCheckEmbeddings: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    sid: number
    id: number
    public: number
    createdAt: number
    enableAi: number
    enableUrlPreview: number
    enableDocEmbedding: number
    name: number
    avatarKey: number
    indexed: number
    lastCheckEmbeddings: number
    _all: number
  }


  export type WorkspaceAvgAggregateInputType = {
    sid?: true
  }

  export type WorkspaceSumAggregateInputType = {
    sid?: true
  }

  export type WorkspaceMinAggregateInputType = {
    sid?: true
    id?: true
    public?: true
    createdAt?: true
    enableAi?: true
    enableUrlPreview?: true
    enableDocEmbedding?: true
    name?: true
    avatarKey?: true
    indexed?: true
    lastCheckEmbeddings?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    sid?: true
    id?: true
    public?: true
    createdAt?: true
    enableAi?: true
    enableUrlPreview?: true
    enableDocEmbedding?: true
    name?: true
    avatarKey?: true
    indexed?: true
    lastCheckEmbeddings?: true
  }

  export type WorkspaceCountAggregateInputType = {
    sid?: true
    id?: true
    public?: true
    createdAt?: true
    enableAi?: true
    enableUrlPreview?: true
    enableDocEmbedding?: true
    name?: true
    avatarKey?: true
    indexed?: true
    lastCheckEmbeddings?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _avg?: WorkspaceAvgAggregateInputType
    _sum?: WorkspaceSumAggregateInputType
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    sid: number
    id: string
    public: boolean
    createdAt: Date
    enableAi: boolean
    enableUrlPreview: boolean
    enableDocEmbedding: boolean
    name: string | null
    avatarKey: string | null
    indexed: boolean
    lastCheckEmbeddings: Date
    _count: WorkspaceCountAggregateOutputType | null
    _avg: WorkspaceAvgAggregateOutputType | null
    _sum: WorkspaceSumAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    public?: boolean
    createdAt?: boolean
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: boolean
    avatarKey?: boolean
    indexed?: boolean
    lastCheckEmbeddings?: boolean
    features?: boolean | Workspace$featuresArgs<ExtArgs>
    docs?: boolean | Workspace$docsArgs<ExtArgs>
    permissions?: boolean | Workspace$permissionsArgs<ExtArgs>
    docPermissions?: boolean | Workspace$docPermissionsArgs<ExtArgs>
    blobs?: boolean | Workspace$blobsArgs<ExtArgs>
    ignoredDocs?: boolean | Workspace$ignoredDocsArgs<ExtArgs>
    embedFiles?: boolean | Workspace$embedFilesArgs<ExtArgs>
    comments?: boolean | Workspace$commentsArgs<ExtArgs>
    commentAttachments?: boolean | Workspace$commentAttachmentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    public?: boolean
    createdAt?: boolean
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: boolean
    avatarKey?: boolean
    indexed?: boolean
    lastCheckEmbeddings?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    public?: boolean
    createdAt?: boolean
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: boolean
    avatarKey?: boolean
    indexed?: boolean
    lastCheckEmbeddings?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    sid?: boolean
    id?: boolean
    public?: boolean
    createdAt?: boolean
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: boolean
    avatarKey?: boolean
    indexed?: boolean
    lastCheckEmbeddings?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sid" | "id" | "public" | "createdAt" | "enableAi" | "enableUrlPreview" | "enableDocEmbedding" | "name" | "avatarKey" | "indexed" | "lastCheckEmbeddings", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Workspace$featuresArgs<ExtArgs>
    docs?: boolean | Workspace$docsArgs<ExtArgs>
    permissions?: boolean | Workspace$permissionsArgs<ExtArgs>
    docPermissions?: boolean | Workspace$docPermissionsArgs<ExtArgs>
    blobs?: boolean | Workspace$blobsArgs<ExtArgs>
    ignoredDocs?: boolean | Workspace$ignoredDocsArgs<ExtArgs>
    embedFiles?: boolean | Workspace$embedFilesArgs<ExtArgs>
    comments?: boolean | Workspace$commentsArgs<ExtArgs>
    commentAttachments?: boolean | Workspace$commentAttachmentsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      features: Prisma.$WorkspaceFeaturePayload<ExtArgs>[]
      docs: Prisma.$WorkspaceDocPayload<ExtArgs>[]
      permissions: Prisma.$WorkspaceUserRolePayload<ExtArgs>[]
      docPermissions: Prisma.$WorkspaceDocUserRolePayload<ExtArgs>[]
      blobs: Prisma.$BlobPayload<ExtArgs>[]
      ignoredDocs: Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>[]
      embedFiles: Prisma.$AiWorkspaceFilesPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      commentAttachments: Prisma.$CommentAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sid: number
      id: string
      public: boolean
      createdAt: Date
      enableAi: boolean
      enableUrlPreview: boolean
      enableDocEmbedding: boolean
      name: string | null
      avatarKey: string | null
      indexed: boolean
      lastCheckEmbeddings: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const workspaceWithSidOnly = await prisma.workspace.findMany({ select: { sid: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `sid`
     * const workspaceWithSidOnly = await prisma.workspace.createManyAndReturn({
     *   select: { sid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `sid`
     * const workspaceWithSidOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { sid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Workspace$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    docs<T extends Workspace$docsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$docsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Workspace$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    docPermissions<T extends Workspace$docPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$docPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blobs<T extends Workspace$blobsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$blobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ignoredDocs<T extends Workspace$ignoredDocsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$ignoredDocsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    embedFiles<T extends Workspace$embedFilesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$embedFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Workspace$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentAttachments<T extends Workspace$commentAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$commentAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly sid: FieldRef<"Workspace", 'Int'>
    readonly id: FieldRef<"Workspace", 'String'>
    readonly public: FieldRef<"Workspace", 'Boolean'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly enableAi: FieldRef<"Workspace", 'Boolean'>
    readonly enableUrlPreview: FieldRef<"Workspace", 'Boolean'>
    readonly enableDocEmbedding: FieldRef<"Workspace", 'Boolean'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly avatarKey: FieldRef<"Workspace", 'String'>
    readonly indexed: FieldRef<"Workspace", 'Boolean'>
    readonly lastCheckEmbeddings: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.features
   */
  export type Workspace$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    where?: WorkspaceFeatureWhereInput
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    cursor?: WorkspaceFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceFeatureScalarFieldEnum | WorkspaceFeatureScalarFieldEnum[]
  }

  /**
   * Workspace.docs
   */
  export type Workspace$docsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    where?: WorkspaceDocWhereInput
    orderBy?: WorkspaceDocOrderByWithRelationInput | WorkspaceDocOrderByWithRelationInput[]
    cursor?: WorkspaceDocWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceDocScalarFieldEnum | WorkspaceDocScalarFieldEnum[]
  }

  /**
   * Workspace.permissions
   */
  export type Workspace$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    where?: WorkspaceUserRoleWhereInput
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    cursor?: WorkspaceUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
  }

  /**
   * Workspace.docPermissions
   */
  export type Workspace$docPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    where?: WorkspaceDocUserRoleWhereInput
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceDocUserRoleScalarFieldEnum | WorkspaceDocUserRoleScalarFieldEnum[]
  }

  /**
   * Workspace.blobs
   */
  export type Workspace$blobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    where?: BlobWhereInput
    orderBy?: BlobOrderByWithRelationInput | BlobOrderByWithRelationInput[]
    cursor?: BlobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlobScalarFieldEnum | BlobScalarFieldEnum[]
  }

  /**
   * Workspace.ignoredDocs
   */
  export type Workspace$ignoredDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    where?: AiWorkspaceIgnoredDocsWhereInput
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithRelationInput | AiWorkspaceIgnoredDocsOrderByWithRelationInput[]
    cursor?: AiWorkspaceIgnoredDocsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiWorkspaceIgnoredDocsScalarFieldEnum | AiWorkspaceIgnoredDocsScalarFieldEnum[]
  }

  /**
   * Workspace.embedFiles
   */
  export type Workspace$embedFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    where?: AiWorkspaceFilesWhereInput
    orderBy?: AiWorkspaceFilesOrderByWithRelationInput | AiWorkspaceFilesOrderByWithRelationInput[]
    cursor?: AiWorkspaceFilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiWorkspaceFilesScalarFieldEnum | AiWorkspaceFilesScalarFieldEnum[]
  }

  /**
   * Workspace.comments
   */
  export type Workspace$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Workspace.commentAttachments
   */
  export type Workspace$commentAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    where?: CommentAttachmentWhereInput
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    cursor?: CommentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentAttachmentScalarFieldEnum | CommentAttachmentScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceDoc
   */

  export type AggregateWorkspaceDoc = {
    _count: WorkspaceDocCountAggregateOutputType | null
    _avg: WorkspaceDocAvgAggregateOutputType | null
    _sum: WorkspaceDocSumAggregateOutputType | null
    _min: WorkspaceDocMinAggregateOutputType | null
    _max: WorkspaceDocMaxAggregateOutputType | null
  }

  export type WorkspaceDocAvgAggregateOutputType = {
    defaultRole: number | null
    mode: number | null
  }

  export type WorkspaceDocSumAggregateOutputType = {
    defaultRole: number | null
    mode: number | null
  }

  export type WorkspaceDocMinAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    public: boolean | null
    defaultRole: number | null
    mode: number | null
    blocked: boolean | null
    title: string | null
    summary: string | null
  }

  export type WorkspaceDocMaxAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    public: boolean | null
    defaultRole: number | null
    mode: number | null
    blocked: boolean | null
    title: string | null
    summary: string | null
  }

  export type WorkspaceDocCountAggregateOutputType = {
    workspaceId: number
    docId: number
    public: number
    defaultRole: number
    mode: number
    blocked: number
    title: number
    summary: number
    _all: number
  }


  export type WorkspaceDocAvgAggregateInputType = {
    defaultRole?: true
    mode?: true
  }

  export type WorkspaceDocSumAggregateInputType = {
    defaultRole?: true
    mode?: true
  }

  export type WorkspaceDocMinAggregateInputType = {
    workspaceId?: true
    docId?: true
    public?: true
    defaultRole?: true
    mode?: true
    blocked?: true
    title?: true
    summary?: true
  }

  export type WorkspaceDocMaxAggregateInputType = {
    workspaceId?: true
    docId?: true
    public?: true
    defaultRole?: true
    mode?: true
    blocked?: true
    title?: true
    summary?: true
  }

  export type WorkspaceDocCountAggregateInputType = {
    workspaceId?: true
    docId?: true
    public?: true
    defaultRole?: true
    mode?: true
    blocked?: true
    title?: true
    summary?: true
    _all?: true
  }

  export type WorkspaceDocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceDoc to aggregate.
     */
    where?: WorkspaceDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocs to fetch.
     */
    orderBy?: WorkspaceDocOrderByWithRelationInput | WorkspaceDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceDocs
    **/
    _count?: true | WorkspaceDocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceDocAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceDocSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceDocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceDocMaxAggregateInputType
  }

  export type GetWorkspaceDocAggregateType<T extends WorkspaceDocAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceDoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceDoc[P]>
      : GetScalarType<T[P], AggregateWorkspaceDoc[P]>
  }




  export type WorkspaceDocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceDocWhereInput
    orderBy?: WorkspaceDocOrderByWithAggregationInput | WorkspaceDocOrderByWithAggregationInput[]
    by: WorkspaceDocScalarFieldEnum[] | WorkspaceDocScalarFieldEnum
    having?: WorkspaceDocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceDocCountAggregateInputType | true
    _avg?: WorkspaceDocAvgAggregateInputType
    _sum?: WorkspaceDocSumAggregateInputType
    _min?: WorkspaceDocMinAggregateInputType
    _max?: WorkspaceDocMaxAggregateInputType
  }

  export type WorkspaceDocGroupByOutputType = {
    workspaceId: string
    docId: string
    public: boolean
    defaultRole: number
    mode: number
    blocked: boolean
    title: string | null
    summary: string | null
    _count: WorkspaceDocCountAggregateOutputType | null
    _avg: WorkspaceDocAvgAggregateOutputType | null
    _sum: WorkspaceDocSumAggregateOutputType | null
    _min: WorkspaceDocMinAggregateOutputType | null
    _max: WorkspaceDocMaxAggregateOutputType | null
  }

  type GetWorkspaceDocGroupByPayload<T extends WorkspaceDocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceDocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceDocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceDocGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceDocGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceDocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    public?: boolean
    defaultRole?: boolean
    mode?: boolean
    blocked?: boolean
    title?: boolean
    summary?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDoc"]>

  export type WorkspaceDocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    public?: boolean
    defaultRole?: boolean
    mode?: boolean
    blocked?: boolean
    title?: boolean
    summary?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDoc"]>

  export type WorkspaceDocSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    public?: boolean
    defaultRole?: boolean
    mode?: boolean
    blocked?: boolean
    title?: boolean
    summary?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDoc"]>

  export type WorkspaceDocSelectScalar = {
    workspaceId?: boolean
    docId?: boolean
    public?: boolean
    defaultRole?: boolean
    mode?: boolean
    blocked?: boolean
    title?: boolean
    summary?: boolean
  }

  export type WorkspaceDocOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "docId" | "public" | "defaultRole" | "mode" | "blocked" | "title" | "summary", ExtArgs["result"]["workspaceDoc"]>
  export type WorkspaceDocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceDocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceDocIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceDocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceDoc"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      docId: string
      public: boolean
      defaultRole: number
      mode: number
      blocked: boolean
      title: string | null
      summary: string | null
    }, ExtArgs["result"]["workspaceDoc"]>
    composites: {}
  }

  type WorkspaceDocGetPayload<S extends boolean | null | undefined | WorkspaceDocDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceDocPayload, S>

  type WorkspaceDocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceDocFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WorkspaceDocCountAggregateInputType | true
    }

  export interface WorkspaceDocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceDoc'], meta: { name: 'WorkspaceDoc' } }
    /**
     * Find zero or one WorkspaceDoc that matches the filter.
     * @param {WorkspaceDocFindUniqueArgs} args - Arguments to find a WorkspaceDoc
     * @example
     * // Get one WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceDocFindUniqueArgs>(args: SelectSubset<T, WorkspaceDocFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceDoc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceDocFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceDoc
     * @example
     * // Get one WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceDocFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceDocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceDoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocFindFirstArgs} args - Arguments to find a WorkspaceDoc
     * @example
     * // Get one WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceDocFindFirstArgs>(args?: SelectSubset<T, WorkspaceDocFindFirstArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceDoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocFindFirstOrThrowArgs} args - Arguments to find a WorkspaceDoc
     * @example
     * // Get one WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceDocFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceDocFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceDocs
     * const workspaceDocs = await prisma.workspaceDoc.findMany()
     * 
     * // Get first 10 WorkspaceDocs
     * const workspaceDocs = await prisma.workspaceDoc.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const workspaceDocWithWorkspaceIdOnly = await prisma.workspaceDoc.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends WorkspaceDocFindManyArgs>(args?: SelectSubset<T, WorkspaceDocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceDoc.
     * @param {WorkspaceDocCreateArgs} args - Arguments to create a WorkspaceDoc.
     * @example
     * // Create one WorkspaceDoc
     * const WorkspaceDoc = await prisma.workspaceDoc.create({
     *   data: {
     *     // ... data to create a WorkspaceDoc
     *   }
     * })
     * 
     */
    create<T extends WorkspaceDocCreateArgs>(args: SelectSubset<T, WorkspaceDocCreateArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceDocs.
     * @param {WorkspaceDocCreateManyArgs} args - Arguments to create many WorkspaceDocs.
     * @example
     * // Create many WorkspaceDocs
     * const workspaceDoc = await prisma.workspaceDoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceDocCreateManyArgs>(args?: SelectSubset<T, WorkspaceDocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceDocs and returns the data saved in the database.
     * @param {WorkspaceDocCreateManyAndReturnArgs} args - Arguments to create many WorkspaceDocs.
     * @example
     * // Create many WorkspaceDocs
     * const workspaceDoc = await prisma.workspaceDoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceDocs and only return the `workspaceId`
     * const workspaceDocWithWorkspaceIdOnly = await prisma.workspaceDoc.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceDocCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceDocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceDoc.
     * @param {WorkspaceDocDeleteArgs} args - Arguments to delete one WorkspaceDoc.
     * @example
     * // Delete one WorkspaceDoc
     * const WorkspaceDoc = await prisma.workspaceDoc.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceDoc
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDocDeleteArgs>(args: SelectSubset<T, WorkspaceDocDeleteArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceDoc.
     * @param {WorkspaceDocUpdateArgs} args - Arguments to update one WorkspaceDoc.
     * @example
     * // Update one WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceDocUpdateArgs>(args: SelectSubset<T, WorkspaceDocUpdateArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceDocs.
     * @param {WorkspaceDocDeleteManyArgs} args - Arguments to filter WorkspaceDocs to delete.
     * @example
     * // Delete a few WorkspaceDocs
     * const { count } = await prisma.workspaceDoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDocDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceDocs
     * const workspaceDoc = await prisma.workspaceDoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceDocUpdateManyArgs>(args: SelectSubset<T, WorkspaceDocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceDocs and returns the data updated in the database.
     * @param {WorkspaceDocUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceDocs.
     * @example
     * // Update many WorkspaceDocs
     * const workspaceDoc = await prisma.workspaceDoc.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceDocs and only return the `workspaceId`
     * const workspaceDocWithWorkspaceIdOnly = await prisma.workspaceDoc.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceDocUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceDocUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceDoc.
     * @param {WorkspaceDocUpsertArgs} args - Arguments to update or create a WorkspaceDoc.
     * @example
     * // Update or create a WorkspaceDoc
     * const workspaceDoc = await prisma.workspaceDoc.upsert({
     *   create: {
     *     // ... data to create a WorkspaceDoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceDoc we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceDocUpsertArgs>(args: SelectSubset<T, WorkspaceDocUpsertArgs<ExtArgs>>): Prisma__WorkspaceDocClient<$Result.GetResult<Prisma.$WorkspaceDocPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocCountArgs} args - Arguments to filter WorkspaceDocs to count.
     * @example
     * // Count the number of WorkspaceDocs
     * const count = await prisma.workspaceDoc.count({
     *   where: {
     *     // ... the filter for the WorkspaceDocs we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceDocCountArgs>(
      args?: Subset<T, WorkspaceDocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceDocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceDocAggregateArgs>(args: Subset<T, WorkspaceDocAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceDocAggregateType<T>>

    /**
     * Group by WorkspaceDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceDocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceDocGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceDocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceDocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceDocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceDoc model
   */
  readonly fields: WorkspaceDocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceDoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceDocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceDoc model
   */
  interface WorkspaceDocFieldRefs {
    readonly workspaceId: FieldRef<"WorkspaceDoc", 'String'>
    readonly docId: FieldRef<"WorkspaceDoc", 'String'>
    readonly public: FieldRef<"WorkspaceDoc", 'Boolean'>
    readonly defaultRole: FieldRef<"WorkspaceDoc", 'Int'>
    readonly mode: FieldRef<"WorkspaceDoc", 'Int'>
    readonly blocked: FieldRef<"WorkspaceDoc", 'Boolean'>
    readonly title: FieldRef<"WorkspaceDoc", 'String'>
    readonly summary: FieldRef<"WorkspaceDoc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceDoc findUnique
   */
  export type WorkspaceDocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDoc to fetch.
     */
    where: WorkspaceDocWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc findUniqueOrThrow
   */
  export type WorkspaceDocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDoc to fetch.
     */
    where: WorkspaceDocWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc findFirst
   */
  export type WorkspaceDocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDoc to fetch.
     */
    where?: WorkspaceDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocs to fetch.
     */
    orderBy?: WorkspaceDocOrderByWithRelationInput | WorkspaceDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceDocs.
     */
    cursor?: WorkspaceDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceDocs.
     */
    distinct?: WorkspaceDocScalarFieldEnum | WorkspaceDocScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc findFirstOrThrow
   */
  export type WorkspaceDocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDoc to fetch.
     */
    where?: WorkspaceDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocs to fetch.
     */
    orderBy?: WorkspaceDocOrderByWithRelationInput | WorkspaceDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceDocs.
     */
    cursor?: WorkspaceDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceDocs.
     */
    distinct?: WorkspaceDocScalarFieldEnum | WorkspaceDocScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc findMany
   */
  export type WorkspaceDocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocs to fetch.
     */
    where?: WorkspaceDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocs to fetch.
     */
    orderBy?: WorkspaceDocOrderByWithRelationInput | WorkspaceDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceDocs.
     */
    cursor?: WorkspaceDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocs.
     */
    skip?: number
    distinct?: WorkspaceDocScalarFieldEnum | WorkspaceDocScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc create
   */
  export type WorkspaceDocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceDoc.
     */
    data: XOR<WorkspaceDocCreateInput, WorkspaceDocUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc createMany
   */
  export type WorkspaceDocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceDocs.
     */
    data: WorkspaceDocCreateManyInput | WorkspaceDocCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceDoc createManyAndReturn
   */
  export type WorkspaceDocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceDocs.
     */
    data: WorkspaceDocCreateManyInput | WorkspaceDocCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceDoc update
   */
  export type WorkspaceDocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceDoc.
     */
    data: XOR<WorkspaceDocUpdateInput, WorkspaceDocUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceDoc to update.
     */
    where: WorkspaceDocWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc updateMany
   */
  export type WorkspaceDocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceDocs.
     */
    data: XOR<WorkspaceDocUpdateManyMutationInput, WorkspaceDocUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceDocs to update
     */
    where?: WorkspaceDocWhereInput
    /**
     * Limit how many WorkspaceDocs to update.
     */
    limit?: number
  }

  /**
   * WorkspaceDoc updateManyAndReturn
   */
  export type WorkspaceDocUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceDocs.
     */
    data: XOR<WorkspaceDocUpdateManyMutationInput, WorkspaceDocUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceDocs to update
     */
    where?: WorkspaceDocWhereInput
    /**
     * Limit how many WorkspaceDocs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceDoc upsert
   */
  export type WorkspaceDocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceDoc to update in case it exists.
     */
    where: WorkspaceDocWhereUniqueInput
    /**
     * In case the WorkspaceDoc found by the `where` argument doesn't exist, create a new WorkspaceDoc with this data.
     */
    create: XOR<WorkspaceDocCreateInput, WorkspaceDocUncheckedCreateInput>
    /**
     * In case the WorkspaceDoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceDocUpdateInput, WorkspaceDocUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc delete
   */
  export type WorkspaceDocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceDoc to delete.
     */
    where: WorkspaceDocWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDoc deleteMany
   */
  export type WorkspaceDocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceDocs to delete
     */
    where?: WorkspaceDocWhereInput
    /**
     * Limit how many WorkspaceDocs to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceDoc without action
   */
  export type WorkspaceDocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDoc
     */
    select?: WorkspaceDocSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDoc
     */
    omit?: WorkspaceDocOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceUserRole
   */

  export type AggregateWorkspaceUserRole = {
    _count: WorkspaceUserRoleCountAggregateOutputType | null
    _avg: WorkspaceUserRoleAvgAggregateOutputType | null
    _sum: WorkspaceUserRoleSumAggregateOutputType | null
    _min: WorkspaceUserRoleMinAggregateOutputType | null
    _max: WorkspaceUserRoleMaxAggregateOutputType | null
  }

  export type WorkspaceUserRoleAvgAggregateOutputType = {
    type: number | null
  }

  export type WorkspaceUserRoleSumAggregateOutputType = {
    type: number | null
  }

  export type WorkspaceUserRoleMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    type: number | null
    status: $Enums.WorkspaceMemberStatus | null
    source: $Enums.WorkspaceMemberSource | null
    inviterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accepted: boolean | null
  }

  export type WorkspaceUserRoleMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    type: number | null
    status: $Enums.WorkspaceMemberStatus | null
    source: $Enums.WorkspaceMemberSource | null
    inviterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accepted: boolean | null
  }

  export type WorkspaceUserRoleCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    type: number
    status: number
    source: number
    inviterId: number
    createdAt: number
    updatedAt: number
    accepted: number
    _all: number
  }


  export type WorkspaceUserRoleAvgAggregateInputType = {
    type?: true
  }

  export type WorkspaceUserRoleSumAggregateInputType = {
    type?: true
  }

  export type WorkspaceUserRoleMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    status?: true
    source?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
    accepted?: true
  }

  export type WorkspaceUserRoleMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    status?: true
    source?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
    accepted?: true
  }

  export type WorkspaceUserRoleCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    type?: true
    status?: true
    source?: true
    inviterId?: true
    createdAt?: true
    updatedAt?: true
    accepted?: true
    _all?: true
  }

  export type WorkspaceUserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUserRole to aggregate.
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserRoles to fetch.
     */
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceUserRoles
    **/
    _count?: true | WorkspaceUserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceUserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceUserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceUserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceUserRoleMaxAggregateInputType
  }

  export type GetWorkspaceUserRoleAggregateType<T extends WorkspaceUserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceUserRole[P]>
      : GetScalarType<T[P], AggregateWorkspaceUserRole[P]>
  }




  export type WorkspaceUserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceUserRoleWhereInput
    orderBy?: WorkspaceUserRoleOrderByWithAggregationInput | WorkspaceUserRoleOrderByWithAggregationInput[]
    by: WorkspaceUserRoleScalarFieldEnum[] | WorkspaceUserRoleScalarFieldEnum
    having?: WorkspaceUserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceUserRoleCountAggregateInputType | true
    _avg?: WorkspaceUserRoleAvgAggregateInputType
    _sum?: WorkspaceUserRoleSumAggregateInputType
    _min?: WorkspaceUserRoleMinAggregateInputType
    _max?: WorkspaceUserRoleMaxAggregateInputType
  }

  export type WorkspaceUserRoleGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    type: number
    status: $Enums.WorkspaceMemberStatus
    source: $Enums.WorkspaceMemberSource
    inviterId: string | null
    createdAt: Date
    updatedAt: Date
    accepted: boolean
    _count: WorkspaceUserRoleCountAggregateOutputType | null
    _avg: WorkspaceUserRoleAvgAggregateOutputType | null
    _sum: WorkspaceUserRoleSumAggregateOutputType | null
    _min: WorkspaceUserRoleMinAggregateOutputType | null
    _max: WorkspaceUserRoleMaxAggregateOutputType | null
  }

  type GetWorkspaceUserRoleGroupByPayload<T extends WorkspaceUserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceUserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceUserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceUserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceUserRoleGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceUserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accepted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUserRole"]>

  export type WorkspaceUserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accepted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUserRole"]>

  export type WorkspaceUserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accepted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceUserRole"]>

  export type WorkspaceUserRoleSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    inviterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accepted?: boolean
  }

  export type WorkspaceUserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "userId" | "type" | "status" | "source" | "inviterId" | "createdAt" | "updatedAt" | "accepted", ExtArgs["result"]["workspaceUserRole"]>
  export type WorkspaceUserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }
  export type WorkspaceUserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }
  export type WorkspaceUserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | WorkspaceUserRole$inviterArgs<ExtArgs>
  }

  export type $WorkspaceUserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceUserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      type: number
      /**
       * the invite status of the workspace member
       */
      status: $Enums.WorkspaceMemberStatus
      source: $Enums.WorkspaceMemberSource
      inviterId: string | null
      createdAt: Date
      updatedAt: Date
      /**
       * @deprecated Whether the permission invitation is accepted by the user, use status instead
       */
      accepted: boolean
    }, ExtArgs["result"]["workspaceUserRole"]>
    composites: {}
  }

  type WorkspaceUserRoleGetPayload<S extends boolean | null | undefined | WorkspaceUserRoleDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceUserRolePayload, S>

  type WorkspaceUserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceUserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WorkspaceUserRoleCountAggregateInputType | true
    }

  export interface WorkspaceUserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceUserRole'], meta: { name: 'WorkspaceUserRole' } }
    /**
     * Find zero or one WorkspaceUserRole that matches the filter.
     * @param {WorkspaceUserRoleFindUniqueArgs} args - Arguments to find a WorkspaceUserRole
     * @example
     * // Get one WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceUserRoleFindUniqueArgs>(args: SelectSubset<T, WorkspaceUserRoleFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceUserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceUserRoleFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceUserRole
     * @example
     * // Get one WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceUserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceUserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleFindFirstArgs} args - Arguments to find a WorkspaceUserRole
     * @example
     * // Get one WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceUserRoleFindFirstArgs>(args?: SelectSubset<T, WorkspaceUserRoleFindFirstArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceUserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleFindFirstOrThrowArgs} args - Arguments to find a WorkspaceUserRole
     * @example
     * // Get one WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceUserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceUserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceUserRoles
     * const workspaceUserRoles = await prisma.workspaceUserRole.findMany()
     * 
     * // Get first 10 WorkspaceUserRoles
     * const workspaceUserRoles = await prisma.workspaceUserRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceUserRoleWithIdOnly = await prisma.workspaceUserRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceUserRoleFindManyArgs>(args?: SelectSubset<T, WorkspaceUserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceUserRole.
     * @param {WorkspaceUserRoleCreateArgs} args - Arguments to create a WorkspaceUserRole.
     * @example
     * // Create one WorkspaceUserRole
     * const WorkspaceUserRole = await prisma.workspaceUserRole.create({
     *   data: {
     *     // ... data to create a WorkspaceUserRole
     *   }
     * })
     * 
     */
    create<T extends WorkspaceUserRoleCreateArgs>(args: SelectSubset<T, WorkspaceUserRoleCreateArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceUserRoles.
     * @param {WorkspaceUserRoleCreateManyArgs} args - Arguments to create many WorkspaceUserRoles.
     * @example
     * // Create many WorkspaceUserRoles
     * const workspaceUserRole = await prisma.workspaceUserRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceUserRoleCreateManyArgs>(args?: SelectSubset<T, WorkspaceUserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceUserRoles and returns the data saved in the database.
     * @param {WorkspaceUserRoleCreateManyAndReturnArgs} args - Arguments to create many WorkspaceUserRoles.
     * @example
     * // Create many WorkspaceUserRoles
     * const workspaceUserRole = await prisma.workspaceUserRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceUserRoles and only return the `id`
     * const workspaceUserRoleWithIdOnly = await prisma.workspaceUserRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceUserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceUserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceUserRole.
     * @param {WorkspaceUserRoleDeleteArgs} args - Arguments to delete one WorkspaceUserRole.
     * @example
     * // Delete one WorkspaceUserRole
     * const WorkspaceUserRole = await prisma.workspaceUserRole.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceUserRole
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceUserRoleDeleteArgs>(args: SelectSubset<T, WorkspaceUserRoleDeleteArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceUserRole.
     * @param {WorkspaceUserRoleUpdateArgs} args - Arguments to update one WorkspaceUserRole.
     * @example
     * // Update one WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUserRoleUpdateArgs>(args: SelectSubset<T, WorkspaceUserRoleUpdateArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceUserRoles.
     * @param {WorkspaceUserRoleDeleteManyArgs} args - Arguments to filter WorkspaceUserRoles to delete.
     * @example
     * // Delete a few WorkspaceUserRoles
     * const { count } = await prisma.workspaceUserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceUserRoleDeleteManyArgs>(args?: SelectSubset<T, WorkspaceUserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceUserRoles
     * const workspaceUserRole = await prisma.workspaceUserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUserRoleUpdateManyArgs>(args: SelectSubset<T, WorkspaceUserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceUserRoles and returns the data updated in the database.
     * @param {WorkspaceUserRoleUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceUserRoles.
     * @example
     * // Update many WorkspaceUserRoles
     * const workspaceUserRole = await prisma.workspaceUserRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceUserRoles and only return the `id`
     * const workspaceUserRoleWithIdOnly = await prisma.workspaceUserRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceUserRole.
     * @param {WorkspaceUserRoleUpsertArgs} args - Arguments to update or create a WorkspaceUserRole.
     * @example
     * // Update or create a WorkspaceUserRole
     * const workspaceUserRole = await prisma.workspaceUserRole.upsert({
     *   create: {
     *     // ... data to create a WorkspaceUserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceUserRole we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUserRoleUpsertArgs>(args: SelectSubset<T, WorkspaceUserRoleUpsertArgs<ExtArgs>>): Prisma__WorkspaceUserRoleClient<$Result.GetResult<Prisma.$WorkspaceUserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleCountArgs} args - Arguments to filter WorkspaceUserRoles to count.
     * @example
     * // Count the number of WorkspaceUserRoles
     * const count = await prisma.workspaceUserRole.count({
     *   where: {
     *     // ... the filter for the WorkspaceUserRoles we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceUserRoleCountArgs>(
      args?: Subset<T, WorkspaceUserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceUserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceUserRoleAggregateArgs>(args: Subset<T, WorkspaceUserRoleAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceUserRoleAggregateType<T>>

    /**
     * Group by WorkspaceUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceUserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceUserRoleGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceUserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceUserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceUserRole model
   */
  readonly fields: WorkspaceUserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceUserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceUserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends WorkspaceUserRole$inviterArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceUserRole$inviterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceUserRole model
   */
  interface WorkspaceUserRoleFieldRefs {
    readonly id: FieldRef<"WorkspaceUserRole", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceUserRole", 'String'>
    readonly userId: FieldRef<"WorkspaceUserRole", 'String'>
    readonly type: FieldRef<"WorkspaceUserRole", 'Int'>
    readonly status: FieldRef<"WorkspaceUserRole", 'WorkspaceMemberStatus'>
    readonly source: FieldRef<"WorkspaceUserRole", 'WorkspaceMemberSource'>
    readonly inviterId: FieldRef<"WorkspaceUserRole", 'String'>
    readonly createdAt: FieldRef<"WorkspaceUserRole", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkspaceUserRole", 'DateTime'>
    readonly accepted: FieldRef<"WorkspaceUserRole", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceUserRole findUnique
   */
  export type WorkspaceUserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserRole to fetch.
     */
    where: WorkspaceUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole findUniqueOrThrow
   */
  export type WorkspaceUserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserRole to fetch.
     */
    where: WorkspaceUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole findFirst
   */
  export type WorkspaceUserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserRole to fetch.
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserRoles to fetch.
     */
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUserRoles.
     */
    cursor?: WorkspaceUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUserRoles.
     */
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole findFirstOrThrow
   */
  export type WorkspaceUserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserRole to fetch.
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserRoles to fetch.
     */
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceUserRoles.
     */
    cursor?: WorkspaceUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceUserRoles.
     */
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole findMany
   */
  export type WorkspaceUserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceUserRoles to fetch.
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceUserRoles to fetch.
     */
    orderBy?: WorkspaceUserRoleOrderByWithRelationInput | WorkspaceUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceUserRoles.
     */
    cursor?: WorkspaceUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceUserRoles.
     */
    skip?: number
    distinct?: WorkspaceUserRoleScalarFieldEnum | WorkspaceUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole create
   */
  export type WorkspaceUserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceUserRole.
     */
    data: XOR<WorkspaceUserRoleCreateInput, WorkspaceUserRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole createMany
   */
  export type WorkspaceUserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceUserRoles.
     */
    data: WorkspaceUserRoleCreateManyInput | WorkspaceUserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceUserRole createManyAndReturn
   */
  export type WorkspaceUserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceUserRoles.
     */
    data: WorkspaceUserRoleCreateManyInput | WorkspaceUserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUserRole update
   */
  export type WorkspaceUserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceUserRole.
     */
    data: XOR<WorkspaceUserRoleUpdateInput, WorkspaceUserRoleUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceUserRole to update.
     */
    where: WorkspaceUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole updateMany
   */
  export type WorkspaceUserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceUserRoles.
     */
    data: XOR<WorkspaceUserRoleUpdateManyMutationInput, WorkspaceUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUserRoles to update
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * Limit how many WorkspaceUserRoles to update.
     */
    limit?: number
  }

  /**
   * WorkspaceUserRole updateManyAndReturn
   */
  export type WorkspaceUserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceUserRoles.
     */
    data: XOR<WorkspaceUserRoleUpdateManyMutationInput, WorkspaceUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceUserRoles to update
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * Limit how many WorkspaceUserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceUserRole upsert
   */
  export type WorkspaceUserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceUserRole to update in case it exists.
     */
    where: WorkspaceUserRoleWhereUniqueInput
    /**
     * In case the WorkspaceUserRole found by the `where` argument doesn't exist, create a new WorkspaceUserRole with this data.
     */
    create: XOR<WorkspaceUserRoleCreateInput, WorkspaceUserRoleUncheckedCreateInput>
    /**
     * In case the WorkspaceUserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUserRoleUpdateInput, WorkspaceUserRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole delete
   */
  export type WorkspaceUserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceUserRole to delete.
     */
    where: WorkspaceUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceUserRole deleteMany
   */
  export type WorkspaceUserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceUserRoles to delete
     */
    where?: WorkspaceUserRoleWhereInput
    /**
     * Limit how many WorkspaceUserRoles to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceUserRole.inviter
   */
  export type WorkspaceUserRole$inviterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkspaceUserRole without action
   */
  export type WorkspaceUserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceUserRole
     */
    select?: WorkspaceUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceUserRole
     */
    omit?: WorkspaceUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceUserRoleInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceDocUserRole
   */

  export type AggregateWorkspaceDocUserRole = {
    _count: WorkspaceDocUserRoleCountAggregateOutputType | null
    _avg: WorkspaceDocUserRoleAvgAggregateOutputType | null
    _sum: WorkspaceDocUserRoleSumAggregateOutputType | null
    _min: WorkspaceDocUserRoleMinAggregateOutputType | null
    _max: WorkspaceDocUserRoleMaxAggregateOutputType | null
  }

  export type WorkspaceDocUserRoleAvgAggregateOutputType = {
    type: number | null
  }

  export type WorkspaceDocUserRoleSumAggregateOutputType = {
    type: number | null
  }

  export type WorkspaceDocUserRoleMinAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    userId: string | null
    type: number | null
    createdAt: Date | null
  }

  export type WorkspaceDocUserRoleMaxAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    userId: string | null
    type: number | null
    createdAt: Date | null
  }

  export type WorkspaceDocUserRoleCountAggregateOutputType = {
    workspaceId: number
    docId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type WorkspaceDocUserRoleAvgAggregateInputType = {
    type?: true
  }

  export type WorkspaceDocUserRoleSumAggregateInputType = {
    type?: true
  }

  export type WorkspaceDocUserRoleMinAggregateInputType = {
    workspaceId?: true
    docId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type WorkspaceDocUserRoleMaxAggregateInputType = {
    workspaceId?: true
    docId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type WorkspaceDocUserRoleCountAggregateInputType = {
    workspaceId?: true
    docId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type WorkspaceDocUserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceDocUserRole to aggregate.
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocUserRoles to fetch.
     */
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceDocUserRoles
    **/
    _count?: true | WorkspaceDocUserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceDocUserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceDocUserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceDocUserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceDocUserRoleMaxAggregateInputType
  }

  export type GetWorkspaceDocUserRoleAggregateType<T extends WorkspaceDocUserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceDocUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceDocUserRole[P]>
      : GetScalarType<T[P], AggregateWorkspaceDocUserRole[P]>
  }




  export type WorkspaceDocUserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceDocUserRoleWhereInput
    orderBy?: WorkspaceDocUserRoleOrderByWithAggregationInput | WorkspaceDocUserRoleOrderByWithAggregationInput[]
    by: WorkspaceDocUserRoleScalarFieldEnum[] | WorkspaceDocUserRoleScalarFieldEnum
    having?: WorkspaceDocUserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceDocUserRoleCountAggregateInputType | true
    _avg?: WorkspaceDocUserRoleAvgAggregateInputType
    _sum?: WorkspaceDocUserRoleSumAggregateInputType
    _min?: WorkspaceDocUserRoleMinAggregateInputType
    _max?: WorkspaceDocUserRoleMaxAggregateInputType
  }

  export type WorkspaceDocUserRoleGroupByOutputType = {
    workspaceId: string
    docId: string
    userId: string
    type: number
    createdAt: Date
    _count: WorkspaceDocUserRoleCountAggregateOutputType | null
    _avg: WorkspaceDocUserRoleAvgAggregateOutputType | null
    _sum: WorkspaceDocUserRoleSumAggregateOutputType | null
    _min: WorkspaceDocUserRoleMinAggregateOutputType | null
    _max: WorkspaceDocUserRoleMaxAggregateOutputType | null
  }

  type GetWorkspaceDocUserRoleGroupByPayload<T extends WorkspaceDocUserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceDocUserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceDocUserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceDocUserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceDocUserRoleGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceDocUserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDocUserRole"]>

  export type WorkspaceDocUserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDocUserRole"]>

  export type WorkspaceDocUserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceDocUserRole"]>

  export type WorkspaceDocUserRoleSelectScalar = {
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type WorkspaceDocUserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "docId" | "userId" | "type" | "createdAt", ExtArgs["result"]["workspaceDocUserRole"]>
  export type WorkspaceDocUserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceDocUserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceDocUserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceDocUserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceDocUserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      docId: string
      userId: string
      type: number
      createdAt: Date
    }, ExtArgs["result"]["workspaceDocUserRole"]>
    composites: {}
  }

  type WorkspaceDocUserRoleGetPayload<S extends boolean | null | undefined | WorkspaceDocUserRoleDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceDocUserRolePayload, S>

  type WorkspaceDocUserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceDocUserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WorkspaceDocUserRoleCountAggregateInputType | true
    }

  export interface WorkspaceDocUserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceDocUserRole'], meta: { name: 'WorkspaceDocUserRole' } }
    /**
     * Find zero or one WorkspaceDocUserRole that matches the filter.
     * @param {WorkspaceDocUserRoleFindUniqueArgs} args - Arguments to find a WorkspaceDocUserRole
     * @example
     * // Get one WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceDocUserRoleFindUniqueArgs>(args: SelectSubset<T, WorkspaceDocUserRoleFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceDocUserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceDocUserRoleFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceDocUserRole
     * @example
     * // Get one WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceDocUserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceDocUserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceDocUserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleFindFirstArgs} args - Arguments to find a WorkspaceDocUserRole
     * @example
     * // Get one WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceDocUserRoleFindFirstArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleFindFirstArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceDocUserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleFindFirstOrThrowArgs} args - Arguments to find a WorkspaceDocUserRole
     * @example
     * // Get one WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceDocUserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceDocUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceDocUserRoles
     * const workspaceDocUserRoles = await prisma.workspaceDocUserRole.findMany()
     * 
     * // Get first 10 WorkspaceDocUserRoles
     * const workspaceDocUserRoles = await prisma.workspaceDocUserRole.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const workspaceDocUserRoleWithWorkspaceIdOnly = await prisma.workspaceDocUserRole.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends WorkspaceDocUserRoleFindManyArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceDocUserRole.
     * @param {WorkspaceDocUserRoleCreateArgs} args - Arguments to create a WorkspaceDocUserRole.
     * @example
     * // Create one WorkspaceDocUserRole
     * const WorkspaceDocUserRole = await prisma.workspaceDocUserRole.create({
     *   data: {
     *     // ... data to create a WorkspaceDocUserRole
     *   }
     * })
     * 
     */
    create<T extends WorkspaceDocUserRoleCreateArgs>(args: SelectSubset<T, WorkspaceDocUserRoleCreateArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceDocUserRoles.
     * @param {WorkspaceDocUserRoleCreateManyArgs} args - Arguments to create many WorkspaceDocUserRoles.
     * @example
     * // Create many WorkspaceDocUserRoles
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceDocUserRoleCreateManyArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceDocUserRoles and returns the data saved in the database.
     * @param {WorkspaceDocUserRoleCreateManyAndReturnArgs} args - Arguments to create many WorkspaceDocUserRoles.
     * @example
     * // Create many WorkspaceDocUserRoles
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceDocUserRoles and only return the `workspaceId`
     * const workspaceDocUserRoleWithWorkspaceIdOnly = await prisma.workspaceDocUserRole.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceDocUserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceDocUserRole.
     * @param {WorkspaceDocUserRoleDeleteArgs} args - Arguments to delete one WorkspaceDocUserRole.
     * @example
     * // Delete one WorkspaceDocUserRole
     * const WorkspaceDocUserRole = await prisma.workspaceDocUserRole.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceDocUserRole
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDocUserRoleDeleteArgs>(args: SelectSubset<T, WorkspaceDocUserRoleDeleteArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceDocUserRole.
     * @param {WorkspaceDocUserRoleUpdateArgs} args - Arguments to update one WorkspaceDocUserRole.
     * @example
     * // Update one WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceDocUserRoleUpdateArgs>(args: SelectSubset<T, WorkspaceDocUserRoleUpdateArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceDocUserRoles.
     * @param {WorkspaceDocUserRoleDeleteManyArgs} args - Arguments to filter WorkspaceDocUserRoles to delete.
     * @example
     * // Delete a few WorkspaceDocUserRoles
     * const { count } = await prisma.workspaceDocUserRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDocUserRoleDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDocUserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceDocUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceDocUserRoles
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceDocUserRoleUpdateManyArgs>(args: SelectSubset<T, WorkspaceDocUserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceDocUserRoles and returns the data updated in the database.
     * @param {WorkspaceDocUserRoleUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceDocUserRoles.
     * @example
     * // Update many WorkspaceDocUserRoles
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceDocUserRoles and only return the `workspaceId`
     * const workspaceDocUserRoleWithWorkspaceIdOnly = await prisma.workspaceDocUserRole.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceDocUserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceDocUserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceDocUserRole.
     * @param {WorkspaceDocUserRoleUpsertArgs} args - Arguments to update or create a WorkspaceDocUserRole.
     * @example
     * // Update or create a WorkspaceDocUserRole
     * const workspaceDocUserRole = await prisma.workspaceDocUserRole.upsert({
     *   create: {
     *     // ... data to create a WorkspaceDocUserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceDocUserRole we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceDocUserRoleUpsertArgs>(args: SelectSubset<T, WorkspaceDocUserRoleUpsertArgs<ExtArgs>>): Prisma__WorkspaceDocUserRoleClient<$Result.GetResult<Prisma.$WorkspaceDocUserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceDocUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleCountArgs} args - Arguments to filter WorkspaceDocUserRoles to count.
     * @example
     * // Count the number of WorkspaceDocUserRoles
     * const count = await prisma.workspaceDocUserRole.count({
     *   where: {
     *     // ... the filter for the WorkspaceDocUserRoles we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceDocUserRoleCountArgs>(
      args?: Subset<T, WorkspaceDocUserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceDocUserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceDocUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceDocUserRoleAggregateArgs>(args: Subset<T, WorkspaceDocUserRoleAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceDocUserRoleAggregateType<T>>

    /**
     * Group by WorkspaceDocUserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceDocUserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceDocUserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceDocUserRoleGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceDocUserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceDocUserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceDocUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceDocUserRole model
   */
  readonly fields: WorkspaceDocUserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceDocUserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceDocUserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceDocUserRole model
   */
  interface WorkspaceDocUserRoleFieldRefs {
    readonly workspaceId: FieldRef<"WorkspaceDocUserRole", 'String'>
    readonly docId: FieldRef<"WorkspaceDocUserRole", 'String'>
    readonly userId: FieldRef<"WorkspaceDocUserRole", 'String'>
    readonly type: FieldRef<"WorkspaceDocUserRole", 'Int'>
    readonly createdAt: FieldRef<"WorkspaceDocUserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceDocUserRole findUnique
   */
  export type WorkspaceDocUserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocUserRole to fetch.
     */
    where: WorkspaceDocUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole findUniqueOrThrow
   */
  export type WorkspaceDocUserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocUserRole to fetch.
     */
    where: WorkspaceDocUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole findFirst
   */
  export type WorkspaceDocUserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocUserRole to fetch.
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocUserRoles to fetch.
     */
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceDocUserRoles.
     */
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceDocUserRoles.
     */
    distinct?: WorkspaceDocUserRoleScalarFieldEnum | WorkspaceDocUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole findFirstOrThrow
   */
  export type WorkspaceDocUserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocUserRole to fetch.
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocUserRoles to fetch.
     */
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceDocUserRoles.
     */
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceDocUserRoles.
     */
    distinct?: WorkspaceDocUserRoleScalarFieldEnum | WorkspaceDocUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole findMany
   */
  export type WorkspaceDocUserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceDocUserRoles to fetch.
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceDocUserRoles to fetch.
     */
    orderBy?: WorkspaceDocUserRoleOrderByWithRelationInput | WorkspaceDocUserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceDocUserRoles.
     */
    cursor?: WorkspaceDocUserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceDocUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceDocUserRoles.
     */
    skip?: number
    distinct?: WorkspaceDocUserRoleScalarFieldEnum | WorkspaceDocUserRoleScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole create
   */
  export type WorkspaceDocUserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceDocUserRole.
     */
    data: XOR<WorkspaceDocUserRoleCreateInput, WorkspaceDocUserRoleUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole createMany
   */
  export type WorkspaceDocUserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceDocUserRoles.
     */
    data: WorkspaceDocUserRoleCreateManyInput | WorkspaceDocUserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceDocUserRole createManyAndReturn
   */
  export type WorkspaceDocUserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceDocUserRoles.
     */
    data: WorkspaceDocUserRoleCreateManyInput | WorkspaceDocUserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceDocUserRole update
   */
  export type WorkspaceDocUserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceDocUserRole.
     */
    data: XOR<WorkspaceDocUserRoleUpdateInput, WorkspaceDocUserRoleUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceDocUserRole to update.
     */
    where: WorkspaceDocUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole updateMany
   */
  export type WorkspaceDocUserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceDocUserRoles.
     */
    data: XOR<WorkspaceDocUserRoleUpdateManyMutationInput, WorkspaceDocUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceDocUserRoles to update
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * Limit how many WorkspaceDocUserRoles to update.
     */
    limit?: number
  }

  /**
   * WorkspaceDocUserRole updateManyAndReturn
   */
  export type WorkspaceDocUserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceDocUserRoles.
     */
    data: XOR<WorkspaceDocUserRoleUpdateManyMutationInput, WorkspaceDocUserRoleUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceDocUserRoles to update
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * Limit how many WorkspaceDocUserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceDocUserRole upsert
   */
  export type WorkspaceDocUserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceDocUserRole to update in case it exists.
     */
    where: WorkspaceDocUserRoleWhereUniqueInput
    /**
     * In case the WorkspaceDocUserRole found by the `where` argument doesn't exist, create a new WorkspaceDocUserRole with this data.
     */
    create: XOR<WorkspaceDocUserRoleCreateInput, WorkspaceDocUserRoleUncheckedCreateInput>
    /**
     * In case the WorkspaceDocUserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceDocUserRoleUpdateInput, WorkspaceDocUserRoleUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole delete
   */
  export type WorkspaceDocUserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceDocUserRole to delete.
     */
    where: WorkspaceDocUserRoleWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceDocUserRole deleteMany
   */
  export type WorkspaceDocUserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceDocUserRoles to delete
     */
    where?: WorkspaceDocUserRoleWhereInput
    /**
     * Limit how many WorkspaceDocUserRoles to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceDocUserRole without action
   */
  export type WorkspaceDocUserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceDocUserRole
     */
    select?: WorkspaceDocUserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceDocUserRole
     */
    omit?: WorkspaceDocUserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceDocUserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureAvgAggregateOutputType = {
    id: number | null
    deprecatedVersion: number | null
    deprecatedType: number | null
  }

  export type FeatureSumAggregateOutputType = {
    id: number | null
    deprecatedVersion: number | null
    deprecatedType: number | null
  }

  export type FeatureMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deprecatedVersion: number | null
    deprecatedType: number | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deprecatedVersion: number | null
    deprecatedType: number | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    name: number
    configs: number
    createdAt: number
    updatedAt: number
    deprecatedVersion: number
    deprecatedType: number
    _all: number
  }


  export type FeatureAvgAggregateInputType = {
    id?: true
    deprecatedVersion?: true
    deprecatedType?: true
  }

  export type FeatureSumAggregateInputType = {
    id?: true
    deprecatedVersion?: true
    deprecatedType?: true
  }

  export type FeatureMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deprecatedVersion?: true
    deprecatedType?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deprecatedVersion?: true
    deprecatedType?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    name?: true
    configs?: true
    createdAt?: true
    updatedAt?: true
    deprecatedVersion?: true
    deprecatedType?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _avg?: FeatureAvgAggregateInputType
    _sum?: FeatureSumAggregateInputType
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: number
    name: string
    configs: JsonValue
    createdAt: Date
    updatedAt: Date
    deprecatedVersion: number
    deprecatedType: number
    _count: FeatureCountAggregateOutputType | null
    _avg: FeatureAvgAggregateOutputType | null
    _sum: FeatureSumAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    configs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deprecatedVersion?: boolean
    deprecatedType?: boolean
    userFeatures?: boolean | Feature$userFeaturesArgs<ExtArgs>
    workspaceFeatures?: boolean | Feature$workspaceFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    configs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deprecatedVersion?: boolean
    deprecatedType?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    configs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deprecatedVersion?: boolean
    deprecatedType?: boolean
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    id?: boolean
    name?: boolean
    configs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deprecatedVersion?: boolean
    deprecatedType?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "configs" | "createdAt" | "updatedAt" | "deprecatedVersion" | "deprecatedType", ExtArgs["result"]["feature"]>
  export type FeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFeatures?: boolean | Feature$userFeaturesArgs<ExtArgs>
    workspaceFeatures?: boolean | Feature$workspaceFeaturesArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {
      userFeatures: Prisma.$UserFeaturePayload<ExtArgs>[]
      workspaceFeatures: Prisma.$WorkspaceFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      configs: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      /**
       * TODO(@forehalo): remove in the coming version
       * @deprecated
       * we don't need to record all the historical version of features
       */
      deprecatedVersion: number
      /**
       * @deprecated
       * we don't need to record type of features any more, there are always static,
       * but set it in `WorkspaceFeature` and `UserFeature` for fast query with just a little redundant.
       */
      deprecatedType: number
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userFeatures<T extends Feature$userFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$userFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaceFeatures<T extends Feature$workspaceFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, Feature$workspaceFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'Int'>
    readonly name: FieldRef<"Feature", 'String'>
    readonly configs: FieldRef<"Feature", 'Json'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
    readonly deprecatedVersion: FieldRef<"Feature", 'Int'>
    readonly deprecatedType: FieldRef<"Feature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature.userFeatures
   */
  export type Feature$userFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    where?: UserFeatureWhereInput
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    cursor?: UserFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeatureScalarFieldEnum | UserFeatureScalarFieldEnum[]
  }

  /**
   * Feature.workspaceFeatures
   */
  export type Feature$workspaceFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    where?: WorkspaceFeatureWhereInput
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    cursor?: WorkspaceFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceFeatureScalarFieldEnum | WorkspaceFeatureScalarFieldEnum[]
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
  }


  /**
   * Model UserFeature
   */

  export type AggregateUserFeature = {
    _count: UserFeatureCountAggregateOutputType | null
    _avg: UserFeatureAvgAggregateOutputType | null
    _sum: UserFeatureSumAggregateOutputType | null
    _min: UserFeatureMinAggregateOutputType | null
    _max: UserFeatureMaxAggregateOutputType | null
  }

  export type UserFeatureAvgAggregateOutputType = {
    id: number | null
    featureId: number | null
    type: number | null
  }

  export type UserFeatureSumAggregateOutputType = {
    id: number | null
    featureId: number | null
    type: number | null
  }

  export type UserFeatureMinAggregateOutputType = {
    id: number | null
    userId: string | null
    featureId: number | null
    name: string | null
    type: number | null
    reason: string | null
    createdAt: Date | null
    expiredAt: Date | null
    activated: boolean | null
  }

  export type UserFeatureMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    featureId: number | null
    name: string | null
    type: number | null
    reason: string | null
    createdAt: Date | null
    expiredAt: Date | null
    activated: boolean | null
  }

  export type UserFeatureCountAggregateOutputType = {
    id: number
    userId: number
    featureId: number
    name: number
    type: number
    reason: number
    createdAt: number
    expiredAt: number
    activated: number
    _all: number
  }


  export type UserFeatureAvgAggregateInputType = {
    id?: true
    featureId?: true
    type?: true
  }

  export type UserFeatureSumAggregateInputType = {
    id?: true
    featureId?: true
    type?: true
  }

  export type UserFeatureMinAggregateInputType = {
    id?: true
    userId?: true
    featureId?: true
    name?: true
    type?: true
    reason?: true
    createdAt?: true
    expiredAt?: true
    activated?: true
  }

  export type UserFeatureMaxAggregateInputType = {
    id?: true
    userId?: true
    featureId?: true
    name?: true
    type?: true
    reason?: true
    createdAt?: true
    expiredAt?: true
    activated?: true
  }

  export type UserFeatureCountAggregateInputType = {
    id?: true
    userId?: true
    featureId?: true
    name?: true
    type?: true
    reason?: true
    createdAt?: true
    expiredAt?: true
    activated?: true
    _all?: true
  }

  export type UserFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeature to aggregate.
     */
    where?: UserFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatures to fetch.
     */
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeatures
    **/
    _count?: true | UserFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeatureMaxAggregateInputType
  }

  export type GetUserFeatureAggregateType<T extends UserFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeature[P]>
      : GetScalarType<T[P], AggregateUserFeature[P]>
  }




  export type UserFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureWhereInput
    orderBy?: UserFeatureOrderByWithAggregationInput | UserFeatureOrderByWithAggregationInput[]
    by: UserFeatureScalarFieldEnum[] | UserFeatureScalarFieldEnum
    having?: UserFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeatureCountAggregateInputType | true
    _avg?: UserFeatureAvgAggregateInputType
    _sum?: UserFeatureSumAggregateInputType
    _min?: UserFeatureMinAggregateInputType
    _max?: UserFeatureMaxAggregateInputType
  }

  export type UserFeatureGroupByOutputType = {
    id: number
    userId: string
    featureId: number
    name: string
    type: number
    reason: string
    createdAt: Date
    expiredAt: Date | null
    activated: boolean
    _count: UserFeatureCountAggregateOutputType | null
    _avg: UserFeatureAvgAggregateOutputType | null
    _sum: UserFeatureSumAggregateOutputType | null
    _min: UserFeatureMinAggregateOutputType | null
    _max: UserFeatureMaxAggregateOutputType | null
  }

  type GetUserFeatureGroupByPayload<T extends UserFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeatureGroupByOutputType[P]>
        }
      >
    >


  export type UserFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    activated?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeature"]>

  export type UserFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    activated?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeature"]>

  export type UserFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    activated?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeature"]>

  export type UserFeatureSelectScalar = {
    id?: boolean
    userId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    reason?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    activated?: boolean
  }

  export type UserFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "featureId" | "name" | "type" | "reason" | "createdAt" | "expiredAt" | "activated", ExtArgs["result"]["userFeature"]>
  export type UserFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      featureId: number
      name: string
      type: number
      reason: string
      createdAt: Date
      expiredAt: Date | null
      activated: boolean
    }, ExtArgs["result"]["userFeature"]>
    composites: {}
  }

  type UserFeatureGetPayload<S extends boolean | null | undefined | UserFeatureDefaultArgs> = $Result.GetResult<Prisma.$UserFeaturePayload, S>

  type UserFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserFeatureCountAggregateInputType | true
    }

  export interface UserFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeature'], meta: { name: 'UserFeature' } }
    /**
     * Find zero or one UserFeature that matches the filter.
     * @param {UserFeatureFindUniqueArgs} args - Arguments to find a UserFeature
     * @example
     * // Get one UserFeature
     * const userFeature = await prisma.userFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeatureFindUniqueArgs>(args: SelectSubset<T, UserFeatureFindUniqueArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFeatureFindUniqueOrThrowArgs} args - Arguments to find a UserFeature
     * @example
     * // Get one UserFeature
     * const userFeature = await prisma.userFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFindFirstArgs} args - Arguments to find a UserFeature
     * @example
     * // Get one UserFeature
     * const userFeature = await prisma.userFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeatureFindFirstArgs>(args?: SelectSubset<T, UserFeatureFindFirstArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFindFirstOrThrowArgs} args - Arguments to find a UserFeature
     * @example
     * // Get one UserFeature
     * const userFeature = await prisma.userFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeatures
     * const userFeatures = await prisma.userFeature.findMany()
     * 
     * // Get first 10 UserFeatures
     * const userFeatures = await prisma.userFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeatureWithIdOnly = await prisma.userFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeatureFindManyArgs>(args?: SelectSubset<T, UserFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFeature.
     * @param {UserFeatureCreateArgs} args - Arguments to create a UserFeature.
     * @example
     * // Create one UserFeature
     * const UserFeature = await prisma.userFeature.create({
     *   data: {
     *     // ... data to create a UserFeature
     *   }
     * })
     * 
     */
    create<T extends UserFeatureCreateArgs>(args: SelectSubset<T, UserFeatureCreateArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFeatures.
     * @param {UserFeatureCreateManyArgs} args - Arguments to create many UserFeatures.
     * @example
     * // Create many UserFeatures
     * const userFeature = await prisma.userFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeatureCreateManyArgs>(args?: SelectSubset<T, UserFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeatures and returns the data saved in the database.
     * @param {UserFeatureCreateManyAndReturnArgs} args - Arguments to create many UserFeatures.
     * @example
     * // Create many UserFeatures
     * const userFeature = await prisma.userFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeatures and only return the `id`
     * const userFeatureWithIdOnly = await prisma.userFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFeature.
     * @param {UserFeatureDeleteArgs} args - Arguments to delete one UserFeature.
     * @example
     * // Delete one UserFeature
     * const UserFeature = await prisma.userFeature.delete({
     *   where: {
     *     // ... filter to delete one UserFeature
     *   }
     * })
     * 
     */
    delete<T extends UserFeatureDeleteArgs>(args: SelectSubset<T, UserFeatureDeleteArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFeature.
     * @param {UserFeatureUpdateArgs} args - Arguments to update one UserFeature.
     * @example
     * // Update one UserFeature
     * const userFeature = await prisma.userFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeatureUpdateArgs>(args: SelectSubset<T, UserFeatureUpdateArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFeatures.
     * @param {UserFeatureDeleteManyArgs} args - Arguments to filter UserFeatures to delete.
     * @example
     * // Delete a few UserFeatures
     * const { count } = await prisma.userFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeatureDeleteManyArgs>(args?: SelectSubset<T, UserFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeatures
     * const userFeature = await prisma.userFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeatureUpdateManyArgs>(args: SelectSubset<T, UserFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatures and returns the data updated in the database.
     * @param {UserFeatureUpdateManyAndReturnArgs} args - Arguments to update many UserFeatures.
     * @example
     * // Update many UserFeatures
     * const userFeature = await prisma.userFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFeatures and only return the `id`
     * const userFeatureWithIdOnly = await prisma.userFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFeature.
     * @param {UserFeatureUpsertArgs} args - Arguments to update or create a UserFeature.
     * @example
     * // Update or create a UserFeature
     * const userFeature = await prisma.userFeature.upsert({
     *   create: {
     *     // ... data to create a UserFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeature we want to update
     *   }
     * })
     */
    upsert<T extends UserFeatureUpsertArgs>(args: SelectSubset<T, UserFeatureUpsertArgs<ExtArgs>>): Prisma__UserFeatureClient<$Result.GetResult<Prisma.$UserFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureCountArgs} args - Arguments to filter UserFeatures to count.
     * @example
     * // Count the number of UserFeatures
     * const count = await prisma.userFeature.count({
     *   where: {
     *     // ... the filter for the UserFeatures we want to count
     *   }
     * })
    **/
    count<T extends UserFeatureCountArgs>(
      args?: Subset<T, UserFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeatureAggregateArgs>(args: Subset<T, UserFeatureAggregateArgs>): Prisma.PrismaPromise<GetUserFeatureAggregateType<T>>

    /**
     * Group by UserFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeatureGroupByArgs['orderBy'] }
        : { orderBy?: UserFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeature model
   */
  readonly fields: UserFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeature model
   */
  interface UserFeatureFieldRefs {
    readonly id: FieldRef<"UserFeature", 'Int'>
    readonly userId: FieldRef<"UserFeature", 'String'>
    readonly featureId: FieldRef<"UserFeature", 'Int'>
    readonly name: FieldRef<"UserFeature", 'String'>
    readonly type: FieldRef<"UserFeature", 'Int'>
    readonly reason: FieldRef<"UserFeature", 'String'>
    readonly createdAt: FieldRef<"UserFeature", 'DateTime'>
    readonly expiredAt: FieldRef<"UserFeature", 'DateTime'>
    readonly activated: FieldRef<"UserFeature", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserFeature findUnique
   */
  export type UserFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UserFeature to fetch.
     */
    where: UserFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature findUniqueOrThrow
   */
  export type UserFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UserFeature to fetch.
     */
    where: UserFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature findFirst
   */
  export type UserFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UserFeature to fetch.
     */
    where?: UserFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatures to fetch.
     */
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatures.
     */
    cursor?: UserFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatures.
     */
    distinct?: UserFeatureScalarFieldEnum | UserFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature findFirstOrThrow
   */
  export type UserFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UserFeature to fetch.
     */
    where?: UserFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatures to fetch.
     */
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatures.
     */
    cursor?: UserFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatures.
     */
    distinct?: UserFeatureScalarFieldEnum | UserFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature findMany
   */
  export type UserFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatures to fetch.
     */
    where?: UserFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatures to fetch.
     */
    orderBy?: UserFeatureOrderByWithRelationInput | UserFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeatures.
     */
    cursor?: UserFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatures.
     */
    skip?: number
    distinct?: UserFeatureScalarFieldEnum | UserFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature create
   */
  export type UserFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeature.
     */
    data: XOR<UserFeatureCreateInput, UserFeatureUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature createMany
   */
  export type UserFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeatures.
     */
    data: UserFeatureCreateManyInput | UserFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeature createManyAndReturn
   */
  export type UserFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many UserFeatures.
     */
    data: UserFeatureCreateManyInput | UserFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeature update
   */
  export type UserFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeature.
     */
    data: XOR<UserFeatureUpdateInput, UserFeatureUncheckedUpdateInput>
    /**
     * Choose, which UserFeature to update.
     */
    where: UserFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature updateMany
   */
  export type UserFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeatures.
     */
    data: XOR<UserFeatureUpdateManyMutationInput, UserFeatureUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatures to update
     */
    where?: UserFeatureWhereInput
    /**
     * Limit how many UserFeatures to update.
     */
    limit?: number
  }

  /**
   * UserFeature updateManyAndReturn
   */
  export type UserFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * The data used to update UserFeatures.
     */
    data: XOR<UserFeatureUpdateManyMutationInput, UserFeatureUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatures to update
     */
    where?: UserFeatureWhereInput
    /**
     * Limit how many UserFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeature upsert
   */
  export type UserFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeature to update in case it exists.
     */
    where: UserFeatureWhereUniqueInput
    /**
     * In case the UserFeature found by the `where` argument doesn't exist, create a new UserFeature with this data.
     */
    create: XOR<UserFeatureCreateInput, UserFeatureUncheckedCreateInput>
    /**
     * In case the UserFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeatureUpdateInput, UserFeatureUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature delete
   */
  export type UserFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
    /**
     * Filter which UserFeature to delete.
     */
    where: UserFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserFeature deleteMany
   */
  export type UserFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatures to delete
     */
    where?: UserFeatureWhereInput
    /**
     * Limit how many UserFeatures to delete.
     */
    limit?: number
  }

  /**
   * UserFeature without action
   */
  export type UserFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeature
     */
    select?: UserFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeature
     */
    omit?: UserFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceFeature
   */

  export type AggregateWorkspaceFeature = {
    _count: WorkspaceFeatureCountAggregateOutputType | null
    _avg: WorkspaceFeatureAvgAggregateOutputType | null
    _sum: WorkspaceFeatureSumAggregateOutputType | null
    _min: WorkspaceFeatureMinAggregateOutputType | null
    _max: WorkspaceFeatureMaxAggregateOutputType | null
  }

  export type WorkspaceFeatureAvgAggregateOutputType = {
    id: number | null
    featureId: number | null
    type: number | null
  }

  export type WorkspaceFeatureSumAggregateOutputType = {
    id: number | null
    featureId: number | null
    type: number | null
  }

  export type WorkspaceFeatureMinAggregateOutputType = {
    id: number | null
    workspaceId: string | null
    featureId: number | null
    name: string | null
    type: number | null
    reason: string | null
    createdAt: Date | null
    activated: boolean | null
    expiredAt: Date | null
  }

  export type WorkspaceFeatureMaxAggregateOutputType = {
    id: number | null
    workspaceId: string | null
    featureId: number | null
    name: string | null
    type: number | null
    reason: string | null
    createdAt: Date | null
    activated: boolean | null
    expiredAt: Date | null
  }

  export type WorkspaceFeatureCountAggregateOutputType = {
    id: number
    workspaceId: number
    featureId: number
    name: number
    type: number
    configs: number
    reason: number
    createdAt: number
    activated: number
    expiredAt: number
    _all: number
  }


  export type WorkspaceFeatureAvgAggregateInputType = {
    id?: true
    featureId?: true
    type?: true
  }

  export type WorkspaceFeatureSumAggregateInputType = {
    id?: true
    featureId?: true
    type?: true
  }

  export type WorkspaceFeatureMinAggregateInputType = {
    id?: true
    workspaceId?: true
    featureId?: true
    name?: true
    type?: true
    reason?: true
    createdAt?: true
    activated?: true
    expiredAt?: true
  }

  export type WorkspaceFeatureMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    featureId?: true
    name?: true
    type?: true
    reason?: true
    createdAt?: true
    activated?: true
    expiredAt?: true
  }

  export type WorkspaceFeatureCountAggregateInputType = {
    id?: true
    workspaceId?: true
    featureId?: true
    name?: true
    type?: true
    configs?: true
    reason?: true
    createdAt?: true
    activated?: true
    expiredAt?: true
    _all?: true
  }

  export type WorkspaceFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceFeature to aggregate.
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceFeatures to fetch.
     */
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceFeatures
    **/
    _count?: true | WorkspaceFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkspaceFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkspaceFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceFeatureMaxAggregateInputType
  }

  export type GetWorkspaceFeatureAggregateType<T extends WorkspaceFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceFeature[P]>
      : GetScalarType<T[P], AggregateWorkspaceFeature[P]>
  }




  export type WorkspaceFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceFeatureWhereInput
    orderBy?: WorkspaceFeatureOrderByWithAggregationInput | WorkspaceFeatureOrderByWithAggregationInput[]
    by: WorkspaceFeatureScalarFieldEnum[] | WorkspaceFeatureScalarFieldEnum
    having?: WorkspaceFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceFeatureCountAggregateInputType | true
    _avg?: WorkspaceFeatureAvgAggregateInputType
    _sum?: WorkspaceFeatureSumAggregateInputType
    _min?: WorkspaceFeatureMinAggregateInputType
    _max?: WorkspaceFeatureMaxAggregateInputType
  }

  export type WorkspaceFeatureGroupByOutputType = {
    id: number
    workspaceId: string
    featureId: number
    name: string
    type: number
    configs: JsonValue
    reason: string
    createdAt: Date
    activated: boolean
    expiredAt: Date | null
    _count: WorkspaceFeatureCountAggregateOutputType | null
    _avg: WorkspaceFeatureAvgAggregateOutputType | null
    _sum: WorkspaceFeatureSumAggregateOutputType | null
    _min: WorkspaceFeatureMinAggregateOutputType | null
    _max: WorkspaceFeatureMaxAggregateOutputType | null
  }

  type GetWorkspaceFeatureGroupByPayload<T extends WorkspaceFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceFeatureGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    configs?: boolean
    reason?: boolean
    createdAt?: boolean
    activated?: boolean
    expiredAt?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceFeature"]>

  export type WorkspaceFeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    configs?: boolean
    reason?: boolean
    createdAt?: boolean
    activated?: boolean
    expiredAt?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceFeature"]>

  export type WorkspaceFeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    configs?: boolean
    reason?: boolean
    createdAt?: boolean
    activated?: boolean
    expiredAt?: boolean
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceFeature"]>

  export type WorkspaceFeatureSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    featureId?: boolean
    name?: boolean
    type?: boolean
    configs?: boolean
    reason?: boolean
    createdAt?: boolean
    activated?: boolean
    expiredAt?: boolean
  }

  export type WorkspaceFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "featureId" | "name" | "type" | "configs" | "reason" | "createdAt" | "activated" | "expiredAt", ExtArgs["result"]["workspaceFeature"]>
  export type WorkspaceFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceFeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WorkspaceFeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feature?: boolean | FeatureDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WorkspaceFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceFeature"
    objects: {
      feature: Prisma.$FeaturePayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workspaceId: string
      featureId: number
      name: string
      type: number
      /**
       * overrides for the default feature configs
       */
      configs: Prisma.JsonValue
      reason: string
      createdAt: Date
      activated: boolean
      expiredAt: Date | null
    }, ExtArgs["result"]["workspaceFeature"]>
    composites: {}
  }

  type WorkspaceFeatureGetPayload<S extends boolean | null | undefined | WorkspaceFeatureDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceFeaturePayload, S>

  type WorkspaceFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WorkspaceFeatureCountAggregateInputType | true
    }

  export interface WorkspaceFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceFeature'], meta: { name: 'WorkspaceFeature' } }
    /**
     * Find zero or one WorkspaceFeature that matches the filter.
     * @param {WorkspaceFeatureFindUniqueArgs} args - Arguments to find a WorkspaceFeature
     * @example
     * // Get one WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFeatureFindUniqueArgs>(args: SelectSubset<T, WorkspaceFeatureFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFeatureFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceFeature
     * @example
     * // Get one WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureFindFirstArgs} args - Arguments to find a WorkspaceFeature
     * @example
     * // Get one WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFeatureFindFirstArgs>(args?: SelectSubset<T, WorkspaceFeatureFindFirstArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureFindFirstOrThrowArgs} args - Arguments to find a WorkspaceFeature
     * @example
     * // Get one WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceFeatures
     * const workspaceFeatures = await prisma.workspaceFeature.findMany()
     * 
     * // Get first 10 WorkspaceFeatures
     * const workspaceFeatures = await prisma.workspaceFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceFeatureWithIdOnly = await prisma.workspaceFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFeatureFindManyArgs>(args?: SelectSubset<T, WorkspaceFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceFeature.
     * @param {WorkspaceFeatureCreateArgs} args - Arguments to create a WorkspaceFeature.
     * @example
     * // Create one WorkspaceFeature
     * const WorkspaceFeature = await prisma.workspaceFeature.create({
     *   data: {
     *     // ... data to create a WorkspaceFeature
     *   }
     * })
     * 
     */
    create<T extends WorkspaceFeatureCreateArgs>(args: SelectSubset<T, WorkspaceFeatureCreateArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceFeatures.
     * @param {WorkspaceFeatureCreateManyArgs} args - Arguments to create many WorkspaceFeatures.
     * @example
     * // Create many WorkspaceFeatures
     * const workspaceFeature = await prisma.workspaceFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceFeatureCreateManyArgs>(args?: SelectSubset<T, WorkspaceFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceFeatures and returns the data saved in the database.
     * @param {WorkspaceFeatureCreateManyAndReturnArgs} args - Arguments to create many WorkspaceFeatures.
     * @example
     * // Create many WorkspaceFeatures
     * const workspaceFeature = await prisma.workspaceFeature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceFeatures and only return the `id`
     * const workspaceFeatureWithIdOnly = await prisma.workspaceFeature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceFeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceFeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceFeature.
     * @param {WorkspaceFeatureDeleteArgs} args - Arguments to delete one WorkspaceFeature.
     * @example
     * // Delete one WorkspaceFeature
     * const WorkspaceFeature = await prisma.workspaceFeature.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceFeature
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceFeatureDeleteArgs>(args: SelectSubset<T, WorkspaceFeatureDeleteArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceFeature.
     * @param {WorkspaceFeatureUpdateArgs} args - Arguments to update one WorkspaceFeature.
     * @example
     * // Update one WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceFeatureUpdateArgs>(args: SelectSubset<T, WorkspaceFeatureUpdateArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceFeatures.
     * @param {WorkspaceFeatureDeleteManyArgs} args - Arguments to filter WorkspaceFeatures to delete.
     * @example
     * // Delete a few WorkspaceFeatures
     * const { count } = await prisma.workspaceFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceFeatureDeleteManyArgs>(args?: SelectSubset<T, WorkspaceFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceFeatures
     * const workspaceFeature = await prisma.workspaceFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceFeatureUpdateManyArgs>(args: SelectSubset<T, WorkspaceFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceFeatures and returns the data updated in the database.
     * @param {WorkspaceFeatureUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceFeatures.
     * @example
     * // Update many WorkspaceFeatures
     * const workspaceFeature = await prisma.workspaceFeature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceFeatures and only return the `id`
     * const workspaceFeatureWithIdOnly = await prisma.workspaceFeature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceFeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceFeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceFeature.
     * @param {WorkspaceFeatureUpsertArgs} args - Arguments to update or create a WorkspaceFeature.
     * @example
     * // Update or create a WorkspaceFeature
     * const workspaceFeature = await prisma.workspaceFeature.upsert({
     *   create: {
     *     // ... data to create a WorkspaceFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceFeature we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceFeatureUpsertArgs>(args: SelectSubset<T, WorkspaceFeatureUpsertArgs<ExtArgs>>): Prisma__WorkspaceFeatureClient<$Result.GetResult<Prisma.$WorkspaceFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureCountArgs} args - Arguments to filter WorkspaceFeatures to count.
     * @example
     * // Count the number of WorkspaceFeatures
     * const count = await prisma.workspaceFeature.count({
     *   where: {
     *     // ... the filter for the WorkspaceFeatures we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceFeatureCountArgs>(
      args?: Subset<T, WorkspaceFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceFeatureAggregateArgs>(args: Subset<T, WorkspaceFeatureAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceFeatureAggregateType<T>>

    /**
     * Group by WorkspaceFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceFeatureGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceFeature model
   */
  readonly fields: WorkspaceFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feature<T extends FeatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeatureDefaultArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceFeature model
   */
  interface WorkspaceFeatureFieldRefs {
    readonly id: FieldRef<"WorkspaceFeature", 'Int'>
    readonly workspaceId: FieldRef<"WorkspaceFeature", 'String'>
    readonly featureId: FieldRef<"WorkspaceFeature", 'Int'>
    readonly name: FieldRef<"WorkspaceFeature", 'String'>
    readonly type: FieldRef<"WorkspaceFeature", 'Int'>
    readonly configs: FieldRef<"WorkspaceFeature", 'Json'>
    readonly reason: FieldRef<"WorkspaceFeature", 'String'>
    readonly createdAt: FieldRef<"WorkspaceFeature", 'DateTime'>
    readonly activated: FieldRef<"WorkspaceFeature", 'Boolean'>
    readonly expiredAt: FieldRef<"WorkspaceFeature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceFeature findUnique
   */
  export type WorkspaceFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceFeature to fetch.
     */
    where: WorkspaceFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature findUniqueOrThrow
   */
  export type WorkspaceFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceFeature to fetch.
     */
    where: WorkspaceFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature findFirst
   */
  export type WorkspaceFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceFeature to fetch.
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceFeatures to fetch.
     */
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceFeatures.
     */
    cursor?: WorkspaceFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceFeatures.
     */
    distinct?: WorkspaceFeatureScalarFieldEnum | WorkspaceFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature findFirstOrThrow
   */
  export type WorkspaceFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceFeature to fetch.
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceFeatures to fetch.
     */
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceFeatures.
     */
    cursor?: WorkspaceFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceFeatures.
     */
    distinct?: WorkspaceFeatureScalarFieldEnum | WorkspaceFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature findMany
   */
  export type WorkspaceFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceFeatures to fetch.
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceFeatures to fetch.
     */
    orderBy?: WorkspaceFeatureOrderByWithRelationInput | WorkspaceFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceFeatures.
     */
    cursor?: WorkspaceFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceFeatures.
     */
    skip?: number
    distinct?: WorkspaceFeatureScalarFieldEnum | WorkspaceFeatureScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature create
   */
  export type WorkspaceFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceFeature.
     */
    data: XOR<WorkspaceFeatureCreateInput, WorkspaceFeatureUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature createMany
   */
  export type WorkspaceFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceFeatures.
     */
    data: WorkspaceFeatureCreateManyInput | WorkspaceFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceFeature createManyAndReturn
   */
  export type WorkspaceFeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceFeatures.
     */
    data: WorkspaceFeatureCreateManyInput | WorkspaceFeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceFeature update
   */
  export type WorkspaceFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceFeature.
     */
    data: XOR<WorkspaceFeatureUpdateInput, WorkspaceFeatureUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceFeature to update.
     */
    where: WorkspaceFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature updateMany
   */
  export type WorkspaceFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceFeatures.
     */
    data: XOR<WorkspaceFeatureUpdateManyMutationInput, WorkspaceFeatureUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceFeatures to update
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * Limit how many WorkspaceFeatures to update.
     */
    limit?: number
  }

  /**
   * WorkspaceFeature updateManyAndReturn
   */
  export type WorkspaceFeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceFeatures.
     */
    data: XOR<WorkspaceFeatureUpdateManyMutationInput, WorkspaceFeatureUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceFeatures to update
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * Limit how many WorkspaceFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceFeature upsert
   */
  export type WorkspaceFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceFeature to update in case it exists.
     */
    where: WorkspaceFeatureWhereUniqueInput
    /**
     * In case the WorkspaceFeature found by the `where` argument doesn't exist, create a new WorkspaceFeature with this data.
     */
    create: XOR<WorkspaceFeatureCreateInput, WorkspaceFeatureUncheckedCreateInput>
    /**
     * In case the WorkspaceFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceFeatureUpdateInput, WorkspaceFeatureUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature delete
   */
  export type WorkspaceFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceFeature to delete.
     */
    where: WorkspaceFeatureWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WorkspaceFeature deleteMany
   */
  export type WorkspaceFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceFeatures to delete
     */
    where?: WorkspaceFeatureWhereInput
    /**
     * Limit how many WorkspaceFeatures to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceFeature without action
   */
  export type WorkspaceFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceFeature
     */
    select?: WorkspaceFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceFeature
     */
    omit?: WorkspaceFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceFeatureInclude<ExtArgs> | null
  }


  /**
   * Model Snapshot
   */

  export type AggregateSnapshot = {
    _count: SnapshotCountAggregateOutputType | null
    _avg: SnapshotAvgAggregateOutputType | null
    _sum: SnapshotSumAggregateOutputType | null
    _min: SnapshotMinAggregateOutputType | null
    _max: SnapshotMaxAggregateOutputType | null
  }

  export type SnapshotAvgAggregateOutputType = {
    seq: number | null
  }

  export type SnapshotSumAggregateOutputType = {
    seq: number | null
  }

  export type SnapshotMinAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    blob: Uint8Array | null
    state: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    seq: number | null
  }

  export type SnapshotMaxAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    blob: Uint8Array | null
    state: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    seq: number | null
  }

  export type SnapshotCountAggregateOutputType = {
    workspaceId: number
    id: number
    blob: number
    state: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    seq: number
    _all: number
  }


  export type SnapshotAvgAggregateInputType = {
    seq?: true
  }

  export type SnapshotSumAggregateInputType = {
    seq?: true
  }

  export type SnapshotMinAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    seq?: true
  }

  export type SnapshotMaxAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    seq?: true
  }

  export type SnapshotCountAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    seq?: true
    _all?: true
  }

  export type SnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snapshot to aggregate.
     */
    where?: SnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snapshots to fetch.
     */
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snapshots
    **/
    _count?: true | SnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnapshotMaxAggregateInputType
  }

  export type GetSnapshotAggregateType<T extends SnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnapshot[P]>
      : GetScalarType<T[P], AggregateSnapshot[P]>
  }




  export type SnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnapshotWhereInput
    orderBy?: SnapshotOrderByWithAggregationInput | SnapshotOrderByWithAggregationInput[]
    by: SnapshotScalarFieldEnum[] | SnapshotScalarFieldEnum
    having?: SnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnapshotCountAggregateInputType | true
    _avg?: SnapshotAvgAggregateInputType
    _sum?: SnapshotSumAggregateInputType
    _min?: SnapshotMinAggregateInputType
    _max?: SnapshotMaxAggregateInputType
  }

  export type SnapshotGroupByOutputType = {
    workspaceId: string
    id: string
    blob: Uint8Array
    state: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    seq: number | null
    _count: SnapshotCountAggregateOutputType | null
    _avg: SnapshotAvgAggregateOutputType | null
    _sum: SnapshotSumAggregateOutputType | null
    _min: SnapshotMinAggregateOutputType | null
    _max: SnapshotMaxAggregateOutputType | null
  }

  type GetSnapshotGroupByPayload<T extends SnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], SnapshotGroupByOutputType[P]>
        }
      >
    >


  export type SnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
    embedding?: boolean | Snapshot$embeddingArgs<ExtArgs>
    _count?: boolean | SnapshotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snapshot"]>

  export type SnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["snapshot"]>

  export type SnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["snapshot"]>

  export type SnapshotSelectScalar = {
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    seq?: boolean
  }

  export type SnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "id" | "blob" | "state" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "seq", ExtArgs["result"]["snapshot"]>
  export type SnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
    embedding?: boolean | Snapshot$embeddingArgs<ExtArgs>
    _count?: boolean | SnapshotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
  }
  export type SnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Snapshot$createdByUserArgs<ExtArgs>
    updatedByUser?: boolean | Snapshot$updatedByUserArgs<ExtArgs>
  }

  export type $SnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snapshot"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      updatedByUser: Prisma.$UserPayload<ExtArgs> | null
      embedding: Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      id: string
      blob: Uint8Array
      state: Uint8Array | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
      seq: number | null
    }, ExtArgs["result"]["snapshot"]>
    composites: {}
  }

  type SnapshotGetPayload<S extends boolean | null | undefined | SnapshotDefaultArgs> = $Result.GetResult<Prisma.$SnapshotPayload, S>

  type SnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SnapshotCountAggregateInputType | true
    }

  export interface SnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snapshot'], meta: { name: 'Snapshot' } }
    /**
     * Find zero or one Snapshot that matches the filter.
     * @param {SnapshotFindUniqueArgs} args - Arguments to find a Snapshot
     * @example
     * // Get one Snapshot
     * const snapshot = await prisma.snapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnapshotFindUniqueArgs>(args: SelectSubset<T, SnapshotFindUniqueArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Snapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SnapshotFindUniqueOrThrowArgs} args - Arguments to find a Snapshot
     * @example
     * // Get one Snapshot
     * const snapshot = await prisma.snapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, SnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotFindFirstArgs} args - Arguments to find a Snapshot
     * @example
     * // Get one Snapshot
     * const snapshot = await prisma.snapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnapshotFindFirstArgs>(args?: SelectSubset<T, SnapshotFindFirstArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotFindFirstOrThrowArgs} args - Arguments to find a Snapshot
     * @example
     * // Get one Snapshot
     * const snapshot = await prisma.snapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, SnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Snapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snapshots
     * const snapshots = await prisma.snapshot.findMany()
     * 
     * // Get first 10 Snapshots
     * const snapshots = await prisma.snapshot.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const snapshotWithWorkspaceIdOnly = await prisma.snapshot.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends SnapshotFindManyArgs>(args?: SelectSubset<T, SnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Snapshot.
     * @param {SnapshotCreateArgs} args - Arguments to create a Snapshot.
     * @example
     * // Create one Snapshot
     * const Snapshot = await prisma.snapshot.create({
     *   data: {
     *     // ... data to create a Snapshot
     *   }
     * })
     * 
     */
    create<T extends SnapshotCreateArgs>(args: SelectSubset<T, SnapshotCreateArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Snapshots.
     * @param {SnapshotCreateManyArgs} args - Arguments to create many Snapshots.
     * @example
     * // Create many Snapshots
     * const snapshot = await prisma.snapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnapshotCreateManyArgs>(args?: SelectSubset<T, SnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snapshots and returns the data saved in the database.
     * @param {SnapshotCreateManyAndReturnArgs} args - Arguments to create many Snapshots.
     * @example
     * // Create many Snapshots
     * const snapshot = await prisma.snapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snapshots and only return the `workspaceId`
     * const snapshotWithWorkspaceIdOnly = await prisma.snapshot.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, SnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Snapshot.
     * @param {SnapshotDeleteArgs} args - Arguments to delete one Snapshot.
     * @example
     * // Delete one Snapshot
     * const Snapshot = await prisma.snapshot.delete({
     *   where: {
     *     // ... filter to delete one Snapshot
     *   }
     * })
     * 
     */
    delete<T extends SnapshotDeleteArgs>(args: SelectSubset<T, SnapshotDeleteArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Snapshot.
     * @param {SnapshotUpdateArgs} args - Arguments to update one Snapshot.
     * @example
     * // Update one Snapshot
     * const snapshot = await prisma.snapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnapshotUpdateArgs>(args: SelectSubset<T, SnapshotUpdateArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Snapshots.
     * @param {SnapshotDeleteManyArgs} args - Arguments to filter Snapshots to delete.
     * @example
     * // Delete a few Snapshots
     * const { count } = await prisma.snapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnapshotDeleteManyArgs>(args?: SelectSubset<T, SnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snapshots
     * const snapshot = await prisma.snapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnapshotUpdateManyArgs>(args: SelectSubset<T, SnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snapshots and returns the data updated in the database.
     * @param {SnapshotUpdateManyAndReturnArgs} args - Arguments to update many Snapshots.
     * @example
     * // Update many Snapshots
     * const snapshot = await prisma.snapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Snapshots and only return the `workspaceId`
     * const snapshotWithWorkspaceIdOnly = await prisma.snapshot.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, SnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Snapshot.
     * @param {SnapshotUpsertArgs} args - Arguments to update or create a Snapshot.
     * @example
     * // Update or create a Snapshot
     * const snapshot = await prisma.snapshot.upsert({
     *   create: {
     *     // ... data to create a Snapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snapshot we want to update
     *   }
     * })
     */
    upsert<T extends SnapshotUpsertArgs>(args: SelectSubset<T, SnapshotUpsertArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Snapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotCountArgs} args - Arguments to filter Snapshots to count.
     * @example
     * // Count the number of Snapshots
     * const count = await prisma.snapshot.count({
     *   where: {
     *     // ... the filter for the Snapshots we want to count
     *   }
     * })
    **/
    count<T extends SnapshotCountArgs>(
      args?: Subset<T, SnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnapshotAggregateArgs>(args: Subset<T, SnapshotAggregateArgs>): Prisma.PrismaPromise<GetSnapshotAggregateType<T>>

    /**
     * Group by Snapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnapshotGroupByArgs['orderBy'] }
        : { orderBy?: SnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snapshot model
   */
  readonly fields: SnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends Snapshot$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, Snapshot$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedByUser<T extends Snapshot$updatedByUserArgs<ExtArgs> = {}>(args?: Subset<T, Snapshot$updatedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    embedding<T extends Snapshot$embeddingArgs<ExtArgs> = {}>(args?: Subset<T, Snapshot$embeddingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snapshot model
   */
  interface SnapshotFieldRefs {
    readonly workspaceId: FieldRef<"Snapshot", 'String'>
    readonly id: FieldRef<"Snapshot", 'String'>
    readonly blob: FieldRef<"Snapshot", 'Bytes'>
    readonly state: FieldRef<"Snapshot", 'Bytes'>
    readonly createdAt: FieldRef<"Snapshot", 'DateTime'>
    readonly updatedAt: FieldRef<"Snapshot", 'DateTime'>
    readonly createdBy: FieldRef<"Snapshot", 'String'>
    readonly updatedBy: FieldRef<"Snapshot", 'String'>
    readonly seq: FieldRef<"Snapshot", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Snapshot findUnique
   */
  export type SnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter, which Snapshot to fetch.
     */
    where: SnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot findUniqueOrThrow
   */
  export type SnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter, which Snapshot to fetch.
     */
    where: SnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot findFirst
   */
  export type SnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter, which Snapshot to fetch.
     */
    where?: SnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snapshots to fetch.
     */
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snapshots.
     */
    cursor?: SnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snapshots.
     */
    distinct?: SnapshotScalarFieldEnum | SnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot findFirstOrThrow
   */
  export type SnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter, which Snapshot to fetch.
     */
    where?: SnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snapshots to fetch.
     */
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snapshots.
     */
    cursor?: SnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snapshots.
     */
    distinct?: SnapshotScalarFieldEnum | SnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot findMany
   */
  export type SnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter, which Snapshots to fetch.
     */
    where?: SnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snapshots to fetch.
     */
    orderBy?: SnapshotOrderByWithRelationInput | SnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snapshots.
     */
    cursor?: SnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snapshots.
     */
    skip?: number
    distinct?: SnapshotScalarFieldEnum | SnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot create
   */
  export type SnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a Snapshot.
     */
    data: XOR<SnapshotCreateInput, SnapshotUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot createMany
   */
  export type SnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snapshots.
     */
    data: SnapshotCreateManyInput | SnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snapshot createManyAndReturn
   */
  export type SnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many Snapshots.
     */
    data: SnapshotCreateManyInput | SnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snapshot update
   */
  export type SnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a Snapshot.
     */
    data: XOR<SnapshotUpdateInput, SnapshotUncheckedUpdateInput>
    /**
     * Choose, which Snapshot to update.
     */
    where: SnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot updateMany
   */
  export type SnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snapshots.
     */
    data: XOR<SnapshotUpdateManyMutationInput, SnapshotUncheckedUpdateManyInput>
    /**
     * Filter which Snapshots to update
     */
    where?: SnapshotWhereInput
    /**
     * Limit how many Snapshots to update.
     */
    limit?: number
  }

  /**
   * Snapshot updateManyAndReturn
   */
  export type SnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * The data used to update Snapshots.
     */
    data: XOR<SnapshotUpdateManyMutationInput, SnapshotUncheckedUpdateManyInput>
    /**
     * Filter which Snapshots to update
     */
    where?: SnapshotWhereInput
    /**
     * Limit how many Snapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snapshot upsert
   */
  export type SnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the Snapshot to update in case it exists.
     */
    where: SnapshotWhereUniqueInput
    /**
     * In case the Snapshot found by the `where` argument doesn't exist, create a new Snapshot with this data.
     */
    create: XOR<SnapshotCreateInput, SnapshotUncheckedCreateInput>
    /**
     * In case the Snapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnapshotUpdateInput, SnapshotUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot delete
   */
  export type SnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
    /**
     * Filter which Snapshot to delete.
     */
    where: SnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Snapshot deleteMany
   */
  export type SnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snapshots to delete
     */
    where?: SnapshotWhereInput
    /**
     * Limit how many Snapshots to delete.
     */
    limit?: number
  }

  /**
   * Snapshot.createdByUser
   */
  export type Snapshot$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Snapshot.updatedByUser
   */
  export type Snapshot$updatedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Snapshot.embedding
   */
  export type Snapshot$embeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    where?: AiWorkspaceEmbeddingWhereInput
    orderBy?: AiWorkspaceEmbeddingOrderByWithRelationInput | AiWorkspaceEmbeddingOrderByWithRelationInput[]
    cursor?: AiWorkspaceEmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiWorkspaceEmbeddingScalarFieldEnum | AiWorkspaceEmbeddingScalarFieldEnum[]
  }

  /**
   * Snapshot without action
   */
  export type SnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snapshot
     */
    select?: SnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snapshot
     */
    omit?: SnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotInclude<ExtArgs> | null
  }


  /**
   * Model UserSnapshot
   */

  export type AggregateUserSnapshot = {
    _count: UserSnapshotCountAggregateOutputType | null
    _min: UserSnapshotMinAggregateOutputType | null
    _max: UserSnapshotMaxAggregateOutputType | null
  }

  export type UserSnapshotMinAggregateOutputType = {
    userId: string | null
    id: string | null
    blob: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSnapshotMaxAggregateOutputType = {
    userId: string | null
    id: string | null
    blob: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSnapshotCountAggregateOutputType = {
    userId: number
    id: number
    blob: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSnapshotMinAggregateInputType = {
    userId?: true
    id?: true
    blob?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSnapshotMaxAggregateInputType = {
    userId?: true
    id?: true
    blob?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSnapshotCountAggregateInputType = {
    userId?: true
    id?: true
    blob?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSnapshot to aggregate.
     */
    where?: UserSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSnapshots to fetch.
     */
    orderBy?: UserSnapshotOrderByWithRelationInput | UserSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSnapshots
    **/
    _count?: true | UserSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSnapshotMaxAggregateInputType
  }

  export type GetUserSnapshotAggregateType<T extends UserSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSnapshot[P]>
      : GetScalarType<T[P], AggregateUserSnapshot[P]>
  }




  export type UserSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSnapshotWhereInput
    orderBy?: UserSnapshotOrderByWithAggregationInput | UserSnapshotOrderByWithAggregationInput[]
    by: UserSnapshotScalarFieldEnum[] | UserSnapshotScalarFieldEnum
    having?: UserSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSnapshotCountAggregateInputType | true
    _min?: UserSnapshotMinAggregateInputType
    _max?: UserSnapshotMaxAggregateInputType
  }

  export type UserSnapshotGroupByOutputType = {
    userId: string
    id: string
    blob: Uint8Array
    createdAt: Date
    updatedAt: Date
    _count: UserSnapshotCountAggregateOutputType | null
    _min: UserSnapshotMinAggregateOutputType | null
    _max: UserSnapshotMaxAggregateOutputType | null
  }

  type GetUserSnapshotGroupByPayload<T extends UserSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], UserSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type UserSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSnapshot"]>

  export type UserSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSnapshot"]>

  export type UserSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSnapshot"]>

  export type UserSnapshotSelectScalar = {
    userId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "id" | "blob" | "createdAt" | "updatedAt", ExtArgs["result"]["userSnapshot"]>
  export type UserSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSnapshot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      id: string
      blob: Uint8Array
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSnapshot"]>
    composites: {}
  }

  type UserSnapshotGetPayload<S extends boolean | null | undefined | UserSnapshotDefaultArgs> = $Result.GetResult<Prisma.$UserSnapshotPayload, S>

  type UserSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserSnapshotCountAggregateInputType | true
    }

  export interface UserSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSnapshot'], meta: { name: 'UserSnapshot' } }
    /**
     * Find zero or one UserSnapshot that matches the filter.
     * @param {UserSnapshotFindUniqueArgs} args - Arguments to find a UserSnapshot
     * @example
     * // Get one UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSnapshotFindUniqueArgs>(args: SelectSubset<T, UserSnapshotFindUniqueArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSnapshotFindUniqueOrThrowArgs} args - Arguments to find a UserSnapshot
     * @example
     * // Get one UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotFindFirstArgs} args - Arguments to find a UserSnapshot
     * @example
     * // Get one UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSnapshotFindFirstArgs>(args?: SelectSubset<T, UserSnapshotFindFirstArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotFindFirstOrThrowArgs} args - Arguments to find a UserSnapshot
     * @example
     * // Get one UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSnapshots
     * const userSnapshots = await prisma.userSnapshot.findMany()
     * 
     * // Get first 10 UserSnapshots
     * const userSnapshots = await prisma.userSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSnapshotWithUserIdOnly = await prisma.userSnapshot.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSnapshotFindManyArgs>(args?: SelectSubset<T, UserSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSnapshot.
     * @param {UserSnapshotCreateArgs} args - Arguments to create a UserSnapshot.
     * @example
     * // Create one UserSnapshot
     * const UserSnapshot = await prisma.userSnapshot.create({
     *   data: {
     *     // ... data to create a UserSnapshot
     *   }
     * })
     * 
     */
    create<T extends UserSnapshotCreateArgs>(args: SelectSubset<T, UserSnapshotCreateArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSnapshots.
     * @param {UserSnapshotCreateManyArgs} args - Arguments to create many UserSnapshots.
     * @example
     * // Create many UserSnapshots
     * const userSnapshot = await prisma.userSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSnapshotCreateManyArgs>(args?: SelectSubset<T, UserSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSnapshots and returns the data saved in the database.
     * @param {UserSnapshotCreateManyAndReturnArgs} args - Arguments to create many UserSnapshots.
     * @example
     * // Create many UserSnapshots
     * const userSnapshot = await prisma.userSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSnapshots and only return the `userId`
     * const userSnapshotWithUserIdOnly = await prisma.userSnapshot.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSnapshot.
     * @param {UserSnapshotDeleteArgs} args - Arguments to delete one UserSnapshot.
     * @example
     * // Delete one UserSnapshot
     * const UserSnapshot = await prisma.userSnapshot.delete({
     *   where: {
     *     // ... filter to delete one UserSnapshot
     *   }
     * })
     * 
     */
    delete<T extends UserSnapshotDeleteArgs>(args: SelectSubset<T, UserSnapshotDeleteArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSnapshot.
     * @param {UserSnapshotUpdateArgs} args - Arguments to update one UserSnapshot.
     * @example
     * // Update one UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSnapshotUpdateArgs>(args: SelectSubset<T, UserSnapshotUpdateArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSnapshots.
     * @param {UserSnapshotDeleteManyArgs} args - Arguments to filter UserSnapshots to delete.
     * @example
     * // Delete a few UserSnapshots
     * const { count } = await prisma.userSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSnapshotDeleteManyArgs>(args?: SelectSubset<T, UserSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSnapshots
     * const userSnapshot = await prisma.userSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSnapshotUpdateManyArgs>(args: SelectSubset<T, UserSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSnapshots and returns the data updated in the database.
     * @param {UserSnapshotUpdateManyAndReturnArgs} args - Arguments to update many UserSnapshots.
     * @example
     * // Update many UserSnapshots
     * const userSnapshot = await prisma.userSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSnapshots and only return the `userId`
     * const userSnapshotWithUserIdOnly = await prisma.userSnapshot.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSnapshot.
     * @param {UserSnapshotUpsertArgs} args - Arguments to update or create a UserSnapshot.
     * @example
     * // Update or create a UserSnapshot
     * const userSnapshot = await prisma.userSnapshot.upsert({
     *   create: {
     *     // ... data to create a UserSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends UserSnapshotUpsertArgs>(args: SelectSubset<T, UserSnapshotUpsertArgs<ExtArgs>>): Prisma__UserSnapshotClient<$Result.GetResult<Prisma.$UserSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotCountArgs} args - Arguments to filter UserSnapshots to count.
     * @example
     * // Count the number of UserSnapshots
     * const count = await prisma.userSnapshot.count({
     *   where: {
     *     // ... the filter for the UserSnapshots we want to count
     *   }
     * })
    **/
    count<T extends UserSnapshotCountArgs>(
      args?: Subset<T, UserSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSnapshotAggregateArgs>(args: Subset<T, UserSnapshotAggregateArgs>): Prisma.PrismaPromise<GetUserSnapshotAggregateType<T>>

    /**
     * Group by UserSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: UserSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSnapshot model
   */
  readonly fields: UserSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSnapshot model
   */
  interface UserSnapshotFieldRefs {
    readonly userId: FieldRef<"UserSnapshot", 'String'>
    readonly id: FieldRef<"UserSnapshot", 'String'>
    readonly blob: FieldRef<"UserSnapshot", 'Bytes'>
    readonly createdAt: FieldRef<"UserSnapshot", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSnapshot findUnique
   */
  export type UserSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which UserSnapshot to fetch.
     */
    where: UserSnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot findUniqueOrThrow
   */
  export type UserSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which UserSnapshot to fetch.
     */
    where: UserSnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot findFirst
   */
  export type UserSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which UserSnapshot to fetch.
     */
    where?: UserSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSnapshots to fetch.
     */
    orderBy?: UserSnapshotOrderByWithRelationInput | UserSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSnapshots.
     */
    cursor?: UserSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSnapshots.
     */
    distinct?: UserSnapshotScalarFieldEnum | UserSnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot findFirstOrThrow
   */
  export type UserSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which UserSnapshot to fetch.
     */
    where?: UserSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSnapshots to fetch.
     */
    orderBy?: UserSnapshotOrderByWithRelationInput | UserSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSnapshots.
     */
    cursor?: UserSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSnapshots.
     */
    distinct?: UserSnapshotScalarFieldEnum | UserSnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot findMany
   */
  export type UserSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which UserSnapshots to fetch.
     */
    where?: UserSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSnapshots to fetch.
     */
    orderBy?: UserSnapshotOrderByWithRelationInput | UserSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSnapshots.
     */
    cursor?: UserSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSnapshots.
     */
    skip?: number
    distinct?: UserSnapshotScalarFieldEnum | UserSnapshotScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot create
   */
  export type UserSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSnapshot.
     */
    data: XOR<UserSnapshotCreateInput, UserSnapshotUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot createMany
   */
  export type UserSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSnapshots.
     */
    data: UserSnapshotCreateManyInput | UserSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSnapshot createManyAndReturn
   */
  export type UserSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many UserSnapshots.
     */
    data: UserSnapshotCreateManyInput | UserSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSnapshot update
   */
  export type UserSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSnapshot.
     */
    data: XOR<UserSnapshotUpdateInput, UserSnapshotUncheckedUpdateInput>
    /**
     * Choose, which UserSnapshot to update.
     */
    where: UserSnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot updateMany
   */
  export type UserSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSnapshots.
     */
    data: XOR<UserSnapshotUpdateManyMutationInput, UserSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which UserSnapshots to update
     */
    where?: UserSnapshotWhereInput
    /**
     * Limit how many UserSnapshots to update.
     */
    limit?: number
  }

  /**
   * UserSnapshot updateManyAndReturn
   */
  export type UserSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update UserSnapshots.
     */
    data: XOR<UserSnapshotUpdateManyMutationInput, UserSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which UserSnapshots to update
     */
    where?: UserSnapshotWhereInput
    /**
     * Limit how many UserSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSnapshot upsert
   */
  export type UserSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSnapshot to update in case it exists.
     */
    where: UserSnapshotWhereUniqueInput
    /**
     * In case the UserSnapshot found by the `where` argument doesn't exist, create a new UserSnapshot with this data.
     */
    create: XOR<UserSnapshotCreateInput, UserSnapshotUncheckedCreateInput>
    /**
     * In case the UserSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSnapshotUpdateInput, UserSnapshotUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot delete
   */
  export type UserSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
    /**
     * Filter which UserSnapshot to delete.
     */
    where: UserSnapshotWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSnapshot deleteMany
   */
  export type UserSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSnapshots to delete
     */
    where?: UserSnapshotWhereInput
    /**
     * Limit how many UserSnapshots to delete.
     */
    limit?: number
  }

  /**
   * UserSnapshot without action
   */
  export type UserSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSnapshot
     */
    select?: UserSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSnapshot
     */
    omit?: UserSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model Update
   */

  export type AggregateUpdate = {
    _count: UpdateCountAggregateOutputType | null
    _avg: UpdateAvgAggregateOutputType | null
    _sum: UpdateSumAggregateOutputType | null
    _min: UpdateMinAggregateOutputType | null
    _max: UpdateMaxAggregateOutputType | null
  }

  export type UpdateAvgAggregateOutputType = {
    seq: number | null
  }

  export type UpdateSumAggregateOutputType = {
    seq: number | null
  }

  export type UpdateMinAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    blob: Uint8Array | null
    createdAt: Date | null
    createdBy: string | null
    seq: number | null
  }

  export type UpdateMaxAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    blob: Uint8Array | null
    createdAt: Date | null
    createdBy: string | null
    seq: number | null
  }

  export type UpdateCountAggregateOutputType = {
    workspaceId: number
    id: number
    blob: number
    createdAt: number
    createdBy: number
    seq: number
    _all: number
  }


  export type UpdateAvgAggregateInputType = {
    seq?: true
  }

  export type UpdateSumAggregateInputType = {
    seq?: true
  }

  export type UpdateMinAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    createdAt?: true
    createdBy?: true
    seq?: true
  }

  export type UpdateMaxAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    createdAt?: true
    createdBy?: true
    seq?: true
  }

  export type UpdateCountAggregateInputType = {
    workspaceId?: true
    id?: true
    blob?: true
    createdAt?: true
    createdBy?: true
    seq?: true
    _all?: true
  }

  export type UpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Update to aggregate.
     */
    where?: UpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Updates to fetch.
     */
    orderBy?: UpdateOrderByWithRelationInput | UpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Updates
    **/
    _count?: true | UpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UpdateMaxAggregateInputType
  }

  export type GetUpdateAggregateType<T extends UpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpdate[P]>
      : GetScalarType<T[P], AggregateUpdate[P]>
  }




  export type UpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UpdateWhereInput
    orderBy?: UpdateOrderByWithAggregationInput | UpdateOrderByWithAggregationInput[]
    by: UpdateScalarFieldEnum[] | UpdateScalarFieldEnum
    having?: UpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UpdateCountAggregateInputType | true
    _avg?: UpdateAvgAggregateInputType
    _sum?: UpdateSumAggregateInputType
    _min?: UpdateMinAggregateInputType
    _max?: UpdateMaxAggregateInputType
  }

  export type UpdateGroupByOutputType = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date
    createdBy: string | null
    seq: number | null
    _count: UpdateCountAggregateOutputType | null
    _avg: UpdateAvgAggregateOutputType | null
    _sum: UpdateSumAggregateOutputType | null
    _min: UpdateMinAggregateOutputType | null
    _max: UpdateMaxAggregateOutputType | null
  }

  type GetUpdateGroupByPayload<T extends UpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UpdateGroupByOutputType[P]>
            : GetScalarType<T[P], UpdateGroupByOutputType[P]>
        }
      >
    >


  export type UpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    createdBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["update"]>

  export type UpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    createdBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["update"]>

  export type UpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    createdBy?: boolean
    seq?: boolean
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["update"]>

  export type UpdateSelectScalar = {
    workspaceId?: boolean
    id?: boolean
    blob?: boolean
    createdAt?: boolean
    createdBy?: boolean
    seq?: boolean
  }

  export type UpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "id" | "blob" | "createdAt" | "createdBy" | "seq", ExtArgs["result"]["update"]>
  export type UpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }
  export type UpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }
  export type UpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | Update$createdByUserArgs<ExtArgs>
  }

  export type $UpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Update"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      id: string
      blob: Uint8Array
      createdAt: Date
      createdBy: string | null
      seq: number | null
    }, ExtArgs["result"]["update"]>
    composites: {}
  }

  type UpdateGetPayload<S extends boolean | null | undefined | UpdateDefaultArgs> = $Result.GetResult<Prisma.$UpdatePayload, S>

  type UpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UpdateCountAggregateInputType | true
    }

  export interface UpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Update'], meta: { name: 'Update' } }
    /**
     * Find zero or one Update that matches the filter.
     * @param {UpdateFindUniqueArgs} args - Arguments to find a Update
     * @example
     * // Get one Update
     * const update = await prisma.update.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UpdateFindUniqueArgs>(args: SelectSubset<T, UpdateFindUniqueArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Update that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UpdateFindUniqueOrThrowArgs} args - Arguments to find a Update
     * @example
     * // Get one Update
     * const update = await prisma.update.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, UpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Update that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateFindFirstArgs} args - Arguments to find a Update
     * @example
     * // Get one Update
     * const update = await prisma.update.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UpdateFindFirstArgs>(args?: SelectSubset<T, UpdateFindFirstArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Update that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateFindFirstOrThrowArgs} args - Arguments to find a Update
     * @example
     * // Get one Update
     * const update = await prisma.update.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, UpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Updates
     * const updates = await prisma.update.findMany()
     * 
     * // Get first 10 Updates
     * const updates = await prisma.update.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const updateWithWorkspaceIdOnly = await prisma.update.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends UpdateFindManyArgs>(args?: SelectSubset<T, UpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Update.
     * @param {UpdateCreateArgs} args - Arguments to create a Update.
     * @example
     * // Create one Update
     * const Update = await prisma.update.create({
     *   data: {
     *     // ... data to create a Update
     *   }
     * })
     * 
     */
    create<T extends UpdateCreateArgs>(args: SelectSubset<T, UpdateCreateArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Updates.
     * @param {UpdateCreateManyArgs} args - Arguments to create many Updates.
     * @example
     * // Create many Updates
     * const update = await prisma.update.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UpdateCreateManyArgs>(args?: SelectSubset<T, UpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Updates and returns the data saved in the database.
     * @param {UpdateCreateManyAndReturnArgs} args - Arguments to create many Updates.
     * @example
     * // Create many Updates
     * const update = await prisma.update.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Updates and only return the `workspaceId`
     * const updateWithWorkspaceIdOnly = await prisma.update.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, UpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Update.
     * @param {UpdateDeleteArgs} args - Arguments to delete one Update.
     * @example
     * // Delete one Update
     * const Update = await prisma.update.delete({
     *   where: {
     *     // ... filter to delete one Update
     *   }
     * })
     * 
     */
    delete<T extends UpdateDeleteArgs>(args: SelectSubset<T, UpdateDeleteArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Update.
     * @param {UpdateUpdateArgs} args - Arguments to update one Update.
     * @example
     * // Update one Update
     * const update = await prisma.update.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UpdateUpdateArgs>(args: SelectSubset<T, UpdateUpdateArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Updates.
     * @param {UpdateDeleteManyArgs} args - Arguments to filter Updates to delete.
     * @example
     * // Delete a few Updates
     * const { count } = await prisma.update.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UpdateDeleteManyArgs>(args?: SelectSubset<T, UpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Updates
     * const update = await prisma.update.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UpdateUpdateManyArgs>(args: SelectSubset<T, UpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Updates and returns the data updated in the database.
     * @param {UpdateUpdateManyAndReturnArgs} args - Arguments to update many Updates.
     * @example
     * // Update many Updates
     * const update = await prisma.update.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Updates and only return the `workspaceId`
     * const updateWithWorkspaceIdOnly = await prisma.update.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, UpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Update.
     * @param {UpdateUpsertArgs} args - Arguments to update or create a Update.
     * @example
     * // Update or create a Update
     * const update = await prisma.update.upsert({
     *   create: {
     *     // ... data to create a Update
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Update we want to update
     *   }
     * })
     */
    upsert<T extends UpdateUpsertArgs>(args: SelectSubset<T, UpdateUpsertArgs<ExtArgs>>): Prisma__UpdateClient<$Result.GetResult<Prisma.$UpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateCountArgs} args - Arguments to filter Updates to count.
     * @example
     * // Count the number of Updates
     * const count = await prisma.update.count({
     *   where: {
     *     // ... the filter for the Updates we want to count
     *   }
     * })
    **/
    count<T extends UpdateCountArgs>(
      args?: Subset<T, UpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UpdateAggregateArgs>(args: Subset<T, UpdateAggregateArgs>): Prisma.PrismaPromise<GetUpdateAggregateType<T>>

    /**
     * Group by Update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UpdateGroupByArgs['orderBy'] }
        : { orderBy?: UpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Update model
   */
  readonly fields: UpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Update.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends Update$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, Update$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Update model
   */
  interface UpdateFieldRefs {
    readonly workspaceId: FieldRef<"Update", 'String'>
    readonly id: FieldRef<"Update", 'String'>
    readonly blob: FieldRef<"Update", 'Bytes'>
    readonly createdAt: FieldRef<"Update", 'DateTime'>
    readonly createdBy: FieldRef<"Update", 'String'>
    readonly seq: FieldRef<"Update", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Update findUnique
   */
  export type UpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter, which Update to fetch.
     */
    where: UpdateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update findUniqueOrThrow
   */
  export type UpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter, which Update to fetch.
     */
    where: UpdateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update findFirst
   */
  export type UpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter, which Update to fetch.
     */
    where?: UpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Updates to fetch.
     */
    orderBy?: UpdateOrderByWithRelationInput | UpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Updates.
     */
    cursor?: UpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Updates.
     */
    distinct?: UpdateScalarFieldEnum | UpdateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update findFirstOrThrow
   */
  export type UpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter, which Update to fetch.
     */
    where?: UpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Updates to fetch.
     */
    orderBy?: UpdateOrderByWithRelationInput | UpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Updates.
     */
    cursor?: UpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Updates.
     */
    distinct?: UpdateScalarFieldEnum | UpdateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update findMany
   */
  export type UpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter, which Updates to fetch.
     */
    where?: UpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Updates to fetch.
     */
    orderBy?: UpdateOrderByWithRelationInput | UpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Updates.
     */
    cursor?: UpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Updates.
     */
    skip?: number
    distinct?: UpdateScalarFieldEnum | UpdateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update create
   */
  export type UpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a Update.
     */
    data: XOR<UpdateCreateInput, UpdateUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update createMany
   */
  export type UpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Updates.
     */
    data: UpdateCreateManyInput | UpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Update createManyAndReturn
   */
  export type UpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * The data used to create many Updates.
     */
    data: UpdateCreateManyInput | UpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Update update
   */
  export type UpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a Update.
     */
    data: XOR<UpdateUpdateInput, UpdateUncheckedUpdateInput>
    /**
     * Choose, which Update to update.
     */
    where: UpdateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update updateMany
   */
  export type UpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Updates.
     */
    data: XOR<UpdateUpdateManyMutationInput, UpdateUncheckedUpdateManyInput>
    /**
     * Filter which Updates to update
     */
    where?: UpdateWhereInput
    /**
     * Limit how many Updates to update.
     */
    limit?: number
  }

  /**
   * Update updateManyAndReturn
   */
  export type UpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * The data used to update Updates.
     */
    data: XOR<UpdateUpdateManyMutationInput, UpdateUncheckedUpdateManyInput>
    /**
     * Filter which Updates to update
     */
    where?: UpdateWhereInput
    /**
     * Limit how many Updates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Update upsert
   */
  export type UpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the Update to update in case it exists.
     */
    where: UpdateWhereUniqueInput
    /**
     * In case the Update found by the `where` argument doesn't exist, create a new Update with this data.
     */
    create: XOR<UpdateCreateInput, UpdateUncheckedCreateInput>
    /**
     * In case the Update was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UpdateUpdateInput, UpdateUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update delete
   */
  export type UpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
    /**
     * Filter which Update to delete.
     */
    where: UpdateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Update deleteMany
   */
  export type UpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Updates to delete
     */
    where?: UpdateWhereInput
    /**
     * Limit how many Updates to delete.
     */
    limit?: number
  }

  /**
   * Update.createdByUser
   */
  export type Update$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Update without action
   */
  export type UpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Update
     */
    select?: UpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Update
     */
    omit?: UpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UpdateInclude<ExtArgs> | null
  }


  /**
   * Model SnapshotHistory
   */

  export type AggregateSnapshotHistory = {
    _count: SnapshotHistoryCountAggregateOutputType | null
    _min: SnapshotHistoryMinAggregateOutputType | null
    _max: SnapshotHistoryMaxAggregateOutputType | null
  }

  export type SnapshotHistoryMinAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    timestamp: Date | null
    blob: Uint8Array | null
    state: Uint8Array | null
    expiredAt: Date | null
    createdBy: string | null
  }

  export type SnapshotHistoryMaxAggregateOutputType = {
    workspaceId: string | null
    id: string | null
    timestamp: Date | null
    blob: Uint8Array | null
    state: Uint8Array | null
    expiredAt: Date | null
    createdBy: string | null
  }

  export type SnapshotHistoryCountAggregateOutputType = {
    workspaceId: number
    id: number
    timestamp: number
    blob: number
    state: number
    expiredAt: number
    createdBy: number
    _all: number
  }


  export type SnapshotHistoryMinAggregateInputType = {
    workspaceId?: true
    id?: true
    timestamp?: true
    blob?: true
    state?: true
    expiredAt?: true
    createdBy?: true
  }

  export type SnapshotHistoryMaxAggregateInputType = {
    workspaceId?: true
    id?: true
    timestamp?: true
    blob?: true
    state?: true
    expiredAt?: true
    createdBy?: true
  }

  export type SnapshotHistoryCountAggregateInputType = {
    workspaceId?: true
    id?: true
    timestamp?: true
    blob?: true
    state?: true
    expiredAt?: true
    createdBy?: true
    _all?: true
  }

  export type SnapshotHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SnapshotHistory to aggregate.
     */
    where?: SnapshotHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SnapshotHistories to fetch.
     */
    orderBy?: SnapshotHistoryOrderByWithRelationInput | SnapshotHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnapshotHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SnapshotHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SnapshotHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SnapshotHistories
    **/
    _count?: true | SnapshotHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnapshotHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnapshotHistoryMaxAggregateInputType
  }

  export type GetSnapshotHistoryAggregateType<T extends SnapshotHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSnapshotHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnapshotHistory[P]>
      : GetScalarType<T[P], AggregateSnapshotHistory[P]>
  }




  export type SnapshotHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnapshotHistoryWhereInput
    orderBy?: SnapshotHistoryOrderByWithAggregationInput | SnapshotHistoryOrderByWithAggregationInput[]
    by: SnapshotHistoryScalarFieldEnum[] | SnapshotHistoryScalarFieldEnum
    having?: SnapshotHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnapshotHistoryCountAggregateInputType | true
    _min?: SnapshotHistoryMinAggregateInputType
    _max?: SnapshotHistoryMaxAggregateInputType
  }

  export type SnapshotHistoryGroupByOutputType = {
    workspaceId: string
    id: string
    timestamp: Date
    blob: Uint8Array
    state: Uint8Array | null
    expiredAt: Date
    createdBy: string | null
    _count: SnapshotHistoryCountAggregateOutputType | null
    _min: SnapshotHistoryMinAggregateOutputType | null
    _max: SnapshotHistoryMaxAggregateOutputType | null
  }

  type GetSnapshotHistoryGroupByPayload<T extends SnapshotHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnapshotHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnapshotHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnapshotHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SnapshotHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SnapshotHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    timestamp?: boolean
    blob?: boolean
    state?: boolean
    expiredAt?: boolean
    createdBy?: boolean
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["snapshotHistory"]>

  export type SnapshotHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    timestamp?: boolean
    blob?: boolean
    state?: boolean
    expiredAt?: boolean
    createdBy?: boolean
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["snapshotHistory"]>

  export type SnapshotHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    id?: boolean
    timestamp?: boolean
    blob?: boolean
    state?: boolean
    expiredAt?: boolean
    createdBy?: boolean
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["snapshotHistory"]>

  export type SnapshotHistorySelectScalar = {
    workspaceId?: boolean
    id?: boolean
    timestamp?: boolean
    blob?: boolean
    state?: boolean
    expiredAt?: boolean
    createdBy?: boolean
  }

  export type SnapshotHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "id" | "timestamp" | "blob" | "state" | "expiredAt" | "createdBy", ExtArgs["result"]["snapshotHistory"]>
  export type SnapshotHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }
  export type SnapshotHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }
  export type SnapshotHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | SnapshotHistory$createdByUserArgs<ExtArgs>
  }

  export type $SnapshotHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SnapshotHistory"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      id: string
      timestamp: Date
      blob: Uint8Array
      state: Uint8Array | null
      expiredAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["snapshotHistory"]>
    composites: {}
  }

  type SnapshotHistoryGetPayload<S extends boolean | null | undefined | SnapshotHistoryDefaultArgs> = $Result.GetResult<Prisma.$SnapshotHistoryPayload, S>

  type SnapshotHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SnapshotHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SnapshotHistoryCountAggregateInputType | true
    }

  export interface SnapshotHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SnapshotHistory'], meta: { name: 'SnapshotHistory' } }
    /**
     * Find zero or one SnapshotHistory that matches the filter.
     * @param {SnapshotHistoryFindUniqueArgs} args - Arguments to find a SnapshotHistory
     * @example
     * // Get one SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnapshotHistoryFindUniqueArgs>(args: SelectSubset<T, SnapshotHistoryFindUniqueArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SnapshotHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SnapshotHistoryFindUniqueOrThrowArgs} args - Arguments to find a SnapshotHistory
     * @example
     * // Get one SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnapshotHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SnapshotHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SnapshotHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryFindFirstArgs} args - Arguments to find a SnapshotHistory
     * @example
     * // Get one SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnapshotHistoryFindFirstArgs>(args?: SelectSubset<T, SnapshotHistoryFindFirstArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SnapshotHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryFindFirstOrThrowArgs} args - Arguments to find a SnapshotHistory
     * @example
     * // Get one SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnapshotHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SnapshotHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SnapshotHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SnapshotHistories
     * const snapshotHistories = await prisma.snapshotHistory.findMany()
     * 
     * // Get first 10 SnapshotHistories
     * const snapshotHistories = await prisma.snapshotHistory.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const snapshotHistoryWithWorkspaceIdOnly = await prisma.snapshotHistory.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends SnapshotHistoryFindManyArgs>(args?: SelectSubset<T, SnapshotHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SnapshotHistory.
     * @param {SnapshotHistoryCreateArgs} args - Arguments to create a SnapshotHistory.
     * @example
     * // Create one SnapshotHistory
     * const SnapshotHistory = await prisma.snapshotHistory.create({
     *   data: {
     *     // ... data to create a SnapshotHistory
     *   }
     * })
     * 
     */
    create<T extends SnapshotHistoryCreateArgs>(args: SelectSubset<T, SnapshotHistoryCreateArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SnapshotHistories.
     * @param {SnapshotHistoryCreateManyArgs} args - Arguments to create many SnapshotHistories.
     * @example
     * // Create many SnapshotHistories
     * const snapshotHistory = await prisma.snapshotHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnapshotHistoryCreateManyArgs>(args?: SelectSubset<T, SnapshotHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SnapshotHistories and returns the data saved in the database.
     * @param {SnapshotHistoryCreateManyAndReturnArgs} args - Arguments to create many SnapshotHistories.
     * @example
     * // Create many SnapshotHistories
     * const snapshotHistory = await prisma.snapshotHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SnapshotHistories and only return the `workspaceId`
     * const snapshotHistoryWithWorkspaceIdOnly = await prisma.snapshotHistory.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnapshotHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SnapshotHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SnapshotHistory.
     * @param {SnapshotHistoryDeleteArgs} args - Arguments to delete one SnapshotHistory.
     * @example
     * // Delete one SnapshotHistory
     * const SnapshotHistory = await prisma.snapshotHistory.delete({
     *   where: {
     *     // ... filter to delete one SnapshotHistory
     *   }
     * })
     * 
     */
    delete<T extends SnapshotHistoryDeleteArgs>(args: SelectSubset<T, SnapshotHistoryDeleteArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SnapshotHistory.
     * @param {SnapshotHistoryUpdateArgs} args - Arguments to update one SnapshotHistory.
     * @example
     * // Update one SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnapshotHistoryUpdateArgs>(args: SelectSubset<T, SnapshotHistoryUpdateArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SnapshotHistories.
     * @param {SnapshotHistoryDeleteManyArgs} args - Arguments to filter SnapshotHistories to delete.
     * @example
     * // Delete a few SnapshotHistories
     * const { count } = await prisma.snapshotHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnapshotHistoryDeleteManyArgs>(args?: SelectSubset<T, SnapshotHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SnapshotHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SnapshotHistories
     * const snapshotHistory = await prisma.snapshotHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnapshotHistoryUpdateManyArgs>(args: SelectSubset<T, SnapshotHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SnapshotHistories and returns the data updated in the database.
     * @param {SnapshotHistoryUpdateManyAndReturnArgs} args - Arguments to update many SnapshotHistories.
     * @example
     * // Update many SnapshotHistories
     * const snapshotHistory = await prisma.snapshotHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SnapshotHistories and only return the `workspaceId`
     * const snapshotHistoryWithWorkspaceIdOnly = await prisma.snapshotHistory.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SnapshotHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SnapshotHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SnapshotHistory.
     * @param {SnapshotHistoryUpsertArgs} args - Arguments to update or create a SnapshotHistory.
     * @example
     * // Update or create a SnapshotHistory
     * const snapshotHistory = await prisma.snapshotHistory.upsert({
     *   create: {
     *     // ... data to create a SnapshotHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SnapshotHistory we want to update
     *   }
     * })
     */
    upsert<T extends SnapshotHistoryUpsertArgs>(args: SelectSubset<T, SnapshotHistoryUpsertArgs<ExtArgs>>): Prisma__SnapshotHistoryClient<$Result.GetResult<Prisma.$SnapshotHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SnapshotHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryCountArgs} args - Arguments to filter SnapshotHistories to count.
     * @example
     * // Count the number of SnapshotHistories
     * const count = await prisma.snapshotHistory.count({
     *   where: {
     *     // ... the filter for the SnapshotHistories we want to count
     *   }
     * })
    **/
    count<T extends SnapshotHistoryCountArgs>(
      args?: Subset<T, SnapshotHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnapshotHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SnapshotHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnapshotHistoryAggregateArgs>(args: Subset<T, SnapshotHistoryAggregateArgs>): Prisma.PrismaPromise<GetSnapshotHistoryAggregateType<T>>

    /**
     * Group by SnapshotHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnapshotHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnapshotHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnapshotHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SnapshotHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnapshotHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnapshotHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SnapshotHistory model
   */
  readonly fields: SnapshotHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SnapshotHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnapshotHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends SnapshotHistory$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, SnapshotHistory$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SnapshotHistory model
   */
  interface SnapshotHistoryFieldRefs {
    readonly workspaceId: FieldRef<"SnapshotHistory", 'String'>
    readonly id: FieldRef<"SnapshotHistory", 'String'>
    readonly timestamp: FieldRef<"SnapshotHistory", 'DateTime'>
    readonly blob: FieldRef<"SnapshotHistory", 'Bytes'>
    readonly state: FieldRef<"SnapshotHistory", 'Bytes'>
    readonly expiredAt: FieldRef<"SnapshotHistory", 'DateTime'>
    readonly createdBy: FieldRef<"SnapshotHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SnapshotHistory findUnique
   */
  export type SnapshotHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SnapshotHistory to fetch.
     */
    where: SnapshotHistoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory findUniqueOrThrow
   */
  export type SnapshotHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SnapshotHistory to fetch.
     */
    where: SnapshotHistoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory findFirst
   */
  export type SnapshotHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SnapshotHistory to fetch.
     */
    where?: SnapshotHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SnapshotHistories to fetch.
     */
    orderBy?: SnapshotHistoryOrderByWithRelationInput | SnapshotHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SnapshotHistories.
     */
    cursor?: SnapshotHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SnapshotHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SnapshotHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SnapshotHistories.
     */
    distinct?: SnapshotHistoryScalarFieldEnum | SnapshotHistoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory findFirstOrThrow
   */
  export type SnapshotHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SnapshotHistory to fetch.
     */
    where?: SnapshotHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SnapshotHistories to fetch.
     */
    orderBy?: SnapshotHistoryOrderByWithRelationInput | SnapshotHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SnapshotHistories.
     */
    cursor?: SnapshotHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SnapshotHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SnapshotHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SnapshotHistories.
     */
    distinct?: SnapshotHistoryScalarFieldEnum | SnapshotHistoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory findMany
   */
  export type SnapshotHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SnapshotHistories to fetch.
     */
    where?: SnapshotHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SnapshotHistories to fetch.
     */
    orderBy?: SnapshotHistoryOrderByWithRelationInput | SnapshotHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SnapshotHistories.
     */
    cursor?: SnapshotHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SnapshotHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SnapshotHistories.
     */
    skip?: number
    distinct?: SnapshotHistoryScalarFieldEnum | SnapshotHistoryScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory create
   */
  export type SnapshotHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SnapshotHistory.
     */
    data: XOR<SnapshotHistoryCreateInput, SnapshotHistoryUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory createMany
   */
  export type SnapshotHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SnapshotHistories.
     */
    data: SnapshotHistoryCreateManyInput | SnapshotHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SnapshotHistory createManyAndReturn
   */
  export type SnapshotHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SnapshotHistories.
     */
    data: SnapshotHistoryCreateManyInput | SnapshotHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SnapshotHistory update
   */
  export type SnapshotHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SnapshotHistory.
     */
    data: XOR<SnapshotHistoryUpdateInput, SnapshotHistoryUncheckedUpdateInput>
    /**
     * Choose, which SnapshotHistory to update.
     */
    where: SnapshotHistoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory updateMany
   */
  export type SnapshotHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SnapshotHistories.
     */
    data: XOR<SnapshotHistoryUpdateManyMutationInput, SnapshotHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SnapshotHistories to update
     */
    where?: SnapshotHistoryWhereInput
    /**
     * Limit how many SnapshotHistories to update.
     */
    limit?: number
  }

  /**
   * SnapshotHistory updateManyAndReturn
   */
  export type SnapshotHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SnapshotHistories.
     */
    data: XOR<SnapshotHistoryUpdateManyMutationInput, SnapshotHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SnapshotHistories to update
     */
    where?: SnapshotHistoryWhereInput
    /**
     * Limit how many SnapshotHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SnapshotHistory upsert
   */
  export type SnapshotHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SnapshotHistory to update in case it exists.
     */
    where: SnapshotHistoryWhereUniqueInput
    /**
     * In case the SnapshotHistory found by the `where` argument doesn't exist, create a new SnapshotHistory with this data.
     */
    create: XOR<SnapshotHistoryCreateInput, SnapshotHistoryUncheckedCreateInput>
    /**
     * In case the SnapshotHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnapshotHistoryUpdateInput, SnapshotHistoryUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory delete
   */
  export type SnapshotHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
    /**
     * Filter which SnapshotHistory to delete.
     */
    where: SnapshotHistoryWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SnapshotHistory deleteMany
   */
  export type SnapshotHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SnapshotHistories to delete
     */
    where?: SnapshotHistoryWhereInput
    /**
     * Limit how many SnapshotHistories to delete.
     */
    limit?: number
  }

  /**
   * SnapshotHistory.createdByUser
   */
  export type SnapshotHistory$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SnapshotHistory without action
   */
  export type SnapshotHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnapshotHistory
     */
    select?: SnapshotHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SnapshotHistory
     */
    omit?: SnapshotHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnapshotHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AiPromptMessage
   */

  export type AggregateAiPromptMessage = {
    _count: AiPromptMessageCountAggregateOutputType | null
    _avg: AiPromptMessageAvgAggregateOutputType | null
    _sum: AiPromptMessageSumAggregateOutputType | null
    _min: AiPromptMessageMinAggregateOutputType | null
    _max: AiPromptMessageMaxAggregateOutputType | null
  }

  export type AiPromptMessageAvgAggregateOutputType = {
    promptId: number | null
    idx: number | null
  }

  export type AiPromptMessageSumAggregateOutputType = {
    promptId: number | null
    idx: number | null
  }

  export type AiPromptMessageMinAggregateOutputType = {
    promptId: number | null
    idx: number | null
    role: $Enums.AiPromptRole | null
    content: string | null
    createdAt: Date | null
  }

  export type AiPromptMessageMaxAggregateOutputType = {
    promptId: number | null
    idx: number | null
    role: $Enums.AiPromptRole | null
    content: string | null
    createdAt: Date | null
  }

  export type AiPromptMessageCountAggregateOutputType = {
    promptId: number
    idx: number
    role: number
    content: number
    attachments: number
    params: number
    createdAt: number
    _all: number
  }


  export type AiPromptMessageAvgAggregateInputType = {
    promptId?: true
    idx?: true
  }

  export type AiPromptMessageSumAggregateInputType = {
    promptId?: true
    idx?: true
  }

  export type AiPromptMessageMinAggregateInputType = {
    promptId?: true
    idx?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AiPromptMessageMaxAggregateInputType = {
    promptId?: true
    idx?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type AiPromptMessageCountAggregateInputType = {
    promptId?: true
    idx?: true
    role?: true
    content?: true
    attachments?: true
    params?: true
    createdAt?: true
    _all?: true
  }

  export type AiPromptMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPromptMessage to aggregate.
     */
    where?: AiPromptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPromptMessages to fetch.
     */
    orderBy?: AiPromptMessageOrderByWithRelationInput | AiPromptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiPromptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPromptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPromptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiPromptMessages
    **/
    _count?: true | AiPromptMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiPromptMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiPromptMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiPromptMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiPromptMessageMaxAggregateInputType
  }

  export type GetAiPromptMessageAggregateType<T extends AiPromptMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiPromptMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiPromptMessage[P]>
      : GetScalarType<T[P], AggregateAiPromptMessage[P]>
  }




  export type AiPromptMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiPromptMessageWhereInput
    orderBy?: AiPromptMessageOrderByWithAggregationInput | AiPromptMessageOrderByWithAggregationInput[]
    by: AiPromptMessageScalarFieldEnum[] | AiPromptMessageScalarFieldEnum
    having?: AiPromptMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiPromptMessageCountAggregateInputType | true
    _avg?: AiPromptMessageAvgAggregateInputType
    _sum?: AiPromptMessageSumAggregateInputType
    _min?: AiPromptMessageMinAggregateInputType
    _max?: AiPromptMessageMaxAggregateInputType
  }

  export type AiPromptMessageGroupByOutputType = {
    promptId: number
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments: JsonValue | null
    params: JsonValue | null
    createdAt: Date
    _count: AiPromptMessageCountAggregateOutputType | null
    _avg: AiPromptMessageAvgAggregateOutputType | null
    _sum: AiPromptMessageSumAggregateOutputType | null
    _min: AiPromptMessageMinAggregateOutputType | null
    _max: AiPromptMessageMaxAggregateOutputType | null
  }

  type GetAiPromptMessageGroupByPayload<T extends AiPromptMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiPromptMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiPromptMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiPromptMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AiPromptMessageGroupByOutputType[P]>
        }
      >
    >


  export type AiPromptMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    promptId?: boolean
    idx?: boolean
    role?: boolean
    content?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPromptMessage"]>

  export type AiPromptMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    promptId?: boolean
    idx?: boolean
    role?: boolean
    content?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPromptMessage"]>

  export type AiPromptMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    promptId?: boolean
    idx?: boolean
    role?: boolean
    content?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPromptMessage"]>

  export type AiPromptMessageSelectScalar = {
    promptId?: boolean
    idx?: boolean
    role?: boolean
    content?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
  }

  export type AiPromptMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"promptId" | "idx" | "role" | "content" | "attachments" | "params" | "createdAt", ExtArgs["result"]["aiPromptMessage"]>
  export type AiPromptMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }
  export type AiPromptMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }
  export type AiPromptMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }

  export type $AiPromptMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiPromptMessage"
    objects: {
      prompt: Prisma.$AiPromptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      promptId: number
      idx: number
      role: $Enums.AiPromptRole
      content: string
      attachments: Prisma.JsonValue | null
      params: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["aiPromptMessage"]>
    composites: {}
  }

  type AiPromptMessageGetPayload<S extends boolean | null | undefined | AiPromptMessageDefaultArgs> = $Result.GetResult<Prisma.$AiPromptMessagePayload, S>

  type AiPromptMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiPromptMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiPromptMessageCountAggregateInputType | true
    }

  export interface AiPromptMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiPromptMessage'], meta: { name: 'AiPromptMessage' } }
    /**
     * Find zero or one AiPromptMessage that matches the filter.
     * @param {AiPromptMessageFindUniqueArgs} args - Arguments to find a AiPromptMessage
     * @example
     * // Get one AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiPromptMessageFindUniqueArgs>(args: SelectSubset<T, AiPromptMessageFindUniqueArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiPromptMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiPromptMessageFindUniqueOrThrowArgs} args - Arguments to find a AiPromptMessage
     * @example
     * // Get one AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiPromptMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiPromptMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPromptMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageFindFirstArgs} args - Arguments to find a AiPromptMessage
     * @example
     * // Get one AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiPromptMessageFindFirstArgs>(args?: SelectSubset<T, AiPromptMessageFindFirstArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPromptMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageFindFirstOrThrowArgs} args - Arguments to find a AiPromptMessage
     * @example
     * // Get one AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiPromptMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiPromptMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiPromptMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiPromptMessages
     * const aiPromptMessages = await prisma.aiPromptMessage.findMany()
     * 
     * // Get first 10 AiPromptMessages
     * const aiPromptMessages = await prisma.aiPromptMessage.findMany({ take: 10 })
     * 
     * // Only select the `promptId`
     * const aiPromptMessageWithPromptIdOnly = await prisma.aiPromptMessage.findMany({ select: { promptId: true } })
     * 
     */
    findMany<T extends AiPromptMessageFindManyArgs>(args?: SelectSubset<T, AiPromptMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiPromptMessage.
     * @param {AiPromptMessageCreateArgs} args - Arguments to create a AiPromptMessage.
     * @example
     * // Create one AiPromptMessage
     * const AiPromptMessage = await prisma.aiPromptMessage.create({
     *   data: {
     *     // ... data to create a AiPromptMessage
     *   }
     * })
     * 
     */
    create<T extends AiPromptMessageCreateArgs>(args: SelectSubset<T, AiPromptMessageCreateArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiPromptMessages.
     * @param {AiPromptMessageCreateManyArgs} args - Arguments to create many AiPromptMessages.
     * @example
     * // Create many AiPromptMessages
     * const aiPromptMessage = await prisma.aiPromptMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiPromptMessageCreateManyArgs>(args?: SelectSubset<T, AiPromptMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiPromptMessages and returns the data saved in the database.
     * @param {AiPromptMessageCreateManyAndReturnArgs} args - Arguments to create many AiPromptMessages.
     * @example
     * // Create many AiPromptMessages
     * const aiPromptMessage = await prisma.aiPromptMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiPromptMessages and only return the `promptId`
     * const aiPromptMessageWithPromptIdOnly = await prisma.aiPromptMessage.createManyAndReturn({
     *   select: { promptId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiPromptMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AiPromptMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiPromptMessage.
     * @param {AiPromptMessageDeleteArgs} args - Arguments to delete one AiPromptMessage.
     * @example
     * // Delete one AiPromptMessage
     * const AiPromptMessage = await prisma.aiPromptMessage.delete({
     *   where: {
     *     // ... filter to delete one AiPromptMessage
     *   }
     * })
     * 
     */
    delete<T extends AiPromptMessageDeleteArgs>(args: SelectSubset<T, AiPromptMessageDeleteArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiPromptMessage.
     * @param {AiPromptMessageUpdateArgs} args - Arguments to update one AiPromptMessage.
     * @example
     * // Update one AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiPromptMessageUpdateArgs>(args: SelectSubset<T, AiPromptMessageUpdateArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiPromptMessages.
     * @param {AiPromptMessageDeleteManyArgs} args - Arguments to filter AiPromptMessages to delete.
     * @example
     * // Delete a few AiPromptMessages
     * const { count } = await prisma.aiPromptMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiPromptMessageDeleteManyArgs>(args?: SelectSubset<T, AiPromptMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPromptMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiPromptMessages
     * const aiPromptMessage = await prisma.aiPromptMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiPromptMessageUpdateManyArgs>(args: SelectSubset<T, AiPromptMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPromptMessages and returns the data updated in the database.
     * @param {AiPromptMessageUpdateManyAndReturnArgs} args - Arguments to update many AiPromptMessages.
     * @example
     * // Update many AiPromptMessages
     * const aiPromptMessage = await prisma.aiPromptMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiPromptMessages and only return the `promptId`
     * const aiPromptMessageWithPromptIdOnly = await prisma.aiPromptMessage.updateManyAndReturn({
     *   select: { promptId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiPromptMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AiPromptMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiPromptMessage.
     * @param {AiPromptMessageUpsertArgs} args - Arguments to update or create a AiPromptMessage.
     * @example
     * // Update or create a AiPromptMessage
     * const aiPromptMessage = await prisma.aiPromptMessage.upsert({
     *   create: {
     *     // ... data to create a AiPromptMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiPromptMessage we want to update
     *   }
     * })
     */
    upsert<T extends AiPromptMessageUpsertArgs>(args: SelectSubset<T, AiPromptMessageUpsertArgs<ExtArgs>>): Prisma__AiPromptMessageClient<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiPromptMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageCountArgs} args - Arguments to filter AiPromptMessages to count.
     * @example
     * // Count the number of AiPromptMessages
     * const count = await prisma.aiPromptMessage.count({
     *   where: {
     *     // ... the filter for the AiPromptMessages we want to count
     *   }
     * })
    **/
    count<T extends AiPromptMessageCountArgs>(
      args?: Subset<T, AiPromptMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiPromptMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiPromptMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiPromptMessageAggregateArgs>(args: Subset<T, AiPromptMessageAggregateArgs>): Prisma.PrismaPromise<GetAiPromptMessageAggregateType<T>>

    /**
     * Group by AiPromptMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiPromptMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiPromptMessageGroupByArgs['orderBy'] }
        : { orderBy?: AiPromptMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiPromptMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiPromptMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiPromptMessage model
   */
  readonly fields: AiPromptMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiPromptMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiPromptMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompt<T extends AiPromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiPromptDefaultArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiPromptMessage model
   */
  interface AiPromptMessageFieldRefs {
    readonly promptId: FieldRef<"AiPromptMessage", 'Int'>
    readonly idx: FieldRef<"AiPromptMessage", 'Int'>
    readonly role: FieldRef<"AiPromptMessage", 'AiPromptRole'>
    readonly content: FieldRef<"AiPromptMessage", 'String'>
    readonly attachments: FieldRef<"AiPromptMessage", 'Json'>
    readonly params: FieldRef<"AiPromptMessage", 'Json'>
    readonly createdAt: FieldRef<"AiPromptMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiPromptMessage findUnique
   */
  export type AiPromptMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiPromptMessage to fetch.
     */
    where: AiPromptMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage findUniqueOrThrow
   */
  export type AiPromptMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiPromptMessage to fetch.
     */
    where: AiPromptMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage findFirst
   */
  export type AiPromptMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiPromptMessage to fetch.
     */
    where?: AiPromptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPromptMessages to fetch.
     */
    orderBy?: AiPromptMessageOrderByWithRelationInput | AiPromptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPromptMessages.
     */
    cursor?: AiPromptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPromptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPromptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPromptMessages.
     */
    distinct?: AiPromptMessageScalarFieldEnum | AiPromptMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage findFirstOrThrow
   */
  export type AiPromptMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiPromptMessage to fetch.
     */
    where?: AiPromptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPromptMessages to fetch.
     */
    orderBy?: AiPromptMessageOrderByWithRelationInput | AiPromptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPromptMessages.
     */
    cursor?: AiPromptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPromptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPromptMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPromptMessages.
     */
    distinct?: AiPromptMessageScalarFieldEnum | AiPromptMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage findMany
   */
  export type AiPromptMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiPromptMessages to fetch.
     */
    where?: AiPromptMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPromptMessages to fetch.
     */
    orderBy?: AiPromptMessageOrderByWithRelationInput | AiPromptMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiPromptMessages.
     */
    cursor?: AiPromptMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPromptMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPromptMessages.
     */
    skip?: number
    distinct?: AiPromptMessageScalarFieldEnum | AiPromptMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage create
   */
  export type AiPromptMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiPromptMessage.
     */
    data: XOR<AiPromptMessageCreateInput, AiPromptMessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage createMany
   */
  export type AiPromptMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiPromptMessages.
     */
    data: AiPromptMessageCreateManyInput | AiPromptMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiPromptMessage createManyAndReturn
   */
  export type AiPromptMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AiPromptMessages.
     */
    data: AiPromptMessageCreateManyInput | AiPromptMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiPromptMessage update
   */
  export type AiPromptMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiPromptMessage.
     */
    data: XOR<AiPromptMessageUpdateInput, AiPromptMessageUncheckedUpdateInput>
    /**
     * Choose, which AiPromptMessage to update.
     */
    where: AiPromptMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage updateMany
   */
  export type AiPromptMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiPromptMessages.
     */
    data: XOR<AiPromptMessageUpdateManyMutationInput, AiPromptMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiPromptMessages to update
     */
    where?: AiPromptMessageWhereInput
    /**
     * Limit how many AiPromptMessages to update.
     */
    limit?: number
  }

  /**
   * AiPromptMessage updateManyAndReturn
   */
  export type AiPromptMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * The data used to update AiPromptMessages.
     */
    data: XOR<AiPromptMessageUpdateManyMutationInput, AiPromptMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiPromptMessages to update
     */
    where?: AiPromptMessageWhereInput
    /**
     * Limit how many AiPromptMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiPromptMessage upsert
   */
  export type AiPromptMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiPromptMessage to update in case it exists.
     */
    where: AiPromptMessageWhereUniqueInput
    /**
     * In case the AiPromptMessage found by the `where` argument doesn't exist, create a new AiPromptMessage with this data.
     */
    create: XOR<AiPromptMessageCreateInput, AiPromptMessageUncheckedCreateInput>
    /**
     * In case the AiPromptMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiPromptMessageUpdateInput, AiPromptMessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage delete
   */
  export type AiPromptMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    /**
     * Filter which AiPromptMessage to delete.
     */
    where: AiPromptMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPromptMessage deleteMany
   */
  export type AiPromptMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPromptMessages to delete
     */
    where?: AiPromptMessageWhereInput
    /**
     * Limit how many AiPromptMessages to delete.
     */
    limit?: number
  }

  /**
   * AiPromptMessage without action
   */
  export type AiPromptMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
  }


  /**
   * Model AiPrompt
   */

  export type AggregateAiPrompt = {
    _count: AiPromptCountAggregateOutputType | null
    _avg: AiPromptAvgAggregateOutputType | null
    _sum: AiPromptSumAggregateOutputType | null
    _min: AiPromptMinAggregateOutputType | null
    _max: AiPromptMaxAggregateOutputType | null
  }

  export type AiPromptAvgAggregateOutputType = {
    id: number | null
  }

  export type AiPromptSumAggregateOutputType = {
    id: number | null
  }

  export type AiPromptMinAggregateOutputType = {
    id: number | null
    name: string | null
    action: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
    modified: boolean | null
  }

  export type AiPromptMaxAggregateOutputType = {
    id: number | null
    name: string | null
    action: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
    modified: boolean | null
  }

  export type AiPromptCountAggregateOutputType = {
    id: number
    name: number
    action: number
    model: number
    optionalModels: number
    config: number
    createdAt: number
    updatedAt: number
    modified: number
    _all: number
  }


  export type AiPromptAvgAggregateInputType = {
    id?: true
  }

  export type AiPromptSumAggregateInputType = {
    id?: true
  }

  export type AiPromptMinAggregateInputType = {
    id?: true
    name?: true
    action?: true
    model?: true
    createdAt?: true
    updatedAt?: true
    modified?: true
  }

  export type AiPromptMaxAggregateInputType = {
    id?: true
    name?: true
    action?: true
    model?: true
    createdAt?: true
    updatedAt?: true
    modified?: true
  }

  export type AiPromptCountAggregateInputType = {
    id?: true
    name?: true
    action?: true
    model?: true
    optionalModels?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    modified?: true
    _all?: true
  }

  export type AiPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPrompt to aggregate.
     */
    where?: AiPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPrompts to fetch.
     */
    orderBy?: AiPromptOrderByWithRelationInput | AiPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiPrompts
    **/
    _count?: true | AiPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiPromptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiPromptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiPromptMaxAggregateInputType
  }

  export type GetAiPromptAggregateType<T extends AiPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateAiPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiPrompt[P]>
      : GetScalarType<T[P], AggregateAiPrompt[P]>
  }




  export type AiPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiPromptWhereInput
    orderBy?: AiPromptOrderByWithAggregationInput | AiPromptOrderByWithAggregationInput[]
    by: AiPromptScalarFieldEnum[] | AiPromptScalarFieldEnum
    having?: AiPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiPromptCountAggregateInputType | true
    _avg?: AiPromptAvgAggregateInputType
    _sum?: AiPromptSumAggregateInputType
    _min?: AiPromptMinAggregateInputType
    _max?: AiPromptMaxAggregateInputType
  }

  export type AiPromptGroupByOutputType = {
    id: number
    name: string
    action: string | null
    model: string
    optionalModels: string[]
    config: JsonValue | null
    createdAt: Date
    updatedAt: Date
    modified: boolean
    _count: AiPromptCountAggregateOutputType | null
    _avg: AiPromptAvgAggregateOutputType | null
    _sum: AiPromptSumAggregateOutputType | null
    _min: AiPromptMinAggregateOutputType | null
    _max: AiPromptMaxAggregateOutputType | null
  }

  type GetAiPromptGroupByPayload<T extends AiPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiPromptGroupByOutputType[P]>
            : GetScalarType<T[P], AiPromptGroupByOutputType[P]>
        }
      >
    >


  export type AiPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    action?: boolean
    model?: boolean
    optionalModels?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modified?: boolean
    messages?: boolean | AiPrompt$messagesArgs<ExtArgs>
    sessions?: boolean | AiPrompt$sessionsArgs<ExtArgs>
    _count?: boolean | AiPromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiPrompt"]>

  export type AiPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    action?: boolean
    model?: boolean
    optionalModels?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modified?: boolean
  }, ExtArgs["result"]["aiPrompt"]>

  export type AiPromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    action?: boolean
    model?: boolean
    optionalModels?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modified?: boolean
  }, ExtArgs["result"]["aiPrompt"]>

  export type AiPromptSelectScalar = {
    id?: boolean
    name?: boolean
    action?: boolean
    model?: boolean
    optionalModels?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modified?: boolean
  }

  export type AiPromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "action" | "model" | "optionalModels" | "config" | "createdAt" | "updatedAt" | "modified", ExtArgs["result"]["aiPrompt"]>
  export type AiPromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | AiPrompt$messagesArgs<ExtArgs>
    sessions?: boolean | AiPrompt$sessionsArgs<ExtArgs>
    _count?: boolean | AiPromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiPromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AiPromptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AiPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiPrompt"
    objects: {
      messages: Prisma.$AiPromptMessagePayload<ExtArgs>[]
      sessions: Prisma.$AiSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      action: string | null
      model: string
      optionalModels: string[]
      config: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      modified: boolean
    }, ExtArgs["result"]["aiPrompt"]>
    composites: {}
  }

  type AiPromptGetPayload<S extends boolean | null | undefined | AiPromptDefaultArgs> = $Result.GetResult<Prisma.$AiPromptPayload, S>

  type AiPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiPromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiPromptCountAggregateInputType | true
    }

  export interface AiPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiPrompt'], meta: { name: 'AiPrompt' } }
    /**
     * Find zero or one AiPrompt that matches the filter.
     * @param {AiPromptFindUniqueArgs} args - Arguments to find a AiPrompt
     * @example
     * // Get one AiPrompt
     * const aiPrompt = await prisma.aiPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiPromptFindUniqueArgs>(args: SelectSubset<T, AiPromptFindUniqueArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiPrompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiPromptFindUniqueOrThrowArgs} args - Arguments to find a AiPrompt
     * @example
     * // Get one AiPrompt
     * const aiPrompt = await prisma.aiPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, AiPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptFindFirstArgs} args - Arguments to find a AiPrompt
     * @example
     * // Get one AiPrompt
     * const aiPrompt = await prisma.aiPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiPromptFindFirstArgs>(args?: SelectSubset<T, AiPromptFindFirstArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptFindFirstOrThrowArgs} args - Arguments to find a AiPrompt
     * @example
     * // Get one AiPrompt
     * const aiPrompt = await prisma.aiPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, AiPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiPrompts
     * const aiPrompts = await prisma.aiPrompt.findMany()
     * 
     * // Get first 10 AiPrompts
     * const aiPrompts = await prisma.aiPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiPromptWithIdOnly = await prisma.aiPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiPromptFindManyArgs>(args?: SelectSubset<T, AiPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiPrompt.
     * @param {AiPromptCreateArgs} args - Arguments to create a AiPrompt.
     * @example
     * // Create one AiPrompt
     * const AiPrompt = await prisma.aiPrompt.create({
     *   data: {
     *     // ... data to create a AiPrompt
     *   }
     * })
     * 
     */
    create<T extends AiPromptCreateArgs>(args: SelectSubset<T, AiPromptCreateArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiPrompts.
     * @param {AiPromptCreateManyArgs} args - Arguments to create many AiPrompts.
     * @example
     * // Create many AiPrompts
     * const aiPrompt = await prisma.aiPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiPromptCreateManyArgs>(args?: SelectSubset<T, AiPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiPrompts and returns the data saved in the database.
     * @param {AiPromptCreateManyAndReturnArgs} args - Arguments to create many AiPrompts.
     * @example
     * // Create many AiPrompts
     * const aiPrompt = await prisma.aiPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiPrompts and only return the `id`
     * const aiPromptWithIdOnly = await prisma.aiPrompt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, AiPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiPrompt.
     * @param {AiPromptDeleteArgs} args - Arguments to delete one AiPrompt.
     * @example
     * // Delete one AiPrompt
     * const AiPrompt = await prisma.aiPrompt.delete({
     *   where: {
     *     // ... filter to delete one AiPrompt
     *   }
     * })
     * 
     */
    delete<T extends AiPromptDeleteArgs>(args: SelectSubset<T, AiPromptDeleteArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiPrompt.
     * @param {AiPromptUpdateArgs} args - Arguments to update one AiPrompt.
     * @example
     * // Update one AiPrompt
     * const aiPrompt = await prisma.aiPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiPromptUpdateArgs>(args: SelectSubset<T, AiPromptUpdateArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiPrompts.
     * @param {AiPromptDeleteManyArgs} args - Arguments to filter AiPrompts to delete.
     * @example
     * // Delete a few AiPrompts
     * const { count } = await prisma.aiPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiPromptDeleteManyArgs>(args?: SelectSubset<T, AiPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiPrompts
     * const aiPrompt = await prisma.aiPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiPromptUpdateManyArgs>(args: SelectSubset<T, AiPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiPrompts and returns the data updated in the database.
     * @param {AiPromptUpdateManyAndReturnArgs} args - Arguments to update many AiPrompts.
     * @example
     * // Update many AiPrompts
     * const aiPrompt = await prisma.aiPrompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiPrompts and only return the `id`
     * const aiPromptWithIdOnly = await prisma.aiPrompt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiPromptUpdateManyAndReturnArgs>(args: SelectSubset<T, AiPromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiPrompt.
     * @param {AiPromptUpsertArgs} args - Arguments to update or create a AiPrompt.
     * @example
     * // Update or create a AiPrompt
     * const aiPrompt = await prisma.aiPrompt.upsert({
     *   create: {
     *     // ... data to create a AiPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiPrompt we want to update
     *   }
     * })
     */
    upsert<T extends AiPromptUpsertArgs>(args: SelectSubset<T, AiPromptUpsertArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptCountArgs} args - Arguments to filter AiPrompts to count.
     * @example
     * // Count the number of AiPrompts
     * const count = await prisma.aiPrompt.count({
     *   where: {
     *     // ... the filter for the AiPrompts we want to count
     *   }
     * })
    **/
    count<T extends AiPromptCountArgs>(
      args?: Subset<T, AiPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiPromptAggregateArgs>(args: Subset<T, AiPromptAggregateArgs>): Prisma.PrismaPromise<GetAiPromptAggregateType<T>>

    /**
     * Group by AiPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiPromptGroupByArgs['orderBy'] }
        : { orderBy?: AiPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiPrompt model
   */
  readonly fields: AiPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends AiPrompt$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AiPrompt$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiPromptMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends AiPrompt$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AiPrompt$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiPrompt model
   */
  interface AiPromptFieldRefs {
    readonly id: FieldRef<"AiPrompt", 'Int'>
    readonly name: FieldRef<"AiPrompt", 'String'>
    readonly action: FieldRef<"AiPrompt", 'String'>
    readonly model: FieldRef<"AiPrompt", 'String'>
    readonly optionalModels: FieldRef<"AiPrompt", 'String[]'>
    readonly config: FieldRef<"AiPrompt", 'Json'>
    readonly createdAt: FieldRef<"AiPrompt", 'DateTime'>
    readonly updatedAt: FieldRef<"AiPrompt", 'DateTime'>
    readonly modified: FieldRef<"AiPrompt", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AiPrompt findUnique
   */
  export type AiPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter, which AiPrompt to fetch.
     */
    where: AiPromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt findUniqueOrThrow
   */
  export type AiPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter, which AiPrompt to fetch.
     */
    where: AiPromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt findFirst
   */
  export type AiPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter, which AiPrompt to fetch.
     */
    where?: AiPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPrompts to fetch.
     */
    orderBy?: AiPromptOrderByWithRelationInput | AiPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPrompts.
     */
    cursor?: AiPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPrompts.
     */
    distinct?: AiPromptScalarFieldEnum | AiPromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt findFirstOrThrow
   */
  export type AiPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter, which AiPrompt to fetch.
     */
    where?: AiPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPrompts to fetch.
     */
    orderBy?: AiPromptOrderByWithRelationInput | AiPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiPrompts.
     */
    cursor?: AiPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiPrompts.
     */
    distinct?: AiPromptScalarFieldEnum | AiPromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt findMany
   */
  export type AiPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter, which AiPrompts to fetch.
     */
    where?: AiPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiPrompts to fetch.
     */
    orderBy?: AiPromptOrderByWithRelationInput | AiPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiPrompts.
     */
    cursor?: AiPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiPrompts.
     */
    skip?: number
    distinct?: AiPromptScalarFieldEnum | AiPromptScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt create
   */
  export type AiPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * The data needed to create a AiPrompt.
     */
    data: XOR<AiPromptCreateInput, AiPromptUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt createMany
   */
  export type AiPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiPrompts.
     */
    data: AiPromptCreateManyInput | AiPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiPrompt createManyAndReturn
   */
  export type AiPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * The data used to create many AiPrompts.
     */
    data: AiPromptCreateManyInput | AiPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiPrompt update
   */
  export type AiPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * The data needed to update a AiPrompt.
     */
    data: XOR<AiPromptUpdateInput, AiPromptUncheckedUpdateInput>
    /**
     * Choose, which AiPrompt to update.
     */
    where: AiPromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt updateMany
   */
  export type AiPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiPrompts.
     */
    data: XOR<AiPromptUpdateManyMutationInput, AiPromptUncheckedUpdateManyInput>
    /**
     * Filter which AiPrompts to update
     */
    where?: AiPromptWhereInput
    /**
     * Limit how many AiPrompts to update.
     */
    limit?: number
  }

  /**
   * AiPrompt updateManyAndReturn
   */
  export type AiPromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * The data used to update AiPrompts.
     */
    data: XOR<AiPromptUpdateManyMutationInput, AiPromptUncheckedUpdateManyInput>
    /**
     * Filter which AiPrompts to update
     */
    where?: AiPromptWhereInput
    /**
     * Limit how many AiPrompts to update.
     */
    limit?: number
  }

  /**
   * AiPrompt upsert
   */
  export type AiPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * The filter to search for the AiPrompt to update in case it exists.
     */
    where: AiPromptWhereUniqueInput
    /**
     * In case the AiPrompt found by the `where` argument doesn't exist, create a new AiPrompt with this data.
     */
    create: XOR<AiPromptCreateInput, AiPromptUncheckedCreateInput>
    /**
     * In case the AiPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiPromptUpdateInput, AiPromptUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt delete
   */
  export type AiPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
    /**
     * Filter which AiPrompt to delete.
     */
    where: AiPromptWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiPrompt deleteMany
   */
  export type AiPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiPrompts to delete
     */
    where?: AiPromptWhereInput
    /**
     * Limit how many AiPrompts to delete.
     */
    limit?: number
  }

  /**
   * AiPrompt.messages
   */
  export type AiPrompt$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPromptMessage
     */
    select?: AiPromptMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPromptMessage
     */
    omit?: AiPromptMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptMessageInclude<ExtArgs> | null
    where?: AiPromptMessageWhereInput
    orderBy?: AiPromptMessageOrderByWithRelationInput | AiPromptMessageOrderByWithRelationInput[]
    cursor?: AiPromptMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiPromptMessageScalarFieldEnum | AiPromptMessageScalarFieldEnum[]
  }

  /**
   * AiPrompt.sessions
   */
  export type AiPrompt$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    where?: AiSessionWhereInput
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    cursor?: AiSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiSessionScalarFieldEnum | AiSessionScalarFieldEnum[]
  }

  /**
   * AiPrompt without action
   */
  export type AiPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiPrompt
     */
    select?: AiPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiPrompt
     */
    omit?: AiPromptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiPromptInclude<ExtArgs> | null
  }


  /**
   * Model AiSessionMessage
   */

  export type AggregateAiSessionMessage = {
    _count: AiSessionMessageCountAggregateOutputType | null
    _min: AiSessionMessageMinAggregateOutputType | null
    _max: AiSessionMessageMaxAggregateOutputType | null
  }

  export type AiSessionMessageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: $Enums.AiPromptRole | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiSessionMessageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    role: $Enums.AiPromptRole | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiSessionMessageCountAggregateOutputType = {
    id: number
    sessionId: number
    role: number
    content: number
    streamObjects: number
    attachments: number
    params: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiSessionMessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiSessionMessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiSessionMessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    role?: true
    content?: true
    streamObjects?: true
    attachments?: true
    params?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiSessionMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSessionMessage to aggregate.
     */
    where?: AiSessionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessionMessages to fetch.
     */
    orderBy?: AiSessionMessageOrderByWithRelationInput | AiSessionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiSessionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiSessionMessages
    **/
    _count?: true | AiSessionMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiSessionMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiSessionMessageMaxAggregateInputType
  }

  export type GetAiSessionMessageAggregateType<T extends AiSessionMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateAiSessionMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiSessionMessage[P]>
      : GetScalarType<T[P], AggregateAiSessionMessage[P]>
  }




  export type AiSessionMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSessionMessageWhereInput
    orderBy?: AiSessionMessageOrderByWithAggregationInput | AiSessionMessageOrderByWithAggregationInput[]
    by: AiSessionMessageScalarFieldEnum[] | AiSessionMessageScalarFieldEnum
    having?: AiSessionMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiSessionMessageCountAggregateInputType | true
    _min?: AiSessionMessageMinAggregateInputType
    _max?: AiSessionMessageMaxAggregateInputType
  }

  export type AiSessionMessageGroupByOutputType = {
    id: string
    sessionId: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects: JsonValue | null
    attachments: JsonValue | null
    params: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AiSessionMessageCountAggregateOutputType | null
    _min: AiSessionMessageMinAggregateOutputType | null
    _max: AiSessionMessageMaxAggregateOutputType | null
  }

  type GetAiSessionMessageGroupByPayload<T extends AiSessionMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiSessionMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiSessionMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiSessionMessageGroupByOutputType[P]>
            : GetScalarType<T[P], AiSessionMessageGroupByOutputType[P]>
        }
      >
    >


  export type AiSessionMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    streamObjects?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSessionMessage"]>

  export type AiSessionMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    streamObjects?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSessionMessage"]>

  export type AiSessionMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    streamObjects?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSessionMessage"]>

  export type AiSessionMessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    role?: boolean
    content?: boolean
    streamObjects?: boolean
    attachments?: boolean
    params?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiSessionMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "role" | "content" | "streamObjects" | "attachments" | "params" | "createdAt" | "updatedAt", ExtArgs["result"]["aiSessionMessage"]>
  export type AiSessionMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }
  export type AiSessionMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }
  export type AiSessionMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }

  export type $AiSessionMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiSessionMessage"
    objects: {
      session: Prisma.$AiSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      role: $Enums.AiPromptRole
      content: string
      streamObjects: Prisma.JsonValue | null
      attachments: Prisma.JsonValue | null
      params: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiSessionMessage"]>
    composites: {}
  }

  type AiSessionMessageGetPayload<S extends boolean | null | undefined | AiSessionMessageDefaultArgs> = $Result.GetResult<Prisma.$AiSessionMessagePayload, S>

  type AiSessionMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiSessionMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiSessionMessageCountAggregateInputType | true
    }

  export interface AiSessionMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiSessionMessage'], meta: { name: 'AiSessionMessage' } }
    /**
     * Find zero or one AiSessionMessage that matches the filter.
     * @param {AiSessionMessageFindUniqueArgs} args - Arguments to find a AiSessionMessage
     * @example
     * // Get one AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiSessionMessageFindUniqueArgs>(args: SelectSubset<T, AiSessionMessageFindUniqueArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiSessionMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiSessionMessageFindUniqueOrThrowArgs} args - Arguments to find a AiSessionMessage
     * @example
     * // Get one AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiSessionMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, AiSessionMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSessionMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageFindFirstArgs} args - Arguments to find a AiSessionMessage
     * @example
     * // Get one AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiSessionMessageFindFirstArgs>(args?: SelectSubset<T, AiSessionMessageFindFirstArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSessionMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageFindFirstOrThrowArgs} args - Arguments to find a AiSessionMessage
     * @example
     * // Get one AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiSessionMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, AiSessionMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiSessionMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiSessionMessages
     * const aiSessionMessages = await prisma.aiSessionMessage.findMany()
     * 
     * // Get first 10 AiSessionMessages
     * const aiSessionMessages = await prisma.aiSessionMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiSessionMessageWithIdOnly = await prisma.aiSessionMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiSessionMessageFindManyArgs>(args?: SelectSubset<T, AiSessionMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiSessionMessage.
     * @param {AiSessionMessageCreateArgs} args - Arguments to create a AiSessionMessage.
     * @example
     * // Create one AiSessionMessage
     * const AiSessionMessage = await prisma.aiSessionMessage.create({
     *   data: {
     *     // ... data to create a AiSessionMessage
     *   }
     * })
     * 
     */
    create<T extends AiSessionMessageCreateArgs>(args: SelectSubset<T, AiSessionMessageCreateArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiSessionMessages.
     * @param {AiSessionMessageCreateManyArgs} args - Arguments to create many AiSessionMessages.
     * @example
     * // Create many AiSessionMessages
     * const aiSessionMessage = await prisma.aiSessionMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiSessionMessageCreateManyArgs>(args?: SelectSubset<T, AiSessionMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiSessionMessages and returns the data saved in the database.
     * @param {AiSessionMessageCreateManyAndReturnArgs} args - Arguments to create many AiSessionMessages.
     * @example
     * // Create many AiSessionMessages
     * const aiSessionMessage = await prisma.aiSessionMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiSessionMessages and only return the `id`
     * const aiSessionMessageWithIdOnly = await prisma.aiSessionMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiSessionMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, AiSessionMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiSessionMessage.
     * @param {AiSessionMessageDeleteArgs} args - Arguments to delete one AiSessionMessage.
     * @example
     * // Delete one AiSessionMessage
     * const AiSessionMessage = await prisma.aiSessionMessage.delete({
     *   where: {
     *     // ... filter to delete one AiSessionMessage
     *   }
     * })
     * 
     */
    delete<T extends AiSessionMessageDeleteArgs>(args: SelectSubset<T, AiSessionMessageDeleteArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiSessionMessage.
     * @param {AiSessionMessageUpdateArgs} args - Arguments to update one AiSessionMessage.
     * @example
     * // Update one AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiSessionMessageUpdateArgs>(args: SelectSubset<T, AiSessionMessageUpdateArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiSessionMessages.
     * @param {AiSessionMessageDeleteManyArgs} args - Arguments to filter AiSessionMessages to delete.
     * @example
     * // Delete a few AiSessionMessages
     * const { count } = await prisma.aiSessionMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiSessionMessageDeleteManyArgs>(args?: SelectSubset<T, AiSessionMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSessionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiSessionMessages
     * const aiSessionMessage = await prisma.aiSessionMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiSessionMessageUpdateManyArgs>(args: SelectSubset<T, AiSessionMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSessionMessages and returns the data updated in the database.
     * @param {AiSessionMessageUpdateManyAndReturnArgs} args - Arguments to update many AiSessionMessages.
     * @example
     * // Update many AiSessionMessages
     * const aiSessionMessage = await prisma.aiSessionMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiSessionMessages and only return the `id`
     * const aiSessionMessageWithIdOnly = await prisma.aiSessionMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiSessionMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, AiSessionMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiSessionMessage.
     * @param {AiSessionMessageUpsertArgs} args - Arguments to update or create a AiSessionMessage.
     * @example
     * // Update or create a AiSessionMessage
     * const aiSessionMessage = await prisma.aiSessionMessage.upsert({
     *   create: {
     *     // ... data to create a AiSessionMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiSessionMessage we want to update
     *   }
     * })
     */
    upsert<T extends AiSessionMessageUpsertArgs>(args: SelectSubset<T, AiSessionMessageUpsertArgs<ExtArgs>>): Prisma__AiSessionMessageClient<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiSessionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageCountArgs} args - Arguments to filter AiSessionMessages to count.
     * @example
     * // Count the number of AiSessionMessages
     * const count = await prisma.aiSessionMessage.count({
     *   where: {
     *     // ... the filter for the AiSessionMessages we want to count
     *   }
     * })
    **/
    count<T extends AiSessionMessageCountArgs>(
      args?: Subset<T, AiSessionMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiSessionMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiSessionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiSessionMessageAggregateArgs>(args: Subset<T, AiSessionMessageAggregateArgs>): Prisma.PrismaPromise<GetAiSessionMessageAggregateType<T>>

    /**
     * Group by AiSessionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiSessionMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiSessionMessageGroupByArgs['orderBy'] }
        : { orderBy?: AiSessionMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiSessionMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiSessionMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiSessionMessage model
   */
  readonly fields: AiSessionMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiSessionMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiSessionMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends AiSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiSessionDefaultArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiSessionMessage model
   */
  interface AiSessionMessageFieldRefs {
    readonly id: FieldRef<"AiSessionMessage", 'String'>
    readonly sessionId: FieldRef<"AiSessionMessage", 'String'>
    readonly role: FieldRef<"AiSessionMessage", 'AiPromptRole'>
    readonly content: FieldRef<"AiSessionMessage", 'String'>
    readonly streamObjects: FieldRef<"AiSessionMessage", 'Json'>
    readonly attachments: FieldRef<"AiSessionMessage", 'Json'>
    readonly params: FieldRef<"AiSessionMessage", 'Json'>
    readonly createdAt: FieldRef<"AiSessionMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"AiSessionMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiSessionMessage findUnique
   */
  export type AiSessionMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiSessionMessage to fetch.
     */
    where: AiSessionMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage findUniqueOrThrow
   */
  export type AiSessionMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiSessionMessage to fetch.
     */
    where: AiSessionMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage findFirst
   */
  export type AiSessionMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiSessionMessage to fetch.
     */
    where?: AiSessionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessionMessages to fetch.
     */
    orderBy?: AiSessionMessageOrderByWithRelationInput | AiSessionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSessionMessages.
     */
    cursor?: AiSessionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSessionMessages.
     */
    distinct?: AiSessionMessageScalarFieldEnum | AiSessionMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage findFirstOrThrow
   */
  export type AiSessionMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiSessionMessage to fetch.
     */
    where?: AiSessionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessionMessages to fetch.
     */
    orderBy?: AiSessionMessageOrderByWithRelationInput | AiSessionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSessionMessages.
     */
    cursor?: AiSessionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSessionMessages.
     */
    distinct?: AiSessionMessageScalarFieldEnum | AiSessionMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage findMany
   */
  export type AiSessionMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter, which AiSessionMessages to fetch.
     */
    where?: AiSessionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessionMessages to fetch.
     */
    orderBy?: AiSessionMessageOrderByWithRelationInput | AiSessionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiSessionMessages.
     */
    cursor?: AiSessionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessionMessages.
     */
    skip?: number
    distinct?: AiSessionMessageScalarFieldEnum | AiSessionMessageScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage create
   */
  export type AiSessionMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a AiSessionMessage.
     */
    data: XOR<AiSessionMessageCreateInput, AiSessionMessageUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage createMany
   */
  export type AiSessionMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiSessionMessages.
     */
    data: AiSessionMessageCreateManyInput | AiSessionMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiSessionMessage createManyAndReturn
   */
  export type AiSessionMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * The data used to create many AiSessionMessages.
     */
    data: AiSessionMessageCreateManyInput | AiSessionMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSessionMessage update
   */
  export type AiSessionMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a AiSessionMessage.
     */
    data: XOR<AiSessionMessageUpdateInput, AiSessionMessageUncheckedUpdateInput>
    /**
     * Choose, which AiSessionMessage to update.
     */
    where: AiSessionMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage updateMany
   */
  export type AiSessionMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiSessionMessages.
     */
    data: XOR<AiSessionMessageUpdateManyMutationInput, AiSessionMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiSessionMessages to update
     */
    where?: AiSessionMessageWhereInput
    /**
     * Limit how many AiSessionMessages to update.
     */
    limit?: number
  }

  /**
   * AiSessionMessage updateManyAndReturn
   */
  export type AiSessionMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * The data used to update AiSessionMessages.
     */
    data: XOR<AiSessionMessageUpdateManyMutationInput, AiSessionMessageUncheckedUpdateManyInput>
    /**
     * Filter which AiSessionMessages to update
     */
    where?: AiSessionMessageWhereInput
    /**
     * Limit how many AiSessionMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSessionMessage upsert
   */
  export type AiSessionMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the AiSessionMessage to update in case it exists.
     */
    where: AiSessionMessageWhereUniqueInput
    /**
     * In case the AiSessionMessage found by the `where` argument doesn't exist, create a new AiSessionMessage with this data.
     */
    create: XOR<AiSessionMessageCreateInput, AiSessionMessageUncheckedCreateInput>
    /**
     * In case the AiSessionMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiSessionMessageUpdateInput, AiSessionMessageUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage delete
   */
  export type AiSessionMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    /**
     * Filter which AiSessionMessage to delete.
     */
    where: AiSessionMessageWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSessionMessage deleteMany
   */
  export type AiSessionMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSessionMessages to delete
     */
    where?: AiSessionMessageWhereInput
    /**
     * Limit how many AiSessionMessages to delete.
     */
    limit?: number
  }

  /**
   * AiSessionMessage without action
   */
  export type AiSessionMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
  }


  /**
   * Model AiSession
   */

  export type AggregateAiSession = {
    _count: AiSessionCountAggregateOutputType | null
    _avg: AiSessionAvgAggregateOutputType | null
    _sum: AiSessionSumAggregateOutputType | null
    _min: AiSessionMinAggregateOutputType | null
    _max: AiSessionMaxAggregateOutputType | null
  }

  export type AiSessionAvgAggregateOutputType = {
    messageCost: number | null
    tokenCost: number | null
  }

  export type AiSessionSumAggregateOutputType = {
    messageCost: number | null
    tokenCost: number | null
  }

  export type AiSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    docId: string | null
    promptName: string | null
    promptAction: string | null
    pinned: boolean | null
    title: string | null
    parentSessionId: string | null
    messageCost: number | null
    tokenCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AiSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    docId: string | null
    promptName: string | null
    promptAction: string | null
    pinned: boolean | null
    title: string | null
    parentSessionId: string | null
    messageCost: number | null
    tokenCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AiSessionCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    docId: number
    promptName: number
    promptAction: number
    pinned: number
    title: number
    parentSessionId: number
    messageCost: number
    tokenCost: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AiSessionAvgAggregateInputType = {
    messageCost?: true
    tokenCost?: true
  }

  export type AiSessionSumAggregateInputType = {
    messageCost?: true
    tokenCost?: true
  }

  export type AiSessionMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    docId?: true
    promptName?: true
    promptAction?: true
    pinned?: true
    title?: true
    parentSessionId?: true
    messageCost?: true
    tokenCost?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AiSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    docId?: true
    promptName?: true
    promptAction?: true
    pinned?: true
    title?: true
    parentSessionId?: true
    messageCost?: true
    tokenCost?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AiSessionCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    docId?: true
    promptName?: true
    promptAction?: true
    pinned?: true
    title?: true
    parentSessionId?: true
    messageCost?: true
    tokenCost?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AiSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSession to aggregate.
     */
    where?: AiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessions to fetch.
     */
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiSessions
    **/
    _count?: true | AiSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiSessionMaxAggregateInputType
  }

  export type GetAiSessionAggregateType<T extends AiSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAiSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiSession[P]>
      : GetScalarType<T[P], AggregateAiSession[P]>
  }




  export type AiSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiSessionWhereInput
    orderBy?: AiSessionOrderByWithAggregationInput | AiSessionOrderByWithAggregationInput[]
    by: AiSessionScalarFieldEnum[] | AiSessionScalarFieldEnum
    having?: AiSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiSessionCountAggregateInputType | true
    _avg?: AiSessionAvgAggregateInputType
    _sum?: AiSessionSumAggregateInputType
    _min?: AiSessionMinAggregateInputType
    _max?: AiSessionMaxAggregateInputType
  }

  export type AiSessionGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    docId: string | null
    promptName: string
    promptAction: string | null
    pinned: boolean
    title: string | null
    parentSessionId: string | null
    messageCost: number
    tokenCost: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AiSessionCountAggregateOutputType | null
    _avg: AiSessionAvgAggregateOutputType | null
    _sum: AiSessionSumAggregateOutputType | null
    _min: AiSessionMinAggregateOutputType | null
    _max: AiSessionMaxAggregateOutputType | null
  }

  type GetAiSessionGroupByPayload<T extends AiSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AiSessionGroupByOutputType[P]>
        }
      >
    >


  export type AiSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    docId?: boolean
    promptName?: boolean
    promptAction?: boolean
    pinned?: boolean
    title?: boolean
    parentSessionId?: boolean
    messageCost?: boolean
    tokenCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
    messages?: boolean | AiSession$messagesArgs<ExtArgs>
    context?: boolean | AiSession$contextArgs<ExtArgs>
    _count?: boolean | AiSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSession"]>

  export type AiSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    docId?: boolean
    promptName?: boolean
    promptAction?: boolean
    pinned?: boolean
    title?: boolean
    parentSessionId?: boolean
    messageCost?: boolean
    tokenCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSession"]>

  export type AiSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    docId?: boolean
    promptName?: boolean
    promptAction?: boolean
    pinned?: boolean
    title?: boolean
    parentSessionId?: boolean
    messageCost?: boolean
    tokenCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiSession"]>

  export type AiSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    docId?: boolean
    promptName?: boolean
    promptAction?: boolean
    pinned?: boolean
    title?: boolean
    parentSessionId?: boolean
    messageCost?: boolean
    tokenCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AiSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "workspaceId" | "docId" | "promptName" | "promptAction" | "pinned" | "title" | "parentSessionId" | "messageCost" | "tokenCost" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["aiSession"]>
  export type AiSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
    messages?: boolean | AiSession$messagesArgs<ExtArgs>
    context?: boolean | AiSession$contextArgs<ExtArgs>
    _count?: boolean | AiSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }
  export type AiSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    prompt?: boolean | AiPromptDefaultArgs<ExtArgs>
  }

  export type $AiSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      prompt: Prisma.$AiPromptPayload<ExtArgs>
      messages: Prisma.$AiSessionMessagePayload<ExtArgs>[]
      context: Prisma.$AiContextPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      docId: string | null
      promptName: string
      promptAction: string | null
      pinned: boolean
      title: string | null
      parentSessionId: string | null
      messageCost: number
      tokenCost: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["aiSession"]>
    composites: {}
  }

  type AiSessionGetPayload<S extends boolean | null | undefined | AiSessionDefaultArgs> = $Result.GetResult<Prisma.$AiSessionPayload, S>

  type AiSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiSessionCountAggregateInputType | true
    }

  export interface AiSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiSession'], meta: { name: 'AiSession' } }
    /**
     * Find zero or one AiSession that matches the filter.
     * @param {AiSessionFindUniqueArgs} args - Arguments to find a AiSession
     * @example
     * // Get one AiSession
     * const aiSession = await prisma.aiSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiSessionFindUniqueArgs>(args: SelectSubset<T, AiSessionFindUniqueArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiSessionFindUniqueOrThrowArgs} args - Arguments to find a AiSession
     * @example
     * // Get one AiSession
     * const aiSession = await prisma.aiSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AiSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionFindFirstArgs} args - Arguments to find a AiSession
     * @example
     * // Get one AiSession
     * const aiSession = await prisma.aiSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiSessionFindFirstArgs>(args?: SelectSubset<T, AiSessionFindFirstArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionFindFirstOrThrowArgs} args - Arguments to find a AiSession
     * @example
     * // Get one AiSession
     * const aiSession = await prisma.aiSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AiSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiSessions
     * const aiSessions = await prisma.aiSession.findMany()
     * 
     * // Get first 10 AiSessions
     * const aiSessions = await prisma.aiSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiSessionWithIdOnly = await prisma.aiSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiSessionFindManyArgs>(args?: SelectSubset<T, AiSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiSession.
     * @param {AiSessionCreateArgs} args - Arguments to create a AiSession.
     * @example
     * // Create one AiSession
     * const AiSession = await prisma.aiSession.create({
     *   data: {
     *     // ... data to create a AiSession
     *   }
     * })
     * 
     */
    create<T extends AiSessionCreateArgs>(args: SelectSubset<T, AiSessionCreateArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiSessions.
     * @param {AiSessionCreateManyArgs} args - Arguments to create many AiSessions.
     * @example
     * // Create many AiSessions
     * const aiSession = await prisma.aiSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiSessionCreateManyArgs>(args?: SelectSubset<T, AiSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiSessions and returns the data saved in the database.
     * @param {AiSessionCreateManyAndReturnArgs} args - Arguments to create many AiSessions.
     * @example
     * // Create many AiSessions
     * const aiSession = await prisma.aiSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiSessions and only return the `id`
     * const aiSessionWithIdOnly = await prisma.aiSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AiSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiSession.
     * @param {AiSessionDeleteArgs} args - Arguments to delete one AiSession.
     * @example
     * // Delete one AiSession
     * const AiSession = await prisma.aiSession.delete({
     *   where: {
     *     // ... filter to delete one AiSession
     *   }
     * })
     * 
     */
    delete<T extends AiSessionDeleteArgs>(args: SelectSubset<T, AiSessionDeleteArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiSession.
     * @param {AiSessionUpdateArgs} args - Arguments to update one AiSession.
     * @example
     * // Update one AiSession
     * const aiSession = await prisma.aiSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiSessionUpdateArgs>(args: SelectSubset<T, AiSessionUpdateArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiSessions.
     * @param {AiSessionDeleteManyArgs} args - Arguments to filter AiSessions to delete.
     * @example
     * // Delete a few AiSessions
     * const { count } = await prisma.aiSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiSessionDeleteManyArgs>(args?: SelectSubset<T, AiSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiSessions
     * const aiSession = await prisma.aiSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiSessionUpdateManyArgs>(args: SelectSubset<T, AiSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiSessions and returns the data updated in the database.
     * @param {AiSessionUpdateManyAndReturnArgs} args - Arguments to update many AiSessions.
     * @example
     * // Update many AiSessions
     * const aiSession = await prisma.aiSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiSessions and only return the `id`
     * const aiSessionWithIdOnly = await prisma.aiSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AiSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiSession.
     * @param {AiSessionUpsertArgs} args - Arguments to update or create a AiSession.
     * @example
     * // Update or create a AiSession
     * const aiSession = await prisma.aiSession.upsert({
     *   create: {
     *     // ... data to create a AiSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiSession we want to update
     *   }
     * })
     */
    upsert<T extends AiSessionUpsertArgs>(args: SelectSubset<T, AiSessionUpsertArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionCountArgs} args - Arguments to filter AiSessions to count.
     * @example
     * // Count the number of AiSessions
     * const count = await prisma.aiSession.count({
     *   where: {
     *     // ... the filter for the AiSessions we want to count
     *   }
     * })
    **/
    count<T extends AiSessionCountArgs>(
      args?: Subset<T, AiSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiSessionAggregateArgs>(args: Subset<T, AiSessionAggregateArgs>): Prisma.PrismaPromise<GetAiSessionAggregateType<T>>

    /**
     * Group by AiSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiSessionGroupByArgs['orderBy'] }
        : { orderBy?: AiSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiSession model
   */
  readonly fields: AiSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prompt<T extends AiPromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiPromptDefaultArgs<ExtArgs>>): Prisma__AiPromptClient<$Result.GetResult<Prisma.$AiPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends AiSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, AiSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiSessionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    context<T extends AiSession$contextArgs<ExtArgs> = {}>(args?: Subset<T, AiSession$contextArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiSession model
   */
  interface AiSessionFieldRefs {
    readonly id: FieldRef<"AiSession", 'String'>
    readonly userId: FieldRef<"AiSession", 'String'>
    readonly workspaceId: FieldRef<"AiSession", 'String'>
    readonly docId: FieldRef<"AiSession", 'String'>
    readonly promptName: FieldRef<"AiSession", 'String'>
    readonly promptAction: FieldRef<"AiSession", 'String'>
    readonly pinned: FieldRef<"AiSession", 'Boolean'>
    readonly title: FieldRef<"AiSession", 'String'>
    readonly parentSessionId: FieldRef<"AiSession", 'String'>
    readonly messageCost: FieldRef<"AiSession", 'Int'>
    readonly tokenCost: FieldRef<"AiSession", 'Int'>
    readonly createdAt: FieldRef<"AiSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AiSession", 'DateTime'>
    readonly deletedAt: FieldRef<"AiSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiSession findUnique
   */
  export type AiSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter, which AiSession to fetch.
     */
    where: AiSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession findUniqueOrThrow
   */
  export type AiSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter, which AiSession to fetch.
     */
    where: AiSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession findFirst
   */
  export type AiSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter, which AiSession to fetch.
     */
    where?: AiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessions to fetch.
     */
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSessions.
     */
    cursor?: AiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSessions.
     */
    distinct?: AiSessionScalarFieldEnum | AiSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession findFirstOrThrow
   */
  export type AiSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter, which AiSession to fetch.
     */
    where?: AiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessions to fetch.
     */
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiSessions.
     */
    cursor?: AiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiSessions.
     */
    distinct?: AiSessionScalarFieldEnum | AiSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession findMany
   */
  export type AiSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter, which AiSessions to fetch.
     */
    where?: AiSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiSessions to fetch.
     */
    orderBy?: AiSessionOrderByWithRelationInput | AiSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiSessions.
     */
    cursor?: AiSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiSessions.
     */
    skip?: number
    distinct?: AiSessionScalarFieldEnum | AiSessionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession create
   */
  export type AiSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AiSession.
     */
    data: XOR<AiSessionCreateInput, AiSessionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession createMany
   */
  export type AiSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiSessions.
     */
    data: AiSessionCreateManyInput | AiSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiSession createManyAndReturn
   */
  export type AiSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AiSessions.
     */
    data: AiSessionCreateManyInput | AiSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSession update
   */
  export type AiSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AiSession.
     */
    data: XOR<AiSessionUpdateInput, AiSessionUncheckedUpdateInput>
    /**
     * Choose, which AiSession to update.
     */
    where: AiSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession updateMany
   */
  export type AiSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiSessions.
     */
    data: XOR<AiSessionUpdateManyMutationInput, AiSessionUncheckedUpdateManyInput>
    /**
     * Filter which AiSessions to update
     */
    where?: AiSessionWhereInput
    /**
     * Limit how many AiSessions to update.
     */
    limit?: number
  }

  /**
   * AiSession updateManyAndReturn
   */
  export type AiSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * The data used to update AiSessions.
     */
    data: XOR<AiSessionUpdateManyMutationInput, AiSessionUncheckedUpdateManyInput>
    /**
     * Filter which AiSessions to update
     */
    where?: AiSessionWhereInput
    /**
     * Limit how many AiSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiSession upsert
   */
  export type AiSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AiSession to update in case it exists.
     */
    where: AiSessionWhereUniqueInput
    /**
     * In case the AiSession found by the `where` argument doesn't exist, create a new AiSession with this data.
     */
    create: XOR<AiSessionCreateInput, AiSessionUncheckedCreateInput>
    /**
     * In case the AiSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiSessionUpdateInput, AiSessionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession delete
   */
  export type AiSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
    /**
     * Filter which AiSession to delete.
     */
    where: AiSessionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiSession deleteMany
   */
  export type AiSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiSessions to delete
     */
    where?: AiSessionWhereInput
    /**
     * Limit how many AiSessions to delete.
     */
    limit?: number
  }

  /**
   * AiSession.messages
   */
  export type AiSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSessionMessage
     */
    select?: AiSessionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSessionMessage
     */
    omit?: AiSessionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionMessageInclude<ExtArgs> | null
    where?: AiSessionMessageWhereInput
    orderBy?: AiSessionMessageOrderByWithRelationInput | AiSessionMessageOrderByWithRelationInput[]
    cursor?: AiSessionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiSessionMessageScalarFieldEnum | AiSessionMessageScalarFieldEnum[]
  }

  /**
   * AiSession.context
   */
  export type AiSession$contextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    where?: AiContextWhereInput
    orderBy?: AiContextOrderByWithRelationInput | AiContextOrderByWithRelationInput[]
    cursor?: AiContextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiContextScalarFieldEnum | AiContextScalarFieldEnum[]
  }

  /**
   * AiSession without action
   */
  export type AiSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiSession
     */
    select?: AiSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiSession
     */
    omit?: AiSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiSessionInclude<ExtArgs> | null
  }


  /**
   * Model AiContext
   */

  export type AggregateAiContext = {
    _count: AiContextCountAggregateOutputType | null
    _min: AiContextMinAggregateOutputType | null
    _max: AiContextMaxAggregateOutputType | null
  }

  export type AiContextMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiContextMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiContextCountAggregateOutputType = {
    id: number
    sessionId: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiContextMinAggregateInputType = {
    id?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiContextMaxAggregateInputType = {
    id?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiContextCountAggregateInputType = {
    id?: true
    sessionId?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiContext to aggregate.
     */
    where?: AiContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContexts to fetch.
     */
    orderBy?: AiContextOrderByWithRelationInput | AiContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiContexts
    **/
    _count?: true | AiContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiContextMaxAggregateInputType
  }

  export type GetAiContextAggregateType<T extends AiContextAggregateArgs> = {
        [P in keyof T & keyof AggregateAiContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiContext[P]>
      : GetScalarType<T[P], AggregateAiContext[P]>
  }




  export type AiContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiContextWhereInput
    orderBy?: AiContextOrderByWithAggregationInput | AiContextOrderByWithAggregationInput[]
    by: AiContextScalarFieldEnum[] | AiContextScalarFieldEnum
    having?: AiContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiContextCountAggregateInputType | true
    _min?: AiContextMinAggregateInputType
    _max?: AiContextMaxAggregateInputType
  }

  export type AiContextGroupByOutputType = {
    id: string
    sessionId: string
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AiContextCountAggregateOutputType | null
    _min: AiContextMinAggregateOutputType | null
    _max: AiContextMaxAggregateOutputType | null
  }

  type GetAiContextGroupByPayload<T extends AiContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiContextGroupByOutputType[P]>
            : GetScalarType<T[P], AiContextGroupByOutputType[P]>
        }
      >
    >


  export type AiContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    embeddings?: boolean | AiContext$embeddingsArgs<ExtArgs>
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
    _count?: boolean | AiContextCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiContext"]>

  export type AiContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiContext"]>

  export type AiContextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiContext"]>

  export type AiContextSelectScalar = {
    id?: boolean
    sessionId?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiContextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "config" | "createdAt" | "updatedAt", ExtArgs["result"]["aiContext"]>
  export type AiContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    embeddings?: boolean | AiContext$embeddingsArgs<ExtArgs>
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
    _count?: boolean | AiContextCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }
  export type AiContextIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | AiSessionDefaultArgs<ExtArgs>
  }

  export type $AiContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiContext"
    objects: {
      embeddings: Prisma.$AiContextEmbeddingPayload<ExtArgs>[]
      session: Prisma.$AiSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiContext"]>
    composites: {}
  }

  type AiContextGetPayload<S extends boolean | null | undefined | AiContextDefaultArgs> = $Result.GetResult<Prisma.$AiContextPayload, S>

  type AiContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiContextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiContextCountAggregateInputType | true
    }

  export interface AiContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiContext'], meta: { name: 'AiContext' } }
    /**
     * Find zero or one AiContext that matches the filter.
     * @param {AiContextFindUniqueArgs} args - Arguments to find a AiContext
     * @example
     * // Get one AiContext
     * const aiContext = await prisma.aiContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiContextFindUniqueArgs>(args: SelectSubset<T, AiContextFindUniqueArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiContext that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiContextFindUniqueOrThrowArgs} args - Arguments to find a AiContext
     * @example
     * // Get one AiContext
     * const aiContext = await prisma.aiContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiContextFindUniqueOrThrowArgs>(args: SelectSubset<T, AiContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextFindFirstArgs} args - Arguments to find a AiContext
     * @example
     * // Get one AiContext
     * const aiContext = await prisma.aiContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiContextFindFirstArgs>(args?: SelectSubset<T, AiContextFindFirstArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextFindFirstOrThrowArgs} args - Arguments to find a AiContext
     * @example
     * // Get one AiContext
     * const aiContext = await prisma.aiContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiContextFindFirstOrThrowArgs>(args?: SelectSubset<T, AiContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiContexts
     * const aiContexts = await prisma.aiContext.findMany()
     * 
     * // Get first 10 AiContexts
     * const aiContexts = await prisma.aiContext.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiContextWithIdOnly = await prisma.aiContext.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiContextFindManyArgs>(args?: SelectSubset<T, AiContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiContext.
     * @param {AiContextCreateArgs} args - Arguments to create a AiContext.
     * @example
     * // Create one AiContext
     * const AiContext = await prisma.aiContext.create({
     *   data: {
     *     // ... data to create a AiContext
     *   }
     * })
     * 
     */
    create<T extends AiContextCreateArgs>(args: SelectSubset<T, AiContextCreateArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiContexts.
     * @param {AiContextCreateManyArgs} args - Arguments to create many AiContexts.
     * @example
     * // Create many AiContexts
     * const aiContext = await prisma.aiContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiContextCreateManyArgs>(args?: SelectSubset<T, AiContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiContexts and returns the data saved in the database.
     * @param {AiContextCreateManyAndReturnArgs} args - Arguments to create many AiContexts.
     * @example
     * // Create many AiContexts
     * const aiContext = await prisma.aiContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiContexts and only return the `id`
     * const aiContextWithIdOnly = await prisma.aiContext.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiContextCreateManyAndReturnArgs>(args?: SelectSubset<T, AiContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiContext.
     * @param {AiContextDeleteArgs} args - Arguments to delete one AiContext.
     * @example
     * // Delete one AiContext
     * const AiContext = await prisma.aiContext.delete({
     *   where: {
     *     // ... filter to delete one AiContext
     *   }
     * })
     * 
     */
    delete<T extends AiContextDeleteArgs>(args: SelectSubset<T, AiContextDeleteArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiContext.
     * @param {AiContextUpdateArgs} args - Arguments to update one AiContext.
     * @example
     * // Update one AiContext
     * const aiContext = await prisma.aiContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiContextUpdateArgs>(args: SelectSubset<T, AiContextUpdateArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiContexts.
     * @param {AiContextDeleteManyArgs} args - Arguments to filter AiContexts to delete.
     * @example
     * // Delete a few AiContexts
     * const { count } = await prisma.aiContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiContextDeleteManyArgs>(args?: SelectSubset<T, AiContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiContexts
     * const aiContext = await prisma.aiContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiContextUpdateManyArgs>(args: SelectSubset<T, AiContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiContexts and returns the data updated in the database.
     * @param {AiContextUpdateManyAndReturnArgs} args - Arguments to update many AiContexts.
     * @example
     * // Update many AiContexts
     * const aiContext = await prisma.aiContext.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiContexts and only return the `id`
     * const aiContextWithIdOnly = await prisma.aiContext.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiContextUpdateManyAndReturnArgs>(args: SelectSubset<T, AiContextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiContext.
     * @param {AiContextUpsertArgs} args - Arguments to update or create a AiContext.
     * @example
     * // Update or create a AiContext
     * const aiContext = await prisma.aiContext.upsert({
     *   create: {
     *     // ... data to create a AiContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiContext we want to update
     *   }
     * })
     */
    upsert<T extends AiContextUpsertArgs>(args: SelectSubset<T, AiContextUpsertArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextCountArgs} args - Arguments to filter AiContexts to count.
     * @example
     * // Count the number of AiContexts
     * const count = await prisma.aiContext.count({
     *   where: {
     *     // ... the filter for the AiContexts we want to count
     *   }
     * })
    **/
    count<T extends AiContextCountArgs>(
      args?: Subset<T, AiContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiContextAggregateArgs>(args: Subset<T, AiContextAggregateArgs>): Prisma.PrismaPromise<GetAiContextAggregateType<T>>

    /**
     * Group by AiContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiContextGroupByArgs['orderBy'] }
        : { orderBy?: AiContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiContext model
   */
  readonly fields: AiContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    embeddings<T extends AiContext$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, AiContext$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session<T extends AiSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiSessionDefaultArgs<ExtArgs>>): Prisma__AiSessionClient<$Result.GetResult<Prisma.$AiSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiContext model
   */
  interface AiContextFieldRefs {
    readonly id: FieldRef<"AiContext", 'String'>
    readonly sessionId: FieldRef<"AiContext", 'String'>
    readonly config: FieldRef<"AiContext", 'Json'>
    readonly createdAt: FieldRef<"AiContext", 'DateTime'>
    readonly updatedAt: FieldRef<"AiContext", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiContext findUnique
   */
  export type AiContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter, which AiContext to fetch.
     */
    where: AiContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext findUniqueOrThrow
   */
  export type AiContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter, which AiContext to fetch.
     */
    where: AiContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext findFirst
   */
  export type AiContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter, which AiContext to fetch.
     */
    where?: AiContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContexts to fetch.
     */
    orderBy?: AiContextOrderByWithRelationInput | AiContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiContexts.
     */
    cursor?: AiContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiContexts.
     */
    distinct?: AiContextScalarFieldEnum | AiContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext findFirstOrThrow
   */
  export type AiContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter, which AiContext to fetch.
     */
    where?: AiContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContexts to fetch.
     */
    orderBy?: AiContextOrderByWithRelationInput | AiContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiContexts.
     */
    cursor?: AiContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiContexts.
     */
    distinct?: AiContextScalarFieldEnum | AiContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext findMany
   */
  export type AiContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter, which AiContexts to fetch.
     */
    where?: AiContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContexts to fetch.
     */
    orderBy?: AiContextOrderByWithRelationInput | AiContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiContexts.
     */
    cursor?: AiContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContexts.
     */
    skip?: number
    distinct?: AiContextScalarFieldEnum | AiContextScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext create
   */
  export type AiContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * The data needed to create a AiContext.
     */
    data: XOR<AiContextCreateInput, AiContextUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext createMany
   */
  export type AiContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiContexts.
     */
    data: AiContextCreateManyInput | AiContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiContext createManyAndReturn
   */
  export type AiContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * The data used to create many AiContexts.
     */
    data: AiContextCreateManyInput | AiContextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiContext update
   */
  export type AiContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * The data needed to update a AiContext.
     */
    data: XOR<AiContextUpdateInput, AiContextUncheckedUpdateInput>
    /**
     * Choose, which AiContext to update.
     */
    where: AiContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext updateMany
   */
  export type AiContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiContexts.
     */
    data: XOR<AiContextUpdateManyMutationInput, AiContextUncheckedUpdateManyInput>
    /**
     * Filter which AiContexts to update
     */
    where?: AiContextWhereInput
    /**
     * Limit how many AiContexts to update.
     */
    limit?: number
  }

  /**
   * AiContext updateManyAndReturn
   */
  export type AiContextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * The data used to update AiContexts.
     */
    data: XOR<AiContextUpdateManyMutationInput, AiContextUncheckedUpdateManyInput>
    /**
     * Filter which AiContexts to update
     */
    where?: AiContextWhereInput
    /**
     * Limit how many AiContexts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiContext upsert
   */
  export type AiContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * The filter to search for the AiContext to update in case it exists.
     */
    where: AiContextWhereUniqueInput
    /**
     * In case the AiContext found by the `where` argument doesn't exist, create a new AiContext with this data.
     */
    create: XOR<AiContextCreateInput, AiContextUncheckedCreateInput>
    /**
     * In case the AiContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiContextUpdateInput, AiContextUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext delete
   */
  export type AiContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
    /**
     * Filter which AiContext to delete.
     */
    where: AiContextWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContext deleteMany
   */
  export type AiContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiContexts to delete
     */
    where?: AiContextWhereInput
    /**
     * Limit how many AiContexts to delete.
     */
    limit?: number
  }

  /**
   * AiContext.embeddings
   */
  export type AiContext$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    where?: AiContextEmbeddingWhereInput
    orderBy?: AiContextEmbeddingOrderByWithRelationInput | AiContextEmbeddingOrderByWithRelationInput[]
    cursor?: AiContextEmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiContextEmbeddingScalarFieldEnum | AiContextEmbeddingScalarFieldEnum[]
  }

  /**
   * AiContext without action
   */
  export type AiContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContext
     */
    select?: AiContextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContext
     */
    omit?: AiContextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextInclude<ExtArgs> | null
  }


  /**
   * Model AiContextEmbedding
   */

  export type AggregateAiContextEmbedding = {
    _count: AiContextEmbeddingCountAggregateOutputType | null
    _avg: AiContextEmbeddingAvgAggregateOutputType | null
    _sum: AiContextEmbeddingSumAggregateOutputType | null
    _min: AiContextEmbeddingMinAggregateOutputType | null
    _max: AiContextEmbeddingMaxAggregateOutputType | null
  }

  export type AiContextEmbeddingAvgAggregateOutputType = {
    chunk: number | null
  }

  export type AiContextEmbeddingSumAggregateOutputType = {
    chunk: number | null
  }

  export type AiContextEmbeddingMinAggregateOutputType = {
    id: string | null
    contextId: string | null
    fileId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiContextEmbeddingMaxAggregateOutputType = {
    id: string | null
    contextId: string | null
    fileId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiContextEmbeddingCountAggregateOutputType = {
    id: number
    contextId: number
    fileId: number
    chunk: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiContextEmbeddingAvgAggregateInputType = {
    chunk?: true
  }

  export type AiContextEmbeddingSumAggregateInputType = {
    chunk?: true
  }

  export type AiContextEmbeddingMinAggregateInputType = {
    id?: true
    contextId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiContextEmbeddingMaxAggregateInputType = {
    id?: true
    contextId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiContextEmbeddingCountAggregateInputType = {
    id?: true
    contextId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiContextEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiContextEmbedding to aggregate.
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContextEmbeddings to fetch.
     */
    orderBy?: AiContextEmbeddingOrderByWithRelationInput | AiContextEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiContextEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContextEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContextEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiContextEmbeddings
    **/
    _count?: true | AiContextEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiContextEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiContextEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiContextEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiContextEmbeddingMaxAggregateInputType
  }

  export type GetAiContextEmbeddingAggregateType<T extends AiContextEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateAiContextEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiContextEmbedding[P]>
      : GetScalarType<T[P], AggregateAiContextEmbedding[P]>
  }




  export type AiContextEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiContextEmbeddingWhereInput
    orderBy?: AiContextEmbeddingOrderByWithAggregationInput | AiContextEmbeddingOrderByWithAggregationInput[]
    by: AiContextEmbeddingScalarFieldEnum[] | AiContextEmbeddingScalarFieldEnum
    having?: AiContextEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiContextEmbeddingCountAggregateInputType | true
    _avg?: AiContextEmbeddingAvgAggregateInputType
    _sum?: AiContextEmbeddingSumAggregateInputType
    _min?: AiContextEmbeddingMinAggregateInputType
    _max?: AiContextEmbeddingMaxAggregateInputType
  }

  export type AiContextEmbeddingGroupByOutputType = {
    id: string
    contextId: string
    fileId: string
    chunk: number
    content: string
    createdAt: Date
    updatedAt: Date
    _count: AiContextEmbeddingCountAggregateOutputType | null
    _avg: AiContextEmbeddingAvgAggregateOutputType | null
    _sum: AiContextEmbeddingSumAggregateOutputType | null
    _min: AiContextEmbeddingMinAggregateOutputType | null
    _max: AiContextEmbeddingMaxAggregateOutputType | null
  }

  type GetAiContextEmbeddingGroupByPayload<T extends AiContextEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiContextEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiContextEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiContextEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], AiContextEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type AiContextEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contextId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    context?: boolean | AiContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiContextEmbedding"]>


  export type AiContextEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contextId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    context?: boolean | AiContextDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiContextEmbedding"]>

  export type AiContextEmbeddingSelectScalar = {
    id?: boolean
    contextId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiContextEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contextId" | "fileId" | "chunk" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["aiContextEmbedding"]>
  export type AiContextEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    context?: boolean | AiContextDefaultArgs<ExtArgs>
  }
  export type AiContextEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    context?: boolean | AiContextDefaultArgs<ExtArgs>
  }

  export type $AiContextEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiContextEmbedding"
    objects: {
      context: Prisma.$AiContextPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contextId: string
      fileId: string
      chunk: number
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiContextEmbedding"]>
    composites: {}
  }

  type AiContextEmbeddingGetPayload<S extends boolean | null | undefined | AiContextEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$AiContextEmbeddingPayload, S>

  type AiContextEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiContextEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiContextEmbeddingCountAggregateInputType | true
    }

  export interface AiContextEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiContextEmbedding'], meta: { name: 'AiContextEmbedding' } }
    /**
     * Find zero or one AiContextEmbedding that matches the filter.
     * @param {AiContextEmbeddingFindUniqueArgs} args - Arguments to find a AiContextEmbedding
     * @example
     * // Get one AiContextEmbedding
     * const aiContextEmbedding = await prisma.aiContextEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiContextEmbeddingFindUniqueArgs>(args: SelectSubset<T, AiContextEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiContextEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiContextEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a AiContextEmbedding
     * @example
     * // Get one AiContextEmbedding
     * const aiContextEmbedding = await prisma.aiContextEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiContextEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, AiContextEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiContextEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingFindFirstArgs} args - Arguments to find a AiContextEmbedding
     * @example
     * // Get one AiContextEmbedding
     * const aiContextEmbedding = await prisma.aiContextEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiContextEmbeddingFindFirstArgs>(args?: SelectSubset<T, AiContextEmbeddingFindFirstArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiContextEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingFindFirstOrThrowArgs} args - Arguments to find a AiContextEmbedding
     * @example
     * // Get one AiContextEmbedding
     * const aiContextEmbedding = await prisma.aiContextEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiContextEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, AiContextEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiContextEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiContextEmbeddings
     * const aiContextEmbeddings = await prisma.aiContextEmbedding.findMany()
     * 
     * // Get first 10 AiContextEmbeddings
     * const aiContextEmbeddings = await prisma.aiContextEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiContextEmbeddingWithIdOnly = await prisma.aiContextEmbedding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiContextEmbeddingFindManyArgs>(args?: SelectSubset<T, AiContextEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a AiContextEmbedding.
     * @param {AiContextEmbeddingDeleteArgs} args - Arguments to delete one AiContextEmbedding.
     * @example
     * // Delete one AiContextEmbedding
     * const AiContextEmbedding = await prisma.aiContextEmbedding.delete({
     *   where: {
     *     // ... filter to delete one AiContextEmbedding
     *   }
     * })
     * 
     */
    delete<T extends AiContextEmbeddingDeleteArgs>(args: SelectSubset<T, AiContextEmbeddingDeleteArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiContextEmbedding.
     * @param {AiContextEmbeddingUpdateArgs} args - Arguments to update one AiContextEmbedding.
     * @example
     * // Update one AiContextEmbedding
     * const aiContextEmbedding = await prisma.aiContextEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiContextEmbeddingUpdateArgs>(args: SelectSubset<T, AiContextEmbeddingUpdateArgs<ExtArgs>>): Prisma__AiContextEmbeddingClient<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiContextEmbeddings.
     * @param {AiContextEmbeddingDeleteManyArgs} args - Arguments to filter AiContextEmbeddings to delete.
     * @example
     * // Delete a few AiContextEmbeddings
     * const { count } = await prisma.aiContextEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiContextEmbeddingDeleteManyArgs>(args?: SelectSubset<T, AiContextEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiContextEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiContextEmbeddings
     * const aiContextEmbedding = await prisma.aiContextEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiContextEmbeddingUpdateManyArgs>(args: SelectSubset<T, AiContextEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiContextEmbeddings and returns the data updated in the database.
     * @param {AiContextEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many AiContextEmbeddings.
     * @example
     * // Update many AiContextEmbeddings
     * const aiContextEmbedding = await prisma.aiContextEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiContextEmbeddings and only return the `id`
     * const aiContextEmbeddingWithIdOnly = await prisma.aiContextEmbedding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiContextEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, AiContextEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiContextEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of AiContextEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingCountArgs} args - Arguments to filter AiContextEmbeddings to count.
     * @example
     * // Count the number of AiContextEmbeddings
     * const count = await prisma.aiContextEmbedding.count({
     *   where: {
     *     // ... the filter for the AiContextEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends AiContextEmbeddingCountArgs>(
      args?: Subset<T, AiContextEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiContextEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiContextEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiContextEmbeddingAggregateArgs>(args: Subset<T, AiContextEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetAiContextEmbeddingAggregateType<T>>

    /**
     * Group by AiContextEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiContextEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiContextEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiContextEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: AiContextEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiContextEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiContextEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiContextEmbedding model
   */
  readonly fields: AiContextEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiContextEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiContextEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    context<T extends AiContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiContextDefaultArgs<ExtArgs>>): Prisma__AiContextClient<$Result.GetResult<Prisma.$AiContextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiContextEmbedding model
   */
  interface AiContextEmbeddingFieldRefs {
    readonly id: FieldRef<"AiContextEmbedding", 'String'>
    readonly contextId: FieldRef<"AiContextEmbedding", 'String'>
    readonly fileId: FieldRef<"AiContextEmbedding", 'String'>
    readonly chunk: FieldRef<"AiContextEmbedding", 'Int'>
    readonly content: FieldRef<"AiContextEmbedding", 'String'>
    readonly createdAt: FieldRef<"AiContextEmbedding", 'DateTime'>
    readonly updatedAt: FieldRef<"AiContextEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiContextEmbedding findUnique
   */
  export type AiContextEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiContextEmbedding to fetch.
     */
    where: AiContextEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding findUniqueOrThrow
   */
  export type AiContextEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiContextEmbedding to fetch.
     */
    where: AiContextEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding findFirst
   */
  export type AiContextEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiContextEmbedding to fetch.
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContextEmbeddings to fetch.
     */
    orderBy?: AiContextEmbeddingOrderByWithRelationInput | AiContextEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiContextEmbeddings.
     */
    cursor?: AiContextEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContextEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContextEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiContextEmbeddings.
     */
    distinct?: AiContextEmbeddingScalarFieldEnum | AiContextEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding findFirstOrThrow
   */
  export type AiContextEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiContextEmbedding to fetch.
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContextEmbeddings to fetch.
     */
    orderBy?: AiContextEmbeddingOrderByWithRelationInput | AiContextEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiContextEmbeddings.
     */
    cursor?: AiContextEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContextEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContextEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiContextEmbeddings.
     */
    distinct?: AiContextEmbeddingScalarFieldEnum | AiContextEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding findMany
   */
  export type AiContextEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiContextEmbeddings to fetch.
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiContextEmbeddings to fetch.
     */
    orderBy?: AiContextEmbeddingOrderByWithRelationInput | AiContextEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiContextEmbeddings.
     */
    cursor?: AiContextEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiContextEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiContextEmbeddings.
     */
    skip?: number
    distinct?: AiContextEmbeddingScalarFieldEnum | AiContextEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding update
   */
  export type AiContextEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a AiContextEmbedding.
     */
    data: XOR<AiContextEmbeddingUpdateInput, AiContextEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which AiContextEmbedding to update.
     */
    where: AiContextEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding updateMany
   */
  export type AiContextEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiContextEmbeddings.
     */
    data: XOR<AiContextEmbeddingUpdateManyMutationInput, AiContextEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiContextEmbeddings to update
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * Limit how many AiContextEmbeddings to update.
     */
    limit?: number
  }

  /**
   * AiContextEmbedding updateManyAndReturn
   */
  export type AiContextEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update AiContextEmbeddings.
     */
    data: XOR<AiContextEmbeddingUpdateManyMutationInput, AiContextEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiContextEmbeddings to update
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * Limit how many AiContextEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiContextEmbedding delete
   */
  export type AiContextEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which AiContextEmbedding to delete.
     */
    where: AiContextEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiContextEmbedding deleteMany
   */
  export type AiContextEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiContextEmbeddings to delete
     */
    where?: AiContextEmbeddingWhereInput
    /**
     * Limit how many AiContextEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * AiContextEmbedding without action
   */
  export type AiContextEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiContextEmbedding
     */
    select?: AiContextEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiContextEmbedding
     */
    omit?: AiContextEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiContextEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model AiWorkspaceEmbedding
   */

  export type AggregateAiWorkspaceEmbedding = {
    _count: AiWorkspaceEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceEmbeddingMaxAggregateOutputType | null
  }

  export type AiWorkspaceEmbeddingAvgAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceEmbeddingSumAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceEmbeddingMinAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiWorkspaceEmbeddingMaxAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AiWorkspaceEmbeddingCountAggregateOutputType = {
    workspaceId: number
    docId: number
    chunk: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AiWorkspaceEmbeddingAvgAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceEmbeddingSumAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceEmbeddingMinAggregateInputType = {
    workspaceId?: true
    docId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiWorkspaceEmbeddingMaxAggregateInputType = {
    workspaceId?: true
    docId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AiWorkspaceEmbeddingCountAggregateInputType = {
    workspaceId?: true
    docId?: true
    chunk?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AiWorkspaceEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceEmbedding to aggregate.
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceEmbeddingOrderByWithRelationInput | AiWorkspaceEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiWorkspaceEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiWorkspaceEmbeddings
    **/
    _count?: true | AiWorkspaceEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiWorkspaceEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiWorkspaceEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiWorkspaceEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiWorkspaceEmbeddingMaxAggregateInputType
  }

  export type GetAiWorkspaceEmbeddingAggregateType<T extends AiWorkspaceEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateAiWorkspaceEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiWorkspaceEmbedding[P]>
      : GetScalarType<T[P], AggregateAiWorkspaceEmbedding[P]>
  }




  export type AiWorkspaceEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceEmbeddingWhereInput
    orderBy?: AiWorkspaceEmbeddingOrderByWithAggregationInput | AiWorkspaceEmbeddingOrderByWithAggregationInput[]
    by: AiWorkspaceEmbeddingScalarFieldEnum[] | AiWorkspaceEmbeddingScalarFieldEnum
    having?: AiWorkspaceEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiWorkspaceEmbeddingCountAggregateInputType | true
    _avg?: AiWorkspaceEmbeddingAvgAggregateInputType
    _sum?: AiWorkspaceEmbeddingSumAggregateInputType
    _min?: AiWorkspaceEmbeddingMinAggregateInputType
    _max?: AiWorkspaceEmbeddingMaxAggregateInputType
  }

  export type AiWorkspaceEmbeddingGroupByOutputType = {
    workspaceId: string
    docId: string
    chunk: number
    content: string
    createdAt: Date
    updatedAt: Date
    _count: AiWorkspaceEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceEmbeddingMaxAggregateOutputType | null
  }

  type GetAiWorkspaceEmbeddingGroupByPayload<T extends AiWorkspaceEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiWorkspaceEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiWorkspaceEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiWorkspaceEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], AiWorkspaceEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type AiWorkspaceEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    snapshot?: boolean | SnapshotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceEmbedding"]>


  export type AiWorkspaceEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    snapshot?: boolean | SnapshotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceEmbedding"]>

  export type AiWorkspaceEmbeddingSelectScalar = {
    workspaceId?: boolean
    docId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AiWorkspaceEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "docId" | "chunk" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["aiWorkspaceEmbedding"]>
  export type AiWorkspaceEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshot?: boolean | SnapshotDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshot?: boolean | SnapshotDefaultArgs<ExtArgs>
  }

  export type $AiWorkspaceEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiWorkspaceEmbedding"
    objects: {
      snapshot: Prisma.$SnapshotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      docId: string
      chunk: number
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aiWorkspaceEmbedding"]>
    composites: {}
  }

  type AiWorkspaceEmbeddingGetPayload<S extends boolean | null | undefined | AiWorkspaceEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload, S>

  type AiWorkspaceEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiWorkspaceEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiWorkspaceEmbeddingCountAggregateInputType | true
    }

  export interface AiWorkspaceEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiWorkspaceEmbedding'], meta: { name: 'AiWorkspaceEmbedding' } }
    /**
     * Find zero or one AiWorkspaceEmbedding that matches the filter.
     * @param {AiWorkspaceEmbeddingFindUniqueArgs} args - Arguments to find a AiWorkspaceEmbedding
     * @example
     * // Get one AiWorkspaceEmbedding
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiWorkspaceEmbeddingFindUniqueArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiWorkspaceEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiWorkspaceEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a AiWorkspaceEmbedding
     * @example
     * // Get one AiWorkspaceEmbedding
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiWorkspaceEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingFindFirstArgs} args - Arguments to find a AiWorkspaceEmbedding
     * @example
     * // Get one AiWorkspaceEmbedding
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiWorkspaceEmbeddingFindFirstArgs>(args?: SelectSubset<T, AiWorkspaceEmbeddingFindFirstArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingFindFirstOrThrowArgs} args - Arguments to find a AiWorkspaceEmbedding
     * @example
     * // Get one AiWorkspaceEmbedding
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiWorkspaceEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, AiWorkspaceEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiWorkspaceEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiWorkspaceEmbeddings
     * const aiWorkspaceEmbeddings = await prisma.aiWorkspaceEmbedding.findMany()
     * 
     * // Get first 10 AiWorkspaceEmbeddings
     * const aiWorkspaceEmbeddings = await prisma.aiWorkspaceEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const aiWorkspaceEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceEmbedding.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends AiWorkspaceEmbeddingFindManyArgs>(args?: SelectSubset<T, AiWorkspaceEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a AiWorkspaceEmbedding.
     * @param {AiWorkspaceEmbeddingDeleteArgs} args - Arguments to delete one AiWorkspaceEmbedding.
     * @example
     * // Delete one AiWorkspaceEmbedding
     * const AiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.delete({
     *   where: {
     *     // ... filter to delete one AiWorkspaceEmbedding
     *   }
     * })
     * 
     */
    delete<T extends AiWorkspaceEmbeddingDeleteArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingDeleteArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiWorkspaceEmbedding.
     * @param {AiWorkspaceEmbeddingUpdateArgs} args - Arguments to update one AiWorkspaceEmbedding.
     * @example
     * // Update one AiWorkspaceEmbedding
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiWorkspaceEmbeddingUpdateArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingUpdateArgs<ExtArgs>>): Prisma__AiWorkspaceEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiWorkspaceEmbeddings.
     * @param {AiWorkspaceEmbeddingDeleteManyArgs} args - Arguments to filter AiWorkspaceEmbeddings to delete.
     * @example
     * // Delete a few AiWorkspaceEmbeddings
     * const { count } = await prisma.aiWorkspaceEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiWorkspaceEmbeddingDeleteManyArgs>(args?: SelectSubset<T, AiWorkspaceEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiWorkspaceEmbeddings
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiWorkspaceEmbeddingUpdateManyArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceEmbeddings and returns the data updated in the database.
     * @param {AiWorkspaceEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many AiWorkspaceEmbeddings.
     * @example
     * // Update many AiWorkspaceEmbeddings
     * const aiWorkspaceEmbedding = await prisma.aiWorkspaceEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiWorkspaceEmbeddings and only return the `workspaceId`
     * const aiWorkspaceEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceEmbedding.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiWorkspaceEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, AiWorkspaceEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of AiWorkspaceEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingCountArgs} args - Arguments to filter AiWorkspaceEmbeddings to count.
     * @example
     * // Count the number of AiWorkspaceEmbeddings
     * const count = await prisma.aiWorkspaceEmbedding.count({
     *   where: {
     *     // ... the filter for the AiWorkspaceEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends AiWorkspaceEmbeddingCountArgs>(
      args?: Subset<T, AiWorkspaceEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiWorkspaceEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiWorkspaceEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiWorkspaceEmbeddingAggregateArgs>(args: Subset<T, AiWorkspaceEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetAiWorkspaceEmbeddingAggregateType<T>>

    /**
     * Group by AiWorkspaceEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiWorkspaceEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiWorkspaceEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: AiWorkspaceEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiWorkspaceEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiWorkspaceEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiWorkspaceEmbedding model
   */
  readonly fields: AiWorkspaceEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiWorkspaceEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiWorkspaceEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snapshot<T extends SnapshotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SnapshotDefaultArgs<ExtArgs>>): Prisma__SnapshotClient<$Result.GetResult<Prisma.$SnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiWorkspaceEmbedding model
   */
  interface AiWorkspaceEmbeddingFieldRefs {
    readonly workspaceId: FieldRef<"AiWorkspaceEmbedding", 'String'>
    readonly docId: FieldRef<"AiWorkspaceEmbedding", 'String'>
    readonly chunk: FieldRef<"AiWorkspaceEmbedding", 'Int'>
    readonly content: FieldRef<"AiWorkspaceEmbedding", 'String'>
    readonly createdAt: FieldRef<"AiWorkspaceEmbedding", 'DateTime'>
    readonly updatedAt: FieldRef<"AiWorkspaceEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiWorkspaceEmbedding findUnique
   */
  export type AiWorkspaceEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceEmbedding to fetch.
     */
    where: AiWorkspaceEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding findUniqueOrThrow
   */
  export type AiWorkspaceEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceEmbedding to fetch.
     */
    where: AiWorkspaceEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding findFirst
   */
  export type AiWorkspaceEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceEmbedding to fetch.
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceEmbeddingOrderByWithRelationInput | AiWorkspaceEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceEmbeddings.
     */
    cursor?: AiWorkspaceEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceEmbeddings.
     */
    distinct?: AiWorkspaceEmbeddingScalarFieldEnum | AiWorkspaceEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding findFirstOrThrow
   */
  export type AiWorkspaceEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceEmbedding to fetch.
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceEmbeddingOrderByWithRelationInput | AiWorkspaceEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceEmbeddings.
     */
    cursor?: AiWorkspaceEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceEmbeddings.
     */
    distinct?: AiWorkspaceEmbeddingScalarFieldEnum | AiWorkspaceEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding findMany
   */
  export type AiWorkspaceEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceEmbeddings to fetch.
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceEmbeddingOrderByWithRelationInput | AiWorkspaceEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiWorkspaceEmbeddings.
     */
    cursor?: AiWorkspaceEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceEmbeddings.
     */
    skip?: number
    distinct?: AiWorkspaceEmbeddingScalarFieldEnum | AiWorkspaceEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding update
   */
  export type AiWorkspaceEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a AiWorkspaceEmbedding.
     */
    data: XOR<AiWorkspaceEmbeddingUpdateInput, AiWorkspaceEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which AiWorkspaceEmbedding to update.
     */
    where: AiWorkspaceEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding updateMany
   */
  export type AiWorkspaceEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiWorkspaceEmbeddings.
     */
    data: XOR<AiWorkspaceEmbeddingUpdateManyMutationInput, AiWorkspaceEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceEmbeddings to update
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceEmbeddings to update.
     */
    limit?: number
  }

  /**
   * AiWorkspaceEmbedding updateManyAndReturn
   */
  export type AiWorkspaceEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update AiWorkspaceEmbeddings.
     */
    data: XOR<AiWorkspaceEmbeddingUpdateManyMutationInput, AiWorkspaceEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceEmbeddings to update
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceEmbedding delete
   */
  export type AiWorkspaceEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which AiWorkspaceEmbedding to delete.
     */
    where: AiWorkspaceEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceEmbedding deleteMany
   */
  export type AiWorkspaceEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceEmbeddings to delete
     */
    where?: AiWorkspaceEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * AiWorkspaceEmbedding without action
   */
  export type AiWorkspaceEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceEmbedding
     */
    select?: AiWorkspaceEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceEmbedding
     */
    omit?: AiWorkspaceEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model AiWorkspaceIgnoredDocs
   */

  export type AggregateAiWorkspaceIgnoredDocs = {
    _count: AiWorkspaceIgnoredDocsCountAggregateOutputType | null
    _min: AiWorkspaceIgnoredDocsMinAggregateOutputType | null
    _max: AiWorkspaceIgnoredDocsMaxAggregateOutputType | null
  }

  export type AiWorkspaceIgnoredDocsMinAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceIgnoredDocsMaxAggregateOutputType = {
    workspaceId: string | null
    docId: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceIgnoredDocsCountAggregateOutputType = {
    workspaceId: number
    docId: number
    createdAt: number
    _all: number
  }


  export type AiWorkspaceIgnoredDocsMinAggregateInputType = {
    workspaceId?: true
    docId?: true
    createdAt?: true
  }

  export type AiWorkspaceIgnoredDocsMaxAggregateInputType = {
    workspaceId?: true
    docId?: true
    createdAt?: true
  }

  export type AiWorkspaceIgnoredDocsCountAggregateInputType = {
    workspaceId?: true
    docId?: true
    createdAt?: true
    _all?: true
  }

  export type AiWorkspaceIgnoredDocsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceIgnoredDocs to aggregate.
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceIgnoredDocs to fetch.
     */
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithRelationInput | AiWorkspaceIgnoredDocsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiWorkspaceIgnoredDocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceIgnoredDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceIgnoredDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiWorkspaceIgnoredDocs
    **/
    _count?: true | AiWorkspaceIgnoredDocsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiWorkspaceIgnoredDocsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiWorkspaceIgnoredDocsMaxAggregateInputType
  }

  export type GetAiWorkspaceIgnoredDocsAggregateType<T extends AiWorkspaceIgnoredDocsAggregateArgs> = {
        [P in keyof T & keyof AggregateAiWorkspaceIgnoredDocs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiWorkspaceIgnoredDocs[P]>
      : GetScalarType<T[P], AggregateAiWorkspaceIgnoredDocs[P]>
  }




  export type AiWorkspaceIgnoredDocsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceIgnoredDocsWhereInput
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithAggregationInput | AiWorkspaceIgnoredDocsOrderByWithAggregationInput[]
    by: AiWorkspaceIgnoredDocsScalarFieldEnum[] | AiWorkspaceIgnoredDocsScalarFieldEnum
    having?: AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiWorkspaceIgnoredDocsCountAggregateInputType | true
    _min?: AiWorkspaceIgnoredDocsMinAggregateInputType
    _max?: AiWorkspaceIgnoredDocsMaxAggregateInputType
  }

  export type AiWorkspaceIgnoredDocsGroupByOutputType = {
    workspaceId: string
    docId: string
    createdAt: Date
    _count: AiWorkspaceIgnoredDocsCountAggregateOutputType | null
    _min: AiWorkspaceIgnoredDocsMinAggregateOutputType | null
    _max: AiWorkspaceIgnoredDocsMaxAggregateOutputType | null
  }

  type GetAiWorkspaceIgnoredDocsGroupByPayload<T extends AiWorkspaceIgnoredDocsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiWorkspaceIgnoredDocsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiWorkspaceIgnoredDocsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiWorkspaceIgnoredDocsGroupByOutputType[P]>
            : GetScalarType<T[P], AiWorkspaceIgnoredDocsGroupByOutputType[P]>
        }
      >
    >


  export type AiWorkspaceIgnoredDocsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceIgnoredDocs"]>

  export type AiWorkspaceIgnoredDocsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceIgnoredDocs"]>

  export type AiWorkspaceIgnoredDocsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    docId?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceIgnoredDocs"]>

  export type AiWorkspaceIgnoredDocsSelectScalar = {
    workspaceId?: boolean
    docId?: boolean
    createdAt?: boolean
  }

  export type AiWorkspaceIgnoredDocsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "docId" | "createdAt", ExtArgs["result"]["aiWorkspaceIgnoredDocs"]>
  export type AiWorkspaceIgnoredDocsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceIgnoredDocsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceIgnoredDocsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AiWorkspaceIgnoredDocsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiWorkspaceIgnoredDocs"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      docId: string
      createdAt: Date
    }, ExtArgs["result"]["aiWorkspaceIgnoredDocs"]>
    composites: {}
  }

  type AiWorkspaceIgnoredDocsGetPayload<S extends boolean | null | undefined | AiWorkspaceIgnoredDocsDefaultArgs> = $Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload, S>

  type AiWorkspaceIgnoredDocsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiWorkspaceIgnoredDocsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiWorkspaceIgnoredDocsCountAggregateInputType | true
    }

  export interface AiWorkspaceIgnoredDocsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiWorkspaceIgnoredDocs'], meta: { name: 'AiWorkspaceIgnoredDocs' } }
    /**
     * Find zero or one AiWorkspaceIgnoredDocs that matches the filter.
     * @param {AiWorkspaceIgnoredDocsFindUniqueArgs} args - Arguments to find a AiWorkspaceIgnoredDocs
     * @example
     * // Get one AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiWorkspaceIgnoredDocsFindUniqueArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsFindUniqueArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiWorkspaceIgnoredDocs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiWorkspaceIgnoredDocsFindUniqueOrThrowArgs} args - Arguments to find a AiWorkspaceIgnoredDocs
     * @example
     * // Get one AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiWorkspaceIgnoredDocsFindUniqueOrThrowArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceIgnoredDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsFindFirstArgs} args - Arguments to find a AiWorkspaceIgnoredDocs
     * @example
     * // Get one AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiWorkspaceIgnoredDocsFindFirstArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsFindFirstArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceIgnoredDocs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsFindFirstOrThrowArgs} args - Arguments to find a AiWorkspaceIgnoredDocs
     * @example
     * // Get one AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiWorkspaceIgnoredDocsFindFirstOrThrowArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiWorkspaceIgnoredDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findMany()
     * 
     * // Get first 10 AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const aiWorkspaceIgnoredDocsWithWorkspaceIdOnly = await prisma.aiWorkspaceIgnoredDocs.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends AiWorkspaceIgnoredDocsFindManyArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsCreateArgs} args - Arguments to create a AiWorkspaceIgnoredDocs.
     * @example
     * // Create one AiWorkspaceIgnoredDocs
     * const AiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.create({
     *   data: {
     *     // ... data to create a AiWorkspaceIgnoredDocs
     *   }
     * })
     * 
     */
    create<T extends AiWorkspaceIgnoredDocsCreateArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsCreateArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsCreateManyArgs} args - Arguments to create many AiWorkspaceIgnoredDocs.
     * @example
     * // Create many AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiWorkspaceIgnoredDocsCreateManyArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiWorkspaceIgnoredDocs and returns the data saved in the database.
     * @param {AiWorkspaceIgnoredDocsCreateManyAndReturnArgs} args - Arguments to create many AiWorkspaceIgnoredDocs.
     * @example
     * // Create many AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiWorkspaceIgnoredDocs and only return the `workspaceId`
     * const aiWorkspaceIgnoredDocsWithWorkspaceIdOnly = await prisma.aiWorkspaceIgnoredDocs.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiWorkspaceIgnoredDocsCreateManyAndReturnArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsDeleteArgs} args - Arguments to delete one AiWorkspaceIgnoredDocs.
     * @example
     * // Delete one AiWorkspaceIgnoredDocs
     * const AiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.delete({
     *   where: {
     *     // ... filter to delete one AiWorkspaceIgnoredDocs
     *   }
     * })
     * 
     */
    delete<T extends AiWorkspaceIgnoredDocsDeleteArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsDeleteArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsUpdateArgs} args - Arguments to update one AiWorkspaceIgnoredDocs.
     * @example
     * // Update one AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiWorkspaceIgnoredDocsUpdateArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsUpdateArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsDeleteManyArgs} args - Arguments to filter AiWorkspaceIgnoredDocs to delete.
     * @example
     * // Delete a few AiWorkspaceIgnoredDocs
     * const { count } = await prisma.aiWorkspaceIgnoredDocs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiWorkspaceIgnoredDocsDeleteManyArgs>(args?: SelectSubset<T, AiWorkspaceIgnoredDocsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceIgnoredDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiWorkspaceIgnoredDocsUpdateManyArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceIgnoredDocs and returns the data updated in the database.
     * @param {AiWorkspaceIgnoredDocsUpdateManyAndReturnArgs} args - Arguments to update many AiWorkspaceIgnoredDocs.
     * @example
     * // Update many AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiWorkspaceIgnoredDocs and only return the `workspaceId`
     * const aiWorkspaceIgnoredDocsWithWorkspaceIdOnly = await prisma.aiWorkspaceIgnoredDocs.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiWorkspaceIgnoredDocsUpdateManyAndReturnArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiWorkspaceIgnoredDocs.
     * @param {AiWorkspaceIgnoredDocsUpsertArgs} args - Arguments to update or create a AiWorkspaceIgnoredDocs.
     * @example
     * // Update or create a AiWorkspaceIgnoredDocs
     * const aiWorkspaceIgnoredDocs = await prisma.aiWorkspaceIgnoredDocs.upsert({
     *   create: {
     *     // ... data to create a AiWorkspaceIgnoredDocs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiWorkspaceIgnoredDocs we want to update
     *   }
     * })
     */
    upsert<T extends AiWorkspaceIgnoredDocsUpsertArgs>(args: SelectSubset<T, AiWorkspaceIgnoredDocsUpsertArgs<ExtArgs>>): Prisma__AiWorkspaceIgnoredDocsClient<$Result.GetResult<Prisma.$AiWorkspaceIgnoredDocsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiWorkspaceIgnoredDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsCountArgs} args - Arguments to filter AiWorkspaceIgnoredDocs to count.
     * @example
     * // Count the number of AiWorkspaceIgnoredDocs
     * const count = await prisma.aiWorkspaceIgnoredDocs.count({
     *   where: {
     *     // ... the filter for the AiWorkspaceIgnoredDocs we want to count
     *   }
     * })
    **/
    count<T extends AiWorkspaceIgnoredDocsCountArgs>(
      args?: Subset<T, AiWorkspaceIgnoredDocsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiWorkspaceIgnoredDocsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiWorkspaceIgnoredDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiWorkspaceIgnoredDocsAggregateArgs>(args: Subset<T, AiWorkspaceIgnoredDocsAggregateArgs>): Prisma.PrismaPromise<GetAiWorkspaceIgnoredDocsAggregateType<T>>

    /**
     * Group by AiWorkspaceIgnoredDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceIgnoredDocsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiWorkspaceIgnoredDocsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiWorkspaceIgnoredDocsGroupByArgs['orderBy'] }
        : { orderBy?: AiWorkspaceIgnoredDocsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiWorkspaceIgnoredDocsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiWorkspaceIgnoredDocsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiWorkspaceIgnoredDocs model
   */
  readonly fields: AiWorkspaceIgnoredDocsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiWorkspaceIgnoredDocs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiWorkspaceIgnoredDocsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiWorkspaceIgnoredDocs model
   */
  interface AiWorkspaceIgnoredDocsFieldRefs {
    readonly workspaceId: FieldRef<"AiWorkspaceIgnoredDocs", 'String'>
    readonly docId: FieldRef<"AiWorkspaceIgnoredDocs", 'String'>
    readonly createdAt: FieldRef<"AiWorkspaceIgnoredDocs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiWorkspaceIgnoredDocs findUnique
   */
  export type AiWorkspaceIgnoredDocsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceIgnoredDocs to fetch.
     */
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs findUniqueOrThrow
   */
  export type AiWorkspaceIgnoredDocsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceIgnoredDocs to fetch.
     */
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs findFirst
   */
  export type AiWorkspaceIgnoredDocsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceIgnoredDocs to fetch.
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceIgnoredDocs to fetch.
     */
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithRelationInput | AiWorkspaceIgnoredDocsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceIgnoredDocs.
     */
    cursor?: AiWorkspaceIgnoredDocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceIgnoredDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceIgnoredDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceIgnoredDocs.
     */
    distinct?: AiWorkspaceIgnoredDocsScalarFieldEnum | AiWorkspaceIgnoredDocsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs findFirstOrThrow
   */
  export type AiWorkspaceIgnoredDocsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceIgnoredDocs to fetch.
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceIgnoredDocs to fetch.
     */
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithRelationInput | AiWorkspaceIgnoredDocsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceIgnoredDocs.
     */
    cursor?: AiWorkspaceIgnoredDocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceIgnoredDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceIgnoredDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceIgnoredDocs.
     */
    distinct?: AiWorkspaceIgnoredDocsScalarFieldEnum | AiWorkspaceIgnoredDocsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs findMany
   */
  export type AiWorkspaceIgnoredDocsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceIgnoredDocs to fetch.
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceIgnoredDocs to fetch.
     */
    orderBy?: AiWorkspaceIgnoredDocsOrderByWithRelationInput | AiWorkspaceIgnoredDocsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiWorkspaceIgnoredDocs.
     */
    cursor?: AiWorkspaceIgnoredDocsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceIgnoredDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceIgnoredDocs.
     */
    skip?: number
    distinct?: AiWorkspaceIgnoredDocsScalarFieldEnum | AiWorkspaceIgnoredDocsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs create
   */
  export type AiWorkspaceIgnoredDocsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * The data needed to create a AiWorkspaceIgnoredDocs.
     */
    data: XOR<AiWorkspaceIgnoredDocsCreateInput, AiWorkspaceIgnoredDocsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs createMany
   */
  export type AiWorkspaceIgnoredDocsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiWorkspaceIgnoredDocs.
     */
    data: AiWorkspaceIgnoredDocsCreateManyInput | AiWorkspaceIgnoredDocsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiWorkspaceIgnoredDocs createManyAndReturn
   */
  export type AiWorkspaceIgnoredDocsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * The data used to create many AiWorkspaceIgnoredDocs.
     */
    data: AiWorkspaceIgnoredDocsCreateManyInput | AiWorkspaceIgnoredDocsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceIgnoredDocs update
   */
  export type AiWorkspaceIgnoredDocsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * The data needed to update a AiWorkspaceIgnoredDocs.
     */
    data: XOR<AiWorkspaceIgnoredDocsUpdateInput, AiWorkspaceIgnoredDocsUncheckedUpdateInput>
    /**
     * Choose, which AiWorkspaceIgnoredDocs to update.
     */
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs updateMany
   */
  export type AiWorkspaceIgnoredDocsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiWorkspaceIgnoredDocs.
     */
    data: XOR<AiWorkspaceIgnoredDocsUpdateManyMutationInput, AiWorkspaceIgnoredDocsUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceIgnoredDocs to update
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * Limit how many AiWorkspaceIgnoredDocs to update.
     */
    limit?: number
  }

  /**
   * AiWorkspaceIgnoredDocs updateManyAndReturn
   */
  export type AiWorkspaceIgnoredDocsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * The data used to update AiWorkspaceIgnoredDocs.
     */
    data: XOR<AiWorkspaceIgnoredDocsUpdateManyMutationInput, AiWorkspaceIgnoredDocsUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceIgnoredDocs to update
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * Limit how many AiWorkspaceIgnoredDocs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceIgnoredDocs upsert
   */
  export type AiWorkspaceIgnoredDocsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * The filter to search for the AiWorkspaceIgnoredDocs to update in case it exists.
     */
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    /**
     * In case the AiWorkspaceIgnoredDocs found by the `where` argument doesn't exist, create a new AiWorkspaceIgnoredDocs with this data.
     */
    create: XOR<AiWorkspaceIgnoredDocsCreateInput, AiWorkspaceIgnoredDocsUncheckedCreateInput>
    /**
     * In case the AiWorkspaceIgnoredDocs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiWorkspaceIgnoredDocsUpdateInput, AiWorkspaceIgnoredDocsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs delete
   */
  export type AiWorkspaceIgnoredDocsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
    /**
     * Filter which AiWorkspaceIgnoredDocs to delete.
     */
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceIgnoredDocs deleteMany
   */
  export type AiWorkspaceIgnoredDocsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceIgnoredDocs to delete
     */
    where?: AiWorkspaceIgnoredDocsWhereInput
    /**
     * Limit how many AiWorkspaceIgnoredDocs to delete.
     */
    limit?: number
  }

  /**
   * AiWorkspaceIgnoredDocs without action
   */
  export type AiWorkspaceIgnoredDocsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceIgnoredDocs
     */
    select?: AiWorkspaceIgnoredDocsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceIgnoredDocs
     */
    omit?: AiWorkspaceIgnoredDocsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceIgnoredDocsInclude<ExtArgs> | null
  }


  /**
   * Model AiWorkspaceFiles
   */

  export type AggregateAiWorkspaceFiles = {
    _count: AiWorkspaceFilesCountAggregateOutputType | null
    _avg: AiWorkspaceFilesAvgAggregateOutputType | null
    _sum: AiWorkspaceFilesSumAggregateOutputType | null
    _min: AiWorkspaceFilesMinAggregateOutputType | null
    _max: AiWorkspaceFilesMaxAggregateOutputType | null
  }

  export type AiWorkspaceFilesAvgAggregateOutputType = {
    size: number | null
  }

  export type AiWorkspaceFilesSumAggregateOutputType = {
    size: number | null
  }

  export type AiWorkspaceFilesMinAggregateOutputType = {
    workspaceId: string | null
    fileId: string | null
    blobId: string | null
    fileName: string | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
  }

  export type AiWorkspaceFilesMaxAggregateOutputType = {
    workspaceId: string | null
    fileId: string | null
    blobId: string | null
    fileName: string | null
    mimeType: string | null
    size: number | null
    createdAt: Date | null
  }

  export type AiWorkspaceFilesCountAggregateOutputType = {
    workspaceId: number
    fileId: number
    blobId: number
    fileName: number
    mimeType: number
    size: number
    createdAt: number
    _all: number
  }


  export type AiWorkspaceFilesAvgAggregateInputType = {
    size?: true
  }

  export type AiWorkspaceFilesSumAggregateInputType = {
    size?: true
  }

  export type AiWorkspaceFilesMinAggregateInputType = {
    workspaceId?: true
    fileId?: true
    blobId?: true
    fileName?: true
    mimeType?: true
    size?: true
    createdAt?: true
  }

  export type AiWorkspaceFilesMaxAggregateInputType = {
    workspaceId?: true
    fileId?: true
    blobId?: true
    fileName?: true
    mimeType?: true
    size?: true
    createdAt?: true
  }

  export type AiWorkspaceFilesCountAggregateInputType = {
    workspaceId?: true
    fileId?: true
    blobId?: true
    fileName?: true
    mimeType?: true
    size?: true
    createdAt?: true
    _all?: true
  }

  export type AiWorkspaceFilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceFiles to aggregate.
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFiles to fetch.
     */
    orderBy?: AiWorkspaceFilesOrderByWithRelationInput | AiWorkspaceFilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiWorkspaceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiWorkspaceFiles
    **/
    _count?: true | AiWorkspaceFilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiWorkspaceFilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiWorkspaceFilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiWorkspaceFilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiWorkspaceFilesMaxAggregateInputType
  }

  export type GetAiWorkspaceFilesAggregateType<T extends AiWorkspaceFilesAggregateArgs> = {
        [P in keyof T & keyof AggregateAiWorkspaceFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiWorkspaceFiles[P]>
      : GetScalarType<T[P], AggregateAiWorkspaceFiles[P]>
  }




  export type AiWorkspaceFilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceFilesWhereInput
    orderBy?: AiWorkspaceFilesOrderByWithAggregationInput | AiWorkspaceFilesOrderByWithAggregationInput[]
    by: AiWorkspaceFilesScalarFieldEnum[] | AiWorkspaceFilesScalarFieldEnum
    having?: AiWorkspaceFilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiWorkspaceFilesCountAggregateInputType | true
    _avg?: AiWorkspaceFilesAvgAggregateInputType
    _sum?: AiWorkspaceFilesSumAggregateInputType
    _min?: AiWorkspaceFilesMinAggregateInputType
    _max?: AiWorkspaceFilesMaxAggregateInputType
  }

  export type AiWorkspaceFilesGroupByOutputType = {
    workspaceId: string
    fileId: string
    blobId: string
    fileName: string
    mimeType: string
    size: number
    createdAt: Date
    _count: AiWorkspaceFilesCountAggregateOutputType | null
    _avg: AiWorkspaceFilesAvgAggregateOutputType | null
    _sum: AiWorkspaceFilesSumAggregateOutputType | null
    _min: AiWorkspaceFilesMinAggregateOutputType | null
    _max: AiWorkspaceFilesMaxAggregateOutputType | null
  }

  type GetAiWorkspaceFilesGroupByPayload<T extends AiWorkspaceFilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiWorkspaceFilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiWorkspaceFilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiWorkspaceFilesGroupByOutputType[P]>
            : GetScalarType<T[P], AiWorkspaceFilesGroupByOutputType[P]>
        }
      >
    >


  export type AiWorkspaceFilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    fileId?: boolean
    blobId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    embeddings?: boolean | AiWorkspaceFiles$embeddingsArgs<ExtArgs>
    _count?: boolean | AiWorkspaceFilesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceFiles"]>

  export type AiWorkspaceFilesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    fileId?: boolean
    blobId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceFiles"]>

  export type AiWorkspaceFilesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    fileId?: boolean
    blobId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceFiles"]>

  export type AiWorkspaceFilesSelectScalar = {
    workspaceId?: boolean
    fileId?: boolean
    blobId?: boolean
    fileName?: boolean
    mimeType?: boolean
    size?: boolean
    createdAt?: boolean
  }

  export type AiWorkspaceFilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "fileId" | "blobId" | "fileName" | "mimeType" | "size" | "createdAt", ExtArgs["result"]["aiWorkspaceFiles"]>
  export type AiWorkspaceFilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    embeddings?: boolean | AiWorkspaceFiles$embeddingsArgs<ExtArgs>
    _count?: boolean | AiWorkspaceFilesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceFilesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceFilesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AiWorkspaceFilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiWorkspaceFiles"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      embeddings: Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      fileId: string
      blobId: string
      fileName: string
      mimeType: string
      size: number
      createdAt: Date
    }, ExtArgs["result"]["aiWorkspaceFiles"]>
    composites: {}
  }

  type AiWorkspaceFilesGetPayload<S extends boolean | null | undefined | AiWorkspaceFilesDefaultArgs> = $Result.GetResult<Prisma.$AiWorkspaceFilesPayload, S>

  type AiWorkspaceFilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiWorkspaceFilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiWorkspaceFilesCountAggregateInputType | true
    }

  export interface AiWorkspaceFilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiWorkspaceFiles'], meta: { name: 'AiWorkspaceFiles' } }
    /**
     * Find zero or one AiWorkspaceFiles that matches the filter.
     * @param {AiWorkspaceFilesFindUniqueArgs} args - Arguments to find a AiWorkspaceFiles
     * @example
     * // Get one AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiWorkspaceFilesFindUniqueArgs>(args: SelectSubset<T, AiWorkspaceFilesFindUniqueArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiWorkspaceFiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiWorkspaceFilesFindUniqueOrThrowArgs} args - Arguments to find a AiWorkspaceFiles
     * @example
     * // Get one AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiWorkspaceFilesFindUniqueOrThrowArgs>(args: SelectSubset<T, AiWorkspaceFilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesFindFirstArgs} args - Arguments to find a AiWorkspaceFiles
     * @example
     * // Get one AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiWorkspaceFilesFindFirstArgs>(args?: SelectSubset<T, AiWorkspaceFilesFindFirstArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceFiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesFindFirstOrThrowArgs} args - Arguments to find a AiWorkspaceFiles
     * @example
     * // Get one AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiWorkspaceFilesFindFirstOrThrowArgs>(args?: SelectSubset<T, AiWorkspaceFilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiWorkspaceFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findMany()
     * 
     * // Get first 10 AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const aiWorkspaceFilesWithWorkspaceIdOnly = await prisma.aiWorkspaceFiles.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends AiWorkspaceFilesFindManyArgs>(args?: SelectSubset<T, AiWorkspaceFilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiWorkspaceFiles.
     * @param {AiWorkspaceFilesCreateArgs} args - Arguments to create a AiWorkspaceFiles.
     * @example
     * // Create one AiWorkspaceFiles
     * const AiWorkspaceFiles = await prisma.aiWorkspaceFiles.create({
     *   data: {
     *     // ... data to create a AiWorkspaceFiles
     *   }
     * })
     * 
     */
    create<T extends AiWorkspaceFilesCreateArgs>(args: SelectSubset<T, AiWorkspaceFilesCreateArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiWorkspaceFiles.
     * @param {AiWorkspaceFilesCreateManyArgs} args - Arguments to create many AiWorkspaceFiles.
     * @example
     * // Create many AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiWorkspaceFilesCreateManyArgs>(args?: SelectSubset<T, AiWorkspaceFilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiWorkspaceFiles and returns the data saved in the database.
     * @param {AiWorkspaceFilesCreateManyAndReturnArgs} args - Arguments to create many AiWorkspaceFiles.
     * @example
     * // Create many AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiWorkspaceFiles and only return the `workspaceId`
     * const aiWorkspaceFilesWithWorkspaceIdOnly = await prisma.aiWorkspaceFiles.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiWorkspaceFilesCreateManyAndReturnArgs>(args?: SelectSubset<T, AiWorkspaceFilesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiWorkspaceFiles.
     * @param {AiWorkspaceFilesDeleteArgs} args - Arguments to delete one AiWorkspaceFiles.
     * @example
     * // Delete one AiWorkspaceFiles
     * const AiWorkspaceFiles = await prisma.aiWorkspaceFiles.delete({
     *   where: {
     *     // ... filter to delete one AiWorkspaceFiles
     *   }
     * })
     * 
     */
    delete<T extends AiWorkspaceFilesDeleteArgs>(args: SelectSubset<T, AiWorkspaceFilesDeleteArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiWorkspaceFiles.
     * @param {AiWorkspaceFilesUpdateArgs} args - Arguments to update one AiWorkspaceFiles.
     * @example
     * // Update one AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiWorkspaceFilesUpdateArgs>(args: SelectSubset<T, AiWorkspaceFilesUpdateArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiWorkspaceFiles.
     * @param {AiWorkspaceFilesDeleteManyArgs} args - Arguments to filter AiWorkspaceFiles to delete.
     * @example
     * // Delete a few AiWorkspaceFiles
     * const { count } = await prisma.aiWorkspaceFiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiWorkspaceFilesDeleteManyArgs>(args?: SelectSubset<T, AiWorkspaceFilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiWorkspaceFilesUpdateManyArgs>(args: SelectSubset<T, AiWorkspaceFilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceFiles and returns the data updated in the database.
     * @param {AiWorkspaceFilesUpdateManyAndReturnArgs} args - Arguments to update many AiWorkspaceFiles.
     * @example
     * // Update many AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiWorkspaceFiles and only return the `workspaceId`
     * const aiWorkspaceFilesWithWorkspaceIdOnly = await prisma.aiWorkspaceFiles.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiWorkspaceFilesUpdateManyAndReturnArgs>(args: SelectSubset<T, AiWorkspaceFilesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiWorkspaceFiles.
     * @param {AiWorkspaceFilesUpsertArgs} args - Arguments to update or create a AiWorkspaceFiles.
     * @example
     * // Update or create a AiWorkspaceFiles
     * const aiWorkspaceFiles = await prisma.aiWorkspaceFiles.upsert({
     *   create: {
     *     // ... data to create a AiWorkspaceFiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiWorkspaceFiles we want to update
     *   }
     * })
     */
    upsert<T extends AiWorkspaceFilesUpsertArgs>(args: SelectSubset<T, AiWorkspaceFilesUpsertArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiWorkspaceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesCountArgs} args - Arguments to filter AiWorkspaceFiles to count.
     * @example
     * // Count the number of AiWorkspaceFiles
     * const count = await prisma.aiWorkspaceFiles.count({
     *   where: {
     *     // ... the filter for the AiWorkspaceFiles we want to count
     *   }
     * })
    **/
    count<T extends AiWorkspaceFilesCountArgs>(
      args?: Subset<T, AiWorkspaceFilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiWorkspaceFilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiWorkspaceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiWorkspaceFilesAggregateArgs>(args: Subset<T, AiWorkspaceFilesAggregateArgs>): Prisma.PrismaPromise<GetAiWorkspaceFilesAggregateType<T>>

    /**
     * Group by AiWorkspaceFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiWorkspaceFilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiWorkspaceFilesGroupByArgs['orderBy'] }
        : { orderBy?: AiWorkspaceFilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiWorkspaceFilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiWorkspaceFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiWorkspaceFiles model
   */
  readonly fields: AiWorkspaceFilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiWorkspaceFiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiWorkspaceFilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    embeddings<T extends AiWorkspaceFiles$embeddingsArgs<ExtArgs> = {}>(args?: Subset<T, AiWorkspaceFiles$embeddingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiWorkspaceFiles model
   */
  interface AiWorkspaceFilesFieldRefs {
    readonly workspaceId: FieldRef<"AiWorkspaceFiles", 'String'>
    readonly fileId: FieldRef<"AiWorkspaceFiles", 'String'>
    readonly blobId: FieldRef<"AiWorkspaceFiles", 'String'>
    readonly fileName: FieldRef<"AiWorkspaceFiles", 'String'>
    readonly mimeType: FieldRef<"AiWorkspaceFiles", 'String'>
    readonly size: FieldRef<"AiWorkspaceFiles", 'Int'>
    readonly createdAt: FieldRef<"AiWorkspaceFiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiWorkspaceFiles findUnique
   */
  export type AiWorkspaceFilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFiles to fetch.
     */
    where: AiWorkspaceFilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles findUniqueOrThrow
   */
  export type AiWorkspaceFilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFiles to fetch.
     */
    where: AiWorkspaceFilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles findFirst
   */
  export type AiWorkspaceFilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFiles to fetch.
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFiles to fetch.
     */
    orderBy?: AiWorkspaceFilesOrderByWithRelationInput | AiWorkspaceFilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceFiles.
     */
    cursor?: AiWorkspaceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceFiles.
     */
    distinct?: AiWorkspaceFilesScalarFieldEnum | AiWorkspaceFilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles findFirstOrThrow
   */
  export type AiWorkspaceFilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFiles to fetch.
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFiles to fetch.
     */
    orderBy?: AiWorkspaceFilesOrderByWithRelationInput | AiWorkspaceFilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceFiles.
     */
    cursor?: AiWorkspaceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceFiles.
     */
    distinct?: AiWorkspaceFilesScalarFieldEnum | AiWorkspaceFilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles findMany
   */
  export type AiWorkspaceFilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFiles to fetch.
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFiles to fetch.
     */
    orderBy?: AiWorkspaceFilesOrderByWithRelationInput | AiWorkspaceFilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiWorkspaceFiles.
     */
    cursor?: AiWorkspaceFilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFiles.
     */
    skip?: number
    distinct?: AiWorkspaceFilesScalarFieldEnum | AiWorkspaceFilesScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles create
   */
  export type AiWorkspaceFilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * The data needed to create a AiWorkspaceFiles.
     */
    data: XOR<AiWorkspaceFilesCreateInput, AiWorkspaceFilesUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles createMany
   */
  export type AiWorkspaceFilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiWorkspaceFiles.
     */
    data: AiWorkspaceFilesCreateManyInput | AiWorkspaceFilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiWorkspaceFiles createManyAndReturn
   */
  export type AiWorkspaceFilesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * The data used to create many AiWorkspaceFiles.
     */
    data: AiWorkspaceFilesCreateManyInput | AiWorkspaceFilesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceFiles update
   */
  export type AiWorkspaceFilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * The data needed to update a AiWorkspaceFiles.
     */
    data: XOR<AiWorkspaceFilesUpdateInput, AiWorkspaceFilesUncheckedUpdateInput>
    /**
     * Choose, which AiWorkspaceFiles to update.
     */
    where: AiWorkspaceFilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles updateMany
   */
  export type AiWorkspaceFilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiWorkspaceFiles.
     */
    data: XOR<AiWorkspaceFilesUpdateManyMutationInput, AiWorkspaceFilesUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceFiles to update
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * Limit how many AiWorkspaceFiles to update.
     */
    limit?: number
  }

  /**
   * AiWorkspaceFiles updateManyAndReturn
   */
  export type AiWorkspaceFilesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * The data used to update AiWorkspaceFiles.
     */
    data: XOR<AiWorkspaceFilesUpdateManyMutationInput, AiWorkspaceFilesUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceFiles to update
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * Limit how many AiWorkspaceFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceFiles upsert
   */
  export type AiWorkspaceFilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * The filter to search for the AiWorkspaceFiles to update in case it exists.
     */
    where: AiWorkspaceFilesWhereUniqueInput
    /**
     * In case the AiWorkspaceFiles found by the `where` argument doesn't exist, create a new AiWorkspaceFiles with this data.
     */
    create: XOR<AiWorkspaceFilesCreateInput, AiWorkspaceFilesUncheckedCreateInput>
    /**
     * In case the AiWorkspaceFiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiWorkspaceFilesUpdateInput, AiWorkspaceFilesUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles delete
   */
  export type AiWorkspaceFilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
    /**
     * Filter which AiWorkspaceFiles to delete.
     */
    where: AiWorkspaceFilesWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFiles deleteMany
   */
  export type AiWorkspaceFilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceFiles to delete
     */
    where?: AiWorkspaceFilesWhereInput
    /**
     * Limit how many AiWorkspaceFiles to delete.
     */
    limit?: number
  }

  /**
   * AiWorkspaceFiles.embeddings
   */
  export type AiWorkspaceFiles$embeddingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    where?: AiWorkspaceFileEmbeddingWhereInput
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithRelationInput | AiWorkspaceFileEmbeddingOrderByWithRelationInput[]
    cursor?: AiWorkspaceFileEmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiWorkspaceFileEmbeddingScalarFieldEnum | AiWorkspaceFileEmbeddingScalarFieldEnum[]
  }

  /**
   * AiWorkspaceFiles without action
   */
  export type AiWorkspaceFilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFiles
     */
    select?: AiWorkspaceFilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFiles
     */
    omit?: AiWorkspaceFilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFilesInclude<ExtArgs> | null
  }


  /**
   * Model AiWorkspaceFileEmbedding
   */

  export type AggregateAiWorkspaceFileEmbedding = {
    _count: AiWorkspaceFileEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceFileEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceFileEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceFileEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceFileEmbeddingMaxAggregateOutputType | null
  }

  export type AiWorkspaceFileEmbeddingAvgAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceFileEmbeddingSumAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceFileEmbeddingMinAggregateOutputType = {
    workspaceId: string | null
    fileId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceFileEmbeddingMaxAggregateOutputType = {
    workspaceId: string | null
    fileId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceFileEmbeddingCountAggregateOutputType = {
    workspaceId: number
    fileId: number
    chunk: number
    content: number
    createdAt: number
    _all: number
  }


  export type AiWorkspaceFileEmbeddingAvgAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceFileEmbeddingSumAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceFileEmbeddingMinAggregateInputType = {
    workspaceId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
  }

  export type AiWorkspaceFileEmbeddingMaxAggregateInputType = {
    workspaceId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
  }

  export type AiWorkspaceFileEmbeddingCountAggregateInputType = {
    workspaceId?: true
    fileId?: true
    chunk?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AiWorkspaceFileEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceFileEmbedding to aggregate.
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFileEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithRelationInput | AiWorkspaceFileEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiWorkspaceFileEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFileEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFileEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiWorkspaceFileEmbeddings
    **/
    _count?: true | AiWorkspaceFileEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiWorkspaceFileEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiWorkspaceFileEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiWorkspaceFileEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiWorkspaceFileEmbeddingMaxAggregateInputType
  }

  export type GetAiWorkspaceFileEmbeddingAggregateType<T extends AiWorkspaceFileEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateAiWorkspaceFileEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiWorkspaceFileEmbedding[P]>
      : GetScalarType<T[P], AggregateAiWorkspaceFileEmbedding[P]>
  }




  export type AiWorkspaceFileEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceFileEmbeddingWhereInput
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithAggregationInput | AiWorkspaceFileEmbeddingOrderByWithAggregationInput[]
    by: AiWorkspaceFileEmbeddingScalarFieldEnum[] | AiWorkspaceFileEmbeddingScalarFieldEnum
    having?: AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiWorkspaceFileEmbeddingCountAggregateInputType | true
    _avg?: AiWorkspaceFileEmbeddingAvgAggregateInputType
    _sum?: AiWorkspaceFileEmbeddingSumAggregateInputType
    _min?: AiWorkspaceFileEmbeddingMinAggregateInputType
    _max?: AiWorkspaceFileEmbeddingMaxAggregateInputType
  }

  export type AiWorkspaceFileEmbeddingGroupByOutputType = {
    workspaceId: string
    fileId: string
    chunk: number
    content: string
    createdAt: Date
    _count: AiWorkspaceFileEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceFileEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceFileEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceFileEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceFileEmbeddingMaxAggregateOutputType | null
  }

  type GetAiWorkspaceFileEmbeddingGroupByPayload<T extends AiWorkspaceFileEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiWorkspaceFileEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiWorkspaceFileEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiWorkspaceFileEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], AiWorkspaceFileEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type AiWorkspaceFileEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    file?: boolean | AiWorkspaceFilesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceFileEmbedding"]>


  export type AiWorkspaceFileEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    file?: boolean | AiWorkspaceFilesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceFileEmbedding"]>

  export type AiWorkspaceFileEmbeddingSelectScalar = {
    workspaceId?: boolean
    fileId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AiWorkspaceFileEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "fileId" | "chunk" | "content" | "createdAt", ExtArgs["result"]["aiWorkspaceFileEmbedding"]>
  export type AiWorkspaceFileEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | AiWorkspaceFilesDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceFileEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | AiWorkspaceFilesDefaultArgs<ExtArgs>
  }

  export type $AiWorkspaceFileEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiWorkspaceFileEmbedding"
    objects: {
      file: Prisma.$AiWorkspaceFilesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      fileId: string
      chunk: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["aiWorkspaceFileEmbedding"]>
    composites: {}
  }

  type AiWorkspaceFileEmbeddingGetPayload<S extends boolean | null | undefined | AiWorkspaceFileEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload, S>

  type AiWorkspaceFileEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiWorkspaceFileEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiWorkspaceFileEmbeddingCountAggregateInputType | true
    }

  export interface AiWorkspaceFileEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiWorkspaceFileEmbedding'], meta: { name: 'AiWorkspaceFileEmbedding' } }
    /**
     * Find zero or one AiWorkspaceFileEmbedding that matches the filter.
     * @param {AiWorkspaceFileEmbeddingFindUniqueArgs} args - Arguments to find a AiWorkspaceFileEmbedding
     * @example
     * // Get one AiWorkspaceFileEmbedding
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiWorkspaceFileEmbeddingFindUniqueArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiWorkspaceFileEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiWorkspaceFileEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a AiWorkspaceFileEmbedding
     * @example
     * // Get one AiWorkspaceFileEmbedding
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiWorkspaceFileEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceFileEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingFindFirstArgs} args - Arguments to find a AiWorkspaceFileEmbedding
     * @example
     * // Get one AiWorkspaceFileEmbedding
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiWorkspaceFileEmbeddingFindFirstArgs>(args?: SelectSubset<T, AiWorkspaceFileEmbeddingFindFirstArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceFileEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingFindFirstOrThrowArgs} args - Arguments to find a AiWorkspaceFileEmbedding
     * @example
     * // Get one AiWorkspaceFileEmbedding
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiWorkspaceFileEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, AiWorkspaceFileEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiWorkspaceFileEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiWorkspaceFileEmbeddings
     * const aiWorkspaceFileEmbeddings = await prisma.aiWorkspaceFileEmbedding.findMany()
     * 
     * // Get first 10 AiWorkspaceFileEmbeddings
     * const aiWorkspaceFileEmbeddings = await prisma.aiWorkspaceFileEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const aiWorkspaceFileEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceFileEmbedding.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends AiWorkspaceFileEmbeddingFindManyArgs>(args?: SelectSubset<T, AiWorkspaceFileEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a AiWorkspaceFileEmbedding.
     * @param {AiWorkspaceFileEmbeddingDeleteArgs} args - Arguments to delete one AiWorkspaceFileEmbedding.
     * @example
     * // Delete one AiWorkspaceFileEmbedding
     * const AiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.delete({
     *   where: {
     *     // ... filter to delete one AiWorkspaceFileEmbedding
     *   }
     * })
     * 
     */
    delete<T extends AiWorkspaceFileEmbeddingDeleteArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingDeleteArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiWorkspaceFileEmbedding.
     * @param {AiWorkspaceFileEmbeddingUpdateArgs} args - Arguments to update one AiWorkspaceFileEmbedding.
     * @example
     * // Update one AiWorkspaceFileEmbedding
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiWorkspaceFileEmbeddingUpdateArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingUpdateArgs<ExtArgs>>): Prisma__AiWorkspaceFileEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiWorkspaceFileEmbeddings.
     * @param {AiWorkspaceFileEmbeddingDeleteManyArgs} args - Arguments to filter AiWorkspaceFileEmbeddings to delete.
     * @example
     * // Delete a few AiWorkspaceFileEmbeddings
     * const { count } = await prisma.aiWorkspaceFileEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiWorkspaceFileEmbeddingDeleteManyArgs>(args?: SelectSubset<T, AiWorkspaceFileEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceFileEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiWorkspaceFileEmbeddings
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiWorkspaceFileEmbeddingUpdateManyArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceFileEmbeddings and returns the data updated in the database.
     * @param {AiWorkspaceFileEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many AiWorkspaceFileEmbeddings.
     * @example
     * // Update many AiWorkspaceFileEmbeddings
     * const aiWorkspaceFileEmbedding = await prisma.aiWorkspaceFileEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiWorkspaceFileEmbeddings and only return the `workspaceId`
     * const aiWorkspaceFileEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceFileEmbedding.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiWorkspaceFileEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, AiWorkspaceFileEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceFileEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of AiWorkspaceFileEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingCountArgs} args - Arguments to filter AiWorkspaceFileEmbeddings to count.
     * @example
     * // Count the number of AiWorkspaceFileEmbeddings
     * const count = await prisma.aiWorkspaceFileEmbedding.count({
     *   where: {
     *     // ... the filter for the AiWorkspaceFileEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends AiWorkspaceFileEmbeddingCountArgs>(
      args?: Subset<T, AiWorkspaceFileEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiWorkspaceFileEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiWorkspaceFileEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiWorkspaceFileEmbeddingAggregateArgs>(args: Subset<T, AiWorkspaceFileEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetAiWorkspaceFileEmbeddingAggregateType<T>>

    /**
     * Group by AiWorkspaceFileEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceFileEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiWorkspaceFileEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiWorkspaceFileEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: AiWorkspaceFileEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiWorkspaceFileEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiWorkspaceFileEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiWorkspaceFileEmbedding model
   */
  readonly fields: AiWorkspaceFileEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiWorkspaceFileEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiWorkspaceFileEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends AiWorkspaceFilesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AiWorkspaceFilesDefaultArgs<ExtArgs>>): Prisma__AiWorkspaceFilesClient<$Result.GetResult<Prisma.$AiWorkspaceFilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiWorkspaceFileEmbedding model
   */
  interface AiWorkspaceFileEmbeddingFieldRefs {
    readonly workspaceId: FieldRef<"AiWorkspaceFileEmbedding", 'String'>
    readonly fileId: FieldRef<"AiWorkspaceFileEmbedding", 'String'>
    readonly chunk: FieldRef<"AiWorkspaceFileEmbedding", 'Int'>
    readonly content: FieldRef<"AiWorkspaceFileEmbedding", 'String'>
    readonly createdAt: FieldRef<"AiWorkspaceFileEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiWorkspaceFileEmbedding findUnique
   */
  export type AiWorkspaceFileEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFileEmbedding to fetch.
     */
    where: AiWorkspaceFileEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding findUniqueOrThrow
   */
  export type AiWorkspaceFileEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFileEmbedding to fetch.
     */
    where: AiWorkspaceFileEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding findFirst
   */
  export type AiWorkspaceFileEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFileEmbedding to fetch.
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFileEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithRelationInput | AiWorkspaceFileEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceFileEmbeddings.
     */
    cursor?: AiWorkspaceFileEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFileEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFileEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceFileEmbeddings.
     */
    distinct?: AiWorkspaceFileEmbeddingScalarFieldEnum | AiWorkspaceFileEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding findFirstOrThrow
   */
  export type AiWorkspaceFileEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFileEmbedding to fetch.
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFileEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithRelationInput | AiWorkspaceFileEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceFileEmbeddings.
     */
    cursor?: AiWorkspaceFileEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFileEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFileEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceFileEmbeddings.
     */
    distinct?: AiWorkspaceFileEmbeddingScalarFieldEnum | AiWorkspaceFileEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding findMany
   */
  export type AiWorkspaceFileEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceFileEmbeddings to fetch.
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceFileEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceFileEmbeddingOrderByWithRelationInput | AiWorkspaceFileEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiWorkspaceFileEmbeddings.
     */
    cursor?: AiWorkspaceFileEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceFileEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceFileEmbeddings.
     */
    skip?: number
    distinct?: AiWorkspaceFileEmbeddingScalarFieldEnum | AiWorkspaceFileEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding update
   */
  export type AiWorkspaceFileEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a AiWorkspaceFileEmbedding.
     */
    data: XOR<AiWorkspaceFileEmbeddingUpdateInput, AiWorkspaceFileEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which AiWorkspaceFileEmbedding to update.
     */
    where: AiWorkspaceFileEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding updateMany
   */
  export type AiWorkspaceFileEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiWorkspaceFileEmbeddings.
     */
    data: XOR<AiWorkspaceFileEmbeddingUpdateManyMutationInput, AiWorkspaceFileEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceFileEmbeddings to update
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceFileEmbeddings to update.
     */
    limit?: number
  }

  /**
   * AiWorkspaceFileEmbedding updateManyAndReturn
   */
  export type AiWorkspaceFileEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update AiWorkspaceFileEmbeddings.
     */
    data: XOR<AiWorkspaceFileEmbeddingUpdateManyMutationInput, AiWorkspaceFileEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceFileEmbeddings to update
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceFileEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceFileEmbedding delete
   */
  export type AiWorkspaceFileEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which AiWorkspaceFileEmbedding to delete.
     */
    where: AiWorkspaceFileEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceFileEmbedding deleteMany
   */
  export type AiWorkspaceFileEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceFileEmbeddings to delete
     */
    where?: AiWorkspaceFileEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceFileEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * AiWorkspaceFileEmbedding without action
   */
  export type AiWorkspaceFileEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceFileEmbedding
     */
    select?: AiWorkspaceFileEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceFileEmbedding
     */
    omit?: AiWorkspaceFileEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceFileEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model AiWorkspaceBlobEmbedding
   */

  export type AggregateAiWorkspaceBlobEmbedding = {
    _count: AiWorkspaceBlobEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceBlobEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceBlobEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceBlobEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceBlobEmbeddingMaxAggregateOutputType | null
  }

  export type AiWorkspaceBlobEmbeddingAvgAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceBlobEmbeddingSumAggregateOutputType = {
    chunk: number | null
  }

  export type AiWorkspaceBlobEmbeddingMinAggregateOutputType = {
    workspaceId: string | null
    blobId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceBlobEmbeddingMaxAggregateOutputType = {
    workspaceId: string | null
    blobId: string | null
    chunk: number | null
    content: string | null
    createdAt: Date | null
  }

  export type AiWorkspaceBlobEmbeddingCountAggregateOutputType = {
    workspaceId: number
    blobId: number
    chunk: number
    content: number
    createdAt: number
    _all: number
  }


  export type AiWorkspaceBlobEmbeddingAvgAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceBlobEmbeddingSumAggregateInputType = {
    chunk?: true
  }

  export type AiWorkspaceBlobEmbeddingMinAggregateInputType = {
    workspaceId?: true
    blobId?: true
    chunk?: true
    content?: true
    createdAt?: true
  }

  export type AiWorkspaceBlobEmbeddingMaxAggregateInputType = {
    workspaceId?: true
    blobId?: true
    chunk?: true
    content?: true
    createdAt?: true
  }

  export type AiWorkspaceBlobEmbeddingCountAggregateInputType = {
    workspaceId?: true
    blobId?: true
    chunk?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type AiWorkspaceBlobEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceBlobEmbedding to aggregate.
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceBlobEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithRelationInput | AiWorkspaceBlobEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiWorkspaceBlobEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceBlobEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceBlobEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiWorkspaceBlobEmbeddings
    **/
    _count?: true | AiWorkspaceBlobEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiWorkspaceBlobEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiWorkspaceBlobEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiWorkspaceBlobEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiWorkspaceBlobEmbeddingMaxAggregateInputType
  }

  export type GetAiWorkspaceBlobEmbeddingAggregateType<T extends AiWorkspaceBlobEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateAiWorkspaceBlobEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiWorkspaceBlobEmbedding[P]>
      : GetScalarType<T[P], AggregateAiWorkspaceBlobEmbedding[P]>
  }




  export type AiWorkspaceBlobEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiWorkspaceBlobEmbeddingWhereInput
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithAggregationInput | AiWorkspaceBlobEmbeddingOrderByWithAggregationInput[]
    by: AiWorkspaceBlobEmbeddingScalarFieldEnum[] | AiWorkspaceBlobEmbeddingScalarFieldEnum
    having?: AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiWorkspaceBlobEmbeddingCountAggregateInputType | true
    _avg?: AiWorkspaceBlobEmbeddingAvgAggregateInputType
    _sum?: AiWorkspaceBlobEmbeddingSumAggregateInputType
    _min?: AiWorkspaceBlobEmbeddingMinAggregateInputType
    _max?: AiWorkspaceBlobEmbeddingMaxAggregateInputType
  }

  export type AiWorkspaceBlobEmbeddingGroupByOutputType = {
    workspaceId: string
    blobId: string
    chunk: number
    content: string
    createdAt: Date
    _count: AiWorkspaceBlobEmbeddingCountAggregateOutputType | null
    _avg: AiWorkspaceBlobEmbeddingAvgAggregateOutputType | null
    _sum: AiWorkspaceBlobEmbeddingSumAggregateOutputType | null
    _min: AiWorkspaceBlobEmbeddingMinAggregateOutputType | null
    _max: AiWorkspaceBlobEmbeddingMaxAggregateOutputType | null
  }

  type GetAiWorkspaceBlobEmbeddingGroupByPayload<T extends AiWorkspaceBlobEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiWorkspaceBlobEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiWorkspaceBlobEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiWorkspaceBlobEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], AiWorkspaceBlobEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type AiWorkspaceBlobEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    blobId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    blob?: boolean | BlobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceBlobEmbedding"]>


  export type AiWorkspaceBlobEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    blobId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
    blob?: boolean | BlobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aiWorkspaceBlobEmbedding"]>

  export type AiWorkspaceBlobEmbeddingSelectScalar = {
    workspaceId?: boolean
    blobId?: boolean
    chunk?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type AiWorkspaceBlobEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "blobId" | "chunk" | "content" | "createdAt", ExtArgs["result"]["aiWorkspaceBlobEmbedding"]>
  export type AiWorkspaceBlobEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blob?: boolean | BlobDefaultArgs<ExtArgs>
  }
  export type AiWorkspaceBlobEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blob?: boolean | BlobDefaultArgs<ExtArgs>
  }

  export type $AiWorkspaceBlobEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiWorkspaceBlobEmbedding"
    objects: {
      blob: Prisma.$BlobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      blobId: string
      chunk: number
      content: string
      createdAt: Date
    }, ExtArgs["result"]["aiWorkspaceBlobEmbedding"]>
    composites: {}
  }

  type AiWorkspaceBlobEmbeddingGetPayload<S extends boolean | null | undefined | AiWorkspaceBlobEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload, S>

  type AiWorkspaceBlobEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiWorkspaceBlobEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiWorkspaceBlobEmbeddingCountAggregateInputType | true
    }

  export interface AiWorkspaceBlobEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiWorkspaceBlobEmbedding'], meta: { name: 'AiWorkspaceBlobEmbedding' } }
    /**
     * Find zero or one AiWorkspaceBlobEmbedding that matches the filter.
     * @param {AiWorkspaceBlobEmbeddingFindUniqueArgs} args - Arguments to find a AiWorkspaceBlobEmbedding
     * @example
     * // Get one AiWorkspaceBlobEmbedding
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiWorkspaceBlobEmbeddingFindUniqueArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiWorkspaceBlobEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiWorkspaceBlobEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a AiWorkspaceBlobEmbedding
     * @example
     * // Get one AiWorkspaceBlobEmbedding
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiWorkspaceBlobEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceBlobEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingFindFirstArgs} args - Arguments to find a AiWorkspaceBlobEmbedding
     * @example
     * // Get one AiWorkspaceBlobEmbedding
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiWorkspaceBlobEmbeddingFindFirstArgs>(args?: SelectSubset<T, AiWorkspaceBlobEmbeddingFindFirstArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiWorkspaceBlobEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingFindFirstOrThrowArgs} args - Arguments to find a AiWorkspaceBlobEmbedding
     * @example
     * // Get one AiWorkspaceBlobEmbedding
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiWorkspaceBlobEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, AiWorkspaceBlobEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiWorkspaceBlobEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiWorkspaceBlobEmbeddings
     * const aiWorkspaceBlobEmbeddings = await prisma.aiWorkspaceBlobEmbedding.findMany()
     * 
     * // Get first 10 AiWorkspaceBlobEmbeddings
     * const aiWorkspaceBlobEmbeddings = await prisma.aiWorkspaceBlobEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const aiWorkspaceBlobEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceBlobEmbedding.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends AiWorkspaceBlobEmbeddingFindManyArgs>(args?: SelectSubset<T, AiWorkspaceBlobEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a AiWorkspaceBlobEmbedding.
     * @param {AiWorkspaceBlobEmbeddingDeleteArgs} args - Arguments to delete one AiWorkspaceBlobEmbedding.
     * @example
     * // Delete one AiWorkspaceBlobEmbedding
     * const AiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.delete({
     *   where: {
     *     // ... filter to delete one AiWorkspaceBlobEmbedding
     *   }
     * })
     * 
     */
    delete<T extends AiWorkspaceBlobEmbeddingDeleteArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingDeleteArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiWorkspaceBlobEmbedding.
     * @param {AiWorkspaceBlobEmbeddingUpdateArgs} args - Arguments to update one AiWorkspaceBlobEmbedding.
     * @example
     * // Update one AiWorkspaceBlobEmbedding
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiWorkspaceBlobEmbeddingUpdateArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingUpdateArgs<ExtArgs>>): Prisma__AiWorkspaceBlobEmbeddingClient<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiWorkspaceBlobEmbeddings.
     * @param {AiWorkspaceBlobEmbeddingDeleteManyArgs} args - Arguments to filter AiWorkspaceBlobEmbeddings to delete.
     * @example
     * // Delete a few AiWorkspaceBlobEmbeddings
     * const { count } = await prisma.aiWorkspaceBlobEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiWorkspaceBlobEmbeddingDeleteManyArgs>(args?: SelectSubset<T, AiWorkspaceBlobEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceBlobEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiWorkspaceBlobEmbeddings
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiWorkspaceBlobEmbeddingUpdateManyArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiWorkspaceBlobEmbeddings and returns the data updated in the database.
     * @param {AiWorkspaceBlobEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many AiWorkspaceBlobEmbeddings.
     * @example
     * // Update many AiWorkspaceBlobEmbeddings
     * const aiWorkspaceBlobEmbedding = await prisma.aiWorkspaceBlobEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiWorkspaceBlobEmbeddings and only return the `workspaceId`
     * const aiWorkspaceBlobEmbeddingWithWorkspaceIdOnly = await prisma.aiWorkspaceBlobEmbedding.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiWorkspaceBlobEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, AiWorkspaceBlobEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of AiWorkspaceBlobEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingCountArgs} args - Arguments to filter AiWorkspaceBlobEmbeddings to count.
     * @example
     * // Count the number of AiWorkspaceBlobEmbeddings
     * const count = await prisma.aiWorkspaceBlobEmbedding.count({
     *   where: {
     *     // ... the filter for the AiWorkspaceBlobEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends AiWorkspaceBlobEmbeddingCountArgs>(
      args?: Subset<T, AiWorkspaceBlobEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiWorkspaceBlobEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiWorkspaceBlobEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiWorkspaceBlobEmbeddingAggregateArgs>(args: Subset<T, AiWorkspaceBlobEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetAiWorkspaceBlobEmbeddingAggregateType<T>>

    /**
     * Group by AiWorkspaceBlobEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiWorkspaceBlobEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiWorkspaceBlobEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiWorkspaceBlobEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: AiWorkspaceBlobEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiWorkspaceBlobEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiWorkspaceBlobEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiWorkspaceBlobEmbedding model
   */
  readonly fields: AiWorkspaceBlobEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiWorkspaceBlobEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiWorkspaceBlobEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blob<T extends BlobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlobDefaultArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiWorkspaceBlobEmbedding model
   */
  interface AiWorkspaceBlobEmbeddingFieldRefs {
    readonly workspaceId: FieldRef<"AiWorkspaceBlobEmbedding", 'String'>
    readonly blobId: FieldRef<"AiWorkspaceBlobEmbedding", 'String'>
    readonly chunk: FieldRef<"AiWorkspaceBlobEmbedding", 'Int'>
    readonly content: FieldRef<"AiWorkspaceBlobEmbedding", 'String'>
    readonly createdAt: FieldRef<"AiWorkspaceBlobEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiWorkspaceBlobEmbedding findUnique
   */
  export type AiWorkspaceBlobEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceBlobEmbedding to fetch.
     */
    where: AiWorkspaceBlobEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding findUniqueOrThrow
   */
  export type AiWorkspaceBlobEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceBlobEmbedding to fetch.
     */
    where: AiWorkspaceBlobEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding findFirst
   */
  export type AiWorkspaceBlobEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceBlobEmbedding to fetch.
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceBlobEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithRelationInput | AiWorkspaceBlobEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceBlobEmbeddings.
     */
    cursor?: AiWorkspaceBlobEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceBlobEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceBlobEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceBlobEmbeddings.
     */
    distinct?: AiWorkspaceBlobEmbeddingScalarFieldEnum | AiWorkspaceBlobEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding findFirstOrThrow
   */
  export type AiWorkspaceBlobEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceBlobEmbedding to fetch.
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceBlobEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithRelationInput | AiWorkspaceBlobEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiWorkspaceBlobEmbeddings.
     */
    cursor?: AiWorkspaceBlobEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceBlobEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceBlobEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiWorkspaceBlobEmbeddings.
     */
    distinct?: AiWorkspaceBlobEmbeddingScalarFieldEnum | AiWorkspaceBlobEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding findMany
   */
  export type AiWorkspaceBlobEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which AiWorkspaceBlobEmbeddings to fetch.
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiWorkspaceBlobEmbeddings to fetch.
     */
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithRelationInput | AiWorkspaceBlobEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiWorkspaceBlobEmbeddings.
     */
    cursor?: AiWorkspaceBlobEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiWorkspaceBlobEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiWorkspaceBlobEmbeddings.
     */
    skip?: number
    distinct?: AiWorkspaceBlobEmbeddingScalarFieldEnum | AiWorkspaceBlobEmbeddingScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding update
   */
  export type AiWorkspaceBlobEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a AiWorkspaceBlobEmbedding.
     */
    data: XOR<AiWorkspaceBlobEmbeddingUpdateInput, AiWorkspaceBlobEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which AiWorkspaceBlobEmbedding to update.
     */
    where: AiWorkspaceBlobEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding updateMany
   */
  export type AiWorkspaceBlobEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiWorkspaceBlobEmbeddings.
     */
    data: XOR<AiWorkspaceBlobEmbeddingUpdateManyMutationInput, AiWorkspaceBlobEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceBlobEmbeddings to update
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceBlobEmbeddings to update.
     */
    limit?: number
  }

  /**
   * AiWorkspaceBlobEmbedding updateManyAndReturn
   */
  export type AiWorkspaceBlobEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update AiWorkspaceBlobEmbeddings.
     */
    data: XOR<AiWorkspaceBlobEmbeddingUpdateManyMutationInput, AiWorkspaceBlobEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which AiWorkspaceBlobEmbeddings to update
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceBlobEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiWorkspaceBlobEmbedding delete
   */
  export type AiWorkspaceBlobEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which AiWorkspaceBlobEmbedding to delete.
     */
    where: AiWorkspaceBlobEmbeddingWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiWorkspaceBlobEmbedding deleteMany
   */
  export type AiWorkspaceBlobEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiWorkspaceBlobEmbeddings to delete
     */
    where?: AiWorkspaceBlobEmbeddingWhereInput
    /**
     * Limit how many AiWorkspaceBlobEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * AiWorkspaceBlobEmbedding without action
   */
  export type AiWorkspaceBlobEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model AiJobs
   */

  export type AggregateAiJobs = {
    _count: AiJobsCountAggregateOutputType | null
    _min: AiJobsMinAggregateOutputType | null
    _max: AiJobsMaxAggregateOutputType | null
  }

  export type AiJobsMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    blobId: string | null
    createdBy: string | null
    type: $Enums.AiJobType | null
    status: $Enums.AiJobStatus | null
    startedAt: Date | null
    finishedAt: Date | null
  }

  export type AiJobsMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    blobId: string | null
    createdBy: string | null
    type: $Enums.AiJobType | null
    status: $Enums.AiJobStatus | null
    startedAt: Date | null
    finishedAt: Date | null
  }

  export type AiJobsCountAggregateOutputType = {
    id: number
    workspaceId: number
    blobId: number
    createdBy: number
    type: number
    status: number
    payload: number
    startedAt: number
    finishedAt: number
    _all: number
  }


  export type AiJobsMinAggregateInputType = {
    id?: true
    workspaceId?: true
    blobId?: true
    createdBy?: true
    type?: true
    status?: true
    startedAt?: true
    finishedAt?: true
  }

  export type AiJobsMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    blobId?: true
    createdBy?: true
    type?: true
    status?: true
    startedAt?: true
    finishedAt?: true
  }

  export type AiJobsCountAggregateInputType = {
    id?: true
    workspaceId?: true
    blobId?: true
    createdBy?: true
    type?: true
    status?: true
    payload?: true
    startedAt?: true
    finishedAt?: true
    _all?: true
  }

  export type AiJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiJobs to aggregate.
     */
    where?: AiJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiJobs to fetch.
     */
    orderBy?: AiJobsOrderByWithRelationInput | AiJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiJobs
    **/
    _count?: true | AiJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiJobsMaxAggregateInputType
  }

  export type GetAiJobsAggregateType<T extends AiJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateAiJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiJobs[P]>
      : GetScalarType<T[P], AggregateAiJobs[P]>
  }




  export type AiJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiJobsWhereInput
    orderBy?: AiJobsOrderByWithAggregationInput | AiJobsOrderByWithAggregationInput[]
    by: AiJobsScalarFieldEnum[] | AiJobsScalarFieldEnum
    having?: AiJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiJobsCountAggregateInputType | true
    _min?: AiJobsMinAggregateInputType
    _max?: AiJobsMaxAggregateInputType
  }

  export type AiJobsGroupByOutputType = {
    id: string
    workspaceId: string
    blobId: string
    createdBy: string | null
    type: $Enums.AiJobType
    status: $Enums.AiJobStatus
    payload: JsonValue
    startedAt: Date
    finishedAt: Date | null
    _count: AiJobsCountAggregateOutputType | null
    _min: AiJobsMinAggregateOutputType | null
    _max: AiJobsMaxAggregateOutputType | null
  }

  type GetAiJobsGroupByPayload<T extends AiJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiJobsGroupByOutputType[P]>
            : GetScalarType<T[P], AiJobsGroupByOutputType[P]>
        }
      >
    >


  export type AiJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    blobId?: boolean
    createdBy?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["aiJobs"]>

  export type AiJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    blobId?: boolean
    createdBy?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["aiJobs"]>

  export type AiJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    blobId?: boolean
    createdBy?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["aiJobs"]>

  export type AiJobsSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    blobId?: boolean
    createdBy?: boolean
    type?: boolean
    status?: boolean
    payload?: boolean
    startedAt?: boolean
    finishedAt?: boolean
  }

  export type AiJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "blobId" | "createdBy" | "type" | "status" | "payload" | "startedAt" | "finishedAt", ExtArgs["result"]["aiJobs"]>
  export type AiJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }
  export type AiJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }
  export type AiJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByUser?: boolean | AiJobs$createdByUserArgs<ExtArgs>
  }

  export type $AiJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiJobs"
    objects: {
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      blobId: string
      createdBy: string | null
      type: $Enums.AiJobType
      status: $Enums.AiJobStatus
      payload: Prisma.JsonValue
      startedAt: Date
      finishedAt: Date | null
    }, ExtArgs["result"]["aiJobs"]>
    composites: {}
  }

  type AiJobsGetPayload<S extends boolean | null | undefined | AiJobsDefaultArgs> = $Result.GetResult<Prisma.$AiJobsPayload, S>

  type AiJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AiJobsCountAggregateInputType | true
    }

  export interface AiJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiJobs'], meta: { name: 'AiJobs' } }
    /**
     * Find zero or one AiJobs that matches the filter.
     * @param {AiJobsFindUniqueArgs} args - Arguments to find a AiJobs
     * @example
     * // Get one AiJobs
     * const aiJobs = await prisma.aiJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiJobsFindUniqueArgs>(args: SelectSubset<T, AiJobsFindUniqueArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AiJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiJobsFindUniqueOrThrowArgs} args - Arguments to find a AiJobs
     * @example
     * // Get one AiJobs
     * const aiJobs = await prisma.aiJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, AiJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsFindFirstArgs} args - Arguments to find a AiJobs
     * @example
     * // Get one AiJobs
     * const aiJobs = await prisma.aiJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiJobsFindFirstArgs>(args?: SelectSubset<T, AiJobsFindFirstArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AiJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsFindFirstOrThrowArgs} args - Arguments to find a AiJobs
     * @example
     * // Get one AiJobs
     * const aiJobs = await prisma.aiJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, AiJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AiJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiJobs
     * const aiJobs = await prisma.aiJobs.findMany()
     * 
     * // Get first 10 AiJobs
     * const aiJobs = await prisma.aiJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiJobsWithIdOnly = await prisma.aiJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiJobsFindManyArgs>(args?: SelectSubset<T, AiJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AiJobs.
     * @param {AiJobsCreateArgs} args - Arguments to create a AiJobs.
     * @example
     * // Create one AiJobs
     * const AiJobs = await prisma.aiJobs.create({
     *   data: {
     *     // ... data to create a AiJobs
     *   }
     * })
     * 
     */
    create<T extends AiJobsCreateArgs>(args: SelectSubset<T, AiJobsCreateArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AiJobs.
     * @param {AiJobsCreateManyArgs} args - Arguments to create many AiJobs.
     * @example
     * // Create many AiJobs
     * const aiJobs = await prisma.aiJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiJobsCreateManyArgs>(args?: SelectSubset<T, AiJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiJobs and returns the data saved in the database.
     * @param {AiJobsCreateManyAndReturnArgs} args - Arguments to create many AiJobs.
     * @example
     * // Create many AiJobs
     * const aiJobs = await prisma.aiJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiJobs and only return the `id`
     * const aiJobsWithIdOnly = await prisma.aiJobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, AiJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AiJobs.
     * @param {AiJobsDeleteArgs} args - Arguments to delete one AiJobs.
     * @example
     * // Delete one AiJobs
     * const AiJobs = await prisma.aiJobs.delete({
     *   where: {
     *     // ... filter to delete one AiJobs
     *   }
     * })
     * 
     */
    delete<T extends AiJobsDeleteArgs>(args: SelectSubset<T, AiJobsDeleteArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AiJobs.
     * @param {AiJobsUpdateArgs} args - Arguments to update one AiJobs.
     * @example
     * // Update one AiJobs
     * const aiJobs = await prisma.aiJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiJobsUpdateArgs>(args: SelectSubset<T, AiJobsUpdateArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AiJobs.
     * @param {AiJobsDeleteManyArgs} args - Arguments to filter AiJobs to delete.
     * @example
     * // Delete a few AiJobs
     * const { count } = await prisma.aiJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiJobsDeleteManyArgs>(args?: SelectSubset<T, AiJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiJobs
     * const aiJobs = await prisma.aiJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiJobsUpdateManyArgs>(args: SelectSubset<T, AiJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiJobs and returns the data updated in the database.
     * @param {AiJobsUpdateManyAndReturnArgs} args - Arguments to update many AiJobs.
     * @example
     * // Update many AiJobs
     * const aiJobs = await prisma.aiJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AiJobs and only return the `id`
     * const aiJobsWithIdOnly = await prisma.aiJobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AiJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, AiJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AiJobs.
     * @param {AiJobsUpsertArgs} args - Arguments to update or create a AiJobs.
     * @example
     * // Update or create a AiJobs
     * const aiJobs = await prisma.aiJobs.upsert({
     *   create: {
     *     // ... data to create a AiJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiJobs we want to update
     *   }
     * })
     */
    upsert<T extends AiJobsUpsertArgs>(args: SelectSubset<T, AiJobsUpsertArgs<ExtArgs>>): Prisma__AiJobsClient<$Result.GetResult<Prisma.$AiJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AiJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsCountArgs} args - Arguments to filter AiJobs to count.
     * @example
     * // Count the number of AiJobs
     * const count = await prisma.aiJobs.count({
     *   where: {
     *     // ... the filter for the AiJobs we want to count
     *   }
     * })
    **/
    count<T extends AiJobsCountArgs>(
      args?: Subset<T, AiJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiJobsAggregateArgs>(args: Subset<T, AiJobsAggregateArgs>): Prisma.PrismaPromise<GetAiJobsAggregateType<T>>

    /**
     * Group by AiJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiJobsGroupByArgs['orderBy'] }
        : { orderBy?: AiJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiJobs model
   */
  readonly fields: AiJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByUser<T extends AiJobs$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, AiJobs$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiJobs model
   */
  interface AiJobsFieldRefs {
    readonly id: FieldRef<"AiJobs", 'String'>
    readonly workspaceId: FieldRef<"AiJobs", 'String'>
    readonly blobId: FieldRef<"AiJobs", 'String'>
    readonly createdBy: FieldRef<"AiJobs", 'String'>
    readonly type: FieldRef<"AiJobs", 'AiJobType'>
    readonly status: FieldRef<"AiJobs", 'AiJobStatus'>
    readonly payload: FieldRef<"AiJobs", 'Json'>
    readonly startedAt: FieldRef<"AiJobs", 'DateTime'>
    readonly finishedAt: FieldRef<"AiJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiJobs findUnique
   */
  export type AiJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter, which AiJobs to fetch.
     */
    where: AiJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs findUniqueOrThrow
   */
  export type AiJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter, which AiJobs to fetch.
     */
    where: AiJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs findFirst
   */
  export type AiJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter, which AiJobs to fetch.
     */
    where?: AiJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiJobs to fetch.
     */
    orderBy?: AiJobsOrderByWithRelationInput | AiJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiJobs.
     */
    cursor?: AiJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiJobs.
     */
    distinct?: AiJobsScalarFieldEnum | AiJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs findFirstOrThrow
   */
  export type AiJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter, which AiJobs to fetch.
     */
    where?: AiJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiJobs to fetch.
     */
    orderBy?: AiJobsOrderByWithRelationInput | AiJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiJobs.
     */
    cursor?: AiJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiJobs.
     */
    distinct?: AiJobsScalarFieldEnum | AiJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs findMany
   */
  export type AiJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter, which AiJobs to fetch.
     */
    where?: AiJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiJobs to fetch.
     */
    orderBy?: AiJobsOrderByWithRelationInput | AiJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiJobs.
     */
    cursor?: AiJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiJobs.
     */
    skip?: number
    distinct?: AiJobsScalarFieldEnum | AiJobsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs create
   */
  export type AiJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a AiJobs.
     */
    data: XOR<AiJobsCreateInput, AiJobsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs createMany
   */
  export type AiJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiJobs.
     */
    data: AiJobsCreateManyInput | AiJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiJobs createManyAndReturn
   */
  export type AiJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * The data used to create many AiJobs.
     */
    data: AiJobsCreateManyInput | AiJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiJobs update
   */
  export type AiJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a AiJobs.
     */
    data: XOR<AiJobsUpdateInput, AiJobsUncheckedUpdateInput>
    /**
     * Choose, which AiJobs to update.
     */
    where: AiJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs updateMany
   */
  export type AiJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiJobs.
     */
    data: XOR<AiJobsUpdateManyMutationInput, AiJobsUncheckedUpdateManyInput>
    /**
     * Filter which AiJobs to update
     */
    where?: AiJobsWhereInput
    /**
     * Limit how many AiJobs to update.
     */
    limit?: number
  }

  /**
   * AiJobs updateManyAndReturn
   */
  export type AiJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * The data used to update AiJobs.
     */
    data: XOR<AiJobsUpdateManyMutationInput, AiJobsUncheckedUpdateManyInput>
    /**
     * Filter which AiJobs to update
     */
    where?: AiJobsWhereInput
    /**
     * Limit how many AiJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiJobs upsert
   */
  export type AiJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the AiJobs to update in case it exists.
     */
    where: AiJobsWhereUniqueInput
    /**
     * In case the AiJobs found by the `where` argument doesn't exist, create a new AiJobs with this data.
     */
    create: XOR<AiJobsCreateInput, AiJobsUncheckedCreateInput>
    /**
     * In case the AiJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiJobsUpdateInput, AiJobsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs delete
   */
  export type AiJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
    /**
     * Filter which AiJobs to delete.
     */
    where: AiJobsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AiJobs deleteMany
   */
  export type AiJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiJobs to delete
     */
    where?: AiJobsWhereInput
    /**
     * Limit how many AiJobs to delete.
     */
    limit?: number
  }

  /**
   * AiJobs.createdByUser
   */
  export type AiJobs$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AiJobs without action
   */
  export type AiJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiJobs
     */
    select?: AiJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiJobs
     */
    omit?: AiJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiJobsInclude<ExtArgs> | null
  }


  /**
   * Model DataMigration
   */

  export type AggregateDataMigration = {
    _count: DataMigrationCountAggregateOutputType | null
    _min: DataMigrationMinAggregateOutputType | null
    _max: DataMigrationMaxAggregateOutputType | null
  }

  export type DataMigrationMinAggregateOutputType = {
    id: string | null
    name: string | null
    startedAt: Date | null
    finishedAt: Date | null
  }

  export type DataMigrationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startedAt: Date | null
    finishedAt: Date | null
  }

  export type DataMigrationCountAggregateOutputType = {
    id: number
    name: number
    startedAt: number
    finishedAt: number
    _all: number
  }


  export type DataMigrationMinAggregateInputType = {
    id?: true
    name?: true
    startedAt?: true
    finishedAt?: true
  }

  export type DataMigrationMaxAggregateInputType = {
    id?: true
    name?: true
    startedAt?: true
    finishedAt?: true
  }

  export type DataMigrationCountAggregateInputType = {
    id?: true
    name?: true
    startedAt?: true
    finishedAt?: true
    _all?: true
  }

  export type DataMigrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataMigration to aggregate.
     */
    where?: DataMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataMigrations to fetch.
     */
    orderBy?: DataMigrationOrderByWithRelationInput | DataMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataMigrations
    **/
    _count?: true | DataMigrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataMigrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataMigrationMaxAggregateInputType
  }

  export type GetDataMigrationAggregateType<T extends DataMigrationAggregateArgs> = {
        [P in keyof T & keyof AggregateDataMigration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataMigration[P]>
      : GetScalarType<T[P], AggregateDataMigration[P]>
  }




  export type DataMigrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataMigrationWhereInput
    orderBy?: DataMigrationOrderByWithAggregationInput | DataMigrationOrderByWithAggregationInput[]
    by: DataMigrationScalarFieldEnum[] | DataMigrationScalarFieldEnum
    having?: DataMigrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataMigrationCountAggregateInputType | true
    _min?: DataMigrationMinAggregateInputType
    _max?: DataMigrationMaxAggregateInputType
  }

  export type DataMigrationGroupByOutputType = {
    id: string
    name: string
    startedAt: Date
    finishedAt: Date | null
    _count: DataMigrationCountAggregateOutputType | null
    _min: DataMigrationMinAggregateOutputType | null
    _max: DataMigrationMaxAggregateOutputType | null
  }

  type GetDataMigrationGroupByPayload<T extends DataMigrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataMigrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataMigrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataMigrationGroupByOutputType[P]>
            : GetScalarType<T[P], DataMigrationGroupByOutputType[P]>
        }
      >
    >


  export type DataMigrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startedAt?: boolean
    finishedAt?: boolean
  }, ExtArgs["result"]["dataMigration"]>

  export type DataMigrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startedAt?: boolean
    finishedAt?: boolean
  }, ExtArgs["result"]["dataMigration"]>

  export type DataMigrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startedAt?: boolean
    finishedAt?: boolean
  }, ExtArgs["result"]["dataMigration"]>

  export type DataMigrationSelectScalar = {
    id?: boolean
    name?: boolean
    startedAt?: boolean
    finishedAt?: boolean
  }

  export type DataMigrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startedAt" | "finishedAt", ExtArgs["result"]["dataMigration"]>

  export type $DataMigrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataMigration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startedAt: Date
      finishedAt: Date | null
    }, ExtArgs["result"]["dataMigration"]>
    composites: {}
  }

  type DataMigrationGetPayload<S extends boolean | null | undefined | DataMigrationDefaultArgs> = $Result.GetResult<Prisma.$DataMigrationPayload, S>

  type DataMigrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataMigrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DataMigrationCountAggregateInputType | true
    }

  export interface DataMigrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataMigration'], meta: { name: 'DataMigration' } }
    /**
     * Find zero or one DataMigration that matches the filter.
     * @param {DataMigrationFindUniqueArgs} args - Arguments to find a DataMigration
     * @example
     * // Get one DataMigration
     * const dataMigration = await prisma.dataMigration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataMigrationFindUniqueArgs>(args: SelectSubset<T, DataMigrationFindUniqueArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataMigration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataMigrationFindUniqueOrThrowArgs} args - Arguments to find a DataMigration
     * @example
     * // Get one DataMigration
     * const dataMigration = await prisma.dataMigration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataMigrationFindUniqueOrThrowArgs>(args: SelectSubset<T, DataMigrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataMigration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationFindFirstArgs} args - Arguments to find a DataMigration
     * @example
     * // Get one DataMigration
     * const dataMigration = await prisma.dataMigration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataMigrationFindFirstArgs>(args?: SelectSubset<T, DataMigrationFindFirstArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataMigration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationFindFirstOrThrowArgs} args - Arguments to find a DataMigration
     * @example
     * // Get one DataMigration
     * const dataMigration = await prisma.dataMigration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataMigrationFindFirstOrThrowArgs>(args?: SelectSubset<T, DataMigrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataMigrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataMigrations
     * const dataMigrations = await prisma.dataMigration.findMany()
     * 
     * // Get first 10 DataMigrations
     * const dataMigrations = await prisma.dataMigration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataMigrationWithIdOnly = await prisma.dataMigration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataMigrationFindManyArgs>(args?: SelectSubset<T, DataMigrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataMigration.
     * @param {DataMigrationCreateArgs} args - Arguments to create a DataMigration.
     * @example
     * // Create one DataMigration
     * const DataMigration = await prisma.dataMigration.create({
     *   data: {
     *     // ... data to create a DataMigration
     *   }
     * })
     * 
     */
    create<T extends DataMigrationCreateArgs>(args: SelectSubset<T, DataMigrationCreateArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataMigrations.
     * @param {DataMigrationCreateManyArgs} args - Arguments to create many DataMigrations.
     * @example
     * // Create many DataMigrations
     * const dataMigration = await prisma.dataMigration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataMigrationCreateManyArgs>(args?: SelectSubset<T, DataMigrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataMigrations and returns the data saved in the database.
     * @param {DataMigrationCreateManyAndReturnArgs} args - Arguments to create many DataMigrations.
     * @example
     * // Create many DataMigrations
     * const dataMigration = await prisma.dataMigration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataMigrations and only return the `id`
     * const dataMigrationWithIdOnly = await prisma.dataMigration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataMigrationCreateManyAndReturnArgs>(args?: SelectSubset<T, DataMigrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DataMigration.
     * @param {DataMigrationDeleteArgs} args - Arguments to delete one DataMigration.
     * @example
     * // Delete one DataMigration
     * const DataMigration = await prisma.dataMigration.delete({
     *   where: {
     *     // ... filter to delete one DataMigration
     *   }
     * })
     * 
     */
    delete<T extends DataMigrationDeleteArgs>(args: SelectSubset<T, DataMigrationDeleteArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataMigration.
     * @param {DataMigrationUpdateArgs} args - Arguments to update one DataMigration.
     * @example
     * // Update one DataMigration
     * const dataMigration = await prisma.dataMigration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataMigrationUpdateArgs>(args: SelectSubset<T, DataMigrationUpdateArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataMigrations.
     * @param {DataMigrationDeleteManyArgs} args - Arguments to filter DataMigrations to delete.
     * @example
     * // Delete a few DataMigrations
     * const { count } = await prisma.dataMigration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataMigrationDeleteManyArgs>(args?: SelectSubset<T, DataMigrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataMigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataMigrations
     * const dataMigration = await prisma.dataMigration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataMigrationUpdateManyArgs>(args: SelectSubset<T, DataMigrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataMigrations and returns the data updated in the database.
     * @param {DataMigrationUpdateManyAndReturnArgs} args - Arguments to update many DataMigrations.
     * @example
     * // Update many DataMigrations
     * const dataMigration = await prisma.dataMigration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DataMigrations and only return the `id`
     * const dataMigrationWithIdOnly = await prisma.dataMigration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DataMigrationUpdateManyAndReturnArgs>(args: SelectSubset<T, DataMigrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DataMigration.
     * @param {DataMigrationUpsertArgs} args - Arguments to update or create a DataMigration.
     * @example
     * // Update or create a DataMigration
     * const dataMigration = await prisma.dataMigration.upsert({
     *   create: {
     *     // ... data to create a DataMigration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataMigration we want to update
     *   }
     * })
     */
    upsert<T extends DataMigrationUpsertArgs>(args: SelectSubset<T, DataMigrationUpsertArgs<ExtArgs>>): Prisma__DataMigrationClient<$Result.GetResult<Prisma.$DataMigrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataMigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationCountArgs} args - Arguments to filter DataMigrations to count.
     * @example
     * // Count the number of DataMigrations
     * const count = await prisma.dataMigration.count({
     *   where: {
     *     // ... the filter for the DataMigrations we want to count
     *   }
     * })
    **/
    count<T extends DataMigrationCountArgs>(
      args?: Subset<T, DataMigrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataMigrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataMigration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataMigrationAggregateArgs>(args: Subset<T, DataMigrationAggregateArgs>): Prisma.PrismaPromise<GetDataMigrationAggregateType<T>>

    /**
     * Group by DataMigration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataMigrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataMigrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataMigrationGroupByArgs['orderBy'] }
        : { orderBy?: DataMigrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataMigrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataMigrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataMigration model
   */
  readonly fields: DataMigrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataMigration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataMigrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataMigration model
   */
  interface DataMigrationFieldRefs {
    readonly id: FieldRef<"DataMigration", 'String'>
    readonly name: FieldRef<"DataMigration", 'String'>
    readonly startedAt: FieldRef<"DataMigration", 'DateTime'>
    readonly finishedAt: FieldRef<"DataMigration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataMigration findUnique
   */
  export type DataMigrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter, which DataMigration to fetch.
     */
    where: DataMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration findUniqueOrThrow
   */
  export type DataMigrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter, which DataMigration to fetch.
     */
    where: DataMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration findFirst
   */
  export type DataMigrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter, which DataMigration to fetch.
     */
    where?: DataMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataMigrations to fetch.
     */
    orderBy?: DataMigrationOrderByWithRelationInput | DataMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataMigrations.
     */
    cursor?: DataMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataMigrations.
     */
    distinct?: DataMigrationScalarFieldEnum | DataMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration findFirstOrThrow
   */
  export type DataMigrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter, which DataMigration to fetch.
     */
    where?: DataMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataMigrations to fetch.
     */
    orderBy?: DataMigrationOrderByWithRelationInput | DataMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataMigrations.
     */
    cursor?: DataMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataMigrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataMigrations.
     */
    distinct?: DataMigrationScalarFieldEnum | DataMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration findMany
   */
  export type DataMigrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter, which DataMigrations to fetch.
     */
    where?: DataMigrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataMigrations to fetch.
     */
    orderBy?: DataMigrationOrderByWithRelationInput | DataMigrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataMigrations.
     */
    cursor?: DataMigrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataMigrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataMigrations.
     */
    skip?: number
    distinct?: DataMigrationScalarFieldEnum | DataMigrationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration create
   */
  export type DataMigrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * The data needed to create a DataMigration.
     */
    data: XOR<DataMigrationCreateInput, DataMigrationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration createMany
   */
  export type DataMigrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataMigrations.
     */
    data: DataMigrationCreateManyInput | DataMigrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataMigration createManyAndReturn
   */
  export type DataMigrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * The data used to create many DataMigrations.
     */
    data: DataMigrationCreateManyInput | DataMigrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataMigration update
   */
  export type DataMigrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * The data needed to update a DataMigration.
     */
    data: XOR<DataMigrationUpdateInput, DataMigrationUncheckedUpdateInput>
    /**
     * Choose, which DataMigration to update.
     */
    where: DataMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration updateMany
   */
  export type DataMigrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataMigrations.
     */
    data: XOR<DataMigrationUpdateManyMutationInput, DataMigrationUncheckedUpdateManyInput>
    /**
     * Filter which DataMigrations to update
     */
    where?: DataMigrationWhereInput
    /**
     * Limit how many DataMigrations to update.
     */
    limit?: number
  }

  /**
   * DataMigration updateManyAndReturn
   */
  export type DataMigrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * The data used to update DataMigrations.
     */
    data: XOR<DataMigrationUpdateManyMutationInput, DataMigrationUncheckedUpdateManyInput>
    /**
     * Filter which DataMigrations to update
     */
    where?: DataMigrationWhereInput
    /**
     * Limit how many DataMigrations to update.
     */
    limit?: number
  }

  /**
   * DataMigration upsert
   */
  export type DataMigrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * The filter to search for the DataMigration to update in case it exists.
     */
    where: DataMigrationWhereUniqueInput
    /**
     * In case the DataMigration found by the `where` argument doesn't exist, create a new DataMigration with this data.
     */
    create: XOR<DataMigrationCreateInput, DataMigrationUncheckedCreateInput>
    /**
     * In case the DataMigration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataMigrationUpdateInput, DataMigrationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration delete
   */
  export type DataMigrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
    /**
     * Filter which DataMigration to delete.
     */
    where: DataMigrationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DataMigration deleteMany
   */
  export type DataMigrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataMigrations to delete
     */
    where?: DataMigrationWhereInput
    /**
     * Limit how many DataMigrations to delete.
     */
    limit?: number
  }

  /**
   * DataMigration without action
   */
  export type DataMigrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataMigration
     */
    select?: DataMigrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataMigration
     */
    omit?: DataMigrationOmit<ExtArgs> | null
  }


  /**
   * Model DeprecatedAppRuntimeSettings
   */

  export type AggregateDeprecatedAppRuntimeSettings = {
    _count: DeprecatedAppRuntimeSettingsCountAggregateOutputType | null
    _min: DeprecatedAppRuntimeSettingsMinAggregateOutputType | null
    _max: DeprecatedAppRuntimeSettingsMaxAggregateOutputType | null
  }

  export type DeprecatedAppRuntimeSettingsMinAggregateOutputType = {
    id: string | null
    type: $Enums.RuntimeConfigType | null
    module: string | null
    key: string | null
    description: string | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastUpdatedBy: string | null
  }

  export type DeprecatedAppRuntimeSettingsMaxAggregateOutputType = {
    id: string | null
    type: $Enums.RuntimeConfigType | null
    module: string | null
    key: string | null
    description: string | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastUpdatedBy: string | null
  }

  export type DeprecatedAppRuntimeSettingsCountAggregateOutputType = {
    id: number
    type: number
    module: number
    key: number
    value: number
    description: number
    updatedAt: number
    deletedAt: number
    lastUpdatedBy: number
    _all: number
  }


  export type DeprecatedAppRuntimeSettingsMinAggregateInputType = {
    id?: true
    type?: true
    module?: true
    key?: true
    description?: true
    updatedAt?: true
    deletedAt?: true
    lastUpdatedBy?: true
  }

  export type DeprecatedAppRuntimeSettingsMaxAggregateInputType = {
    id?: true
    type?: true
    module?: true
    key?: true
    description?: true
    updatedAt?: true
    deletedAt?: true
    lastUpdatedBy?: true
  }

  export type DeprecatedAppRuntimeSettingsCountAggregateInputType = {
    id?: true
    type?: true
    module?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    deletedAt?: true
    lastUpdatedBy?: true
    _all?: true
  }

  export type DeprecatedAppRuntimeSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedAppRuntimeSettings to aggregate.
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedAppRuntimeSettings to fetch.
     */
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithRelationInput | DeprecatedAppRuntimeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeprecatedAppRuntimeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedAppRuntimeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedAppRuntimeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeprecatedAppRuntimeSettings
    **/
    _count?: true | DeprecatedAppRuntimeSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeprecatedAppRuntimeSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeprecatedAppRuntimeSettingsMaxAggregateInputType
  }

  export type GetDeprecatedAppRuntimeSettingsAggregateType<T extends DeprecatedAppRuntimeSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeprecatedAppRuntimeSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeprecatedAppRuntimeSettings[P]>
      : GetScalarType<T[P], AggregateDeprecatedAppRuntimeSettings[P]>
  }




  export type DeprecatedAppRuntimeSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeprecatedAppRuntimeSettingsWhereInput
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithAggregationInput | DeprecatedAppRuntimeSettingsOrderByWithAggregationInput[]
    by: DeprecatedAppRuntimeSettingsScalarFieldEnum[] | DeprecatedAppRuntimeSettingsScalarFieldEnum
    having?: DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeprecatedAppRuntimeSettingsCountAggregateInputType | true
    _min?: DeprecatedAppRuntimeSettingsMinAggregateInputType
    _max?: DeprecatedAppRuntimeSettingsMaxAggregateInputType
  }

  export type DeprecatedAppRuntimeSettingsGroupByOutputType = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonValue
    description: string
    updatedAt: Date
    deletedAt: Date | null
    lastUpdatedBy: string | null
    _count: DeprecatedAppRuntimeSettingsCountAggregateOutputType | null
    _min: DeprecatedAppRuntimeSettingsMinAggregateOutputType | null
    _max: DeprecatedAppRuntimeSettingsMaxAggregateOutputType | null
  }

  type GetDeprecatedAppRuntimeSettingsGroupByPayload<T extends DeprecatedAppRuntimeSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeprecatedAppRuntimeSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeprecatedAppRuntimeSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeprecatedAppRuntimeSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], DeprecatedAppRuntimeSettingsGroupByOutputType[P]>
        }
      >
    >


  export type DeprecatedAppRuntimeSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    module?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deprecatedAppRuntimeSettings"]>

  export type DeprecatedAppRuntimeSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    module?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deprecatedAppRuntimeSettings"]>

  export type DeprecatedAppRuntimeSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    module?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["deprecatedAppRuntimeSettings"]>

  export type DeprecatedAppRuntimeSettingsSelectScalar = {
    id?: boolean
    type?: boolean
    module?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastUpdatedBy?: boolean
  }

  export type DeprecatedAppRuntimeSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "module" | "key" | "value" | "description" | "updatedAt" | "deletedAt" | "lastUpdatedBy", ExtArgs["result"]["deprecatedAppRuntimeSettings"]>
  export type DeprecatedAppRuntimeSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }
  export type DeprecatedAppRuntimeSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }
  export type DeprecatedAppRuntimeSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>
  }

  export type $DeprecatedAppRuntimeSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeprecatedAppRuntimeSettings"
    objects: {
      lastUpdatedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.RuntimeConfigType
      module: string
      key: string
      value: Prisma.JsonValue
      description: string
      updatedAt: Date
      deletedAt: Date | null
      lastUpdatedBy: string | null
    }, ExtArgs["result"]["deprecatedAppRuntimeSettings"]>
    composites: {}
  }

  type DeprecatedAppRuntimeSettingsGetPayload<S extends boolean | null | undefined | DeprecatedAppRuntimeSettingsDefaultArgs> = $Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload, S>

  type DeprecatedAppRuntimeSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeprecatedAppRuntimeSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DeprecatedAppRuntimeSettingsCountAggregateInputType | true
    }

  export interface DeprecatedAppRuntimeSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeprecatedAppRuntimeSettings'], meta: { name: 'DeprecatedAppRuntimeSettings' } }
    /**
     * Find zero or one DeprecatedAppRuntimeSettings that matches the filter.
     * @param {DeprecatedAppRuntimeSettingsFindUniqueArgs} args - Arguments to find a DeprecatedAppRuntimeSettings
     * @example
     * // Get one DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeprecatedAppRuntimeSettingsFindUniqueArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsFindUniqueArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeprecatedAppRuntimeSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeprecatedAppRuntimeSettingsFindUniqueOrThrowArgs} args - Arguments to find a DeprecatedAppRuntimeSettings
     * @example
     * // Get one DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeprecatedAppRuntimeSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedAppRuntimeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsFindFirstArgs} args - Arguments to find a DeprecatedAppRuntimeSettings
     * @example
     * // Get one DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeprecatedAppRuntimeSettingsFindFirstArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsFindFirstArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedAppRuntimeSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsFindFirstOrThrowArgs} args - Arguments to find a DeprecatedAppRuntimeSettings
     * @example
     * // Get one DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeprecatedAppRuntimeSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeprecatedAppRuntimeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findMany()
     * 
     * // Get first 10 DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deprecatedAppRuntimeSettingsWithIdOnly = await prisma.deprecatedAppRuntimeSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeprecatedAppRuntimeSettingsFindManyArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsCreateArgs} args - Arguments to create a DeprecatedAppRuntimeSettings.
     * @example
     * // Create one DeprecatedAppRuntimeSettings
     * const DeprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.create({
     *   data: {
     *     // ... data to create a DeprecatedAppRuntimeSettings
     *   }
     * })
     * 
     */
    create<T extends DeprecatedAppRuntimeSettingsCreateArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsCreateArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsCreateManyArgs} args - Arguments to create many DeprecatedAppRuntimeSettings.
     * @example
     * // Create many DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeprecatedAppRuntimeSettingsCreateManyArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeprecatedAppRuntimeSettings and returns the data saved in the database.
     * @param {DeprecatedAppRuntimeSettingsCreateManyAndReturnArgs} args - Arguments to create many DeprecatedAppRuntimeSettings.
     * @example
     * // Create many DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeprecatedAppRuntimeSettings and only return the `id`
     * const deprecatedAppRuntimeSettingsWithIdOnly = await prisma.deprecatedAppRuntimeSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeprecatedAppRuntimeSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsDeleteArgs} args - Arguments to delete one DeprecatedAppRuntimeSettings.
     * @example
     * // Delete one DeprecatedAppRuntimeSettings
     * const DeprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.delete({
     *   where: {
     *     // ... filter to delete one DeprecatedAppRuntimeSettings
     *   }
     * })
     * 
     */
    delete<T extends DeprecatedAppRuntimeSettingsDeleteArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsDeleteArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsUpdateArgs} args - Arguments to update one DeprecatedAppRuntimeSettings.
     * @example
     * // Update one DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeprecatedAppRuntimeSettingsUpdateArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsUpdateArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsDeleteManyArgs} args - Arguments to filter DeprecatedAppRuntimeSettings to delete.
     * @example
     * // Delete a few DeprecatedAppRuntimeSettings
     * const { count } = await prisma.deprecatedAppRuntimeSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeprecatedAppRuntimeSettingsDeleteManyArgs>(args?: SelectSubset<T, DeprecatedAppRuntimeSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedAppRuntimeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeprecatedAppRuntimeSettingsUpdateManyArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedAppRuntimeSettings and returns the data updated in the database.
     * @param {DeprecatedAppRuntimeSettingsUpdateManyAndReturnArgs} args - Arguments to update many DeprecatedAppRuntimeSettings.
     * @example
     * // Update many DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeprecatedAppRuntimeSettings and only return the `id`
     * const deprecatedAppRuntimeSettingsWithIdOnly = await prisma.deprecatedAppRuntimeSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeprecatedAppRuntimeSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeprecatedAppRuntimeSettings.
     * @param {DeprecatedAppRuntimeSettingsUpsertArgs} args - Arguments to update or create a DeprecatedAppRuntimeSettings.
     * @example
     * // Update or create a DeprecatedAppRuntimeSettings
     * const deprecatedAppRuntimeSettings = await prisma.deprecatedAppRuntimeSettings.upsert({
     *   create: {
     *     // ... data to create a DeprecatedAppRuntimeSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeprecatedAppRuntimeSettings we want to update
     *   }
     * })
     */
    upsert<T extends DeprecatedAppRuntimeSettingsUpsertArgs>(args: SelectSubset<T, DeprecatedAppRuntimeSettingsUpsertArgs<ExtArgs>>): Prisma__DeprecatedAppRuntimeSettingsClient<$Result.GetResult<Prisma.$DeprecatedAppRuntimeSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeprecatedAppRuntimeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsCountArgs} args - Arguments to filter DeprecatedAppRuntimeSettings to count.
     * @example
     * // Count the number of DeprecatedAppRuntimeSettings
     * const count = await prisma.deprecatedAppRuntimeSettings.count({
     *   where: {
     *     // ... the filter for the DeprecatedAppRuntimeSettings we want to count
     *   }
     * })
    **/
    count<T extends DeprecatedAppRuntimeSettingsCountArgs>(
      args?: Subset<T, DeprecatedAppRuntimeSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeprecatedAppRuntimeSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeprecatedAppRuntimeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeprecatedAppRuntimeSettingsAggregateArgs>(args: Subset<T, DeprecatedAppRuntimeSettingsAggregateArgs>): Prisma.PrismaPromise<GetDeprecatedAppRuntimeSettingsAggregateType<T>>

    /**
     * Group by DeprecatedAppRuntimeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedAppRuntimeSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeprecatedAppRuntimeSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeprecatedAppRuntimeSettingsGroupByArgs['orderBy'] }
        : { orderBy?: DeprecatedAppRuntimeSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeprecatedAppRuntimeSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeprecatedAppRuntimeSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeprecatedAppRuntimeSettings model
   */
  readonly fields: DeprecatedAppRuntimeSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeprecatedAppRuntimeSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeprecatedAppRuntimeSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lastUpdatedByUser<T extends DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs> = {}>(args?: Subset<T, DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeprecatedAppRuntimeSettings model
   */
  interface DeprecatedAppRuntimeSettingsFieldRefs {
    readonly id: FieldRef<"DeprecatedAppRuntimeSettings", 'String'>
    readonly type: FieldRef<"DeprecatedAppRuntimeSettings", 'RuntimeConfigType'>
    readonly module: FieldRef<"DeprecatedAppRuntimeSettings", 'String'>
    readonly key: FieldRef<"DeprecatedAppRuntimeSettings", 'String'>
    readonly value: FieldRef<"DeprecatedAppRuntimeSettings", 'Json'>
    readonly description: FieldRef<"DeprecatedAppRuntimeSettings", 'String'>
    readonly updatedAt: FieldRef<"DeprecatedAppRuntimeSettings", 'DateTime'>
    readonly deletedAt: FieldRef<"DeprecatedAppRuntimeSettings", 'DateTime'>
    readonly lastUpdatedBy: FieldRef<"DeprecatedAppRuntimeSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeprecatedAppRuntimeSettings findUnique
   */
  export type DeprecatedAppRuntimeSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which DeprecatedAppRuntimeSettings to fetch.
     */
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings findUniqueOrThrow
   */
  export type DeprecatedAppRuntimeSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which DeprecatedAppRuntimeSettings to fetch.
     */
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings findFirst
   */
  export type DeprecatedAppRuntimeSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which DeprecatedAppRuntimeSettings to fetch.
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedAppRuntimeSettings to fetch.
     */
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithRelationInput | DeprecatedAppRuntimeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedAppRuntimeSettings.
     */
    cursor?: DeprecatedAppRuntimeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedAppRuntimeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedAppRuntimeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedAppRuntimeSettings.
     */
    distinct?: DeprecatedAppRuntimeSettingsScalarFieldEnum | DeprecatedAppRuntimeSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings findFirstOrThrow
   */
  export type DeprecatedAppRuntimeSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which DeprecatedAppRuntimeSettings to fetch.
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedAppRuntimeSettings to fetch.
     */
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithRelationInput | DeprecatedAppRuntimeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedAppRuntimeSettings.
     */
    cursor?: DeprecatedAppRuntimeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedAppRuntimeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedAppRuntimeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedAppRuntimeSettings.
     */
    distinct?: DeprecatedAppRuntimeSettingsScalarFieldEnum | DeprecatedAppRuntimeSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings findMany
   */
  export type DeprecatedAppRuntimeSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which DeprecatedAppRuntimeSettings to fetch.
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedAppRuntimeSettings to fetch.
     */
    orderBy?: DeprecatedAppRuntimeSettingsOrderByWithRelationInput | DeprecatedAppRuntimeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeprecatedAppRuntimeSettings.
     */
    cursor?: DeprecatedAppRuntimeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedAppRuntimeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedAppRuntimeSettings.
     */
    skip?: number
    distinct?: DeprecatedAppRuntimeSettingsScalarFieldEnum | DeprecatedAppRuntimeSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings create
   */
  export type DeprecatedAppRuntimeSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a DeprecatedAppRuntimeSettings.
     */
    data: XOR<DeprecatedAppRuntimeSettingsCreateInput, DeprecatedAppRuntimeSettingsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings createMany
   */
  export type DeprecatedAppRuntimeSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeprecatedAppRuntimeSettings.
     */
    data: DeprecatedAppRuntimeSettingsCreateManyInput | DeprecatedAppRuntimeSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeprecatedAppRuntimeSettings createManyAndReturn
   */
  export type DeprecatedAppRuntimeSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many DeprecatedAppRuntimeSettings.
     */
    data: DeprecatedAppRuntimeSettingsCreateManyInput | DeprecatedAppRuntimeSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeprecatedAppRuntimeSettings update
   */
  export type DeprecatedAppRuntimeSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a DeprecatedAppRuntimeSettings.
     */
    data: XOR<DeprecatedAppRuntimeSettingsUpdateInput, DeprecatedAppRuntimeSettingsUncheckedUpdateInput>
    /**
     * Choose, which DeprecatedAppRuntimeSettings to update.
     */
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings updateMany
   */
  export type DeprecatedAppRuntimeSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeprecatedAppRuntimeSettings.
     */
    data: XOR<DeprecatedAppRuntimeSettingsUpdateManyMutationInput, DeprecatedAppRuntimeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedAppRuntimeSettings to update
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * Limit how many DeprecatedAppRuntimeSettings to update.
     */
    limit?: number
  }

  /**
   * DeprecatedAppRuntimeSettings updateManyAndReturn
   */
  export type DeprecatedAppRuntimeSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * The data used to update DeprecatedAppRuntimeSettings.
     */
    data: XOR<DeprecatedAppRuntimeSettingsUpdateManyMutationInput, DeprecatedAppRuntimeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedAppRuntimeSettings to update
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * Limit how many DeprecatedAppRuntimeSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeprecatedAppRuntimeSettings upsert
   */
  export type DeprecatedAppRuntimeSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the DeprecatedAppRuntimeSettings to update in case it exists.
     */
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    /**
     * In case the DeprecatedAppRuntimeSettings found by the `where` argument doesn't exist, create a new DeprecatedAppRuntimeSettings with this data.
     */
    create: XOR<DeprecatedAppRuntimeSettingsCreateInput, DeprecatedAppRuntimeSettingsUncheckedCreateInput>
    /**
     * In case the DeprecatedAppRuntimeSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeprecatedAppRuntimeSettingsUpdateInput, DeprecatedAppRuntimeSettingsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings delete
   */
  export type DeprecatedAppRuntimeSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
    /**
     * Filter which DeprecatedAppRuntimeSettings to delete.
     */
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedAppRuntimeSettings deleteMany
   */
  export type DeprecatedAppRuntimeSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedAppRuntimeSettings to delete
     */
    where?: DeprecatedAppRuntimeSettingsWhereInput
    /**
     * Limit how many DeprecatedAppRuntimeSettings to delete.
     */
    limit?: number
  }

  /**
   * DeprecatedAppRuntimeSettings.lastUpdatedByUser
   */
  export type DeprecatedAppRuntimeSettings$lastUpdatedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DeprecatedAppRuntimeSettings without action
   */
  export type DeprecatedAppRuntimeSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedAppRuntimeSettings
     */
    select?: DeprecatedAppRuntimeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedAppRuntimeSettings
     */
    omit?: DeprecatedAppRuntimeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeprecatedAppRuntimeSettingsInclude<ExtArgs> | null
  }


  /**
   * Model AppConfig
   */

  export type AggregateAppConfig = {
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  export type AppConfigMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdatedBy: string | null
  }

  export type AppConfigMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUpdatedBy: string | null
  }

  export type AppConfigCountAggregateOutputType = {
    id: number
    value: number
    createdAt: number
    updatedAt: number
    lastUpdatedBy: number
    _all: number
  }


  export type AppConfigMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    lastUpdatedBy?: true
  }

  export type AppConfigMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    lastUpdatedBy?: true
  }

  export type AppConfigCountAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    lastUpdatedBy?: true
    _all?: true
  }

  export type AppConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfig to aggregate.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigs
    **/
    _count?: true | AppConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigMaxAggregateInputType
  }

  export type GetAppConfigAggregateType<T extends AppConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfig[P]>
      : GetScalarType<T[P], AggregateAppConfig[P]>
  }




  export type AppConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithAggregationInput | AppConfigOrderByWithAggregationInput[]
    by: AppConfigScalarFieldEnum[] | AppConfigScalarFieldEnum
    having?: AppConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigCountAggregateInputType | true
    _min?: AppConfigMinAggregateInputType
    _max?: AppConfigMaxAggregateInputType
  }

  export type AppConfigGroupByOutputType = {
    id: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    lastUpdatedBy: string | null
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  type GetAppConfigGroupByPayload<T extends AppConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdatedBy?: boolean
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectScalar = {
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUpdatedBy?: boolean
  }

  export type AppConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "createdAt" | "updatedAt" | "lastUpdatedBy", ExtArgs["result"]["appConfig"]>
  export type AppConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }
  export type AppConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }
  export type AppConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastUpdatedByUser?: boolean | AppConfig$lastUpdatedByUserArgs<ExtArgs>
  }

  export type $AppConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppConfig"
    objects: {
      lastUpdatedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      lastUpdatedBy: string | null
    }, ExtArgs["result"]["appConfig"]>
    composites: {}
  }

  type AppConfigGetPayload<S extends boolean | null | undefined | AppConfigDefaultArgs> = $Result.GetResult<Prisma.$AppConfigPayload, S>

  type AppConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AppConfigCountAggregateInputType | true
    }

  export interface AppConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppConfig'], meta: { name: 'AppConfig' } }
    /**
     * Find zero or one AppConfig that matches the filter.
     * @param {AppConfigFindUniqueArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppConfigFindUniqueArgs>(args: SelectSubset<T, AppConfigFindUniqueArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppConfigFindUniqueOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AppConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppConfigFindFirstArgs>(args?: SelectSubset<T, AppConfigFindFirstArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AppConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigs
     * const appConfigs = await prisma.appConfig.findMany()
     * 
     * // Get first 10 AppConfigs
     * const appConfigs = await prisma.appConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppConfigFindManyArgs>(args?: SelectSubset<T, AppConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppConfig.
     * @param {AppConfigCreateArgs} args - Arguments to create a AppConfig.
     * @example
     * // Create one AppConfig
     * const AppConfig = await prisma.appConfig.create({
     *   data: {
     *     // ... data to create a AppConfig
     *   }
     * })
     * 
     */
    create<T extends AppConfigCreateArgs>(args: SelectSubset<T, AppConfigCreateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppConfigs.
     * @param {AppConfigCreateManyArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppConfigCreateManyArgs>(args?: SelectSubset<T, AppConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppConfigs and returns the data saved in the database.
     * @param {AppConfigCreateManyAndReturnArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AppConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppConfig.
     * @param {AppConfigDeleteArgs} args - Arguments to delete one AppConfig.
     * @example
     * // Delete one AppConfig
     * const AppConfig = await prisma.appConfig.delete({
     *   where: {
     *     // ... filter to delete one AppConfig
     *   }
     * })
     * 
     */
    delete<T extends AppConfigDeleteArgs>(args: SelectSubset<T, AppConfigDeleteArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppConfig.
     * @param {AppConfigUpdateArgs} args - Arguments to update one AppConfig.
     * @example
     * // Update one AppConfig
     * const appConfig = await prisma.appConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppConfigUpdateArgs>(args: SelectSubset<T, AppConfigUpdateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppConfigs.
     * @param {AppConfigDeleteManyArgs} args - Arguments to filter AppConfigs to delete.
     * @example
     * // Delete a few AppConfigs
     * const { count } = await prisma.appConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppConfigDeleteManyArgs>(args?: SelectSubset<T, AppConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppConfigUpdateManyArgs>(args: SelectSubset<T, AppConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs and returns the data updated in the database.
     * @param {AppConfigUpdateManyAndReturnArgs} args - Arguments to update many AppConfigs.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppConfigs and only return the `id`
     * const appConfigWithIdOnly = await prisma.appConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, AppConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppConfig.
     * @param {AppConfigUpsertArgs} args - Arguments to update or create a AppConfig.
     * @example
     * // Update or create a AppConfig
     * const appConfig = await prisma.appConfig.upsert({
     *   create: {
     *     // ... data to create a AppConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfig we want to update
     *   }
     * })
     */
    upsert<T extends AppConfigUpsertArgs>(args: SelectSubset<T, AppConfigUpsertArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigCountArgs} args - Arguments to filter AppConfigs to count.
     * @example
     * // Count the number of AppConfigs
     * const count = await prisma.appConfig.count({
     *   where: {
     *     // ... the filter for the AppConfigs we want to count
     *   }
     * })
    **/
    count<T extends AppConfigCountArgs>(
      args?: Subset<T, AppConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigAggregateArgs>(args: Subset<T, AppConfigAggregateArgs>): Prisma.PrismaPromise<GetAppConfigAggregateType<T>>

    /**
     * Group by AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppConfig model
   */
  readonly fields: AppConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lastUpdatedByUser<T extends AppConfig$lastUpdatedByUserArgs<ExtArgs> = {}>(args?: Subset<T, AppConfig$lastUpdatedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppConfig model
   */
  interface AppConfigFieldRefs {
    readonly id: FieldRef<"AppConfig", 'String'>
    readonly value: FieldRef<"AppConfig", 'Json'>
    readonly createdAt: FieldRef<"AppConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"AppConfig", 'DateTime'>
    readonly lastUpdatedBy: FieldRef<"AppConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AppConfig findUnique
   */
  export type AppConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig findUniqueOrThrow
   */
  export type AppConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig findFirst
   */
  export type AppConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig findFirstOrThrow
   */
  export type AppConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig findMany
   */
  export type AppConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter, which AppConfigs to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig create
   */
  export type AppConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a AppConfig.
     */
    data: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig createMany
   */
  export type AppConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig createManyAndReturn
   */
  export type AppConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppConfig update
   */
  export type AppConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a AppConfig.
     */
    data: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    /**
     * Choose, which AppConfig to update.
     */
    where: AppConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig updateMany
   */
  export type AppConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
  }

  /**
   * AppConfig updateManyAndReturn
   */
  export type AppConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppConfig upsert
   */
  export type AppConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the AppConfig to update in case it exists.
     */
    where: AppConfigWhereUniqueInput
    /**
     * In case the AppConfig found by the `where` argument doesn't exist, create a new AppConfig with this data.
     */
    create: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    /**
     * In case the AppConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig delete
   */
  export type AppConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
    /**
     * Filter which AppConfig to delete.
     */
    where: AppConfigWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AppConfig deleteMany
   */
  export type AppConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfigs to delete
     */
    where?: AppConfigWhereInput
    /**
     * Limit how many AppConfigs to delete.
     */
    limit?: number
  }

  /**
   * AppConfig.lastUpdatedByUser
   */
  export type AppConfig$lastUpdatedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AppConfig without action
   */
  export type AppConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppConfig
     */
    omit?: AppConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppConfigInclude<ExtArgs> | null
  }


  /**
   * Model DeprecatedUserSubscription
   */

  export type AggregateDeprecatedUserSubscription = {
    _count: DeprecatedUserSubscriptionCountAggregateOutputType | null
    _avg: DeprecatedUserSubscriptionAvgAggregateOutputType | null
    _sum: DeprecatedUserSubscriptionSumAggregateOutputType | null
    _min: DeprecatedUserSubscriptionMinAggregateOutputType | null
    _max: DeprecatedUserSubscriptionMaxAggregateOutputType | null
  }

  export type DeprecatedUserSubscriptionAvgAggregateOutputType = {
    id: number | null
  }

  export type DeprecatedUserSubscriptionSumAggregateOutputType = {
    id: number | null
  }

  export type DeprecatedUserSubscriptionMinAggregateOutputType = {
    id: number | null
    userId: string | null
    plan: string | null
    recurring: string | null
    variant: string | null
    stripeSubscriptionId: string | null
    status: string | null
    start: Date | null
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    stripeScheduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeprecatedUserSubscriptionMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    plan: string | null
    recurring: string | null
    variant: string | null
    stripeSubscriptionId: string | null
    status: string | null
    start: Date | null
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    stripeScheduleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeprecatedUserSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    recurring: number
    variant: number
    stripeSubscriptionId: number
    status: number
    start: number
    end: number
    nextBillAt: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    stripeScheduleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeprecatedUserSubscriptionAvgAggregateInputType = {
    id?: true
  }

  export type DeprecatedUserSubscriptionSumAggregateInputType = {
    id?: true
  }

  export type DeprecatedUserSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    recurring?: true
    variant?: true
    stripeSubscriptionId?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    stripeScheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeprecatedUserSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    recurring?: true
    variant?: true
    stripeSubscriptionId?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    stripeScheduleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeprecatedUserSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    recurring?: true
    variant?: true
    stripeSubscriptionId?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    stripeScheduleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeprecatedUserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedUserSubscription to aggregate.
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserSubscriptions to fetch.
     */
    orderBy?: DeprecatedUserSubscriptionOrderByWithRelationInput | DeprecatedUserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeprecatedUserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeprecatedUserSubscriptions
    **/
    _count?: true | DeprecatedUserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeprecatedUserSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeprecatedUserSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeprecatedUserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeprecatedUserSubscriptionMaxAggregateInputType
  }

  export type GetDeprecatedUserSubscriptionAggregateType<T extends DeprecatedUserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeprecatedUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeprecatedUserSubscription[P]>
      : GetScalarType<T[P], AggregateDeprecatedUserSubscription[P]>
  }




  export type DeprecatedUserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeprecatedUserSubscriptionWhereInput
    orderBy?: DeprecatedUserSubscriptionOrderByWithAggregationInput | DeprecatedUserSubscriptionOrderByWithAggregationInput[]
    by: DeprecatedUserSubscriptionScalarFieldEnum[] | DeprecatedUserSubscriptionScalarFieldEnum
    having?: DeprecatedUserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeprecatedUserSubscriptionCountAggregateInputType | true
    _avg?: DeprecatedUserSubscriptionAvgAggregateInputType
    _sum?: DeprecatedUserSubscriptionSumAggregateInputType
    _min?: DeprecatedUserSubscriptionMinAggregateInputType
    _max?: DeprecatedUserSubscriptionMaxAggregateInputType
  }

  export type DeprecatedUserSubscriptionGroupByOutputType = {
    id: number
    userId: string
    plan: string
    recurring: string
    variant: string | null
    stripeSubscriptionId: string | null
    status: string
    start: Date
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    stripeScheduleId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeprecatedUserSubscriptionCountAggregateOutputType | null
    _avg: DeprecatedUserSubscriptionAvgAggregateOutputType | null
    _sum: DeprecatedUserSubscriptionSumAggregateOutputType | null
    _min: DeprecatedUserSubscriptionMinAggregateOutputType | null
    _max: DeprecatedUserSubscriptionMaxAggregateOutputType | null
  }

  type GetDeprecatedUserSubscriptionGroupByPayload<T extends DeprecatedUserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeprecatedUserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeprecatedUserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeprecatedUserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], DeprecatedUserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type DeprecatedUserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    stripeScheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deprecatedUserSubscription"]>

  export type DeprecatedUserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    stripeScheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deprecatedUserSubscription"]>

  export type DeprecatedUserSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    stripeScheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deprecatedUserSubscription"]>

  export type DeprecatedUserSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    stripeScheduleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeprecatedUserSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "plan" | "recurring" | "variant" | "stripeSubscriptionId" | "status" | "start" | "end" | "nextBillAt" | "canceledAt" | "trialStart" | "trialEnd" | "stripeScheduleId" | "createdAt" | "updatedAt", ExtArgs["result"]["deprecatedUserSubscription"]>

  export type $DeprecatedUserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeprecatedUserSubscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      plan: string
      recurring: string
      variant: string | null
      stripeSubscriptionId: string | null
      status: string
      start: Date
      end: Date | null
      nextBillAt: Date | null
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      stripeScheduleId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deprecatedUserSubscription"]>
    composites: {}
  }

  type DeprecatedUserSubscriptionGetPayload<S extends boolean | null | undefined | DeprecatedUserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload, S>

  type DeprecatedUserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeprecatedUserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DeprecatedUserSubscriptionCountAggregateInputType | true
    }

  export interface DeprecatedUserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeprecatedUserSubscription'], meta: { name: 'DeprecatedUserSubscription' } }
    /**
     * Find zero or one DeprecatedUserSubscription that matches the filter.
     * @param {DeprecatedUserSubscriptionFindUniqueArgs} args - Arguments to find a DeprecatedUserSubscription
     * @example
     * // Get one DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeprecatedUserSubscriptionFindUniqueArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeprecatedUserSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeprecatedUserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a DeprecatedUserSubscription
     * @example
     * // Get one DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeprecatedUserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedUserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionFindFirstArgs} args - Arguments to find a DeprecatedUserSubscription
     * @example
     * // Get one DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeprecatedUserSubscriptionFindFirstArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedUserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a DeprecatedUserSubscription
     * @example
     * // Get one DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeprecatedUserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeprecatedUserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeprecatedUserSubscriptions
     * const deprecatedUserSubscriptions = await prisma.deprecatedUserSubscription.findMany()
     * 
     * // Get first 10 DeprecatedUserSubscriptions
     * const deprecatedUserSubscriptions = await prisma.deprecatedUserSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deprecatedUserSubscriptionWithIdOnly = await prisma.deprecatedUserSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeprecatedUserSubscriptionFindManyArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeprecatedUserSubscription.
     * @param {DeprecatedUserSubscriptionCreateArgs} args - Arguments to create a DeprecatedUserSubscription.
     * @example
     * // Create one DeprecatedUserSubscription
     * const DeprecatedUserSubscription = await prisma.deprecatedUserSubscription.create({
     *   data: {
     *     // ... data to create a DeprecatedUserSubscription
     *   }
     * })
     * 
     */
    create<T extends DeprecatedUserSubscriptionCreateArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionCreateArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeprecatedUserSubscriptions.
     * @param {DeprecatedUserSubscriptionCreateManyArgs} args - Arguments to create many DeprecatedUserSubscriptions.
     * @example
     * // Create many DeprecatedUserSubscriptions
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeprecatedUserSubscriptionCreateManyArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeprecatedUserSubscriptions and returns the data saved in the database.
     * @param {DeprecatedUserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many DeprecatedUserSubscriptions.
     * @example
     * // Create many DeprecatedUserSubscriptions
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeprecatedUserSubscriptions and only return the `id`
     * const deprecatedUserSubscriptionWithIdOnly = await prisma.deprecatedUserSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeprecatedUserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeprecatedUserSubscription.
     * @param {DeprecatedUserSubscriptionDeleteArgs} args - Arguments to delete one DeprecatedUserSubscription.
     * @example
     * // Delete one DeprecatedUserSubscription
     * const DeprecatedUserSubscription = await prisma.deprecatedUserSubscription.delete({
     *   where: {
     *     // ... filter to delete one DeprecatedUserSubscription
     *   }
     * })
     * 
     */
    delete<T extends DeprecatedUserSubscriptionDeleteArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionDeleteArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeprecatedUserSubscription.
     * @param {DeprecatedUserSubscriptionUpdateArgs} args - Arguments to update one DeprecatedUserSubscription.
     * @example
     * // Update one DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeprecatedUserSubscriptionUpdateArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionUpdateArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeprecatedUserSubscriptions.
     * @param {DeprecatedUserSubscriptionDeleteManyArgs} args - Arguments to filter DeprecatedUserSubscriptions to delete.
     * @example
     * // Delete a few DeprecatedUserSubscriptions
     * const { count } = await prisma.deprecatedUserSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeprecatedUserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, DeprecatedUserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedUserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeprecatedUserSubscriptions
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeprecatedUserSubscriptionUpdateManyArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedUserSubscriptions and returns the data updated in the database.
     * @param {DeprecatedUserSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many DeprecatedUserSubscriptions.
     * @example
     * // Update many DeprecatedUserSubscriptions
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeprecatedUserSubscriptions and only return the `id`
     * const deprecatedUserSubscriptionWithIdOnly = await prisma.deprecatedUserSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeprecatedUserSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeprecatedUserSubscription.
     * @param {DeprecatedUserSubscriptionUpsertArgs} args - Arguments to update or create a DeprecatedUserSubscription.
     * @example
     * // Update or create a DeprecatedUserSubscription
     * const deprecatedUserSubscription = await prisma.deprecatedUserSubscription.upsert({
     *   create: {
     *     // ... data to create a DeprecatedUserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeprecatedUserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends DeprecatedUserSubscriptionUpsertArgs>(args: SelectSubset<T, DeprecatedUserSubscriptionUpsertArgs<ExtArgs>>): Prisma__DeprecatedUserSubscriptionClient<$Result.GetResult<Prisma.$DeprecatedUserSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeprecatedUserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionCountArgs} args - Arguments to filter DeprecatedUserSubscriptions to count.
     * @example
     * // Count the number of DeprecatedUserSubscriptions
     * const count = await prisma.deprecatedUserSubscription.count({
     *   where: {
     *     // ... the filter for the DeprecatedUserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends DeprecatedUserSubscriptionCountArgs>(
      args?: Subset<T, DeprecatedUserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeprecatedUserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeprecatedUserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeprecatedUserSubscriptionAggregateArgs>(args: Subset<T, DeprecatedUserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetDeprecatedUserSubscriptionAggregateType<T>>

    /**
     * Group by DeprecatedUserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeprecatedUserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeprecatedUserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: DeprecatedUserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeprecatedUserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeprecatedUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeprecatedUserSubscription model
   */
  readonly fields: DeprecatedUserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeprecatedUserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeprecatedUserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeprecatedUserSubscription model
   */
  interface DeprecatedUserSubscriptionFieldRefs {
    readonly id: FieldRef<"DeprecatedUserSubscription", 'Int'>
    readonly userId: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly plan: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly recurring: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly variant: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly status: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly start: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly end: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly nextBillAt: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly canceledAt: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly trialStart: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly trialEnd: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly stripeScheduleId: FieldRef<"DeprecatedUserSubscription", 'String'>
    readonly createdAt: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"DeprecatedUserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeprecatedUserSubscription findUnique
   */
  export type DeprecatedUserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserSubscription to fetch.
     */
    where: DeprecatedUserSubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription findUniqueOrThrow
   */
  export type DeprecatedUserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserSubscription to fetch.
     */
    where: DeprecatedUserSubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription findFirst
   */
  export type DeprecatedUserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserSubscription to fetch.
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserSubscriptions to fetch.
     */
    orderBy?: DeprecatedUserSubscriptionOrderByWithRelationInput | DeprecatedUserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedUserSubscriptions.
     */
    cursor?: DeprecatedUserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedUserSubscriptions.
     */
    distinct?: DeprecatedUserSubscriptionScalarFieldEnum | DeprecatedUserSubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription findFirstOrThrow
   */
  export type DeprecatedUserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserSubscription to fetch.
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserSubscriptions to fetch.
     */
    orderBy?: DeprecatedUserSubscriptionOrderByWithRelationInput | DeprecatedUserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedUserSubscriptions.
     */
    cursor?: DeprecatedUserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedUserSubscriptions.
     */
    distinct?: DeprecatedUserSubscriptionScalarFieldEnum | DeprecatedUserSubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription findMany
   */
  export type DeprecatedUserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserSubscriptions to fetch.
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserSubscriptions to fetch.
     */
    orderBy?: DeprecatedUserSubscriptionOrderByWithRelationInput | DeprecatedUserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeprecatedUserSubscriptions.
     */
    cursor?: DeprecatedUserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserSubscriptions.
     */
    skip?: number
    distinct?: DeprecatedUserSubscriptionScalarFieldEnum | DeprecatedUserSubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription create
   */
  export type DeprecatedUserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a DeprecatedUserSubscription.
     */
    data: XOR<DeprecatedUserSubscriptionCreateInput, DeprecatedUserSubscriptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription createMany
   */
  export type DeprecatedUserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeprecatedUserSubscriptions.
     */
    data: DeprecatedUserSubscriptionCreateManyInput | DeprecatedUserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeprecatedUserSubscription createManyAndReturn
   */
  export type DeprecatedUserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many DeprecatedUserSubscriptions.
     */
    data: DeprecatedUserSubscriptionCreateManyInput | DeprecatedUserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeprecatedUserSubscription update
   */
  export type DeprecatedUserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a DeprecatedUserSubscription.
     */
    data: XOR<DeprecatedUserSubscriptionUpdateInput, DeprecatedUserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which DeprecatedUserSubscription to update.
     */
    where: DeprecatedUserSubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription updateMany
   */
  export type DeprecatedUserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeprecatedUserSubscriptions.
     */
    data: XOR<DeprecatedUserSubscriptionUpdateManyMutationInput, DeprecatedUserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedUserSubscriptions to update
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * Limit how many DeprecatedUserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * DeprecatedUserSubscription updateManyAndReturn
   */
  export type DeprecatedUserSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update DeprecatedUserSubscriptions.
     */
    data: XOR<DeprecatedUserSubscriptionUpdateManyMutationInput, DeprecatedUserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedUserSubscriptions to update
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * Limit how many DeprecatedUserSubscriptions to update.
     */
    limit?: number
  }

  /**
   * DeprecatedUserSubscription upsert
   */
  export type DeprecatedUserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the DeprecatedUserSubscription to update in case it exists.
     */
    where: DeprecatedUserSubscriptionWhereUniqueInput
    /**
     * In case the DeprecatedUserSubscription found by the `where` argument doesn't exist, create a new DeprecatedUserSubscription with this data.
     */
    create: XOR<DeprecatedUserSubscriptionCreateInput, DeprecatedUserSubscriptionUncheckedCreateInput>
    /**
     * In case the DeprecatedUserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeprecatedUserSubscriptionUpdateInput, DeprecatedUserSubscriptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription delete
   */
  export type DeprecatedUserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
    /**
     * Filter which DeprecatedUserSubscription to delete.
     */
    where: DeprecatedUserSubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserSubscription deleteMany
   */
  export type DeprecatedUserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedUserSubscriptions to delete
     */
    where?: DeprecatedUserSubscriptionWhereInput
    /**
     * Limit how many DeprecatedUserSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * DeprecatedUserSubscription without action
   */
  export type DeprecatedUserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserSubscription
     */
    select?: DeprecatedUserSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserSubscription
     */
    omit?: DeprecatedUserSubscriptionOmit<ExtArgs> | null
  }


  /**
   * Model DeprecatedUserInvoice
   */

  export type AggregateDeprecatedUserInvoice = {
    _count: DeprecatedUserInvoiceCountAggregateOutputType | null
    _avg: DeprecatedUserInvoiceAvgAggregateOutputType | null
    _sum: DeprecatedUserInvoiceSumAggregateOutputType | null
    _min: DeprecatedUserInvoiceMinAggregateOutputType | null
    _max: DeprecatedUserInvoiceMaxAggregateOutputType | null
  }

  export type DeprecatedUserInvoiceAvgAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type DeprecatedUserInvoiceSumAggregateOutputType = {
    id: number | null
    amount: number | null
  }

  export type DeprecatedUserInvoiceMinAggregateOutputType = {
    id: number | null
    userId: string | null
    stripeInvoiceId: string | null
    currency: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    plan: string | null
    recurring: string | null
  }

  export type DeprecatedUserInvoiceMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    stripeInvoiceId: string | null
    currency: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    plan: string | null
    recurring: string | null
  }

  export type DeprecatedUserInvoiceCountAggregateOutputType = {
    id: number
    userId: number
    stripeInvoiceId: number
    currency: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    reason: number
    lastPaymentError: number
    link: number
    plan: number
    recurring: number
    _all: number
  }


  export type DeprecatedUserInvoiceAvgAggregateInputType = {
    id?: true
    amount?: true
  }

  export type DeprecatedUserInvoiceSumAggregateInputType = {
    id?: true
    amount?: true
  }

  export type DeprecatedUserInvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    stripeInvoiceId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    plan?: true
    recurring?: true
  }

  export type DeprecatedUserInvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeInvoiceId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    plan?: true
    recurring?: true
  }

  export type DeprecatedUserInvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    stripeInvoiceId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    plan?: true
    recurring?: true
    _all?: true
  }

  export type DeprecatedUserInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedUserInvoice to aggregate.
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserInvoices to fetch.
     */
    orderBy?: DeprecatedUserInvoiceOrderByWithRelationInput | DeprecatedUserInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeprecatedUserInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeprecatedUserInvoices
    **/
    _count?: true | DeprecatedUserInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeprecatedUserInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeprecatedUserInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeprecatedUserInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeprecatedUserInvoiceMaxAggregateInputType
  }

  export type GetDeprecatedUserInvoiceAggregateType<T extends DeprecatedUserInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateDeprecatedUserInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeprecatedUserInvoice[P]>
      : GetScalarType<T[P], AggregateDeprecatedUserInvoice[P]>
  }




  export type DeprecatedUserInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeprecatedUserInvoiceWhereInput
    orderBy?: DeprecatedUserInvoiceOrderByWithAggregationInput | DeprecatedUserInvoiceOrderByWithAggregationInput[]
    by: DeprecatedUserInvoiceScalarFieldEnum[] | DeprecatedUserInvoiceScalarFieldEnum
    having?: DeprecatedUserInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeprecatedUserInvoiceCountAggregateInputType | true
    _avg?: DeprecatedUserInvoiceAvgAggregateInputType
    _sum?: DeprecatedUserInvoiceSumAggregateInputType
    _min?: DeprecatedUserInvoiceMinAggregateInputType
    _max?: DeprecatedUserInvoiceMaxAggregateInputType
  }

  export type DeprecatedUserInvoiceGroupByOutputType = {
    id: number
    userId: string
    stripeInvoiceId: string
    currency: string
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    plan: string | null
    recurring: string | null
    _count: DeprecatedUserInvoiceCountAggregateOutputType | null
    _avg: DeprecatedUserInvoiceAvgAggregateOutputType | null
    _sum: DeprecatedUserInvoiceSumAggregateOutputType | null
    _min: DeprecatedUserInvoiceMinAggregateOutputType | null
    _max: DeprecatedUserInvoiceMaxAggregateOutputType | null
  }

  type GetDeprecatedUserInvoiceGroupByPayload<T extends DeprecatedUserInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeprecatedUserInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeprecatedUserInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeprecatedUserInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], DeprecatedUserInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type DeprecatedUserInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeInvoiceId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    plan?: boolean
    recurring?: boolean
  }, ExtArgs["result"]["deprecatedUserInvoice"]>

  export type DeprecatedUserInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeInvoiceId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    plan?: boolean
    recurring?: boolean
  }, ExtArgs["result"]["deprecatedUserInvoice"]>

  export type DeprecatedUserInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeInvoiceId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    plan?: boolean
    recurring?: boolean
  }, ExtArgs["result"]["deprecatedUserInvoice"]>

  export type DeprecatedUserInvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeInvoiceId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    plan?: boolean
    recurring?: boolean
  }

  export type DeprecatedUserInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stripeInvoiceId" | "currency" | "amount" | "status" | "createdAt" | "updatedAt" | "reason" | "lastPaymentError" | "link" | "plan" | "recurring", ExtArgs["result"]["deprecatedUserInvoice"]>

  export type $DeprecatedUserInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeprecatedUserInvoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      stripeInvoiceId: string
      currency: string
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
      reason: string | null
      lastPaymentError: string | null
      link: string | null
      plan: string | null
      recurring: string | null
    }, ExtArgs["result"]["deprecatedUserInvoice"]>
    composites: {}
  }

  type DeprecatedUserInvoiceGetPayload<S extends boolean | null | undefined | DeprecatedUserInvoiceDefaultArgs> = $Result.GetResult<Prisma.$DeprecatedUserInvoicePayload, S>

  type DeprecatedUserInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeprecatedUserInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: DeprecatedUserInvoiceCountAggregateInputType | true
    }

  export interface DeprecatedUserInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeprecatedUserInvoice'], meta: { name: 'DeprecatedUserInvoice' } }
    /**
     * Find zero or one DeprecatedUserInvoice that matches the filter.
     * @param {DeprecatedUserInvoiceFindUniqueArgs} args - Arguments to find a DeprecatedUserInvoice
     * @example
     * // Get one DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeprecatedUserInvoiceFindUniqueArgs>(args: SelectSubset<T, DeprecatedUserInvoiceFindUniqueArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeprecatedUserInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeprecatedUserInvoiceFindUniqueOrThrowArgs} args - Arguments to find a DeprecatedUserInvoice
     * @example
     * // Get one DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeprecatedUserInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeprecatedUserInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedUserInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceFindFirstArgs} args - Arguments to find a DeprecatedUserInvoice
     * @example
     * // Get one DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeprecatedUserInvoiceFindFirstArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceFindFirstArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeprecatedUserInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceFindFirstOrThrowArgs} args - Arguments to find a DeprecatedUserInvoice
     * @example
     * // Get one DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeprecatedUserInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeprecatedUserInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeprecatedUserInvoices
     * const deprecatedUserInvoices = await prisma.deprecatedUserInvoice.findMany()
     * 
     * // Get first 10 DeprecatedUserInvoices
     * const deprecatedUserInvoices = await prisma.deprecatedUserInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deprecatedUserInvoiceWithIdOnly = await prisma.deprecatedUserInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeprecatedUserInvoiceFindManyArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeprecatedUserInvoice.
     * @param {DeprecatedUserInvoiceCreateArgs} args - Arguments to create a DeprecatedUserInvoice.
     * @example
     * // Create one DeprecatedUserInvoice
     * const DeprecatedUserInvoice = await prisma.deprecatedUserInvoice.create({
     *   data: {
     *     // ... data to create a DeprecatedUserInvoice
     *   }
     * })
     * 
     */
    create<T extends DeprecatedUserInvoiceCreateArgs>(args: SelectSubset<T, DeprecatedUserInvoiceCreateArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeprecatedUserInvoices.
     * @param {DeprecatedUserInvoiceCreateManyArgs} args - Arguments to create many DeprecatedUserInvoices.
     * @example
     * // Create many DeprecatedUserInvoices
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeprecatedUserInvoiceCreateManyArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeprecatedUserInvoices and returns the data saved in the database.
     * @param {DeprecatedUserInvoiceCreateManyAndReturnArgs} args - Arguments to create many DeprecatedUserInvoices.
     * @example
     * // Create many DeprecatedUserInvoices
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeprecatedUserInvoices and only return the `id`
     * const deprecatedUserInvoiceWithIdOnly = await prisma.deprecatedUserInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeprecatedUserInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeprecatedUserInvoice.
     * @param {DeprecatedUserInvoiceDeleteArgs} args - Arguments to delete one DeprecatedUserInvoice.
     * @example
     * // Delete one DeprecatedUserInvoice
     * const DeprecatedUserInvoice = await prisma.deprecatedUserInvoice.delete({
     *   where: {
     *     // ... filter to delete one DeprecatedUserInvoice
     *   }
     * })
     * 
     */
    delete<T extends DeprecatedUserInvoiceDeleteArgs>(args: SelectSubset<T, DeprecatedUserInvoiceDeleteArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeprecatedUserInvoice.
     * @param {DeprecatedUserInvoiceUpdateArgs} args - Arguments to update one DeprecatedUserInvoice.
     * @example
     * // Update one DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeprecatedUserInvoiceUpdateArgs>(args: SelectSubset<T, DeprecatedUserInvoiceUpdateArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeprecatedUserInvoices.
     * @param {DeprecatedUserInvoiceDeleteManyArgs} args - Arguments to filter DeprecatedUserInvoices to delete.
     * @example
     * // Delete a few DeprecatedUserInvoices
     * const { count } = await prisma.deprecatedUserInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeprecatedUserInvoiceDeleteManyArgs>(args?: SelectSubset<T, DeprecatedUserInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedUserInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeprecatedUserInvoices
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeprecatedUserInvoiceUpdateManyArgs>(args: SelectSubset<T, DeprecatedUserInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeprecatedUserInvoices and returns the data updated in the database.
     * @param {DeprecatedUserInvoiceUpdateManyAndReturnArgs} args - Arguments to update many DeprecatedUserInvoices.
     * @example
     * // Update many DeprecatedUserInvoices
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeprecatedUserInvoices and only return the `id`
     * const deprecatedUserInvoiceWithIdOnly = await prisma.deprecatedUserInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeprecatedUserInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeprecatedUserInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeprecatedUserInvoice.
     * @param {DeprecatedUserInvoiceUpsertArgs} args - Arguments to update or create a DeprecatedUserInvoice.
     * @example
     * // Update or create a DeprecatedUserInvoice
     * const deprecatedUserInvoice = await prisma.deprecatedUserInvoice.upsert({
     *   create: {
     *     // ... data to create a DeprecatedUserInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeprecatedUserInvoice we want to update
     *   }
     * })
     */
    upsert<T extends DeprecatedUserInvoiceUpsertArgs>(args: SelectSubset<T, DeprecatedUserInvoiceUpsertArgs<ExtArgs>>): Prisma__DeprecatedUserInvoiceClient<$Result.GetResult<Prisma.$DeprecatedUserInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeprecatedUserInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceCountArgs} args - Arguments to filter DeprecatedUserInvoices to count.
     * @example
     * // Count the number of DeprecatedUserInvoices
     * const count = await prisma.deprecatedUserInvoice.count({
     *   where: {
     *     // ... the filter for the DeprecatedUserInvoices we want to count
     *   }
     * })
    **/
    count<T extends DeprecatedUserInvoiceCountArgs>(
      args?: Subset<T, DeprecatedUserInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeprecatedUserInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeprecatedUserInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeprecatedUserInvoiceAggregateArgs>(args: Subset<T, DeprecatedUserInvoiceAggregateArgs>): Prisma.PrismaPromise<GetDeprecatedUserInvoiceAggregateType<T>>

    /**
     * Group by DeprecatedUserInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeprecatedUserInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeprecatedUserInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeprecatedUserInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: DeprecatedUserInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeprecatedUserInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeprecatedUserInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeprecatedUserInvoice model
   */
  readonly fields: DeprecatedUserInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeprecatedUserInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeprecatedUserInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeprecatedUserInvoice model
   */
  interface DeprecatedUserInvoiceFieldRefs {
    readonly id: FieldRef<"DeprecatedUserInvoice", 'Int'>
    readonly userId: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly stripeInvoiceId: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly currency: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly amount: FieldRef<"DeprecatedUserInvoice", 'Int'>
    readonly status: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly createdAt: FieldRef<"DeprecatedUserInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"DeprecatedUserInvoice", 'DateTime'>
    readonly reason: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly lastPaymentError: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly link: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly plan: FieldRef<"DeprecatedUserInvoice", 'String'>
    readonly recurring: FieldRef<"DeprecatedUserInvoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeprecatedUserInvoice findUnique
   */
  export type DeprecatedUserInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserInvoice to fetch.
     */
    where: DeprecatedUserInvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice findUniqueOrThrow
   */
  export type DeprecatedUserInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserInvoice to fetch.
     */
    where: DeprecatedUserInvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice findFirst
   */
  export type DeprecatedUserInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserInvoice to fetch.
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserInvoices to fetch.
     */
    orderBy?: DeprecatedUserInvoiceOrderByWithRelationInput | DeprecatedUserInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedUserInvoices.
     */
    cursor?: DeprecatedUserInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedUserInvoices.
     */
    distinct?: DeprecatedUserInvoiceScalarFieldEnum | DeprecatedUserInvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice findFirstOrThrow
   */
  export type DeprecatedUserInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserInvoice to fetch.
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserInvoices to fetch.
     */
    orderBy?: DeprecatedUserInvoiceOrderByWithRelationInput | DeprecatedUserInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeprecatedUserInvoices.
     */
    cursor?: DeprecatedUserInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeprecatedUserInvoices.
     */
    distinct?: DeprecatedUserInvoiceScalarFieldEnum | DeprecatedUserInvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice findMany
   */
  export type DeprecatedUserInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter, which DeprecatedUserInvoices to fetch.
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeprecatedUserInvoices to fetch.
     */
    orderBy?: DeprecatedUserInvoiceOrderByWithRelationInput | DeprecatedUserInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeprecatedUserInvoices.
     */
    cursor?: DeprecatedUserInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeprecatedUserInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeprecatedUserInvoices.
     */
    skip?: number
    distinct?: DeprecatedUserInvoiceScalarFieldEnum | DeprecatedUserInvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice create
   */
  export type DeprecatedUserInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * The data needed to create a DeprecatedUserInvoice.
     */
    data: XOR<DeprecatedUserInvoiceCreateInput, DeprecatedUserInvoiceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice createMany
   */
  export type DeprecatedUserInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeprecatedUserInvoices.
     */
    data: DeprecatedUserInvoiceCreateManyInput | DeprecatedUserInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeprecatedUserInvoice createManyAndReturn
   */
  export type DeprecatedUserInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many DeprecatedUserInvoices.
     */
    data: DeprecatedUserInvoiceCreateManyInput | DeprecatedUserInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeprecatedUserInvoice update
   */
  export type DeprecatedUserInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * The data needed to update a DeprecatedUserInvoice.
     */
    data: XOR<DeprecatedUserInvoiceUpdateInput, DeprecatedUserInvoiceUncheckedUpdateInput>
    /**
     * Choose, which DeprecatedUserInvoice to update.
     */
    where: DeprecatedUserInvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice updateMany
   */
  export type DeprecatedUserInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeprecatedUserInvoices.
     */
    data: XOR<DeprecatedUserInvoiceUpdateManyMutationInput, DeprecatedUserInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedUserInvoices to update
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * Limit how many DeprecatedUserInvoices to update.
     */
    limit?: number
  }

  /**
   * DeprecatedUserInvoice updateManyAndReturn
   */
  export type DeprecatedUserInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update DeprecatedUserInvoices.
     */
    data: XOR<DeprecatedUserInvoiceUpdateManyMutationInput, DeprecatedUserInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which DeprecatedUserInvoices to update
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * Limit how many DeprecatedUserInvoices to update.
     */
    limit?: number
  }

  /**
   * DeprecatedUserInvoice upsert
   */
  export type DeprecatedUserInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * The filter to search for the DeprecatedUserInvoice to update in case it exists.
     */
    where: DeprecatedUserInvoiceWhereUniqueInput
    /**
     * In case the DeprecatedUserInvoice found by the `where` argument doesn't exist, create a new DeprecatedUserInvoice with this data.
     */
    create: XOR<DeprecatedUserInvoiceCreateInput, DeprecatedUserInvoiceUncheckedCreateInput>
    /**
     * In case the DeprecatedUserInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeprecatedUserInvoiceUpdateInput, DeprecatedUserInvoiceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice delete
   */
  export type DeprecatedUserInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
    /**
     * Filter which DeprecatedUserInvoice to delete.
     */
    where: DeprecatedUserInvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * DeprecatedUserInvoice deleteMany
   */
  export type DeprecatedUserInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeprecatedUserInvoices to delete
     */
    where?: DeprecatedUserInvoiceWhereInput
    /**
     * Limit how many DeprecatedUserInvoices to delete.
     */
    limit?: number
  }

  /**
   * DeprecatedUserInvoice without action
   */
  export type DeprecatedUserInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeprecatedUserInvoice
     */
    select?: DeprecatedUserInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeprecatedUserInvoice
     */
    omit?: DeprecatedUserInvoiceOmit<ExtArgs> | null
  }


  /**
   * Model UserStripeCustomer
   */

  export type AggregateUserStripeCustomer = {
    _count: UserStripeCustomerCountAggregateOutputType | null
    _min: UserStripeCustomerMinAggregateOutputType | null
    _max: UserStripeCustomerMaxAggregateOutputType | null
  }

  export type UserStripeCustomerMinAggregateOutputType = {
    userId: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
  }

  export type UserStripeCustomerMaxAggregateOutputType = {
    userId: string | null
    stripeCustomerId: string | null
    createdAt: Date | null
  }

  export type UserStripeCustomerCountAggregateOutputType = {
    userId: number
    stripeCustomerId: number
    createdAt: number
    _all: number
  }


  export type UserStripeCustomerMinAggregateInputType = {
    userId?: true
    stripeCustomerId?: true
    createdAt?: true
  }

  export type UserStripeCustomerMaxAggregateInputType = {
    userId?: true
    stripeCustomerId?: true
    createdAt?: true
  }

  export type UserStripeCustomerCountAggregateInputType = {
    userId?: true
    stripeCustomerId?: true
    createdAt?: true
    _all?: true
  }

  export type UserStripeCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStripeCustomer to aggregate.
     */
    where?: UserStripeCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStripeCustomers to fetch.
     */
    orderBy?: UserStripeCustomerOrderByWithRelationInput | UserStripeCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStripeCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStripeCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStripeCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStripeCustomers
    **/
    _count?: true | UserStripeCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStripeCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStripeCustomerMaxAggregateInputType
  }

  export type GetUserStripeCustomerAggregateType<T extends UserStripeCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStripeCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStripeCustomer[P]>
      : GetScalarType<T[P], AggregateUserStripeCustomer[P]>
  }




  export type UserStripeCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStripeCustomerWhereInput
    orderBy?: UserStripeCustomerOrderByWithAggregationInput | UserStripeCustomerOrderByWithAggregationInput[]
    by: UserStripeCustomerScalarFieldEnum[] | UserStripeCustomerScalarFieldEnum
    having?: UserStripeCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStripeCustomerCountAggregateInputType | true
    _min?: UserStripeCustomerMinAggregateInputType
    _max?: UserStripeCustomerMaxAggregateInputType
  }

  export type UserStripeCustomerGroupByOutputType = {
    userId: string
    stripeCustomerId: string
    createdAt: Date
    _count: UserStripeCustomerCountAggregateOutputType | null
    _min: UserStripeCustomerMinAggregateOutputType | null
    _max: UserStripeCustomerMaxAggregateOutputType | null
  }

  type GetUserStripeCustomerGroupByPayload<T extends UserStripeCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStripeCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStripeCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStripeCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], UserStripeCustomerGroupByOutputType[P]>
        }
      >
    >


  export type UserStripeCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStripeCustomer"]>

  export type UserStripeCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStripeCustomer"]>

  export type UserStripeCustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStripeCustomer"]>

  export type UserStripeCustomerSelectScalar = {
    userId?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
  }

  export type UserStripeCustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "stripeCustomerId" | "createdAt", ExtArgs["result"]["userStripeCustomer"]>
  export type UserStripeCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStripeCustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStripeCustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStripeCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStripeCustomer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      stripeCustomerId: string
      createdAt: Date
    }, ExtArgs["result"]["userStripeCustomer"]>
    composites: {}
  }

  type UserStripeCustomerGetPayload<S extends boolean | null | undefined | UserStripeCustomerDefaultArgs> = $Result.GetResult<Prisma.$UserStripeCustomerPayload, S>

  type UserStripeCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStripeCustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserStripeCustomerCountAggregateInputType | true
    }

  export interface UserStripeCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStripeCustomer'], meta: { name: 'UserStripeCustomer' } }
    /**
     * Find zero or one UserStripeCustomer that matches the filter.
     * @param {UserStripeCustomerFindUniqueArgs} args - Arguments to find a UserStripeCustomer
     * @example
     * // Get one UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStripeCustomerFindUniqueArgs>(args: SelectSubset<T, UserStripeCustomerFindUniqueArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStripeCustomer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStripeCustomerFindUniqueOrThrowArgs} args - Arguments to find a UserStripeCustomer
     * @example
     * // Get one UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStripeCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStripeCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStripeCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerFindFirstArgs} args - Arguments to find a UserStripeCustomer
     * @example
     * // Get one UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStripeCustomerFindFirstArgs>(args?: SelectSubset<T, UserStripeCustomerFindFirstArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStripeCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerFindFirstOrThrowArgs} args - Arguments to find a UserStripeCustomer
     * @example
     * // Get one UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStripeCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStripeCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStripeCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStripeCustomers
     * const userStripeCustomers = await prisma.userStripeCustomer.findMany()
     * 
     * // Get first 10 UserStripeCustomers
     * const userStripeCustomers = await prisma.userStripeCustomer.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userStripeCustomerWithUserIdOnly = await prisma.userStripeCustomer.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserStripeCustomerFindManyArgs>(args?: SelectSubset<T, UserStripeCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStripeCustomer.
     * @param {UserStripeCustomerCreateArgs} args - Arguments to create a UserStripeCustomer.
     * @example
     * // Create one UserStripeCustomer
     * const UserStripeCustomer = await prisma.userStripeCustomer.create({
     *   data: {
     *     // ... data to create a UserStripeCustomer
     *   }
     * })
     * 
     */
    create<T extends UserStripeCustomerCreateArgs>(args: SelectSubset<T, UserStripeCustomerCreateArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStripeCustomers.
     * @param {UserStripeCustomerCreateManyArgs} args - Arguments to create many UserStripeCustomers.
     * @example
     * // Create many UserStripeCustomers
     * const userStripeCustomer = await prisma.userStripeCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStripeCustomerCreateManyArgs>(args?: SelectSubset<T, UserStripeCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStripeCustomers and returns the data saved in the database.
     * @param {UserStripeCustomerCreateManyAndReturnArgs} args - Arguments to create many UserStripeCustomers.
     * @example
     * // Create many UserStripeCustomers
     * const userStripeCustomer = await prisma.userStripeCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStripeCustomers and only return the `userId`
     * const userStripeCustomerWithUserIdOnly = await prisma.userStripeCustomer.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStripeCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStripeCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStripeCustomer.
     * @param {UserStripeCustomerDeleteArgs} args - Arguments to delete one UserStripeCustomer.
     * @example
     * // Delete one UserStripeCustomer
     * const UserStripeCustomer = await prisma.userStripeCustomer.delete({
     *   where: {
     *     // ... filter to delete one UserStripeCustomer
     *   }
     * })
     * 
     */
    delete<T extends UserStripeCustomerDeleteArgs>(args: SelectSubset<T, UserStripeCustomerDeleteArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStripeCustomer.
     * @param {UserStripeCustomerUpdateArgs} args - Arguments to update one UserStripeCustomer.
     * @example
     * // Update one UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStripeCustomerUpdateArgs>(args: SelectSubset<T, UserStripeCustomerUpdateArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStripeCustomers.
     * @param {UserStripeCustomerDeleteManyArgs} args - Arguments to filter UserStripeCustomers to delete.
     * @example
     * // Delete a few UserStripeCustomers
     * const { count } = await prisma.userStripeCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStripeCustomerDeleteManyArgs>(args?: SelectSubset<T, UserStripeCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStripeCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStripeCustomers
     * const userStripeCustomer = await prisma.userStripeCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStripeCustomerUpdateManyArgs>(args: SelectSubset<T, UserStripeCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStripeCustomers and returns the data updated in the database.
     * @param {UserStripeCustomerUpdateManyAndReturnArgs} args - Arguments to update many UserStripeCustomers.
     * @example
     * // Update many UserStripeCustomers
     * const userStripeCustomer = await prisma.userStripeCustomer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStripeCustomers and only return the `userId`
     * const userStripeCustomerWithUserIdOnly = await prisma.userStripeCustomer.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStripeCustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStripeCustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStripeCustomer.
     * @param {UserStripeCustomerUpsertArgs} args - Arguments to update or create a UserStripeCustomer.
     * @example
     * // Update or create a UserStripeCustomer
     * const userStripeCustomer = await prisma.userStripeCustomer.upsert({
     *   create: {
     *     // ... data to create a UserStripeCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStripeCustomer we want to update
     *   }
     * })
     */
    upsert<T extends UserStripeCustomerUpsertArgs>(args: SelectSubset<T, UserStripeCustomerUpsertArgs<ExtArgs>>): Prisma__UserStripeCustomerClient<$Result.GetResult<Prisma.$UserStripeCustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStripeCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerCountArgs} args - Arguments to filter UserStripeCustomers to count.
     * @example
     * // Count the number of UserStripeCustomers
     * const count = await prisma.userStripeCustomer.count({
     *   where: {
     *     // ... the filter for the UserStripeCustomers we want to count
     *   }
     * })
    **/
    count<T extends UserStripeCustomerCountArgs>(
      args?: Subset<T, UserStripeCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStripeCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStripeCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStripeCustomerAggregateArgs>(args: Subset<T, UserStripeCustomerAggregateArgs>): Prisma.PrismaPromise<GetUserStripeCustomerAggregateType<T>>

    /**
     * Group by UserStripeCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStripeCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStripeCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStripeCustomerGroupByArgs['orderBy'] }
        : { orderBy?: UserStripeCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStripeCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStripeCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStripeCustomer model
   */
  readonly fields: UserStripeCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStripeCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStripeCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStripeCustomer model
   */
  interface UserStripeCustomerFieldRefs {
    readonly userId: FieldRef<"UserStripeCustomer", 'String'>
    readonly stripeCustomerId: FieldRef<"UserStripeCustomer", 'String'>
    readonly createdAt: FieldRef<"UserStripeCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStripeCustomer findUnique
   */
  export type UserStripeCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserStripeCustomer to fetch.
     */
    where: UserStripeCustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer findUniqueOrThrow
   */
  export type UserStripeCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserStripeCustomer to fetch.
     */
    where: UserStripeCustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer findFirst
   */
  export type UserStripeCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserStripeCustomer to fetch.
     */
    where?: UserStripeCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStripeCustomers to fetch.
     */
    orderBy?: UserStripeCustomerOrderByWithRelationInput | UserStripeCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStripeCustomers.
     */
    cursor?: UserStripeCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStripeCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStripeCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStripeCustomers.
     */
    distinct?: UserStripeCustomerScalarFieldEnum | UserStripeCustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer findFirstOrThrow
   */
  export type UserStripeCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserStripeCustomer to fetch.
     */
    where?: UserStripeCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStripeCustomers to fetch.
     */
    orderBy?: UserStripeCustomerOrderByWithRelationInput | UserStripeCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStripeCustomers.
     */
    cursor?: UserStripeCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStripeCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStripeCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStripeCustomers.
     */
    distinct?: UserStripeCustomerScalarFieldEnum | UserStripeCustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer findMany
   */
  export type UserStripeCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter, which UserStripeCustomers to fetch.
     */
    where?: UserStripeCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStripeCustomers to fetch.
     */
    orderBy?: UserStripeCustomerOrderByWithRelationInput | UserStripeCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStripeCustomers.
     */
    cursor?: UserStripeCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStripeCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStripeCustomers.
     */
    skip?: number
    distinct?: UserStripeCustomerScalarFieldEnum | UserStripeCustomerScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer create
   */
  export type UserStripeCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStripeCustomer.
     */
    data: XOR<UserStripeCustomerCreateInput, UserStripeCustomerUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer createMany
   */
  export type UserStripeCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStripeCustomers.
     */
    data: UserStripeCustomerCreateManyInput | UserStripeCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStripeCustomer createManyAndReturn
   */
  export type UserStripeCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * The data used to create many UserStripeCustomers.
     */
    data: UserStripeCustomerCreateManyInput | UserStripeCustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStripeCustomer update
   */
  export type UserStripeCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStripeCustomer.
     */
    data: XOR<UserStripeCustomerUpdateInput, UserStripeCustomerUncheckedUpdateInput>
    /**
     * Choose, which UserStripeCustomer to update.
     */
    where: UserStripeCustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer updateMany
   */
  export type UserStripeCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStripeCustomers.
     */
    data: XOR<UserStripeCustomerUpdateManyMutationInput, UserStripeCustomerUncheckedUpdateManyInput>
    /**
     * Filter which UserStripeCustomers to update
     */
    where?: UserStripeCustomerWhereInput
    /**
     * Limit how many UserStripeCustomers to update.
     */
    limit?: number
  }

  /**
   * UserStripeCustomer updateManyAndReturn
   */
  export type UserStripeCustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * The data used to update UserStripeCustomers.
     */
    data: XOR<UserStripeCustomerUpdateManyMutationInput, UserStripeCustomerUncheckedUpdateManyInput>
    /**
     * Filter which UserStripeCustomers to update
     */
    where?: UserStripeCustomerWhereInput
    /**
     * Limit how many UserStripeCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStripeCustomer upsert
   */
  export type UserStripeCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStripeCustomer to update in case it exists.
     */
    where: UserStripeCustomerWhereUniqueInput
    /**
     * In case the UserStripeCustomer found by the `where` argument doesn't exist, create a new UserStripeCustomer with this data.
     */
    create: XOR<UserStripeCustomerCreateInput, UserStripeCustomerUncheckedCreateInput>
    /**
     * In case the UserStripeCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStripeCustomerUpdateInput, UserStripeCustomerUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer delete
   */
  export type UserStripeCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
    /**
     * Filter which UserStripeCustomer to delete.
     */
    where: UserStripeCustomerWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserStripeCustomer deleteMany
   */
  export type UserStripeCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStripeCustomers to delete
     */
    where?: UserStripeCustomerWhereInput
    /**
     * Limit how many UserStripeCustomers to delete.
     */
    limit?: number
  }

  /**
   * UserStripeCustomer without action
   */
  export type UserStripeCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStripeCustomer
     */
    select?: UserStripeCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStripeCustomer
     */
    omit?: UserStripeCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStripeCustomerInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    quantity: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    targetId: string | null
    plan: string | null
    recurring: string | null
    variant: string | null
    quantity: number | null
    stripeSubscriptionId: string | null
    stripeScheduleId: string | null
    provider: $Enums.Provider | null
    iapStore: $Enums.IapStore | null
    rcEntitlement: string | null
    rcProductId: string | null
    rcExternalRef: string | null
    status: string | null
    start: Date | null
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    targetId: string | null
    plan: string | null
    recurring: string | null
    variant: string | null
    quantity: number | null
    stripeSubscriptionId: string | null
    stripeScheduleId: string | null
    provider: $Enums.Provider | null
    iapStore: $Enums.IapStore | null
    rcEntitlement: string | null
    rcProductId: string | null
    rcExternalRef: string | null
    status: string | null
    start: Date | null
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    targetId: number
    plan: number
    recurring: number
    variant: number
    quantity: number
    stripeSubscriptionId: number
    stripeScheduleId: number
    provider: number
    iapStore: number
    rcEntitlement: number
    rcProductId: number
    rcExternalRef: number
    status: number
    start: number
    end: number
    nextBillAt: number
    canceledAt: number
    trialStart: number
    trialEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    targetId?: true
    plan?: true
    recurring?: true
    variant?: true
    quantity?: true
    stripeSubscriptionId?: true
    stripeScheduleId?: true
    provider?: true
    iapStore?: true
    rcEntitlement?: true
    rcProductId?: true
    rcExternalRef?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    targetId?: true
    plan?: true
    recurring?: true
    variant?: true
    quantity?: true
    stripeSubscriptionId?: true
    stripeScheduleId?: true
    provider?: true
    iapStore?: true
    rcEntitlement?: true
    rcProductId?: true
    rcExternalRef?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    targetId?: true
    plan?: true
    recurring?: true
    variant?: true
    quantity?: true
    stripeSubscriptionId?: true
    stripeScheduleId?: true
    provider?: true
    iapStore?: true
    rcEntitlement?: true
    rcProductId?: true
    rcExternalRef?: true
    status?: true
    start?: true
    end?: true
    nextBillAt?: true
    canceledAt?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    targetId: string
    plan: string
    recurring: string
    variant: string | null
    quantity: number
    stripeSubscriptionId: string | null
    stripeScheduleId: string | null
    provider: $Enums.Provider
    iapStore: $Enums.IapStore | null
    rcEntitlement: string | null
    rcProductId: string | null
    rcExternalRef: string | null
    status: string
    start: Date
    end: Date | null
    nextBillAt: Date | null
    canceledAt: Date | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    quantity?: boolean
    stripeSubscriptionId?: boolean
    stripeScheduleId?: boolean
    provider?: boolean
    iapStore?: boolean
    rcEntitlement?: boolean
    rcProductId?: boolean
    rcExternalRef?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    quantity?: boolean
    stripeSubscriptionId?: boolean
    stripeScheduleId?: boolean
    provider?: boolean
    iapStore?: boolean
    rcEntitlement?: boolean
    rcProductId?: boolean
    rcExternalRef?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    quantity?: boolean
    stripeSubscriptionId?: boolean
    stripeScheduleId?: boolean
    provider?: boolean
    iapStore?: boolean
    rcEntitlement?: boolean
    rcProductId?: boolean
    rcExternalRef?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    targetId?: boolean
    plan?: boolean
    recurring?: boolean
    variant?: boolean
    quantity?: boolean
    stripeSubscriptionId?: boolean
    stripeScheduleId?: boolean
    provider?: boolean
    iapStore?: boolean
    rcEntitlement?: boolean
    rcProductId?: boolean
    rcExternalRef?: boolean
    status?: boolean
    start?: boolean
    end?: boolean
    nextBillAt?: boolean
    canceledAt?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "targetId" | "plan" | "recurring" | "variant" | "quantity" | "stripeSubscriptionId" | "stripeScheduleId" | "provider" | "iapStore" | "rcEntitlement" | "rcProductId" | "rcExternalRef" | "status" | "start" | "end" | "nextBillAt" | "canceledAt" | "trialStart" | "trialEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      targetId: string
      plan: string
      recurring: string
      variant: string | null
      quantity: number
      stripeSubscriptionId: string | null
      stripeScheduleId: string | null
      provider: $Enums.Provider
      iapStore: $Enums.IapStore | null
      rcEntitlement: string | null
      rcProductId: string | null
      rcExternalRef: string | null
      status: string
      start: Date
      end: Date | null
      nextBillAt: Date | null
      canceledAt: Date | null
      trialStart: Date | null
      trialEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly targetId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly recurring: FieldRef<"Subscription", 'String'>
    readonly variant: FieldRef<"Subscription", 'String'>
    readonly quantity: FieldRef<"Subscription", 'Int'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripeScheduleId: FieldRef<"Subscription", 'String'>
    readonly provider: FieldRef<"Subscription", 'Provider'>
    readonly iapStore: FieldRef<"Subscription", 'IapStore'>
    readonly rcEntitlement: FieldRef<"Subscription", 'String'>
    readonly rcProductId: FieldRef<"Subscription", 'String'>
    readonly rcExternalRef: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly start: FieldRef<"Subscription", 'DateTime'>
    readonly end: FieldRef<"Subscription", 'DateTime'>
    readonly nextBillAt: FieldRef<"Subscription", 'DateTime'>
    readonly canceledAt: FieldRef<"Subscription", 'DateTime'>
    readonly trialStart: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    stripeInvoiceId: string | null
    targetId: string | null
    currency: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    onetimeSubscriptionRedeemed: boolean | null
  }

  export type InvoiceMaxAggregateOutputType = {
    stripeInvoiceId: string | null
    targetId: string | null
    currency: string | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    onetimeSubscriptionRedeemed: boolean | null
  }

  export type InvoiceCountAggregateOutputType = {
    stripeInvoiceId: number
    targetId: number
    currency: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    reason: number
    lastPaymentError: number
    link: number
    onetimeSubscriptionRedeemed: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    stripeInvoiceId?: true
    targetId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    onetimeSubscriptionRedeemed?: true
  }

  export type InvoiceMaxAggregateInputType = {
    stripeInvoiceId?: true
    targetId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    onetimeSubscriptionRedeemed?: true
  }

  export type InvoiceCountAggregateInputType = {
    stripeInvoiceId?: true
    targetId?: true
    currency?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reason?: true
    lastPaymentError?: true
    link?: true
    onetimeSubscriptionRedeemed?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    stripeInvoiceId: string
    targetId: string
    currency: string
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    reason: string | null
    lastPaymentError: string | null
    link: string | null
    onetimeSubscriptionRedeemed: boolean
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stripeInvoiceId?: boolean
    targetId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    onetimeSubscriptionRedeemed?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stripeInvoiceId?: boolean
    targetId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    onetimeSubscriptionRedeemed?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stripeInvoiceId?: boolean
    targetId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    onetimeSubscriptionRedeemed?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    stripeInvoiceId?: boolean
    targetId?: boolean
    currency?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reason?: boolean
    lastPaymentError?: boolean
    link?: boolean
    onetimeSubscriptionRedeemed?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stripeInvoiceId" | "targetId" | "currency" | "amount" | "status" | "createdAt" | "updatedAt" | "reason" | "lastPaymentError" | "link" | "onetimeSubscriptionRedeemed", ExtArgs["result"]["invoice"]>

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      stripeInvoiceId: string
      targetId: string
      currency: string
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
      reason: string | null
      lastPaymentError: string | null
      link: string | null
      onetimeSubscriptionRedeemed: boolean
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `stripeInvoiceId`
     * const invoiceWithStripeInvoiceIdOnly = await prisma.invoice.findMany({ select: { stripeInvoiceId: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `stripeInvoiceId`
     * const invoiceWithStripeInvoiceIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { stripeInvoiceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `stripeInvoiceId`
     * const invoiceWithStripeInvoiceIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { stripeInvoiceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly targetId: FieldRef<"Invoice", 'String'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Int'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly reason: FieldRef<"Invoice", 'String'>
    readonly lastPaymentError: FieldRef<"Invoice", 'String'>
    readonly link: FieldRef<"Invoice", 'String'>
    readonly onetimeSubscriptionRedeemed: FieldRef<"Invoice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseMinAggregateOutputType = {
    key: string | null
    createdAt: Date | null
    revealedAt: Date | null
    installedAt: Date | null
    validateKey: string | null
  }

  export type LicenseMaxAggregateOutputType = {
    key: string | null
    createdAt: Date | null
    revealedAt: Date | null
    installedAt: Date | null
    validateKey: string | null
  }

  export type LicenseCountAggregateOutputType = {
    key: number
    createdAt: number
    revealedAt: number
    installedAt: number
    validateKey: number
    _all: number
  }


  export type LicenseMinAggregateInputType = {
    key?: true
    createdAt?: true
    revealedAt?: true
    installedAt?: true
    validateKey?: true
  }

  export type LicenseMaxAggregateInputType = {
    key?: true
    createdAt?: true
    revealedAt?: true
    installedAt?: true
    validateKey?: true
  }

  export type LicenseCountAggregateInputType = {
    key?: true
    createdAt?: true
    revealedAt?: true
    installedAt?: true
    validateKey?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    key: string
    createdAt: Date
    revealedAt: Date | null
    installedAt: Date | null
    validateKey: string | null
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    createdAt?: boolean
    revealedAt?: boolean
    installedAt?: boolean
    validateKey?: boolean
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    createdAt?: boolean
    revealedAt?: boolean
    installedAt?: boolean
    validateKey?: boolean
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    createdAt?: boolean
    revealedAt?: boolean
    installedAt?: boolean
    validateKey?: boolean
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectScalar = {
    key?: boolean
    createdAt?: boolean
    revealedAt?: boolean
    installedAt?: boolean
    validateKey?: boolean
  }

  export type LicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "createdAt" | "revealedAt" | "installedAt" | "validateKey", ExtArgs["result"]["license"]>

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      createdAt: Date
      revealedAt: Date | null
      installedAt: Date | null
      validateKey: string | null
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const licenseWithKeyOnly = await prisma.license.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenses and returns the data saved in the database.
     * @param {LicenseCreateManyAndReturnArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenses and only return the `key`
     * const licenseWithKeyOnly = await prisma.license.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses and returns the data updated in the database.
     * @param {LicenseUpdateManyAndReturnArgs} args - Arguments to update many Licenses.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Licenses and only return the `key`
     * const licenseWithKeyOnly = await prisma.license.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */
  interface LicenseFieldRefs {
    readonly key: FieldRef<"License", 'String'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
    readonly revealedAt: FieldRef<"License", 'DateTime'>
    readonly installedAt: FieldRef<"License", 'DateTime'>
    readonly validateKey: FieldRef<"License", 'String'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License createManyAndReturn
   */
  export type LicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License updateManyAndReturn
   */
  export type LicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to delete.
     */
    limit?: number
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
  }


  /**
   * Model InstalledLicense
   */

  export type AggregateInstalledLicense = {
    _count: InstalledLicenseCountAggregateOutputType | null
    _avg: InstalledLicenseAvgAggregateOutputType | null
    _sum: InstalledLicenseSumAggregateOutputType | null
    _min: InstalledLicenseMinAggregateOutputType | null
    _max: InstalledLicenseMaxAggregateOutputType | null
  }

  export type InstalledLicenseAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InstalledLicenseSumAggregateOutputType = {
    quantity: number | null
  }

  export type InstalledLicenseMinAggregateOutputType = {
    key: string | null
    workspaceId: string | null
    quantity: number | null
    recurring: string | null
    variant: string | null
    installedAt: Date | null
    validateKey: string | null
    validatedAt: Date | null
    expiredAt: Date | null
    license: Uint8Array | null
  }

  export type InstalledLicenseMaxAggregateOutputType = {
    key: string | null
    workspaceId: string | null
    quantity: number | null
    recurring: string | null
    variant: string | null
    installedAt: Date | null
    validateKey: string | null
    validatedAt: Date | null
    expiredAt: Date | null
    license: Uint8Array | null
  }

  export type InstalledLicenseCountAggregateOutputType = {
    key: number
    workspaceId: number
    quantity: number
    recurring: number
    variant: number
    installedAt: number
    validateKey: number
    validatedAt: number
    expiredAt: number
    license: number
    _all: number
  }


  export type InstalledLicenseAvgAggregateInputType = {
    quantity?: true
  }

  export type InstalledLicenseSumAggregateInputType = {
    quantity?: true
  }

  export type InstalledLicenseMinAggregateInputType = {
    key?: true
    workspaceId?: true
    quantity?: true
    recurring?: true
    variant?: true
    installedAt?: true
    validateKey?: true
    validatedAt?: true
    expiredAt?: true
    license?: true
  }

  export type InstalledLicenseMaxAggregateInputType = {
    key?: true
    workspaceId?: true
    quantity?: true
    recurring?: true
    variant?: true
    installedAt?: true
    validateKey?: true
    validatedAt?: true
    expiredAt?: true
    license?: true
  }

  export type InstalledLicenseCountAggregateInputType = {
    key?: true
    workspaceId?: true
    quantity?: true
    recurring?: true
    variant?: true
    installedAt?: true
    validateKey?: true
    validatedAt?: true
    expiredAt?: true
    license?: true
    _all?: true
  }

  export type InstalledLicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalledLicense to aggregate.
     */
    where?: InstalledLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledLicenses to fetch.
     */
    orderBy?: InstalledLicenseOrderByWithRelationInput | InstalledLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalledLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstalledLicenses
    **/
    _count?: true | InstalledLicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalledLicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalledLicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalledLicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalledLicenseMaxAggregateInputType
  }

  export type GetInstalledLicenseAggregateType<T extends InstalledLicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalledLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalledLicense[P]>
      : GetScalarType<T[P], AggregateInstalledLicense[P]>
  }




  export type InstalledLicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalledLicenseWhereInput
    orderBy?: InstalledLicenseOrderByWithAggregationInput | InstalledLicenseOrderByWithAggregationInput[]
    by: InstalledLicenseScalarFieldEnum[] | InstalledLicenseScalarFieldEnum
    having?: InstalledLicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalledLicenseCountAggregateInputType | true
    _avg?: InstalledLicenseAvgAggregateInputType
    _sum?: InstalledLicenseSumAggregateInputType
    _min?: InstalledLicenseMinAggregateInputType
    _max?: InstalledLicenseMaxAggregateInputType
  }

  export type InstalledLicenseGroupByOutputType = {
    key: string
    workspaceId: string
    quantity: number
    recurring: string
    variant: string | null
    installedAt: Date
    validateKey: string
    validatedAt: Date
    expiredAt: Date | null
    license: Uint8Array | null
    _count: InstalledLicenseCountAggregateOutputType | null
    _avg: InstalledLicenseAvgAggregateOutputType | null
    _sum: InstalledLicenseSumAggregateOutputType | null
    _min: InstalledLicenseMinAggregateOutputType | null
    _max: InstalledLicenseMaxAggregateOutputType | null
  }

  type GetInstalledLicenseGroupByPayload<T extends InstalledLicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalledLicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalledLicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalledLicenseGroupByOutputType[P]>
            : GetScalarType<T[P], InstalledLicenseGroupByOutputType[P]>
        }
      >
    >


  export type InstalledLicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    workspaceId?: boolean
    quantity?: boolean
    recurring?: boolean
    variant?: boolean
    installedAt?: boolean
    validateKey?: boolean
    validatedAt?: boolean
    expiredAt?: boolean
    license?: boolean
  }, ExtArgs["result"]["installedLicense"]>

  export type InstalledLicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    workspaceId?: boolean
    quantity?: boolean
    recurring?: boolean
    variant?: boolean
    installedAt?: boolean
    validateKey?: boolean
    validatedAt?: boolean
    expiredAt?: boolean
    license?: boolean
  }, ExtArgs["result"]["installedLicense"]>

  export type InstalledLicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    workspaceId?: boolean
    quantity?: boolean
    recurring?: boolean
    variant?: boolean
    installedAt?: boolean
    validateKey?: boolean
    validatedAt?: boolean
    expiredAt?: boolean
    license?: boolean
  }, ExtArgs["result"]["installedLicense"]>

  export type InstalledLicenseSelectScalar = {
    key?: boolean
    workspaceId?: boolean
    quantity?: boolean
    recurring?: boolean
    variant?: boolean
    installedAt?: boolean
    validateKey?: boolean
    validatedAt?: boolean
    expiredAt?: boolean
    license?: boolean
  }

  export type InstalledLicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "workspaceId" | "quantity" | "recurring" | "variant" | "installedAt" | "validateKey" | "validatedAt" | "expiredAt" | "license", ExtArgs["result"]["installedLicense"]>

  export type $InstalledLicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstalledLicense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      workspaceId: string
      quantity: number
      recurring: string
      variant: string | null
      installedAt: Date
      validateKey: string
      validatedAt: Date
      expiredAt: Date | null
      license: Uint8Array | null
    }, ExtArgs["result"]["installedLicense"]>
    composites: {}
  }

  type InstalledLicenseGetPayload<S extends boolean | null | undefined | InstalledLicenseDefaultArgs> = $Result.GetResult<Prisma.$InstalledLicensePayload, S>

  type InstalledLicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstalledLicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: InstalledLicenseCountAggregateInputType | true
    }

  export interface InstalledLicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstalledLicense'], meta: { name: 'InstalledLicense' } }
    /**
     * Find zero or one InstalledLicense that matches the filter.
     * @param {InstalledLicenseFindUniqueArgs} args - Arguments to find a InstalledLicense
     * @example
     * // Get one InstalledLicense
     * const installedLicense = await prisma.installedLicense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalledLicenseFindUniqueArgs>(args: SelectSubset<T, InstalledLicenseFindUniqueArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstalledLicense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstalledLicenseFindUniqueOrThrowArgs} args - Arguments to find a InstalledLicense
     * @example
     * // Get one InstalledLicense
     * const installedLicense = await prisma.installedLicense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalledLicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalledLicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalledLicense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseFindFirstArgs} args - Arguments to find a InstalledLicense
     * @example
     * // Get one InstalledLicense
     * const installedLicense = await prisma.installedLicense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalledLicenseFindFirstArgs>(args?: SelectSubset<T, InstalledLicenseFindFirstArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalledLicense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseFindFirstOrThrowArgs} args - Arguments to find a InstalledLicense
     * @example
     * // Get one InstalledLicense
     * const installedLicense = await prisma.installedLicense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalledLicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalledLicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstalledLicenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstalledLicenses
     * const installedLicenses = await prisma.installedLicense.findMany()
     * 
     * // Get first 10 InstalledLicenses
     * const installedLicenses = await prisma.installedLicense.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const installedLicenseWithKeyOnly = await prisma.installedLicense.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends InstalledLicenseFindManyArgs>(args?: SelectSubset<T, InstalledLicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstalledLicense.
     * @param {InstalledLicenseCreateArgs} args - Arguments to create a InstalledLicense.
     * @example
     * // Create one InstalledLicense
     * const InstalledLicense = await prisma.installedLicense.create({
     *   data: {
     *     // ... data to create a InstalledLicense
     *   }
     * })
     * 
     */
    create<T extends InstalledLicenseCreateArgs>(args: SelectSubset<T, InstalledLicenseCreateArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstalledLicenses.
     * @param {InstalledLicenseCreateManyArgs} args - Arguments to create many InstalledLicenses.
     * @example
     * // Create many InstalledLicenses
     * const installedLicense = await prisma.installedLicense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalledLicenseCreateManyArgs>(args?: SelectSubset<T, InstalledLicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstalledLicenses and returns the data saved in the database.
     * @param {InstalledLicenseCreateManyAndReturnArgs} args - Arguments to create many InstalledLicenses.
     * @example
     * // Create many InstalledLicenses
     * const installedLicense = await prisma.installedLicense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstalledLicenses and only return the `key`
     * const installedLicenseWithKeyOnly = await prisma.installedLicense.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalledLicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalledLicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstalledLicense.
     * @param {InstalledLicenseDeleteArgs} args - Arguments to delete one InstalledLicense.
     * @example
     * // Delete one InstalledLicense
     * const InstalledLicense = await prisma.installedLicense.delete({
     *   where: {
     *     // ... filter to delete one InstalledLicense
     *   }
     * })
     * 
     */
    delete<T extends InstalledLicenseDeleteArgs>(args: SelectSubset<T, InstalledLicenseDeleteArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstalledLicense.
     * @param {InstalledLicenseUpdateArgs} args - Arguments to update one InstalledLicense.
     * @example
     * // Update one InstalledLicense
     * const installedLicense = await prisma.installedLicense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalledLicenseUpdateArgs>(args: SelectSubset<T, InstalledLicenseUpdateArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstalledLicenses.
     * @param {InstalledLicenseDeleteManyArgs} args - Arguments to filter InstalledLicenses to delete.
     * @example
     * // Delete a few InstalledLicenses
     * const { count } = await prisma.installedLicense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalledLicenseDeleteManyArgs>(args?: SelectSubset<T, InstalledLicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalledLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstalledLicenses
     * const installedLicense = await prisma.installedLicense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalledLicenseUpdateManyArgs>(args: SelectSubset<T, InstalledLicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalledLicenses and returns the data updated in the database.
     * @param {InstalledLicenseUpdateManyAndReturnArgs} args - Arguments to update many InstalledLicenses.
     * @example
     * // Update many InstalledLicenses
     * const installedLicense = await prisma.installedLicense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstalledLicenses and only return the `key`
     * const installedLicenseWithKeyOnly = await prisma.installedLicense.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstalledLicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, InstalledLicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstalledLicense.
     * @param {InstalledLicenseUpsertArgs} args - Arguments to update or create a InstalledLicense.
     * @example
     * // Update or create a InstalledLicense
     * const installedLicense = await prisma.installedLicense.upsert({
     *   create: {
     *     // ... data to create a InstalledLicense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstalledLicense we want to update
     *   }
     * })
     */
    upsert<T extends InstalledLicenseUpsertArgs>(args: SelectSubset<T, InstalledLicenseUpsertArgs<ExtArgs>>): Prisma__InstalledLicenseClient<$Result.GetResult<Prisma.$InstalledLicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstalledLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseCountArgs} args - Arguments to filter InstalledLicenses to count.
     * @example
     * // Count the number of InstalledLicenses
     * const count = await prisma.installedLicense.count({
     *   where: {
     *     // ... the filter for the InstalledLicenses we want to count
     *   }
     * })
    **/
    count<T extends InstalledLicenseCountArgs>(
      args?: Subset<T, InstalledLicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalledLicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstalledLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalledLicenseAggregateArgs>(args: Subset<T, InstalledLicenseAggregateArgs>): Prisma.PrismaPromise<GetInstalledLicenseAggregateType<T>>

    /**
     * Group by InstalledLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalledLicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalledLicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalledLicenseGroupByArgs['orderBy'] }
        : { orderBy?: InstalledLicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalledLicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalledLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstalledLicense model
   */
  readonly fields: InstalledLicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstalledLicense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalledLicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstalledLicense model
   */
  interface InstalledLicenseFieldRefs {
    readonly key: FieldRef<"InstalledLicense", 'String'>
    readonly workspaceId: FieldRef<"InstalledLicense", 'String'>
    readonly quantity: FieldRef<"InstalledLicense", 'Int'>
    readonly recurring: FieldRef<"InstalledLicense", 'String'>
    readonly variant: FieldRef<"InstalledLicense", 'String'>
    readonly installedAt: FieldRef<"InstalledLicense", 'DateTime'>
    readonly validateKey: FieldRef<"InstalledLicense", 'String'>
    readonly validatedAt: FieldRef<"InstalledLicense", 'DateTime'>
    readonly expiredAt: FieldRef<"InstalledLicense", 'DateTime'>
    readonly license: FieldRef<"InstalledLicense", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * InstalledLicense findUnique
   */
  export type InstalledLicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter, which InstalledLicense to fetch.
     */
    where: InstalledLicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense findUniqueOrThrow
   */
  export type InstalledLicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter, which InstalledLicense to fetch.
     */
    where: InstalledLicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense findFirst
   */
  export type InstalledLicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter, which InstalledLicense to fetch.
     */
    where?: InstalledLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledLicenses to fetch.
     */
    orderBy?: InstalledLicenseOrderByWithRelationInput | InstalledLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalledLicenses.
     */
    cursor?: InstalledLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalledLicenses.
     */
    distinct?: InstalledLicenseScalarFieldEnum | InstalledLicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense findFirstOrThrow
   */
  export type InstalledLicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter, which InstalledLicense to fetch.
     */
    where?: InstalledLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledLicenses to fetch.
     */
    orderBy?: InstalledLicenseOrderByWithRelationInput | InstalledLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalledLicenses.
     */
    cursor?: InstalledLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalledLicenses.
     */
    distinct?: InstalledLicenseScalarFieldEnum | InstalledLicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense findMany
   */
  export type InstalledLicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter, which InstalledLicenses to fetch.
     */
    where?: InstalledLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalledLicenses to fetch.
     */
    orderBy?: InstalledLicenseOrderByWithRelationInput | InstalledLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstalledLicenses.
     */
    cursor?: InstalledLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalledLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalledLicenses.
     */
    skip?: number
    distinct?: InstalledLicenseScalarFieldEnum | InstalledLicenseScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense create
   */
  export type InstalledLicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * The data needed to create a InstalledLicense.
     */
    data: XOR<InstalledLicenseCreateInput, InstalledLicenseUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense createMany
   */
  export type InstalledLicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstalledLicenses.
     */
    data: InstalledLicenseCreateManyInput | InstalledLicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstalledLicense createManyAndReturn
   */
  export type InstalledLicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * The data used to create many InstalledLicenses.
     */
    data: InstalledLicenseCreateManyInput | InstalledLicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstalledLicense update
   */
  export type InstalledLicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * The data needed to update a InstalledLicense.
     */
    data: XOR<InstalledLicenseUpdateInput, InstalledLicenseUncheckedUpdateInput>
    /**
     * Choose, which InstalledLicense to update.
     */
    where: InstalledLicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense updateMany
   */
  export type InstalledLicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstalledLicenses.
     */
    data: XOR<InstalledLicenseUpdateManyMutationInput, InstalledLicenseUncheckedUpdateManyInput>
    /**
     * Filter which InstalledLicenses to update
     */
    where?: InstalledLicenseWhereInput
    /**
     * Limit how many InstalledLicenses to update.
     */
    limit?: number
  }

  /**
   * InstalledLicense updateManyAndReturn
   */
  export type InstalledLicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * The data used to update InstalledLicenses.
     */
    data: XOR<InstalledLicenseUpdateManyMutationInput, InstalledLicenseUncheckedUpdateManyInput>
    /**
     * Filter which InstalledLicenses to update
     */
    where?: InstalledLicenseWhereInput
    /**
     * Limit how many InstalledLicenses to update.
     */
    limit?: number
  }

  /**
   * InstalledLicense upsert
   */
  export type InstalledLicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * The filter to search for the InstalledLicense to update in case it exists.
     */
    where: InstalledLicenseWhereUniqueInput
    /**
     * In case the InstalledLicense found by the `where` argument doesn't exist, create a new InstalledLicense with this data.
     */
    create: XOR<InstalledLicenseCreateInput, InstalledLicenseUncheckedCreateInput>
    /**
     * In case the InstalledLicense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalledLicenseUpdateInput, InstalledLicenseUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense delete
   */
  export type InstalledLicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
    /**
     * Filter which InstalledLicense to delete.
     */
    where: InstalledLicenseWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * InstalledLicense deleteMany
   */
  export type InstalledLicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalledLicenses to delete
     */
    where?: InstalledLicenseWhereInput
    /**
     * Limit how many InstalledLicenses to delete.
     */
    limit?: number
  }

  /**
   * InstalledLicense without action
   */
  export type InstalledLicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalledLicense
     */
    select?: InstalledLicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalledLicense
     */
    omit?: InstalledLicenseOmit<ExtArgs> | null
  }


  /**
   * Model Blob
   */

  export type AggregateBlob = {
    _count: BlobCountAggregateOutputType | null
    _avg: BlobAvgAggregateOutputType | null
    _sum: BlobSumAggregateOutputType | null
    _min: BlobMinAggregateOutputType | null
    _max: BlobMaxAggregateOutputType | null
  }

  export type BlobAvgAggregateOutputType = {
    size: number | null
  }

  export type BlobSumAggregateOutputType = {
    size: number | null
  }

  export type BlobMinAggregateOutputType = {
    workspaceId: string | null
    key: string | null
    size: number | null
    mime: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type BlobMaxAggregateOutputType = {
    workspaceId: string | null
    key: string | null
    size: number | null
    mime: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type BlobCountAggregateOutputType = {
    workspaceId: number
    key: number
    size: number
    mime: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type BlobAvgAggregateInputType = {
    size?: true
  }

  export type BlobSumAggregateInputType = {
    size?: true
  }

  export type BlobMinAggregateInputType = {
    workspaceId?: true
    key?: true
    size?: true
    mime?: true
    createdAt?: true
    deletedAt?: true
  }

  export type BlobMaxAggregateInputType = {
    workspaceId?: true
    key?: true
    size?: true
    mime?: true
    createdAt?: true
    deletedAt?: true
  }

  export type BlobCountAggregateInputType = {
    workspaceId?: true
    key?: true
    size?: true
    mime?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BlobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blob to aggregate.
     */
    where?: BlobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blobs to fetch.
     */
    orderBy?: BlobOrderByWithRelationInput | BlobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blobs
    **/
    _count?: true | BlobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlobMaxAggregateInputType
  }

  export type GetBlobAggregateType<T extends BlobAggregateArgs> = {
        [P in keyof T & keyof AggregateBlob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlob[P]>
      : GetScalarType<T[P], AggregateBlob[P]>
  }




  export type BlobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlobWhereInput
    orderBy?: BlobOrderByWithAggregationInput | BlobOrderByWithAggregationInput[]
    by: BlobScalarFieldEnum[] | BlobScalarFieldEnum
    having?: BlobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlobCountAggregateInputType | true
    _avg?: BlobAvgAggregateInputType
    _sum?: BlobSumAggregateInputType
    _min?: BlobMinAggregateInputType
    _max?: BlobMaxAggregateInputType
  }

  export type BlobGroupByOutputType = {
    workspaceId: string
    key: string
    size: number
    mime: string
    createdAt: Date
    deletedAt: Date | null
    _count: BlobCountAggregateOutputType | null
    _avg: BlobAvgAggregateOutputType | null
    _sum: BlobSumAggregateOutputType | null
    _min: BlobMinAggregateOutputType | null
    _max: BlobMaxAggregateOutputType | null
  }

  type GetBlobGroupByPayload<T extends BlobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlobGroupByOutputType[P]>
            : GetScalarType<T[P], BlobGroupByOutputType[P]>
        }
      >
    >


  export type BlobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    AiWorkspaceBlobEmbedding?: boolean | Blob$AiWorkspaceBlobEmbeddingArgs<ExtArgs>
    _count?: boolean | BlobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blob"]>

  export type BlobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blob"]>

  export type BlobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workspaceId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blob"]>

  export type BlobSelectScalar = {
    workspaceId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type BlobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workspaceId" | "key" | "size" | "mime" | "createdAt" | "deletedAt", ExtArgs["result"]["blob"]>
  export type BlobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    AiWorkspaceBlobEmbedding?: boolean | Blob$AiWorkspaceBlobEmbeddingArgs<ExtArgs>
    _count?: boolean | BlobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type BlobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $BlobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blob"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      AiWorkspaceBlobEmbedding: Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      workspaceId: string
      key: string
      size: number
      mime: string
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["blob"]>
    composites: {}
  }

  type BlobGetPayload<S extends boolean | null | undefined | BlobDefaultArgs> = $Result.GetResult<Prisma.$BlobPayload, S>

  type BlobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: BlobCountAggregateInputType | true
    }

  export interface BlobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blob'], meta: { name: 'Blob' } }
    /**
     * Find zero or one Blob that matches the filter.
     * @param {BlobFindUniqueArgs} args - Arguments to find a Blob
     * @example
     * // Get one Blob
     * const blob = await prisma.blob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlobFindUniqueArgs>(args: SelectSubset<T, BlobFindUniqueArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlobFindUniqueOrThrowArgs} args - Arguments to find a Blob
     * @example
     * // Get one Blob
     * const blob = await prisma.blob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlobFindUniqueOrThrowArgs>(args: SelectSubset<T, BlobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobFindFirstArgs} args - Arguments to find a Blob
     * @example
     * // Get one Blob
     * const blob = await prisma.blob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlobFindFirstArgs>(args?: SelectSubset<T, BlobFindFirstArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobFindFirstOrThrowArgs} args - Arguments to find a Blob
     * @example
     * // Get one Blob
     * const blob = await prisma.blob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlobFindFirstOrThrowArgs>(args?: SelectSubset<T, BlobFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blobs
     * const blobs = await prisma.blob.findMany()
     * 
     * // Get first 10 Blobs
     * const blobs = await prisma.blob.findMany({ take: 10 })
     * 
     * // Only select the `workspaceId`
     * const blobWithWorkspaceIdOnly = await prisma.blob.findMany({ select: { workspaceId: true } })
     * 
     */
    findMany<T extends BlobFindManyArgs>(args?: SelectSubset<T, BlobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blob.
     * @param {BlobCreateArgs} args - Arguments to create a Blob.
     * @example
     * // Create one Blob
     * const Blob = await prisma.blob.create({
     *   data: {
     *     // ... data to create a Blob
     *   }
     * })
     * 
     */
    create<T extends BlobCreateArgs>(args: SelectSubset<T, BlobCreateArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blobs.
     * @param {BlobCreateManyArgs} args - Arguments to create many Blobs.
     * @example
     * // Create many Blobs
     * const blob = await prisma.blob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlobCreateManyArgs>(args?: SelectSubset<T, BlobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blobs and returns the data saved in the database.
     * @param {BlobCreateManyAndReturnArgs} args - Arguments to create many Blobs.
     * @example
     * // Create many Blobs
     * const blob = await prisma.blob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blobs and only return the `workspaceId`
     * const blobWithWorkspaceIdOnly = await prisma.blob.createManyAndReturn({
     *   select: { workspaceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlobCreateManyAndReturnArgs>(args?: SelectSubset<T, BlobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blob.
     * @param {BlobDeleteArgs} args - Arguments to delete one Blob.
     * @example
     * // Delete one Blob
     * const Blob = await prisma.blob.delete({
     *   where: {
     *     // ... filter to delete one Blob
     *   }
     * })
     * 
     */
    delete<T extends BlobDeleteArgs>(args: SelectSubset<T, BlobDeleteArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blob.
     * @param {BlobUpdateArgs} args - Arguments to update one Blob.
     * @example
     * // Update one Blob
     * const blob = await prisma.blob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlobUpdateArgs>(args: SelectSubset<T, BlobUpdateArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blobs.
     * @param {BlobDeleteManyArgs} args - Arguments to filter Blobs to delete.
     * @example
     * // Delete a few Blobs
     * const { count } = await prisma.blob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlobDeleteManyArgs>(args?: SelectSubset<T, BlobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blobs
     * const blob = await prisma.blob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlobUpdateManyArgs>(args: SelectSubset<T, BlobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blobs and returns the data updated in the database.
     * @param {BlobUpdateManyAndReturnArgs} args - Arguments to update many Blobs.
     * @example
     * // Update many Blobs
     * const blob = await prisma.blob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blobs and only return the `workspaceId`
     * const blobWithWorkspaceIdOnly = await prisma.blob.updateManyAndReturn({
     *   select: { workspaceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlobUpdateManyAndReturnArgs>(args: SelectSubset<T, BlobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blob.
     * @param {BlobUpsertArgs} args - Arguments to update or create a Blob.
     * @example
     * // Update or create a Blob
     * const blob = await prisma.blob.upsert({
     *   create: {
     *     // ... data to create a Blob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blob we want to update
     *   }
     * })
     */
    upsert<T extends BlobUpsertArgs>(args: SelectSubset<T, BlobUpsertArgs<ExtArgs>>): Prisma__BlobClient<$Result.GetResult<Prisma.$BlobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobCountArgs} args - Arguments to filter Blobs to count.
     * @example
     * // Count the number of Blobs
     * const count = await prisma.blob.count({
     *   where: {
     *     // ... the filter for the Blobs we want to count
     *   }
     * })
    **/
    count<T extends BlobCountArgs>(
      args?: Subset<T, BlobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlobAggregateArgs>(args: Subset<T, BlobAggregateArgs>): Prisma.PrismaPromise<GetBlobAggregateType<T>>

    /**
     * Group by Blob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlobGroupByArgs['orderBy'] }
        : { orderBy?: BlobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blob model
   */
  readonly fields: BlobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AiWorkspaceBlobEmbedding<T extends Blob$AiWorkspaceBlobEmbeddingArgs<ExtArgs> = {}>(args?: Subset<T, Blob$AiWorkspaceBlobEmbeddingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiWorkspaceBlobEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blob model
   */
  interface BlobFieldRefs {
    readonly workspaceId: FieldRef<"Blob", 'String'>
    readonly key: FieldRef<"Blob", 'String'>
    readonly size: FieldRef<"Blob", 'Int'>
    readonly mime: FieldRef<"Blob", 'String'>
    readonly createdAt: FieldRef<"Blob", 'DateTime'>
    readonly deletedAt: FieldRef<"Blob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blob findUnique
   */
  export type BlobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter, which Blob to fetch.
     */
    where: BlobWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob findUniqueOrThrow
   */
  export type BlobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter, which Blob to fetch.
     */
    where: BlobWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob findFirst
   */
  export type BlobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter, which Blob to fetch.
     */
    where?: BlobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blobs to fetch.
     */
    orderBy?: BlobOrderByWithRelationInput | BlobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blobs.
     */
    cursor?: BlobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blobs.
     */
    distinct?: BlobScalarFieldEnum | BlobScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob findFirstOrThrow
   */
  export type BlobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter, which Blob to fetch.
     */
    where?: BlobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blobs to fetch.
     */
    orderBy?: BlobOrderByWithRelationInput | BlobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blobs.
     */
    cursor?: BlobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blobs.
     */
    distinct?: BlobScalarFieldEnum | BlobScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob findMany
   */
  export type BlobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter, which Blobs to fetch.
     */
    where?: BlobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blobs to fetch.
     */
    orderBy?: BlobOrderByWithRelationInput | BlobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blobs.
     */
    cursor?: BlobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blobs.
     */
    skip?: number
    distinct?: BlobScalarFieldEnum | BlobScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob create
   */
  export type BlobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * The data needed to create a Blob.
     */
    data: XOR<BlobCreateInput, BlobUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob createMany
   */
  export type BlobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blobs.
     */
    data: BlobCreateManyInput | BlobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blob createManyAndReturn
   */
  export type BlobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * The data used to create many Blobs.
     */
    data: BlobCreateManyInput | BlobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blob update
   */
  export type BlobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * The data needed to update a Blob.
     */
    data: XOR<BlobUpdateInput, BlobUncheckedUpdateInput>
    /**
     * Choose, which Blob to update.
     */
    where: BlobWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob updateMany
   */
  export type BlobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blobs.
     */
    data: XOR<BlobUpdateManyMutationInput, BlobUncheckedUpdateManyInput>
    /**
     * Filter which Blobs to update
     */
    where?: BlobWhereInput
    /**
     * Limit how many Blobs to update.
     */
    limit?: number
  }

  /**
   * Blob updateManyAndReturn
   */
  export type BlobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * The data used to update Blobs.
     */
    data: XOR<BlobUpdateManyMutationInput, BlobUncheckedUpdateManyInput>
    /**
     * Filter which Blobs to update
     */
    where?: BlobWhereInput
    /**
     * Limit how many Blobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blob upsert
   */
  export type BlobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * The filter to search for the Blob to update in case it exists.
     */
    where: BlobWhereUniqueInput
    /**
     * In case the Blob found by the `where` argument doesn't exist, create a new Blob with this data.
     */
    create: XOR<BlobCreateInput, BlobUncheckedCreateInput>
    /**
     * In case the Blob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlobUpdateInput, BlobUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob delete
   */
  export type BlobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
    /**
     * Filter which Blob to delete.
     */
    where: BlobWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Blob deleteMany
   */
  export type BlobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blobs to delete
     */
    where?: BlobWhereInput
    /**
     * Limit how many Blobs to delete.
     */
    limit?: number
  }

  /**
   * Blob.AiWorkspaceBlobEmbedding
   */
  export type Blob$AiWorkspaceBlobEmbeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiWorkspaceBlobEmbedding
     */
    select?: AiWorkspaceBlobEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AiWorkspaceBlobEmbedding
     */
    omit?: AiWorkspaceBlobEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiWorkspaceBlobEmbeddingInclude<ExtArgs> | null
    where?: AiWorkspaceBlobEmbeddingWhereInput
    orderBy?: AiWorkspaceBlobEmbeddingOrderByWithRelationInput | AiWorkspaceBlobEmbeddingOrderByWithRelationInput[]
    cursor?: AiWorkspaceBlobEmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiWorkspaceBlobEmbeddingScalarFieldEnum | AiWorkspaceBlobEmbeddingScalarFieldEnum[]
  }

  /**
   * Blob without action
   */
  export type BlobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blob
     */
    select?: BlobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blob
     */
    omit?: BlobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlobInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    level: $Enums.NotificationLevel | null
    read: boolean | null
    type: $Enums.NotificationType | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    level: $Enums.NotificationLevel | null
    read: boolean | null
    type: $Enums.NotificationType | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    level: number
    read: number
    type: number
    body: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    read?: true
    type?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    read?: true
    type?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    read?: true
    type?: true
    body?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    level: $Enums.NotificationLevel
    read: boolean
    type: $Enums.NotificationType
    body: JsonValue
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    read?: boolean
    type?: boolean
    body?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    read?: boolean
    type?: boolean
    body?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    read?: boolean
    type?: boolean
    body?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    read?: boolean
    type?: boolean
    body?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt" | "level" | "read" | "type" | "body", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
      level: $Enums.NotificationLevel
      read: boolean
      type: $Enums.NotificationType
      body: Prisma.JsonValue
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly level: FieldRef<"Notification", 'NotificationLevel'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly body: FieldRef<"Notification", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    userId: number
    createdAt: number
    updatedAt: number
    payload: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    userId?: true
    createdAt?: true
    updatedAt?: true
    payload?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    userId: string
    createdAt: Date
    updatedAt: Date
    payload: JsonValue
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payload?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payload?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "createdAt" | "updatedAt" | "payload", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      createdAt: Date
      updatedAt: Date
      payload: Prisma.JsonValue
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `userId`
     * const userSettingsWithUserIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
    readonly payload: FieldRef<"UserSettings", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    sid: number | null
  }

  export type CommentSumAggregateOutputType = {
    sid: number | null
  }

  export type CommentMinAggregateOutputType = {
    sid: number | null
    id: string | null
    workspaceId: string | null
    docId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    resolved: boolean | null
  }

  export type CommentMaxAggregateOutputType = {
    sid: number | null
    id: string | null
    workspaceId: string | null
    docId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    resolved: boolean | null
  }

  export type CommentCountAggregateOutputType = {
    sid: number
    id: number
    workspaceId: number
    docId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    resolved: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    sid?: true
  }

  export type CommentSumAggregateInputType = {
    sid?: true
  }

  export type CommentMinAggregateInputType = {
    sid?: true
    id?: true
    workspaceId?: true
    docId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    resolved?: true
  }

  export type CommentMaxAggregateInputType = {
    sid?: true
    id?: true
    workspaceId?: true
    docId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    resolved?: true
  }

  export type CommentCountAggregateInputType = {
    sid?: true
    id?: true
    workspaceId?: true
    docId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    resolved?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    sid: number
    id: string
    workspaceId: string
    docId: string
    userId: string
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    resolved: boolean
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resolved?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resolved?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resolved?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    sid?: boolean
    id?: boolean
    workspaceId?: boolean
    docId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    resolved?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sid" | "id" | "workspaceId" | "docId" | "userId" | "content" | "createdAt" | "updatedAt" | "deletedAt" | "resolved", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      replies: Prisma.$ReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sid: number
      id: string
      workspaceId: string
      docId: string
      userId: string
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      resolved: boolean
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const commentWithSidOnly = await prisma.comment.findMany({ select: { sid: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `sid`
     * const commentWithSidOnly = await prisma.comment.createManyAndReturn({
     *   select: { sid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `sid`
     * const commentWithSidOnly = await prisma.comment.updateManyAndReturn({
     *   select: { sid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly sid: FieldRef<"Comment", 'Int'>
    readonly id: FieldRef<"Comment", 'String'>
    readonly workspaceId: FieldRef<"Comment", 'String'>
    readonly docId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'Json'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly deletedAt: FieldRef<"Comment", 'DateTime'>
    readonly resolved: FieldRef<"Comment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    cursor?: ReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Reply
   */

  export type AggregateReply = {
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  export type ReplyAvgAggregateOutputType = {
    sid: number | null
  }

  export type ReplySumAggregateOutputType = {
    sid: number | null
  }

  export type ReplyMinAggregateOutputType = {
    sid: number | null
    id: string | null
    userId: string | null
    commentId: string | null
    workspaceId: string | null
    docId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReplyMaxAggregateOutputType = {
    sid: number | null
    id: string | null
    userId: string | null
    commentId: string | null
    workspaceId: string | null
    docId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReplyCountAggregateOutputType = {
    sid: number
    id: number
    userId: number
    commentId: number
    workspaceId: number
    docId: number
    content: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ReplyAvgAggregateInputType = {
    sid?: true
  }

  export type ReplySumAggregateInputType = {
    sid?: true
  }

  export type ReplyMinAggregateInputType = {
    sid?: true
    id?: true
    userId?: true
    commentId?: true
    workspaceId?: true
    docId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReplyMaxAggregateInputType = {
    sid?: true
    id?: true
    userId?: true
    commentId?: true
    workspaceId?: true
    docId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReplyCountAggregateInputType = {
    sid?: true
    id?: true
    userId?: true
    commentId?: true
    workspaceId?: true
    docId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reply to aggregate.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Replies
    **/
    _count?: true | ReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReplyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReplySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReplyMaxAggregateInputType
  }

  export type GetReplyAggregateType<T extends ReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReply[P]>
      : GetScalarType<T[P], AggregateReply[P]>
  }




  export type ReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyWhereInput
    orderBy?: ReplyOrderByWithAggregationInput | ReplyOrderByWithAggregationInput[]
    by: ReplyScalarFieldEnum[] | ReplyScalarFieldEnum
    having?: ReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReplyCountAggregateInputType | true
    _avg?: ReplyAvgAggregateInputType
    _sum?: ReplySumAggregateInputType
    _min?: ReplyMinAggregateInputType
    _max?: ReplyMaxAggregateInputType
  }

  export type ReplyGroupByOutputType = {
    sid: number
    id: string
    userId: string
    commentId: string
    workspaceId: string
    docId: string
    content: JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ReplyCountAggregateOutputType | null
    _avg: ReplyAvgAggregateOutputType | null
    _sum: ReplySumAggregateOutputType | null
    _min: ReplyMinAggregateOutputType | null
    _max: ReplyMaxAggregateOutputType | null
  }

  type GetReplyGroupByPayload<T extends ReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    userId?: boolean
    commentId?: boolean
    workspaceId?: boolean
    docId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reply"]>

  export type ReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    userId?: boolean
    commentId?: boolean
    workspaceId?: boolean
    docId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reply"]>

  export type ReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    id?: boolean
    userId?: boolean
    commentId?: boolean
    workspaceId?: boolean
    docId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reply"]>

  export type ReplySelectScalar = {
    sid?: boolean
    id?: boolean
    userId?: boolean
    commentId?: boolean
    workspaceId?: boolean
    docId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sid" | "id" | "userId" | "commentId" | "workspaceId" | "docId" | "content" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["reply"]>
  export type ReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $ReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reply"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sid: number
      id: string
      userId: string
      commentId: string
      workspaceId: string
      docId: string
      content: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["reply"]>
    composites: {}
  }

  type ReplyGetPayload<S extends boolean | null | undefined | ReplyDefaultArgs> = $Result.GetResult<Prisma.$ReplyPayload, S>

  type ReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ReplyCountAggregateInputType | true
    }

  export interface ReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reply'], meta: { name: 'Reply' } }
    /**
     * Find zero or one Reply that matches the filter.
     * @param {ReplyFindUniqueArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReplyFindUniqueArgs>(args: SelectSubset<T, ReplyFindUniqueArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReplyFindUniqueOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReplyFindFirstArgs>(args?: SelectSubset<T, ReplyFindFirstArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindFirstOrThrowArgs} args - Arguments to find a Reply
     * @example
     * // Get one Reply
     * const reply = await prisma.reply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Replies
     * const replies = await prisma.reply.findMany()
     * 
     * // Get first 10 Replies
     * const replies = await prisma.reply.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const replyWithSidOnly = await prisma.reply.findMany({ select: { sid: true } })
     * 
     */
    findMany<T extends ReplyFindManyArgs>(args?: SelectSubset<T, ReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reply.
     * @param {ReplyCreateArgs} args - Arguments to create a Reply.
     * @example
     * // Create one Reply
     * const Reply = await prisma.reply.create({
     *   data: {
     *     // ... data to create a Reply
     *   }
     * })
     * 
     */
    create<T extends ReplyCreateArgs>(args: SelectSubset<T, ReplyCreateArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Replies.
     * @param {ReplyCreateManyArgs} args - Arguments to create many Replies.
     * @example
     * // Create many Replies
     * const reply = await prisma.reply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReplyCreateManyArgs>(args?: SelectSubset<T, ReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Replies and returns the data saved in the database.
     * @param {ReplyCreateManyAndReturnArgs} args - Arguments to create many Replies.
     * @example
     * // Create many Replies
     * const reply = await prisma.reply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Replies and only return the `sid`
     * const replyWithSidOnly = await prisma.reply.createManyAndReturn({
     *   select: { sid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, ReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reply.
     * @param {ReplyDeleteArgs} args - Arguments to delete one Reply.
     * @example
     * // Delete one Reply
     * const Reply = await prisma.reply.delete({
     *   where: {
     *     // ... filter to delete one Reply
     *   }
     * })
     * 
     */
    delete<T extends ReplyDeleteArgs>(args: SelectSubset<T, ReplyDeleteArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reply.
     * @param {ReplyUpdateArgs} args - Arguments to update one Reply.
     * @example
     * // Update one Reply
     * const reply = await prisma.reply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReplyUpdateArgs>(args: SelectSubset<T, ReplyUpdateArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Replies.
     * @param {ReplyDeleteManyArgs} args - Arguments to filter Replies to delete.
     * @example
     * // Delete a few Replies
     * const { count } = await prisma.reply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReplyDeleteManyArgs>(args?: SelectSubset<T, ReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Replies
     * const reply = await prisma.reply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReplyUpdateManyArgs>(args: SelectSubset<T, ReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Replies and returns the data updated in the database.
     * @param {ReplyUpdateManyAndReturnArgs} args - Arguments to update many Replies.
     * @example
     * // Update many Replies
     * const reply = await prisma.reply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Replies and only return the `sid`
     * const replyWithSidOnly = await prisma.reply.updateManyAndReturn({
     *   select: { sid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, ReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reply.
     * @param {ReplyUpsertArgs} args - Arguments to update or create a Reply.
     * @example
     * // Update or create a Reply
     * const reply = await prisma.reply.upsert({
     *   create: {
     *     // ... data to create a Reply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reply we want to update
     *   }
     * })
     */
    upsert<T extends ReplyUpsertArgs>(args: SelectSubset<T, ReplyUpsertArgs<ExtArgs>>): Prisma__ReplyClient<$Result.GetResult<Prisma.$ReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCountArgs} args - Arguments to filter Replies to count.
     * @example
     * // Count the number of Replies
     * const count = await prisma.reply.count({
     *   where: {
     *     // ... the filter for the Replies we want to count
     *   }
     * })
    **/
    count<T extends ReplyCountArgs>(
      args?: Subset<T, ReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReplyAggregateArgs>(args: Subset<T, ReplyAggregateArgs>): Prisma.PrismaPromise<GetReplyAggregateType<T>>

    /**
     * Group by Reply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reply model
   */
  readonly fields: ReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reply model
   */
  interface ReplyFieldRefs {
    readonly sid: FieldRef<"Reply", 'Int'>
    readonly id: FieldRef<"Reply", 'String'>
    readonly userId: FieldRef<"Reply", 'String'>
    readonly commentId: FieldRef<"Reply", 'String'>
    readonly workspaceId: FieldRef<"Reply", 'String'>
    readonly docId: FieldRef<"Reply", 'String'>
    readonly content: FieldRef<"Reply", 'Json'>
    readonly createdAt: FieldRef<"Reply", 'DateTime'>
    readonly updatedAt: FieldRef<"Reply", 'DateTime'>
    readonly deletedAt: FieldRef<"Reply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reply findUnique
   */
  export type ReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply findUniqueOrThrow
   */
  export type ReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where: ReplyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply findFirst
   */
  export type ReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply findFirstOrThrow
   */
  export type ReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Reply to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Replies.
     */
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply findMany
   */
  export type ReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter, which Replies to fetch.
     */
    where?: ReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Replies to fetch.
     */
    orderBy?: ReplyOrderByWithRelationInput | ReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Replies.
     */
    cursor?: ReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Replies.
     */
    skip?: number
    distinct?: ReplyScalarFieldEnum | ReplyScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply create
   */
  export type ReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a Reply.
     */
    data: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply createMany
   */
  export type ReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Replies.
     */
    data: ReplyCreateManyInput | ReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reply createManyAndReturn
   */
  export type ReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * The data used to create many Replies.
     */
    data: ReplyCreateManyInput | ReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reply update
   */
  export type ReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a Reply.
     */
    data: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
    /**
     * Choose, which Reply to update.
     */
    where: ReplyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply updateMany
   */
  export type ReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Replies.
     */
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyInput>
    /**
     * Filter which Replies to update
     */
    where?: ReplyWhereInput
    /**
     * Limit how many Replies to update.
     */
    limit?: number
  }

  /**
   * Reply updateManyAndReturn
   */
  export type ReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * The data used to update Replies.
     */
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyInput>
    /**
     * Filter which Replies to update
     */
    where?: ReplyWhereInput
    /**
     * Limit how many Replies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reply upsert
   */
  export type ReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the Reply to update in case it exists.
     */
    where: ReplyWhereUniqueInput
    /**
     * In case the Reply found by the `where` argument doesn't exist, create a new Reply with this data.
     */
    create: XOR<ReplyCreateInput, ReplyUncheckedCreateInput>
    /**
     * In case the Reply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReplyUpdateInput, ReplyUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply delete
   */
  export type ReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
    /**
     * Filter which Reply to delete.
     */
    where: ReplyWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Reply deleteMany
   */
  export type ReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Replies to delete
     */
    where?: ReplyWhereInput
    /**
     * Limit how many Replies to delete.
     */
    limit?: number
  }

  /**
   * Reply without action
   */
  export type ReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reply
     */
    select?: ReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reply
     */
    omit?: ReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyInclude<ExtArgs> | null
  }


  /**
   * Model CommentAttachment
   */

  export type AggregateCommentAttachment = {
    _count: CommentAttachmentCountAggregateOutputType | null
    _avg: CommentAttachmentAvgAggregateOutputType | null
    _sum: CommentAttachmentSumAggregateOutputType | null
    _min: CommentAttachmentMinAggregateOutputType | null
    _max: CommentAttachmentMaxAggregateOutputType | null
  }

  export type CommentAttachmentAvgAggregateOutputType = {
    sid: number | null
    size: number | null
  }

  export type CommentAttachmentSumAggregateOutputType = {
    sid: number | null
    size: number | null
  }

  export type CommentAttachmentMinAggregateOutputType = {
    sid: number | null
    workspaceId: string | null
    docId: string | null
    key: string | null
    size: number | null
    mime: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type CommentAttachmentMaxAggregateOutputType = {
    sid: number | null
    workspaceId: string | null
    docId: string | null
    key: string | null
    size: number | null
    mime: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type CommentAttachmentCountAggregateOutputType = {
    sid: number
    workspaceId: number
    docId: number
    key: number
    size: number
    mime: number
    name: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type CommentAttachmentAvgAggregateInputType = {
    sid?: true
    size?: true
  }

  export type CommentAttachmentSumAggregateInputType = {
    sid?: true
    size?: true
  }

  export type CommentAttachmentMinAggregateInputType = {
    sid?: true
    workspaceId?: true
    docId?: true
    key?: true
    size?: true
    mime?: true
    name?: true
    createdAt?: true
    createdBy?: true
  }

  export type CommentAttachmentMaxAggregateInputType = {
    sid?: true
    workspaceId?: true
    docId?: true
    key?: true
    size?: true
    mime?: true
    name?: true
    createdAt?: true
    createdBy?: true
  }

  export type CommentAttachmentCountAggregateInputType = {
    sid?: true
    workspaceId?: true
    docId?: true
    key?: true
    size?: true
    mime?: true
    name?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type CommentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentAttachment to aggregate.
     */
    where?: CommentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentAttachments to fetch.
     */
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentAttachments
    **/
    _count?: true | CommentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentAttachmentMaxAggregateInputType
  }

  export type GetCommentAttachmentAggregateType<T extends CommentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentAttachment[P]>
      : GetScalarType<T[P], AggregateCommentAttachment[P]>
  }




  export type CommentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentAttachmentWhereInput
    orderBy?: CommentAttachmentOrderByWithAggregationInput | CommentAttachmentOrderByWithAggregationInput[]
    by: CommentAttachmentScalarFieldEnum[] | CommentAttachmentScalarFieldEnum
    having?: CommentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentAttachmentCountAggregateInputType | true
    _avg?: CommentAttachmentAvgAggregateInputType
    _sum?: CommentAttachmentSumAggregateInputType
    _min?: CommentAttachmentMinAggregateInputType
    _max?: CommentAttachmentMaxAggregateInputType
  }

  export type CommentAttachmentGroupByOutputType = {
    sid: number
    workspaceId: string
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt: Date
    createdBy: string | null
    _count: CommentAttachmentCountAggregateOutputType | null
    _avg: CommentAttachmentAvgAggregateOutputType | null
    _sum: CommentAttachmentSumAggregateOutputType | null
    _min: CommentAttachmentMinAggregateOutputType | null
    _max: CommentAttachmentMaxAggregateOutputType | null
  }

  type GetCommentAttachmentGroupByPayload<T extends CommentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type CommentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    workspaceId?: boolean
    docId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["commentAttachment"]>

  export type CommentAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    workspaceId?: boolean
    docId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["commentAttachment"]>

  export type CommentAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    workspaceId?: boolean
    docId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["commentAttachment"]>

  export type CommentAttachmentSelectScalar = {
    sid?: boolean
    workspaceId?: boolean
    docId?: boolean
    key?: boolean
    size?: boolean
    mime?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type CommentAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sid" | "workspaceId" | "docId" | "key" | "size" | "mime" | "name" | "createdAt" | "createdBy", ExtArgs["result"]["commentAttachment"]>
  export type CommentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }
  export type CommentAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }
  export type CommentAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    createdByUser?: boolean | CommentAttachment$createdByUserArgs<ExtArgs>
  }

  export type $CommentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentAttachment"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sid: number
      workspaceId: string
      docId: string
      key: string
      size: number
      mime: string
      name: string
      createdAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["commentAttachment"]>
    composites: {}
  }

  type CommentAttachmentGetPayload<S extends boolean | null | undefined | CommentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$CommentAttachmentPayload, S>

  type CommentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: CommentAttachmentCountAggregateInputType | true
    }

  export interface CommentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentAttachment'], meta: { name: 'CommentAttachment' } }
    /**
     * Find zero or one CommentAttachment that matches the filter.
     * @param {CommentAttachmentFindUniqueArgs} args - Arguments to find a CommentAttachment
     * @example
     * // Get one CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentAttachmentFindUniqueArgs>(args: SelectSubset<T, CommentAttachmentFindUniqueArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a CommentAttachment
     * @example
     * // Get one CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentFindFirstArgs} args - Arguments to find a CommentAttachment
     * @example
     * // Get one CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentAttachmentFindFirstArgs>(args?: SelectSubset<T, CommentAttachmentFindFirstArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentFindFirstOrThrowArgs} args - Arguments to find a CommentAttachment
     * @example
     * // Get one CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentAttachments
     * const commentAttachments = await prisma.commentAttachment.findMany()
     * 
     * // Get first 10 CommentAttachments
     * const commentAttachments = await prisma.commentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const commentAttachmentWithSidOnly = await prisma.commentAttachment.findMany({ select: { sid: true } })
     * 
     */
    findMany<T extends CommentAttachmentFindManyArgs>(args?: SelectSubset<T, CommentAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentAttachment.
     * @param {CommentAttachmentCreateArgs} args - Arguments to create a CommentAttachment.
     * @example
     * // Create one CommentAttachment
     * const CommentAttachment = await prisma.commentAttachment.create({
     *   data: {
     *     // ... data to create a CommentAttachment
     *   }
     * })
     * 
     */
    create<T extends CommentAttachmentCreateArgs>(args: SelectSubset<T, CommentAttachmentCreateArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentAttachments.
     * @param {CommentAttachmentCreateManyArgs} args - Arguments to create many CommentAttachments.
     * @example
     * // Create many CommentAttachments
     * const commentAttachment = await prisma.commentAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentAttachmentCreateManyArgs>(args?: SelectSubset<T, CommentAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentAttachments and returns the data saved in the database.
     * @param {CommentAttachmentCreateManyAndReturnArgs} args - Arguments to create many CommentAttachments.
     * @example
     * // Create many CommentAttachments
     * const commentAttachment = await prisma.commentAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentAttachments and only return the `sid`
     * const commentAttachmentWithSidOnly = await prisma.commentAttachment.createManyAndReturn({
     *   select: { sid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentAttachment.
     * @param {CommentAttachmentDeleteArgs} args - Arguments to delete one CommentAttachment.
     * @example
     * // Delete one CommentAttachment
     * const CommentAttachment = await prisma.commentAttachment.delete({
     *   where: {
     *     // ... filter to delete one CommentAttachment
     *   }
     * })
     * 
     */
    delete<T extends CommentAttachmentDeleteArgs>(args: SelectSubset<T, CommentAttachmentDeleteArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentAttachment.
     * @param {CommentAttachmentUpdateArgs} args - Arguments to update one CommentAttachment.
     * @example
     * // Update one CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentAttachmentUpdateArgs>(args: SelectSubset<T, CommentAttachmentUpdateArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentAttachments.
     * @param {CommentAttachmentDeleteManyArgs} args - Arguments to filter CommentAttachments to delete.
     * @example
     * // Delete a few CommentAttachments
     * const { count } = await prisma.commentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentAttachmentDeleteManyArgs>(args?: SelectSubset<T, CommentAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentAttachments
     * const commentAttachment = await prisma.commentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentAttachmentUpdateManyArgs>(args: SelectSubset<T, CommentAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentAttachments and returns the data updated in the database.
     * @param {CommentAttachmentUpdateManyAndReturnArgs} args - Arguments to update many CommentAttachments.
     * @example
     * // Update many CommentAttachments
     * const commentAttachment = await prisma.commentAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentAttachments and only return the `sid`
     * const commentAttachmentWithSidOnly = await prisma.commentAttachment.updateManyAndReturn({
     *   select: { sid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentAttachment.
     * @param {CommentAttachmentUpsertArgs} args - Arguments to update or create a CommentAttachment.
     * @example
     * // Update or create a CommentAttachment
     * const commentAttachment = await prisma.commentAttachment.upsert({
     *   create: {
     *     // ... data to create a CommentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentAttachment we want to update
     *   }
     * })
     */
    upsert<T extends CommentAttachmentUpsertArgs>(args: SelectSubset<T, CommentAttachmentUpsertArgs<ExtArgs>>): Prisma__CommentAttachmentClient<$Result.GetResult<Prisma.$CommentAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentCountArgs} args - Arguments to filter CommentAttachments to count.
     * @example
     * // Count the number of CommentAttachments
     * const count = await prisma.commentAttachment.count({
     *   where: {
     *     // ... the filter for the CommentAttachments we want to count
     *   }
     * })
    **/
    count<T extends CommentAttachmentCountArgs>(
      args?: Subset<T, CommentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAttachmentAggregateArgs>(args: Subset<T, CommentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetCommentAttachmentAggregateType<T>>

    /**
     * Group by CommentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: CommentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentAttachment model
   */
  readonly fields: CommentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdByUser<T extends CommentAttachment$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, CommentAttachment$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentAttachment model
   */
  interface CommentAttachmentFieldRefs {
    readonly sid: FieldRef<"CommentAttachment", 'Int'>
    readonly workspaceId: FieldRef<"CommentAttachment", 'String'>
    readonly docId: FieldRef<"CommentAttachment", 'String'>
    readonly key: FieldRef<"CommentAttachment", 'String'>
    readonly size: FieldRef<"CommentAttachment", 'Int'>
    readonly mime: FieldRef<"CommentAttachment", 'String'>
    readonly name: FieldRef<"CommentAttachment", 'String'>
    readonly createdAt: FieldRef<"CommentAttachment", 'DateTime'>
    readonly createdBy: FieldRef<"CommentAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommentAttachment findUnique
   */
  export type CommentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentAttachment to fetch.
     */
    where: CommentAttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment findUniqueOrThrow
   */
  export type CommentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentAttachment to fetch.
     */
    where: CommentAttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment findFirst
   */
  export type CommentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentAttachment to fetch.
     */
    where?: CommentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentAttachments to fetch.
     */
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentAttachments.
     */
    cursor?: CommentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentAttachments.
     */
    distinct?: CommentAttachmentScalarFieldEnum | CommentAttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment findFirstOrThrow
   */
  export type CommentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentAttachment to fetch.
     */
    where?: CommentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentAttachments to fetch.
     */
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentAttachments.
     */
    cursor?: CommentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentAttachments.
     */
    distinct?: CommentAttachmentScalarFieldEnum | CommentAttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment findMany
   */
  export type CommentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which CommentAttachments to fetch.
     */
    where?: CommentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentAttachments to fetch.
     */
    orderBy?: CommentAttachmentOrderByWithRelationInput | CommentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentAttachments.
     */
    cursor?: CommentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentAttachments.
     */
    skip?: number
    distinct?: CommentAttachmentScalarFieldEnum | CommentAttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment create
   */
  export type CommentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentAttachment.
     */
    data: XOR<CommentAttachmentCreateInput, CommentAttachmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment createMany
   */
  export type CommentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentAttachments.
     */
    data: CommentAttachmentCreateManyInput | CommentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentAttachment createManyAndReturn
   */
  export type CommentAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many CommentAttachments.
     */
    data: CommentAttachmentCreateManyInput | CommentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentAttachment update
   */
  export type CommentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentAttachment.
     */
    data: XOR<CommentAttachmentUpdateInput, CommentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which CommentAttachment to update.
     */
    where: CommentAttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment updateMany
   */
  export type CommentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentAttachments.
     */
    data: XOR<CommentAttachmentUpdateManyMutationInput, CommentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which CommentAttachments to update
     */
    where?: CommentAttachmentWhereInput
    /**
     * Limit how many CommentAttachments to update.
     */
    limit?: number
  }

  /**
   * CommentAttachment updateManyAndReturn
   */
  export type CommentAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update CommentAttachments.
     */
    data: XOR<CommentAttachmentUpdateManyMutationInput, CommentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which CommentAttachments to update
     */
    where?: CommentAttachmentWhereInput
    /**
     * Limit how many CommentAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentAttachment upsert
   */
  export type CommentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentAttachment to update in case it exists.
     */
    where: CommentAttachmentWhereUniqueInput
    /**
     * In case the CommentAttachment found by the `where` argument doesn't exist, create a new CommentAttachment with this data.
     */
    create: XOR<CommentAttachmentCreateInput, CommentAttachmentUncheckedCreateInput>
    /**
     * In case the CommentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentAttachmentUpdateInput, CommentAttachmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment delete
   */
  export type CommentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which CommentAttachment to delete.
     */
    where: CommentAttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * CommentAttachment deleteMany
   */
  export type CommentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentAttachments to delete
     */
    where?: CommentAttachmentWhereInput
    /**
     * Limit how many CommentAttachments to delete.
     */
    limit?: number
  }

  /**
   * CommentAttachment.createdByUser
   */
  export type CommentAttachment$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CommentAttachment without action
   */
  export type CommentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAttachment
     */
    select?: CommentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAttachment
     */
    omit?: CommentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model AccessToken
   */

  export type AggregateAccessToken = {
    _count: AccessTokenCountAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  export type AccessTokenMinAggregateOutputType = {
    id: string | null
    name: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AccessTokenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type AccessTokenCountAggregateOutputType = {
    id: number
    name: number
    token: number
    userId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type AccessTokenMinAggregateInputType = {
    id?: true
    name?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AccessTokenMaxAggregateInputType = {
    id?: true
    name?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type AccessTokenCountAggregateInputType = {
    id?: true
    name?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type AccessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessToken to aggregate.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessTokens
    **/
    _count?: true | AccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessTokenMaxAggregateInputType
  }

  export type GetAccessTokenAggregateType<T extends AccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessToken[P]>
      : GetScalarType<T[P], AggregateAccessToken[P]>
  }




  export type AccessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithAggregationInput | AccessTokenOrderByWithAggregationInput[]
    by: AccessTokenScalarFieldEnum[] | AccessTokenScalarFieldEnum
    having?: AccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessTokenCountAggregateInputType | true
    _min?: AccessTokenMinAggregateInputType
    _max?: AccessTokenMaxAggregateInputType
  }

  export type AccessTokenGroupByOutputType = {
    id: string
    name: string
    token: string
    userId: string
    createdAt: Date
    expiresAt: Date | null
    _count: AccessTokenCountAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  type GetAccessTokenGroupByPayload<T extends AccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type AccessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectScalar = {
    id?: boolean
    name?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type AccessTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "token" | "userId" | "createdAt" | "expiresAt", ExtArgs["result"]["accessToken"]>
  export type AccessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccessTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccessTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      token: string
      userId: string
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["accessToken"]>
    composites: {}
  }

  type AccessTokenGetPayload<S extends boolean | null | undefined | AccessTokenDefaultArgs> = $Result.GetResult<Prisma.$AccessTokenPayload, S>

  type AccessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AccessTokenCountAggregateInputType | true
    }

  export interface AccessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessToken'], meta: { name: 'AccessToken' } }
    /**
     * Find zero or one AccessToken that matches the filter.
     * @param {AccessTokenFindUniqueArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessTokenFindUniqueArgs>(args: SelectSubset<T, AccessTokenFindUniqueArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessTokenFindUniqueOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessTokenFindFirstArgs>(args?: SelectSubset<T, AccessTokenFindFirstArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessTokens
     * const accessTokens = await prisma.accessToken.findMany()
     * 
     * // Get first 10 AccessTokens
     * const accessTokens = await prisma.accessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessTokenFindManyArgs>(args?: SelectSubset<T, AccessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessToken.
     * @param {AccessTokenCreateArgs} args - Arguments to create a AccessToken.
     * @example
     * // Create one AccessToken
     * const AccessToken = await prisma.accessToken.create({
     *   data: {
     *     // ... data to create a AccessToken
     *   }
     * })
     * 
     */
    create<T extends AccessTokenCreateArgs>(args: SelectSubset<T, AccessTokenCreateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessTokens.
     * @param {AccessTokenCreateManyArgs} args - Arguments to create many AccessTokens.
     * @example
     * // Create many AccessTokens
     * const accessToken = await prisma.accessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessTokenCreateManyArgs>(args?: SelectSubset<T, AccessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessTokens and returns the data saved in the database.
     * @param {AccessTokenCreateManyAndReturnArgs} args - Arguments to create many AccessTokens.
     * @example
     * // Create many AccessTokens
     * const accessToken = await prisma.accessToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessTokens and only return the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessToken.
     * @param {AccessTokenDeleteArgs} args - Arguments to delete one AccessToken.
     * @example
     * // Delete one AccessToken
     * const AccessToken = await prisma.accessToken.delete({
     *   where: {
     *     // ... filter to delete one AccessToken
     *   }
     * })
     * 
     */
    delete<T extends AccessTokenDeleteArgs>(args: SelectSubset<T, AccessTokenDeleteArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessToken.
     * @param {AccessTokenUpdateArgs} args - Arguments to update one AccessToken.
     * @example
     * // Update one AccessToken
     * const accessToken = await prisma.accessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessTokenUpdateArgs>(args: SelectSubset<T, AccessTokenUpdateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessTokens.
     * @param {AccessTokenDeleteManyArgs} args - Arguments to filter AccessTokens to delete.
     * @example
     * // Delete a few AccessTokens
     * const { count } = await prisma.accessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessTokenDeleteManyArgs>(args?: SelectSubset<T, AccessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessTokens
     * const accessToken = await prisma.accessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessTokenUpdateManyArgs>(args: SelectSubset<T, AccessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessTokens and returns the data updated in the database.
     * @param {AccessTokenUpdateManyAndReturnArgs} args - Arguments to update many AccessTokens.
     * @example
     * // Update many AccessTokens
     * const accessToken = await prisma.accessToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessTokens and only return the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessToken.
     * @param {AccessTokenUpsertArgs} args - Arguments to update or create a AccessToken.
     * @example
     * // Update or create a AccessToken
     * const accessToken = await prisma.accessToken.upsert({
     *   create: {
     *     // ... data to create a AccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessToken we want to update
     *   }
     * })
     */
    upsert<T extends AccessTokenUpsertArgs>(args: SelectSubset<T, AccessTokenUpsertArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenCountArgs} args - Arguments to filter AccessTokens to count.
     * @example
     * // Count the number of AccessTokens
     * const count = await prisma.accessToken.count({
     *   where: {
     *     // ... the filter for the AccessTokens we want to count
     *   }
     * })
    **/
    count<T extends AccessTokenCountArgs>(
      args?: Subset<T, AccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessTokenAggregateArgs>(args: Subset<T, AccessTokenAggregateArgs>): Prisma.PrismaPromise<GetAccessTokenAggregateType<T>>

    /**
     * Group by AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: AccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessToken model
   */
  readonly fields: AccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessToken model
   */
  interface AccessTokenFieldRefs {
    readonly id: FieldRef<"AccessToken", 'String'>
    readonly name: FieldRef<"AccessToken", 'String'>
    readonly token: FieldRef<"AccessToken", 'String'>
    readonly userId: FieldRef<"AccessToken", 'String'>
    readonly createdAt: FieldRef<"AccessToken", 'DateTime'>
    readonly expiresAt: FieldRef<"AccessToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessToken findUnique
   */
  export type AccessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken findUniqueOrThrow
   */
  export type AccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken findFirst
   */
  export type AccessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken findFirstOrThrow
   */
  export type AccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken findMany
   */
  export type AccessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessTokens to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken create
   */
  export type AccessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessToken.
     */
    data: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken createMany
   */
  export type AccessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessTokens.
     */
    data: AccessTokenCreateManyInput | AccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessToken createManyAndReturn
   */
  export type AccessTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * The data used to create many AccessTokens.
     */
    data: AccessTokenCreateManyInput | AccessTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessToken update
   */
  export type AccessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessToken.
     */
    data: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
    /**
     * Choose, which AccessToken to update.
     */
    where: AccessTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken updateMany
   */
  export type AccessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessTokens.
     */
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccessTokens to update
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to update.
     */
    limit?: number
  }

  /**
   * AccessToken updateManyAndReturn
   */
  export type AccessTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * The data used to update AccessTokens.
     */
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccessTokens to update
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessToken upsert
   */
  export type AccessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessToken to update in case it exists.
     */
    where: AccessTokenWhereUniqueInput
    /**
     * In case the AccessToken found by the `where` argument doesn't exist, create a new AccessToken with this data.
     */
    create: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
    /**
     * In case the AccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken delete
   */
  export type AccessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter which AccessToken to delete.
     */
    where: AccessTokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AccessToken deleteMany
   */
  export type AccessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessTokens to delete
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to delete.
     */
    limit?: number
  }

  /**
   * AccessToken without action
   */
  export type AccessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerifiedAt: 'emailVerifiedAt',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    password: 'password',
    registered: 'registered',
    disabled: 'disabled'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const ConnectedAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    scope: 'scope',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConnectedAccountScalarFieldEnum = (typeof ConnectedAccountScalarFieldEnum)[keyof typeof ConnectedAccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    deprecated_expiresAt: 'deprecated_expiresAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    token: 'token',
    type: 'type',
    credential: 'credential',
    expiresAt: 'expiresAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    sid: 'sid',
    id: 'id',
    public: 'public',
    createdAt: 'createdAt',
    enableAi: 'enableAi',
    enableUrlPreview: 'enableUrlPreview',
    enableDocEmbedding: 'enableDocEmbedding',
    name: 'name',
    avatarKey: 'avatarKey',
    indexed: 'indexed',
    lastCheckEmbeddings: 'lastCheckEmbeddings'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceDocScalarFieldEnum: {
    workspaceId: 'workspaceId',
    docId: 'docId',
    public: 'public',
    defaultRole: 'defaultRole',
    mode: 'mode',
    blocked: 'blocked',
    title: 'title',
    summary: 'summary'
  };

  export type WorkspaceDocScalarFieldEnum = (typeof WorkspaceDocScalarFieldEnum)[keyof typeof WorkspaceDocScalarFieldEnum]


  export const WorkspaceUserRoleScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    type: 'type',
    status: 'status',
    source: 'source',
    inviterId: 'inviterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accepted: 'accepted'
  };

  export type WorkspaceUserRoleScalarFieldEnum = (typeof WorkspaceUserRoleScalarFieldEnum)[keyof typeof WorkspaceUserRoleScalarFieldEnum]


  export const WorkspaceDocUserRoleScalarFieldEnum: {
    workspaceId: 'workspaceId',
    docId: 'docId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type WorkspaceDocUserRoleScalarFieldEnum = (typeof WorkspaceDocUserRoleScalarFieldEnum)[keyof typeof WorkspaceDocUserRoleScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    configs: 'configs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deprecatedVersion: 'deprecatedVersion',
    deprecatedType: 'deprecatedType'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const UserFeatureScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    featureId: 'featureId',
    name: 'name',
    type: 'type',
    reason: 'reason',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    activated: 'activated'
  };

  export type UserFeatureScalarFieldEnum = (typeof UserFeatureScalarFieldEnum)[keyof typeof UserFeatureScalarFieldEnum]


  export const WorkspaceFeatureScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    featureId: 'featureId',
    name: 'name',
    type: 'type',
    configs: 'configs',
    reason: 'reason',
    createdAt: 'createdAt',
    activated: 'activated',
    expiredAt: 'expiredAt'
  };

  export type WorkspaceFeatureScalarFieldEnum = (typeof WorkspaceFeatureScalarFieldEnum)[keyof typeof WorkspaceFeatureScalarFieldEnum]


  export const SnapshotScalarFieldEnum: {
    workspaceId: 'workspaceId',
    id: 'id',
    blob: 'blob',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    seq: 'seq'
  };

  export type SnapshotScalarFieldEnum = (typeof SnapshotScalarFieldEnum)[keyof typeof SnapshotScalarFieldEnum]


  export const UserSnapshotScalarFieldEnum: {
    userId: 'userId',
    id: 'id',
    blob: 'blob',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSnapshotScalarFieldEnum = (typeof UserSnapshotScalarFieldEnum)[keyof typeof UserSnapshotScalarFieldEnum]


  export const UpdateScalarFieldEnum: {
    workspaceId: 'workspaceId',
    id: 'id',
    blob: 'blob',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    seq: 'seq'
  };

  export type UpdateScalarFieldEnum = (typeof UpdateScalarFieldEnum)[keyof typeof UpdateScalarFieldEnum]


  export const SnapshotHistoryScalarFieldEnum: {
    workspaceId: 'workspaceId',
    id: 'id',
    timestamp: 'timestamp',
    blob: 'blob',
    state: 'state',
    expiredAt: 'expiredAt',
    createdBy: 'createdBy'
  };

  export type SnapshotHistoryScalarFieldEnum = (typeof SnapshotHistoryScalarFieldEnum)[keyof typeof SnapshotHistoryScalarFieldEnum]


  export const AiPromptMessageScalarFieldEnum: {
    promptId: 'promptId',
    idx: 'idx',
    role: 'role',
    content: 'content',
    attachments: 'attachments',
    params: 'params',
    createdAt: 'createdAt'
  };

  export type AiPromptMessageScalarFieldEnum = (typeof AiPromptMessageScalarFieldEnum)[keyof typeof AiPromptMessageScalarFieldEnum]


  export const AiPromptScalarFieldEnum: {
    id: 'id',
    name: 'name',
    action: 'action',
    model: 'model',
    optionalModels: 'optionalModels',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    modified: 'modified'
  };

  export type AiPromptScalarFieldEnum = (typeof AiPromptScalarFieldEnum)[keyof typeof AiPromptScalarFieldEnum]


  export const AiSessionMessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    role: 'role',
    content: 'content',
    streamObjects: 'streamObjects',
    attachments: 'attachments',
    params: 'params',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiSessionMessageScalarFieldEnum = (typeof AiSessionMessageScalarFieldEnum)[keyof typeof AiSessionMessageScalarFieldEnum]


  export const AiSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    docId: 'docId',
    promptName: 'promptName',
    promptAction: 'promptAction',
    pinned: 'pinned',
    title: 'title',
    parentSessionId: 'parentSessionId',
    messageCost: 'messageCost',
    tokenCost: 'tokenCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AiSessionScalarFieldEnum = (typeof AiSessionScalarFieldEnum)[keyof typeof AiSessionScalarFieldEnum]


  export const AiContextScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiContextScalarFieldEnum = (typeof AiContextScalarFieldEnum)[keyof typeof AiContextScalarFieldEnum]


  export const AiContextEmbeddingScalarFieldEnum: {
    id: 'id',
    contextId: 'contextId',
    fileId: 'fileId',
    chunk: 'chunk',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiContextEmbeddingScalarFieldEnum = (typeof AiContextEmbeddingScalarFieldEnum)[keyof typeof AiContextEmbeddingScalarFieldEnum]


  export const AiWorkspaceEmbeddingScalarFieldEnum: {
    workspaceId: 'workspaceId',
    docId: 'docId',
    chunk: 'chunk',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AiWorkspaceEmbeddingScalarFieldEnum = (typeof AiWorkspaceEmbeddingScalarFieldEnum)[keyof typeof AiWorkspaceEmbeddingScalarFieldEnum]


  export const AiWorkspaceIgnoredDocsScalarFieldEnum: {
    workspaceId: 'workspaceId',
    docId: 'docId',
    createdAt: 'createdAt'
  };

  export type AiWorkspaceIgnoredDocsScalarFieldEnum = (typeof AiWorkspaceIgnoredDocsScalarFieldEnum)[keyof typeof AiWorkspaceIgnoredDocsScalarFieldEnum]


  export const AiWorkspaceFilesScalarFieldEnum: {
    workspaceId: 'workspaceId',
    fileId: 'fileId',
    blobId: 'blobId',
    fileName: 'fileName',
    mimeType: 'mimeType',
    size: 'size',
    createdAt: 'createdAt'
  };

  export type AiWorkspaceFilesScalarFieldEnum = (typeof AiWorkspaceFilesScalarFieldEnum)[keyof typeof AiWorkspaceFilesScalarFieldEnum]


  export const AiWorkspaceFileEmbeddingScalarFieldEnum: {
    workspaceId: 'workspaceId',
    fileId: 'fileId',
    chunk: 'chunk',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AiWorkspaceFileEmbeddingScalarFieldEnum = (typeof AiWorkspaceFileEmbeddingScalarFieldEnum)[keyof typeof AiWorkspaceFileEmbeddingScalarFieldEnum]


  export const AiWorkspaceBlobEmbeddingScalarFieldEnum: {
    workspaceId: 'workspaceId',
    blobId: 'blobId',
    chunk: 'chunk',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type AiWorkspaceBlobEmbeddingScalarFieldEnum = (typeof AiWorkspaceBlobEmbeddingScalarFieldEnum)[keyof typeof AiWorkspaceBlobEmbeddingScalarFieldEnum]


  export const AiJobsScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    blobId: 'blobId',
    createdBy: 'createdBy',
    type: 'type',
    status: 'status',
    payload: 'payload',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt'
  };

  export type AiJobsScalarFieldEnum = (typeof AiJobsScalarFieldEnum)[keyof typeof AiJobsScalarFieldEnum]


  export const DataMigrationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt'
  };

  export type DataMigrationScalarFieldEnum = (typeof DataMigrationScalarFieldEnum)[keyof typeof DataMigrationScalarFieldEnum]


  export const DeprecatedAppRuntimeSettingsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    module: 'module',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    lastUpdatedBy: 'lastUpdatedBy'
  };

  export type DeprecatedAppRuntimeSettingsScalarFieldEnum = (typeof DeprecatedAppRuntimeSettingsScalarFieldEnum)[keyof typeof DeprecatedAppRuntimeSettingsScalarFieldEnum]


  export const AppConfigScalarFieldEnum: {
    id: 'id',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUpdatedBy: 'lastUpdatedBy'
  };

  export type AppConfigScalarFieldEnum = (typeof AppConfigScalarFieldEnum)[keyof typeof AppConfigScalarFieldEnum]


  export const DeprecatedUserSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    recurring: 'recurring',
    variant: 'variant',
    stripeSubscriptionId: 'stripeSubscriptionId',
    status: 'status',
    start: 'start',
    end: 'end',
    nextBillAt: 'nextBillAt',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    stripeScheduleId: 'stripeScheduleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeprecatedUserSubscriptionScalarFieldEnum = (typeof DeprecatedUserSubscriptionScalarFieldEnum)[keyof typeof DeprecatedUserSubscriptionScalarFieldEnum]


  export const DeprecatedUserInvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeInvoiceId: 'stripeInvoiceId',
    currency: 'currency',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reason: 'reason',
    lastPaymentError: 'lastPaymentError',
    link: 'link',
    plan: 'plan',
    recurring: 'recurring'
  };

  export type DeprecatedUserInvoiceScalarFieldEnum = (typeof DeprecatedUserInvoiceScalarFieldEnum)[keyof typeof DeprecatedUserInvoiceScalarFieldEnum]


  export const UserStripeCustomerScalarFieldEnum: {
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    createdAt: 'createdAt'
  };

  export type UserStripeCustomerScalarFieldEnum = (typeof UserStripeCustomerScalarFieldEnum)[keyof typeof UserStripeCustomerScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    targetId: 'targetId',
    plan: 'plan',
    recurring: 'recurring',
    variant: 'variant',
    quantity: 'quantity',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeScheduleId: 'stripeScheduleId',
    provider: 'provider',
    iapStore: 'iapStore',
    rcEntitlement: 'rcEntitlement',
    rcProductId: 'rcProductId',
    rcExternalRef: 'rcExternalRef',
    status: 'status',
    start: 'start',
    end: 'end',
    nextBillAt: 'nextBillAt',
    canceledAt: 'canceledAt',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    stripeInvoiceId: 'stripeInvoiceId',
    targetId: 'targetId',
    currency: 'currency',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reason: 'reason',
    lastPaymentError: 'lastPaymentError',
    link: 'link',
    onetimeSubscriptionRedeemed: 'onetimeSubscriptionRedeemed'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    key: 'key',
    createdAt: 'createdAt',
    revealedAt: 'revealedAt',
    installedAt: 'installedAt',
    validateKey: 'validateKey'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const InstalledLicenseScalarFieldEnum: {
    key: 'key',
    workspaceId: 'workspaceId',
    quantity: 'quantity',
    recurring: 'recurring',
    variant: 'variant',
    installedAt: 'installedAt',
    validateKey: 'validateKey',
    validatedAt: 'validatedAt',
    expiredAt: 'expiredAt',
    license: 'license'
  };

  export type InstalledLicenseScalarFieldEnum = (typeof InstalledLicenseScalarFieldEnum)[keyof typeof InstalledLicenseScalarFieldEnum]


  export const BlobScalarFieldEnum: {
    workspaceId: 'workspaceId',
    key: 'key',
    size: 'size',
    mime: 'mime',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type BlobScalarFieldEnum = (typeof BlobScalarFieldEnum)[keyof typeof BlobScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    level: 'level',
    read: 'read',
    type: 'type',
    body: 'body'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    payload: 'payload'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    sid: 'sid',
    id: 'id',
    workspaceId: 'workspaceId',
    docId: 'docId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    resolved: 'resolved'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReplyScalarFieldEnum: {
    sid: 'sid',
    id: 'id',
    userId: 'userId',
    commentId: 'commentId',
    workspaceId: 'workspaceId',
    docId: 'docId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ReplyScalarFieldEnum = (typeof ReplyScalarFieldEnum)[keyof typeof ReplyScalarFieldEnum]


  export const CommentAttachmentScalarFieldEnum: {
    sid: 'sid',
    workspaceId: 'workspaceId',
    docId: 'docId',
    key: 'key',
    size: 'size',
    mime: 'mime',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type CommentAttachmentScalarFieldEnum = (typeof CommentAttachmentScalarFieldEnum)[keyof typeof CommentAttachmentScalarFieldEnum]


  export const AccessTokenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type AccessTokenScalarFieldEnum = (typeof AccessTokenScalarFieldEnum)[keyof typeof AccessTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'WorkspaceMemberStatus'
   */
  export type EnumWorkspaceMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceMemberStatus'>
    


  /**
   * Reference to a field of type 'WorkspaceMemberStatus[]'
   */
  export type ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceMemberStatus[]'>
    


  /**
   * Reference to a field of type 'WorkspaceMemberSource'
   */
  export type EnumWorkspaceMemberSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceMemberSource'>
    


  /**
   * Reference to a field of type 'WorkspaceMemberSource[]'
   */
  export type ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceMemberSource[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'AiPromptRole'
   */
  export type EnumAiPromptRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiPromptRole'>
    


  /**
   * Reference to a field of type 'AiPromptRole[]'
   */
  export type ListEnumAiPromptRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiPromptRole[]'>
    


  /**
   * Reference to a field of type 'AiJobType'
   */
  export type EnumAiJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiJobType'>
    


  /**
   * Reference to a field of type 'AiJobType[]'
   */
  export type ListEnumAiJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiJobType[]'>
    


  /**
   * Reference to a field of type 'AiJobStatus'
   */
  export type EnumAiJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiJobStatus'>
    


  /**
   * Reference to a field of type 'AiJobStatus[]'
   */
  export type ListEnumAiJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AiJobStatus[]'>
    


  /**
   * Reference to a field of type 'RuntimeConfigType'
   */
  export type EnumRuntimeConfigTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuntimeConfigType'>
    


  /**
   * Reference to a field of type 'RuntimeConfigType[]'
   */
  export type ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuntimeConfigType[]'>
    


  /**
   * Reference to a field of type 'Provider'
   */
  export type EnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider'>
    


  /**
   * Reference to a field of type 'Provider[]'
   */
  export type ListEnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider[]'>
    


  /**
   * Reference to a field of type 'IapStore'
   */
  export type EnumIapStoreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IapStore'>
    


  /**
   * Reference to a field of type 'IapStore[]'
   */
  export type ListEnumIapStoreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IapStore[]'>
    


  /**
   * Reference to a field of type 'NotificationLevel'
   */
  export type EnumNotificationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationLevel'>
    


  /**
   * Reference to a field of type 'NotificationLevel[]'
   */
  export type ListEnumNotificationLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationLevel[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    registered?: BoolFilter<"User"> | boolean
    disabled?: BoolFilter<"User"> | boolean
    features?: UserFeatureListRelationFilter
    userStripeCustomer?: XOR<UserStripeCustomerNullableScalarRelationFilter, UserStripeCustomerWhereInput> | null
    workspaces?: WorkspaceUserRoleListRelationFilter
    WorkspaceInvitations?: WorkspaceUserRoleListRelationFilter
    docPermissions?: WorkspaceDocUserRoleListRelationFilter
    connectedAccounts?: ConnectedAccountListRelationFilter
    sessions?: UserSessionListRelationFilter
    aiSessions?: AiSessionListRelationFilter
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsListRelationFilter
    appConfigs?: AppConfigListRelationFilter
    userSnapshots?: UserSnapshotListRelationFilter
    createdSnapshot?: SnapshotListRelationFilter
    updatedSnapshot?: SnapshotListRelationFilter
    createdUpdate?: UpdateListRelationFilter
    createdHistory?: SnapshotHistoryListRelationFilter
    createdAiJobs?: AiJobsListRelationFilter
    notifications?: NotificationListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    comments?: CommentListRelationFilter
    replies?: ReplyListRelationFilter
    commentAttachments?: CommentAttachmentListRelationFilter
    AccessToken?: AccessTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    password?: SortOrderInput | SortOrder
    registered?: SortOrder
    disabled?: SortOrder
    features?: UserFeatureOrderByRelationAggregateInput
    userStripeCustomer?: UserStripeCustomerOrderByWithRelationInput
    workspaces?: WorkspaceUserRoleOrderByRelationAggregateInput
    WorkspaceInvitations?: WorkspaceUserRoleOrderByRelationAggregateInput
    docPermissions?: WorkspaceDocUserRoleOrderByRelationAggregateInput
    connectedAccounts?: ConnectedAccountOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
    aiSessions?: AiSessionOrderByRelationAggregateInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsOrderByRelationAggregateInput
    appConfigs?: AppConfigOrderByRelationAggregateInput
    userSnapshots?: UserSnapshotOrderByRelationAggregateInput
    createdSnapshot?: SnapshotOrderByRelationAggregateInput
    updatedSnapshot?: SnapshotOrderByRelationAggregateInput
    createdUpdate?: UpdateOrderByRelationAggregateInput
    createdHistory?: SnapshotHistoryOrderByRelationAggregateInput
    createdAiJobs?: AiJobsOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    settings?: UserSettingsOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    replies?: ReplyOrderByRelationAggregateInput
    commentAttachments?: CommentAttachmentOrderByRelationAggregateInput
    AccessToken?: AccessTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    password?: StringNullableFilter<"User"> | string | null
    registered?: BoolFilter<"User"> | boolean
    disabled?: BoolFilter<"User"> | boolean
    features?: UserFeatureListRelationFilter
    userStripeCustomer?: XOR<UserStripeCustomerNullableScalarRelationFilter, UserStripeCustomerWhereInput> | null
    workspaces?: WorkspaceUserRoleListRelationFilter
    WorkspaceInvitations?: WorkspaceUserRoleListRelationFilter
    docPermissions?: WorkspaceDocUserRoleListRelationFilter
    connectedAccounts?: ConnectedAccountListRelationFilter
    sessions?: UserSessionListRelationFilter
    aiSessions?: AiSessionListRelationFilter
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsListRelationFilter
    appConfigs?: AppConfigListRelationFilter
    userSnapshots?: UserSnapshotListRelationFilter
    createdSnapshot?: SnapshotListRelationFilter
    updatedSnapshot?: SnapshotListRelationFilter
    createdUpdate?: UpdateListRelationFilter
    createdHistory?: SnapshotHistoryListRelationFilter
    createdAiJobs?: AiJobsListRelationFilter
    notifications?: NotificationListRelationFilter
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    comments?: CommentListRelationFilter
    replies?: ReplyListRelationFilter
    commentAttachments?: CommentAttachmentListRelationFilter
    AccessToken?: AccessTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    password?: SortOrderInput | SortOrder
    registered?: SortOrder
    disabled?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    registered?: BoolWithAggregatesFilter<"User"> | boolean
    disabled?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type ConnectedAccountWhereInput = {
    AND?: ConnectedAccountWhereInput | ConnectedAccountWhereInput[]
    OR?: ConnectedAccountWhereInput[]
    NOT?: ConnectedAccountWhereInput | ConnectedAccountWhereInput[]
    id?: StringFilter<"ConnectedAccount"> | string
    userId?: StringFilter<"ConnectedAccount"> | string
    provider?: StringFilter<"ConnectedAccount"> | string
    providerAccountId?: StringFilter<"ConnectedAccount"> | string
    scope?: StringNullableFilter<"ConnectedAccount"> | string | null
    accessToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    refreshToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConnectedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConnectedAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    scope?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ConnectedAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConnectedAccountWhereInput | ConnectedAccountWhereInput[]
    OR?: ConnectedAccountWhereInput[]
    NOT?: ConnectedAccountWhereInput | ConnectedAccountWhereInput[]
    userId?: StringFilter<"ConnectedAccount"> | string
    provider?: StringFilter<"ConnectedAccount"> | string
    providerAccountId?: StringFilter<"ConnectedAccount"> | string
    scope?: StringNullableFilter<"ConnectedAccount"> | string | null
    accessToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    refreshToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConnectedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ConnectedAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    scope?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConnectedAccountCountOrderByAggregateInput
    _max?: ConnectedAccountMaxOrderByAggregateInput
    _min?: ConnectedAccountMinOrderByAggregateInput
  }

  export type ConnectedAccountScalarWhereWithAggregatesInput = {
    AND?: ConnectedAccountScalarWhereWithAggregatesInput | ConnectedAccountScalarWhereWithAggregatesInput[]
    OR?: ConnectedAccountScalarWhereWithAggregatesInput[]
    NOT?: ConnectedAccountScalarWhereWithAggregatesInput | ConnectedAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectedAccount"> | string
    userId?: StringWithAggregatesFilter<"ConnectedAccount"> | string
    provider?: StringWithAggregatesFilter<"ConnectedAccount"> | string
    providerAccountId?: StringWithAggregatesFilter<"ConnectedAccount"> | string
    scope?: StringNullableWithAggregatesFilter<"ConnectedAccount"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"ConnectedAccount"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"ConnectedAccount"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ConnectedAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConnectedAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConnectedAccount"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    deprecated_expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    userSessions?: UserSessionListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    deprecated_expiresAt?: SortOrderInput | SortOrder
    userSessions?: UserSessionOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    deprecated_expiresAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    userSessions?: UserSessionListRelationFilter
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    deprecated_expiresAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    deprecated_expiresAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionId?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_userId?: UserSessionSessionIdUserIdCompoundUniqueInput
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    sessionId?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionId_userId">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    sessionId?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    token?: StringFilter<"VerificationToken"> | string
    type?: IntFilter<"VerificationToken"> | number
    credential?: StringNullableFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    token?: SortOrder
    type?: SortOrder
    credential?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    type_token?: VerificationTokenTypeTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    token?: StringFilter<"VerificationToken"> | string
    type?: IntFilter<"VerificationToken"> | number
    credential?: StringNullableFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "type_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    token?: SortOrder
    type?: SortOrder
    credential?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _avg?: VerificationTokenAvgOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
    _sum?: VerificationTokenSumOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    type?: IntWithAggregatesFilter<"VerificationToken"> | number
    credential?: StringNullableWithAggregatesFilter<"VerificationToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    sid?: IntFilter<"Workspace"> | number
    id?: StringFilter<"Workspace"> | string
    public?: BoolFilter<"Workspace"> | boolean
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    enableAi?: BoolFilter<"Workspace"> | boolean
    enableUrlPreview?: BoolFilter<"Workspace"> | boolean
    enableDocEmbedding?: BoolFilter<"Workspace"> | boolean
    name?: StringNullableFilter<"Workspace"> | string | null
    avatarKey?: StringNullableFilter<"Workspace"> | string | null
    indexed?: BoolFilter<"Workspace"> | boolean
    lastCheckEmbeddings?: DateTimeFilter<"Workspace"> | Date | string
    features?: WorkspaceFeatureListRelationFilter
    docs?: WorkspaceDocListRelationFilter
    permissions?: WorkspaceUserRoleListRelationFilter
    docPermissions?: WorkspaceDocUserRoleListRelationFilter
    blobs?: BlobListRelationFilter
    ignoredDocs?: AiWorkspaceIgnoredDocsListRelationFilter
    embedFiles?: AiWorkspaceFilesListRelationFilter
    comments?: CommentListRelationFilter
    commentAttachments?: CommentAttachmentListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    sid?: SortOrder
    id?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    enableAi?: SortOrder
    enableUrlPreview?: SortOrder
    enableDocEmbedding?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarKey?: SortOrderInput | SortOrder
    indexed?: SortOrder
    lastCheckEmbeddings?: SortOrder
    features?: WorkspaceFeatureOrderByRelationAggregateInput
    docs?: WorkspaceDocOrderByRelationAggregateInput
    permissions?: WorkspaceUserRoleOrderByRelationAggregateInput
    docPermissions?: WorkspaceDocUserRoleOrderByRelationAggregateInput
    blobs?: BlobOrderByRelationAggregateInput
    ignoredDocs?: AiWorkspaceIgnoredDocsOrderByRelationAggregateInput
    embedFiles?: AiWorkspaceFilesOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    commentAttachments?: CommentAttachmentOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    sid?: number
    id?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    public?: BoolFilter<"Workspace"> | boolean
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    enableAi?: BoolFilter<"Workspace"> | boolean
    enableUrlPreview?: BoolFilter<"Workspace"> | boolean
    enableDocEmbedding?: BoolFilter<"Workspace"> | boolean
    name?: StringNullableFilter<"Workspace"> | string | null
    avatarKey?: StringNullableFilter<"Workspace"> | string | null
    indexed?: BoolFilter<"Workspace"> | boolean
    lastCheckEmbeddings?: DateTimeFilter<"Workspace"> | Date | string
    features?: WorkspaceFeatureListRelationFilter
    docs?: WorkspaceDocListRelationFilter
    permissions?: WorkspaceUserRoleListRelationFilter
    docPermissions?: WorkspaceDocUserRoleListRelationFilter
    blobs?: BlobListRelationFilter
    ignoredDocs?: AiWorkspaceIgnoredDocsListRelationFilter
    embedFiles?: AiWorkspaceFilesListRelationFilter
    comments?: CommentListRelationFilter
    commentAttachments?: CommentAttachmentListRelationFilter
  }, "id" | "sid">

  export type WorkspaceOrderByWithAggregationInput = {
    sid?: SortOrder
    id?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    enableAi?: SortOrder
    enableUrlPreview?: SortOrder
    enableDocEmbedding?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarKey?: SortOrderInput | SortOrder
    indexed?: SortOrder
    lastCheckEmbeddings?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _avg?: WorkspaceAvgOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
    _sum?: WorkspaceSumOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    sid?: IntWithAggregatesFilter<"Workspace"> | number
    id?: StringWithAggregatesFilter<"Workspace"> | string
    public?: BoolWithAggregatesFilter<"Workspace"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    enableAi?: BoolWithAggregatesFilter<"Workspace"> | boolean
    enableUrlPreview?: BoolWithAggregatesFilter<"Workspace"> | boolean
    enableDocEmbedding?: BoolWithAggregatesFilter<"Workspace"> | boolean
    name?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    avatarKey?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    indexed?: BoolWithAggregatesFilter<"Workspace"> | boolean
    lastCheckEmbeddings?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceDocWhereInput = {
    AND?: WorkspaceDocWhereInput | WorkspaceDocWhereInput[]
    OR?: WorkspaceDocWhereInput[]
    NOT?: WorkspaceDocWhereInput | WorkspaceDocWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDoc"> | string
    docId?: StringFilter<"WorkspaceDoc"> | string
    public?: BoolFilter<"WorkspaceDoc"> | boolean
    defaultRole?: IntFilter<"WorkspaceDoc"> | number
    mode?: IntFilter<"WorkspaceDoc"> | number
    blocked?: BoolFilter<"WorkspaceDoc"> | boolean
    title?: StringNullableFilter<"WorkspaceDoc"> | string | null
    summary?: StringNullableFilter<"WorkspaceDoc"> | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceDocOrderByWithRelationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    public?: SortOrder
    defaultRole?: SortOrder
    mode?: SortOrder
    blocked?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceDocWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_docId?: WorkspaceDocWorkspaceIdDocIdCompoundUniqueInput
    AND?: WorkspaceDocWhereInput | WorkspaceDocWhereInput[]
    OR?: WorkspaceDocWhereInput[]
    NOT?: WorkspaceDocWhereInput | WorkspaceDocWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDoc"> | string
    docId?: StringFilter<"WorkspaceDoc"> | string
    public?: BoolFilter<"WorkspaceDoc"> | boolean
    defaultRole?: IntFilter<"WorkspaceDoc"> | number
    mode?: IntFilter<"WorkspaceDoc"> | number
    blocked?: BoolFilter<"WorkspaceDoc"> | boolean
    title?: StringNullableFilter<"WorkspaceDoc"> | string | null
    summary?: StringNullableFilter<"WorkspaceDoc"> | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "workspaceId_docId">

  export type WorkspaceDocOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    public?: SortOrder
    defaultRole?: SortOrder
    mode?: SortOrder
    blocked?: SortOrder
    title?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    _count?: WorkspaceDocCountOrderByAggregateInput
    _avg?: WorkspaceDocAvgOrderByAggregateInput
    _max?: WorkspaceDocMaxOrderByAggregateInput
    _min?: WorkspaceDocMinOrderByAggregateInput
    _sum?: WorkspaceDocSumOrderByAggregateInput
  }

  export type WorkspaceDocScalarWhereWithAggregatesInput = {
    AND?: WorkspaceDocScalarWhereWithAggregatesInput | WorkspaceDocScalarWhereWithAggregatesInput[]
    OR?: WorkspaceDocScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceDocScalarWhereWithAggregatesInput | WorkspaceDocScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"WorkspaceDoc"> | string
    docId?: StringWithAggregatesFilter<"WorkspaceDoc"> | string
    public?: BoolWithAggregatesFilter<"WorkspaceDoc"> | boolean
    defaultRole?: IntWithAggregatesFilter<"WorkspaceDoc"> | number
    mode?: IntWithAggregatesFilter<"WorkspaceDoc"> | number
    blocked?: BoolWithAggregatesFilter<"WorkspaceDoc"> | boolean
    title?: StringNullableWithAggregatesFilter<"WorkspaceDoc"> | string | null
    summary?: StringNullableWithAggregatesFilter<"WorkspaceDoc"> | string | null
  }

  export type WorkspaceUserRoleWhereInput = {
    AND?: WorkspaceUserRoleWhereInput | WorkspaceUserRoleWhereInput[]
    OR?: WorkspaceUserRoleWhereInput[]
    NOT?: WorkspaceUserRoleWhereInput | WorkspaceUserRoleWhereInput[]
    id?: StringFilter<"WorkspaceUserRole"> | string
    workspaceId?: StringFilter<"WorkspaceUserRole"> | string
    userId?: StringFilter<"WorkspaceUserRole"> | string
    type?: IntFilter<"WorkspaceUserRole"> | number
    status?: EnumWorkspaceMemberStatusFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberSource
    inviterId?: StringNullableFilter<"WorkspaceUserRole"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    accepted?: BoolFilter<"WorkspaceUserRole"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WorkspaceUserRoleOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    inviterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accepted?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
  }

  export type WorkspaceUserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_userId?: WorkspaceUserRoleWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceUserRoleWhereInput | WorkspaceUserRoleWhereInput[]
    OR?: WorkspaceUserRoleWhereInput[]
    NOT?: WorkspaceUserRoleWhereInput | WorkspaceUserRoleWhereInput[]
    workspaceId?: StringFilter<"WorkspaceUserRole"> | string
    userId?: StringFilter<"WorkspaceUserRole"> | string
    type?: IntFilter<"WorkspaceUserRole"> | number
    status?: EnumWorkspaceMemberStatusFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberSource
    inviterId?: StringNullableFilter<"WorkspaceUserRole"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    accepted?: BoolFilter<"WorkspaceUserRole"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "workspaceId_userId">

  export type WorkspaceUserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    inviterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accepted?: SortOrder
    _count?: WorkspaceUserRoleCountOrderByAggregateInput
    _avg?: WorkspaceUserRoleAvgOrderByAggregateInput
    _max?: WorkspaceUserRoleMaxOrderByAggregateInput
    _min?: WorkspaceUserRoleMinOrderByAggregateInput
    _sum?: WorkspaceUserRoleSumOrderByAggregateInput
  }

  export type WorkspaceUserRoleScalarWhereWithAggregatesInput = {
    AND?: WorkspaceUserRoleScalarWhereWithAggregatesInput | WorkspaceUserRoleScalarWhereWithAggregatesInput[]
    OR?: WorkspaceUserRoleScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceUserRoleScalarWhereWithAggregatesInput | WorkspaceUserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceUserRole"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceUserRole"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceUserRole"> | string
    type?: IntWithAggregatesFilter<"WorkspaceUserRole"> | number
    status?: EnumWorkspaceMemberStatusWithAggregatesFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceWithAggregatesFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberSource
    inviterId?: StringNullableWithAggregatesFilter<"WorkspaceUserRole"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceUserRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkspaceUserRole"> | Date | string
    accepted?: BoolWithAggregatesFilter<"WorkspaceUserRole"> | boolean
  }

  export type WorkspaceDocUserRoleWhereInput = {
    AND?: WorkspaceDocUserRoleWhereInput | WorkspaceDocUserRoleWhereInput[]
    OR?: WorkspaceDocUserRoleWhereInput[]
    NOT?: WorkspaceDocUserRoleWhereInput | WorkspaceDocUserRoleWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDocUserRole"> | string
    docId?: StringFilter<"WorkspaceDocUserRole"> | string
    userId?: StringFilter<"WorkspaceDocUserRole"> | string
    type?: IntFilter<"WorkspaceDocUserRole"> | number
    createdAt?: DateTimeFilter<"WorkspaceDocUserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceDocUserRoleOrderByWithRelationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceDocUserRoleWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_docId_userId?: WorkspaceDocUserRoleWorkspaceIdDocIdUserIdCompoundUniqueInput
    AND?: WorkspaceDocUserRoleWhereInput | WorkspaceDocUserRoleWhereInput[]
    OR?: WorkspaceDocUserRoleWhereInput[]
    NOT?: WorkspaceDocUserRoleWhereInput | WorkspaceDocUserRoleWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDocUserRole"> | string
    docId?: StringFilter<"WorkspaceDocUserRole"> | string
    userId?: StringFilter<"WorkspaceDocUserRole"> | string
    type?: IntFilter<"WorkspaceDocUserRole"> | number
    createdAt?: DateTimeFilter<"WorkspaceDocUserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "workspaceId_docId_userId">

  export type WorkspaceDocUserRoleOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: WorkspaceDocUserRoleCountOrderByAggregateInput
    _avg?: WorkspaceDocUserRoleAvgOrderByAggregateInput
    _max?: WorkspaceDocUserRoleMaxOrderByAggregateInput
    _min?: WorkspaceDocUserRoleMinOrderByAggregateInput
    _sum?: WorkspaceDocUserRoleSumOrderByAggregateInput
  }

  export type WorkspaceDocUserRoleScalarWhereWithAggregatesInput = {
    AND?: WorkspaceDocUserRoleScalarWhereWithAggregatesInput | WorkspaceDocUserRoleScalarWhereWithAggregatesInput[]
    OR?: WorkspaceDocUserRoleScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceDocUserRoleScalarWhereWithAggregatesInput | WorkspaceDocUserRoleScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"WorkspaceDocUserRole"> | string
    docId?: StringWithAggregatesFilter<"WorkspaceDocUserRole"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceDocUserRole"> | string
    type?: IntWithAggregatesFilter<"WorkspaceDocUserRole"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceDocUserRole"> | Date | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: IntFilter<"Feature"> | number
    name?: StringFilter<"Feature"> | string
    configs?: JsonFilter<"Feature">
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    deprecatedVersion?: IntFilter<"Feature"> | number
    deprecatedType?: IntFilter<"Feature"> | number
    userFeatures?: UserFeatureListRelationFilter
    workspaceFeatures?: WorkspaceFeatureListRelationFilter
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    configs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
    userFeatures?: UserFeatureOrderByRelationAggregateInput
    workspaceFeatures?: WorkspaceFeatureOrderByRelationAggregateInput
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_deprecatedVersion?: FeatureNameDeprecatedVersionCompoundUniqueInput
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    name?: StringFilter<"Feature"> | string
    configs?: JsonFilter<"Feature">
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    deprecatedVersion?: IntFilter<"Feature"> | number
    deprecatedType?: IntFilter<"Feature"> | number
    userFeatures?: UserFeatureListRelationFilter
    workspaceFeatures?: WorkspaceFeatureListRelationFilter
  }, "id" | "name_deprecatedVersion">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    configs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _avg?: FeatureAvgOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
    _sum?: FeatureSumOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feature"> | number
    name?: StringWithAggregatesFilter<"Feature"> | string
    configs?: JsonWithAggregatesFilter<"Feature">
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    deprecatedVersion?: IntWithAggregatesFilter<"Feature"> | number
    deprecatedType?: IntWithAggregatesFilter<"Feature"> | number
  }

  export type UserFeatureWhereInput = {
    AND?: UserFeatureWhereInput | UserFeatureWhereInput[]
    OR?: UserFeatureWhereInput[]
    NOT?: UserFeatureWhereInput | UserFeatureWhereInput[]
    id?: IntFilter<"UserFeature"> | number
    userId?: StringFilter<"UserFeature"> | string
    featureId?: IntFilter<"UserFeature"> | number
    name?: StringFilter<"UserFeature"> | string
    type?: IntFilter<"UserFeature"> | number
    reason?: StringFilter<"UserFeature"> | string
    createdAt?: DateTimeFilter<"UserFeature"> | Date | string
    expiredAt?: DateTimeNullableFilter<"UserFeature"> | Date | string | null
    activated?: BoolFilter<"UserFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFeatureOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    activated?: SortOrder
    feature?: FeatureOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserFeatureWhereInput | UserFeatureWhereInput[]
    OR?: UserFeatureWhereInput[]
    NOT?: UserFeatureWhereInput | UserFeatureWhereInput[]
    userId?: StringFilter<"UserFeature"> | string
    featureId?: IntFilter<"UserFeature"> | number
    name?: StringFilter<"UserFeature"> | string
    type?: IntFilter<"UserFeature"> | number
    reason?: StringFilter<"UserFeature"> | string
    createdAt?: DateTimeFilter<"UserFeature"> | Date | string
    expiredAt?: DateTimeNullableFilter<"UserFeature"> | Date | string | null
    activated?: BoolFilter<"UserFeature"> | boolean
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    activated?: SortOrder
    _count?: UserFeatureCountOrderByAggregateInput
    _avg?: UserFeatureAvgOrderByAggregateInput
    _max?: UserFeatureMaxOrderByAggregateInput
    _min?: UserFeatureMinOrderByAggregateInput
    _sum?: UserFeatureSumOrderByAggregateInput
  }

  export type UserFeatureScalarWhereWithAggregatesInput = {
    AND?: UserFeatureScalarWhereWithAggregatesInput | UserFeatureScalarWhereWithAggregatesInput[]
    OR?: UserFeatureScalarWhereWithAggregatesInput[]
    NOT?: UserFeatureScalarWhereWithAggregatesInput | UserFeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserFeature"> | number
    userId?: StringWithAggregatesFilter<"UserFeature"> | string
    featureId?: IntWithAggregatesFilter<"UserFeature"> | number
    name?: StringWithAggregatesFilter<"UserFeature"> | string
    type?: IntWithAggregatesFilter<"UserFeature"> | number
    reason?: StringWithAggregatesFilter<"UserFeature"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFeature"> | Date | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"UserFeature"> | Date | string | null
    activated?: BoolWithAggregatesFilter<"UserFeature"> | boolean
  }

  export type WorkspaceFeatureWhereInput = {
    AND?: WorkspaceFeatureWhereInput | WorkspaceFeatureWhereInput[]
    OR?: WorkspaceFeatureWhereInput[]
    NOT?: WorkspaceFeatureWhereInput | WorkspaceFeatureWhereInput[]
    id?: IntFilter<"WorkspaceFeature"> | number
    workspaceId?: StringFilter<"WorkspaceFeature"> | string
    featureId?: IntFilter<"WorkspaceFeature"> | number
    name?: StringFilter<"WorkspaceFeature"> | string
    type?: IntFilter<"WorkspaceFeature"> | number
    configs?: JsonFilter<"WorkspaceFeature">
    reason?: StringFilter<"WorkspaceFeature"> | string
    createdAt?: DateTimeFilter<"WorkspaceFeature"> | Date | string
    activated?: BoolFilter<"WorkspaceFeature"> | boolean
    expiredAt?: DateTimeNullableFilter<"WorkspaceFeature"> | Date | string | null
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WorkspaceFeatureOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    configs?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    activated?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    feature?: FeatureOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WorkspaceFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkspaceFeatureWhereInput | WorkspaceFeatureWhereInput[]
    OR?: WorkspaceFeatureWhereInput[]
    NOT?: WorkspaceFeatureWhereInput | WorkspaceFeatureWhereInput[]
    workspaceId?: StringFilter<"WorkspaceFeature"> | string
    featureId?: IntFilter<"WorkspaceFeature"> | number
    name?: StringFilter<"WorkspaceFeature"> | string
    type?: IntFilter<"WorkspaceFeature"> | number
    configs?: JsonFilter<"WorkspaceFeature">
    reason?: StringFilter<"WorkspaceFeature"> | string
    createdAt?: DateTimeFilter<"WorkspaceFeature"> | Date | string
    activated?: BoolFilter<"WorkspaceFeature"> | boolean
    expiredAt?: DateTimeNullableFilter<"WorkspaceFeature"> | Date | string | null
    feature?: XOR<FeatureScalarRelationFilter, FeatureWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type WorkspaceFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    configs?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    activated?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    _count?: WorkspaceFeatureCountOrderByAggregateInput
    _avg?: WorkspaceFeatureAvgOrderByAggregateInput
    _max?: WorkspaceFeatureMaxOrderByAggregateInput
    _min?: WorkspaceFeatureMinOrderByAggregateInput
    _sum?: WorkspaceFeatureSumOrderByAggregateInput
  }

  export type WorkspaceFeatureScalarWhereWithAggregatesInput = {
    AND?: WorkspaceFeatureScalarWhereWithAggregatesInput | WorkspaceFeatureScalarWhereWithAggregatesInput[]
    OR?: WorkspaceFeatureScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceFeatureScalarWhereWithAggregatesInput | WorkspaceFeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WorkspaceFeature"> | number
    workspaceId?: StringWithAggregatesFilter<"WorkspaceFeature"> | string
    featureId?: IntWithAggregatesFilter<"WorkspaceFeature"> | number
    name?: StringWithAggregatesFilter<"WorkspaceFeature"> | string
    type?: IntWithAggregatesFilter<"WorkspaceFeature"> | number
    configs?: JsonWithAggregatesFilter<"WorkspaceFeature">
    reason?: StringWithAggregatesFilter<"WorkspaceFeature"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkspaceFeature"> | Date | string
    activated?: BoolWithAggregatesFilter<"WorkspaceFeature"> | boolean
    expiredAt?: DateTimeNullableWithAggregatesFilter<"WorkspaceFeature"> | Date | string | null
  }

  export type SnapshotWhereInput = {
    AND?: SnapshotWhereInput | SnapshotWhereInput[]
    OR?: SnapshotWhereInput[]
    NOT?: SnapshotWhereInput | SnapshotWhereInput[]
    workspaceId?: StringFilter<"Snapshot"> | string
    id?: StringFilter<"Snapshot"> | string
    blob?: BytesFilter<"Snapshot"> | Uint8Array
    state?: BytesNullableFilter<"Snapshot"> | Uint8Array | null
    createdAt?: DateTimeFilter<"Snapshot"> | Date | string
    updatedAt?: DateTimeFilter<"Snapshot"> | Date | string
    createdBy?: StringNullableFilter<"Snapshot"> | string | null
    updatedBy?: StringNullableFilter<"Snapshot"> | string | null
    seq?: IntNullableFilter<"Snapshot"> | number | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    embedding?: AiWorkspaceEmbeddingListRelationFilter
  }

  export type SnapshotOrderByWithRelationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    seq?: SortOrderInput | SortOrder
    createdByUser?: UserOrderByWithRelationInput
    updatedByUser?: UserOrderByWithRelationInput
    embedding?: AiWorkspaceEmbeddingOrderByRelationAggregateInput
  }

  export type SnapshotWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_id?: SnapshotWorkspaceIdIdCompoundUniqueInput
    AND?: SnapshotWhereInput | SnapshotWhereInput[]
    OR?: SnapshotWhereInput[]
    NOT?: SnapshotWhereInput | SnapshotWhereInput[]
    workspaceId?: StringFilter<"Snapshot"> | string
    id?: StringFilter<"Snapshot"> | string
    blob?: BytesFilter<"Snapshot"> | Uint8Array
    state?: BytesNullableFilter<"Snapshot"> | Uint8Array | null
    createdAt?: DateTimeFilter<"Snapshot"> | Date | string
    updatedAt?: DateTimeFilter<"Snapshot"> | Date | string
    createdBy?: StringNullableFilter<"Snapshot"> | string | null
    updatedBy?: StringNullableFilter<"Snapshot"> | string | null
    seq?: IntNullableFilter<"Snapshot"> | number | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    embedding?: AiWorkspaceEmbeddingListRelationFilter
  }, "workspaceId_id">

  export type SnapshotOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    seq?: SortOrderInput | SortOrder
    _count?: SnapshotCountOrderByAggregateInput
    _avg?: SnapshotAvgOrderByAggregateInput
    _max?: SnapshotMaxOrderByAggregateInput
    _min?: SnapshotMinOrderByAggregateInput
    _sum?: SnapshotSumOrderByAggregateInput
  }

  export type SnapshotScalarWhereWithAggregatesInput = {
    AND?: SnapshotScalarWhereWithAggregatesInput | SnapshotScalarWhereWithAggregatesInput[]
    OR?: SnapshotScalarWhereWithAggregatesInput[]
    NOT?: SnapshotScalarWhereWithAggregatesInput | SnapshotScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"Snapshot"> | string
    id?: StringWithAggregatesFilter<"Snapshot"> | string
    blob?: BytesWithAggregatesFilter<"Snapshot"> | Uint8Array
    state?: BytesNullableWithAggregatesFilter<"Snapshot"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"Snapshot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Snapshot"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Snapshot"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Snapshot"> | string | null
    seq?: IntNullableWithAggregatesFilter<"Snapshot"> | number | null
  }

  export type UserSnapshotWhereInput = {
    AND?: UserSnapshotWhereInput | UserSnapshotWhereInput[]
    OR?: UserSnapshotWhereInput[]
    NOT?: UserSnapshotWhereInput | UserSnapshotWhereInput[]
    userId?: StringFilter<"UserSnapshot"> | string
    id?: StringFilter<"UserSnapshot"> | string
    blob?: BytesFilter<"UserSnapshot"> | Uint8Array
    createdAt?: DateTimeFilter<"UserSnapshot"> | Date | string
    updatedAt?: DateTimeFilter<"UserSnapshot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSnapshotOrderByWithRelationInput = {
    userId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSnapshotWhereUniqueInput = Prisma.AtLeast<{
    userId_id?: UserSnapshotUserIdIdCompoundUniqueInput
    AND?: UserSnapshotWhereInput | UserSnapshotWhereInput[]
    OR?: UserSnapshotWhereInput[]
    NOT?: UserSnapshotWhereInput | UserSnapshotWhereInput[]
    userId?: StringFilter<"UserSnapshot"> | string
    id?: StringFilter<"UserSnapshot"> | string
    blob?: BytesFilter<"UserSnapshot"> | Uint8Array
    createdAt?: DateTimeFilter<"UserSnapshot"> | Date | string
    updatedAt?: DateTimeFilter<"UserSnapshot"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_id">

  export type UserSnapshotOrderByWithAggregationInput = {
    userId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSnapshotCountOrderByAggregateInput
    _max?: UserSnapshotMaxOrderByAggregateInput
    _min?: UserSnapshotMinOrderByAggregateInput
  }

  export type UserSnapshotScalarWhereWithAggregatesInput = {
    AND?: UserSnapshotScalarWhereWithAggregatesInput | UserSnapshotScalarWhereWithAggregatesInput[]
    OR?: UserSnapshotScalarWhereWithAggregatesInput[]
    NOT?: UserSnapshotScalarWhereWithAggregatesInput | UserSnapshotScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSnapshot"> | string
    id?: StringWithAggregatesFilter<"UserSnapshot"> | string
    blob?: BytesWithAggregatesFilter<"UserSnapshot"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"UserSnapshot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSnapshot"> | Date | string
  }

  export type UpdateWhereInput = {
    AND?: UpdateWhereInput | UpdateWhereInput[]
    OR?: UpdateWhereInput[]
    NOT?: UpdateWhereInput | UpdateWhereInput[]
    workspaceId?: StringFilter<"Update"> | string
    id?: StringFilter<"Update"> | string
    blob?: BytesFilter<"Update"> | Uint8Array
    createdAt?: DateTimeFilter<"Update"> | Date | string
    createdBy?: StringNullableFilter<"Update"> | string | null
    seq?: IntNullableFilter<"Update"> | number | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UpdateOrderByWithRelationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    seq?: SortOrderInput | SortOrder
    createdByUser?: UserOrderByWithRelationInput
  }

  export type UpdateWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_id_createdAt?: UpdateWorkspaceIdIdCreatedAtCompoundUniqueInput
    AND?: UpdateWhereInput | UpdateWhereInput[]
    OR?: UpdateWhereInput[]
    NOT?: UpdateWhereInput | UpdateWhereInput[]
    workspaceId?: StringFilter<"Update"> | string
    id?: StringFilter<"Update"> | string
    blob?: BytesFilter<"Update"> | Uint8Array
    createdAt?: DateTimeFilter<"Update"> | Date | string
    createdBy?: StringNullableFilter<"Update"> | string | null
    seq?: IntNullableFilter<"Update"> | number | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "workspaceId_id_createdAt">

  export type UpdateOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    seq?: SortOrderInput | SortOrder
    _count?: UpdateCountOrderByAggregateInput
    _avg?: UpdateAvgOrderByAggregateInput
    _max?: UpdateMaxOrderByAggregateInput
    _min?: UpdateMinOrderByAggregateInput
    _sum?: UpdateSumOrderByAggregateInput
  }

  export type UpdateScalarWhereWithAggregatesInput = {
    AND?: UpdateScalarWhereWithAggregatesInput | UpdateScalarWhereWithAggregatesInput[]
    OR?: UpdateScalarWhereWithAggregatesInput[]
    NOT?: UpdateScalarWhereWithAggregatesInput | UpdateScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"Update"> | string
    id?: StringWithAggregatesFilter<"Update"> | string
    blob?: BytesWithAggregatesFilter<"Update"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"Update"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Update"> | string | null
    seq?: IntNullableWithAggregatesFilter<"Update"> | number | null
  }

  export type SnapshotHistoryWhereInput = {
    AND?: SnapshotHistoryWhereInput | SnapshotHistoryWhereInput[]
    OR?: SnapshotHistoryWhereInput[]
    NOT?: SnapshotHistoryWhereInput | SnapshotHistoryWhereInput[]
    workspaceId?: StringFilter<"SnapshotHistory"> | string
    id?: StringFilter<"SnapshotHistory"> | string
    timestamp?: DateTimeFilter<"SnapshotHistory"> | Date | string
    blob?: BytesFilter<"SnapshotHistory"> | Uint8Array
    state?: BytesNullableFilter<"SnapshotHistory"> | Uint8Array | null
    expiredAt?: DateTimeFilter<"SnapshotHistory"> | Date | string
    createdBy?: StringNullableFilter<"SnapshotHistory"> | string | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SnapshotHistoryOrderByWithRelationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    timestamp?: SortOrder
    blob?: SortOrder
    state?: SortOrderInput | SortOrder
    expiredAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByUser?: UserOrderByWithRelationInput
  }

  export type SnapshotHistoryWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_id_timestamp?: SnapshotHistoryWorkspaceIdIdTimestampCompoundUniqueInput
    AND?: SnapshotHistoryWhereInput | SnapshotHistoryWhereInput[]
    OR?: SnapshotHistoryWhereInput[]
    NOT?: SnapshotHistoryWhereInput | SnapshotHistoryWhereInput[]
    workspaceId?: StringFilter<"SnapshotHistory"> | string
    id?: StringFilter<"SnapshotHistory"> | string
    timestamp?: DateTimeFilter<"SnapshotHistory"> | Date | string
    blob?: BytesFilter<"SnapshotHistory"> | Uint8Array
    state?: BytesNullableFilter<"SnapshotHistory"> | Uint8Array | null
    expiredAt?: DateTimeFilter<"SnapshotHistory"> | Date | string
    createdBy?: StringNullableFilter<"SnapshotHistory"> | string | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "workspaceId_id_timestamp">

  export type SnapshotHistoryOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    timestamp?: SortOrder
    blob?: SortOrder
    state?: SortOrderInput | SortOrder
    expiredAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: SnapshotHistoryCountOrderByAggregateInput
    _max?: SnapshotHistoryMaxOrderByAggregateInput
    _min?: SnapshotHistoryMinOrderByAggregateInput
  }

  export type SnapshotHistoryScalarWhereWithAggregatesInput = {
    AND?: SnapshotHistoryScalarWhereWithAggregatesInput | SnapshotHistoryScalarWhereWithAggregatesInput[]
    OR?: SnapshotHistoryScalarWhereWithAggregatesInput[]
    NOT?: SnapshotHistoryScalarWhereWithAggregatesInput | SnapshotHistoryScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"SnapshotHistory"> | string
    id?: StringWithAggregatesFilter<"SnapshotHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"SnapshotHistory"> | Date | string
    blob?: BytesWithAggregatesFilter<"SnapshotHistory"> | Uint8Array
    state?: BytesNullableWithAggregatesFilter<"SnapshotHistory"> | Uint8Array | null
    expiredAt?: DateTimeWithAggregatesFilter<"SnapshotHistory"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"SnapshotHistory"> | string | null
  }

  export type AiPromptMessageWhereInput = {
    AND?: AiPromptMessageWhereInput | AiPromptMessageWhereInput[]
    OR?: AiPromptMessageWhereInput[]
    NOT?: AiPromptMessageWhereInput | AiPromptMessageWhereInput[]
    promptId?: IntFilter<"AiPromptMessage"> | number
    idx?: IntFilter<"AiPromptMessage"> | number
    role?: EnumAiPromptRoleFilter<"AiPromptMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiPromptMessage"> | string
    attachments?: JsonNullableFilter<"AiPromptMessage">
    params?: JsonNullableFilter<"AiPromptMessage">
    createdAt?: DateTimeFilter<"AiPromptMessage"> | Date | string
    prompt?: XOR<AiPromptScalarRelationFilter, AiPromptWhereInput>
  }

  export type AiPromptMessageOrderByWithRelationInput = {
    promptId?: SortOrder
    idx?: SortOrder
    role?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prompt?: AiPromptOrderByWithRelationInput
  }

  export type AiPromptMessageWhereUniqueInput = Prisma.AtLeast<{
    promptId_idx?: AiPromptMessagePromptIdIdxCompoundUniqueInput
    AND?: AiPromptMessageWhereInput | AiPromptMessageWhereInput[]
    OR?: AiPromptMessageWhereInput[]
    NOT?: AiPromptMessageWhereInput | AiPromptMessageWhereInput[]
    promptId?: IntFilter<"AiPromptMessage"> | number
    idx?: IntFilter<"AiPromptMessage"> | number
    role?: EnumAiPromptRoleFilter<"AiPromptMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiPromptMessage"> | string
    attachments?: JsonNullableFilter<"AiPromptMessage">
    params?: JsonNullableFilter<"AiPromptMessage">
    createdAt?: DateTimeFilter<"AiPromptMessage"> | Date | string
    prompt?: XOR<AiPromptScalarRelationFilter, AiPromptWhereInput>
  }, "promptId_idx">

  export type AiPromptMessageOrderByWithAggregationInput = {
    promptId?: SortOrder
    idx?: SortOrder
    role?: SortOrder
    content?: SortOrder
    attachments?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiPromptMessageCountOrderByAggregateInput
    _avg?: AiPromptMessageAvgOrderByAggregateInput
    _max?: AiPromptMessageMaxOrderByAggregateInput
    _min?: AiPromptMessageMinOrderByAggregateInput
    _sum?: AiPromptMessageSumOrderByAggregateInput
  }

  export type AiPromptMessageScalarWhereWithAggregatesInput = {
    AND?: AiPromptMessageScalarWhereWithAggregatesInput | AiPromptMessageScalarWhereWithAggregatesInput[]
    OR?: AiPromptMessageScalarWhereWithAggregatesInput[]
    NOT?: AiPromptMessageScalarWhereWithAggregatesInput | AiPromptMessageScalarWhereWithAggregatesInput[]
    promptId?: IntWithAggregatesFilter<"AiPromptMessage"> | number
    idx?: IntWithAggregatesFilter<"AiPromptMessage"> | number
    role?: EnumAiPromptRoleWithAggregatesFilter<"AiPromptMessage"> | $Enums.AiPromptRole
    content?: StringWithAggregatesFilter<"AiPromptMessage"> | string
    attachments?: JsonNullableWithAggregatesFilter<"AiPromptMessage">
    params?: JsonNullableWithAggregatesFilter<"AiPromptMessage">
    createdAt?: DateTimeWithAggregatesFilter<"AiPromptMessage"> | Date | string
  }

  export type AiPromptWhereInput = {
    AND?: AiPromptWhereInput | AiPromptWhereInput[]
    OR?: AiPromptWhereInput[]
    NOT?: AiPromptWhereInput | AiPromptWhereInput[]
    id?: IntFilter<"AiPrompt"> | number
    name?: StringFilter<"AiPrompt"> | string
    action?: StringNullableFilter<"AiPrompt"> | string | null
    model?: StringFilter<"AiPrompt"> | string
    optionalModels?: StringNullableListFilter<"AiPrompt">
    config?: JsonNullableFilter<"AiPrompt">
    createdAt?: DateTimeFilter<"AiPrompt"> | Date | string
    updatedAt?: DateTimeFilter<"AiPrompt"> | Date | string
    modified?: BoolFilter<"AiPrompt"> | boolean
    messages?: AiPromptMessageListRelationFilter
    sessions?: AiSessionListRelationFilter
  }

  export type AiPromptOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrderInput | SortOrder
    model?: SortOrder
    optionalModels?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modified?: SortOrder
    messages?: AiPromptMessageOrderByRelationAggregateInput
    sessions?: AiSessionOrderByRelationAggregateInput
  }

  export type AiPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AiPromptWhereInput | AiPromptWhereInput[]
    OR?: AiPromptWhereInput[]
    NOT?: AiPromptWhereInput | AiPromptWhereInput[]
    action?: StringNullableFilter<"AiPrompt"> | string | null
    model?: StringFilter<"AiPrompt"> | string
    optionalModels?: StringNullableListFilter<"AiPrompt">
    config?: JsonNullableFilter<"AiPrompt">
    createdAt?: DateTimeFilter<"AiPrompt"> | Date | string
    updatedAt?: DateTimeFilter<"AiPrompt"> | Date | string
    modified?: BoolFilter<"AiPrompt"> | boolean
    messages?: AiPromptMessageListRelationFilter
    sessions?: AiSessionListRelationFilter
  }, "id" | "name">

  export type AiPromptOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrderInput | SortOrder
    model?: SortOrder
    optionalModels?: SortOrder
    config?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modified?: SortOrder
    _count?: AiPromptCountOrderByAggregateInput
    _avg?: AiPromptAvgOrderByAggregateInput
    _max?: AiPromptMaxOrderByAggregateInput
    _min?: AiPromptMinOrderByAggregateInput
    _sum?: AiPromptSumOrderByAggregateInput
  }

  export type AiPromptScalarWhereWithAggregatesInput = {
    AND?: AiPromptScalarWhereWithAggregatesInput | AiPromptScalarWhereWithAggregatesInput[]
    OR?: AiPromptScalarWhereWithAggregatesInput[]
    NOT?: AiPromptScalarWhereWithAggregatesInput | AiPromptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AiPrompt"> | number
    name?: StringWithAggregatesFilter<"AiPrompt"> | string
    action?: StringNullableWithAggregatesFilter<"AiPrompt"> | string | null
    model?: StringWithAggregatesFilter<"AiPrompt"> | string
    optionalModels?: StringNullableListFilter<"AiPrompt">
    config?: JsonNullableWithAggregatesFilter<"AiPrompt">
    createdAt?: DateTimeWithAggregatesFilter<"AiPrompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiPrompt"> | Date | string
    modified?: BoolWithAggregatesFilter<"AiPrompt"> | boolean
  }

  export type AiSessionMessageWhereInput = {
    AND?: AiSessionMessageWhereInput | AiSessionMessageWhereInput[]
    OR?: AiSessionMessageWhereInput[]
    NOT?: AiSessionMessageWhereInput | AiSessionMessageWhereInput[]
    id?: StringFilter<"AiSessionMessage"> | string
    sessionId?: StringFilter<"AiSessionMessage"> | string
    role?: EnumAiPromptRoleFilter<"AiSessionMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiSessionMessage"> | string
    streamObjects?: JsonNullableFilter<"AiSessionMessage">
    attachments?: JsonNullableFilter<"AiSessionMessage">
    params?: JsonNullableFilter<"AiSessionMessage">
    createdAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
    session?: XOR<AiSessionScalarRelationFilter, AiSessionWhereInput>
  }

  export type AiSessionMessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    streamObjects?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: AiSessionOrderByWithRelationInput
  }

  export type AiSessionMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiSessionMessageWhereInput | AiSessionMessageWhereInput[]
    OR?: AiSessionMessageWhereInput[]
    NOT?: AiSessionMessageWhereInput | AiSessionMessageWhereInput[]
    sessionId?: StringFilter<"AiSessionMessage"> | string
    role?: EnumAiPromptRoleFilter<"AiSessionMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiSessionMessage"> | string
    streamObjects?: JsonNullableFilter<"AiSessionMessage">
    attachments?: JsonNullableFilter<"AiSessionMessage">
    params?: JsonNullableFilter<"AiSessionMessage">
    createdAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
    session?: XOR<AiSessionScalarRelationFilter, AiSessionWhereInput>
  }, "id">

  export type AiSessionMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    streamObjects?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    params?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiSessionMessageCountOrderByAggregateInput
    _max?: AiSessionMessageMaxOrderByAggregateInput
    _min?: AiSessionMessageMinOrderByAggregateInput
  }

  export type AiSessionMessageScalarWhereWithAggregatesInput = {
    AND?: AiSessionMessageScalarWhereWithAggregatesInput | AiSessionMessageScalarWhereWithAggregatesInput[]
    OR?: AiSessionMessageScalarWhereWithAggregatesInput[]
    NOT?: AiSessionMessageScalarWhereWithAggregatesInput | AiSessionMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiSessionMessage"> | string
    sessionId?: StringWithAggregatesFilter<"AiSessionMessage"> | string
    role?: EnumAiPromptRoleWithAggregatesFilter<"AiSessionMessage"> | $Enums.AiPromptRole
    content?: StringWithAggregatesFilter<"AiSessionMessage"> | string
    streamObjects?: JsonNullableWithAggregatesFilter<"AiSessionMessage">
    attachments?: JsonNullableWithAggregatesFilter<"AiSessionMessage">
    params?: JsonNullableWithAggregatesFilter<"AiSessionMessage">
    createdAt?: DateTimeWithAggregatesFilter<"AiSessionMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiSessionMessage"> | Date | string
  }

  export type AiSessionWhereInput = {
    AND?: AiSessionWhereInput | AiSessionWhereInput[]
    OR?: AiSessionWhereInput[]
    NOT?: AiSessionWhereInput | AiSessionWhereInput[]
    id?: StringFilter<"AiSession"> | string
    userId?: StringFilter<"AiSession"> | string
    workspaceId?: StringFilter<"AiSession"> | string
    docId?: StringNullableFilter<"AiSession"> | string | null
    promptName?: StringFilter<"AiSession"> | string
    promptAction?: StringNullableFilter<"AiSession"> | string | null
    pinned?: BoolFilter<"AiSession"> | boolean
    title?: StringNullableFilter<"AiSession"> | string | null
    parentSessionId?: StringNullableFilter<"AiSession"> | string | null
    messageCost?: IntFilter<"AiSession"> | number
    tokenCost?: IntFilter<"AiSession"> | number
    createdAt?: DateTimeFilter<"AiSession"> | Date | string
    updatedAt?: DateTimeFilter<"AiSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AiSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    prompt?: XOR<AiPromptScalarRelationFilter, AiPromptWhereInput>
    messages?: AiSessionMessageListRelationFilter
    context?: AiContextListRelationFilter
  }

  export type AiSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrderInput | SortOrder
    promptName?: SortOrder
    promptAction?: SortOrderInput | SortOrder
    pinned?: SortOrder
    title?: SortOrderInput | SortOrder
    parentSessionId?: SortOrderInput | SortOrder
    messageCost?: SortOrder
    tokenCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    prompt?: AiPromptOrderByWithRelationInput
    messages?: AiSessionMessageOrderByRelationAggregateInput
    context?: AiContextOrderByRelationAggregateInput
  }

  export type AiSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiSessionWhereInput | AiSessionWhereInput[]
    OR?: AiSessionWhereInput[]
    NOT?: AiSessionWhereInput | AiSessionWhereInput[]
    userId?: StringFilter<"AiSession"> | string
    workspaceId?: StringFilter<"AiSession"> | string
    docId?: StringNullableFilter<"AiSession"> | string | null
    promptName?: StringFilter<"AiSession"> | string
    promptAction?: StringNullableFilter<"AiSession"> | string | null
    pinned?: BoolFilter<"AiSession"> | boolean
    title?: StringNullableFilter<"AiSession"> | string | null
    parentSessionId?: StringNullableFilter<"AiSession"> | string | null
    messageCost?: IntFilter<"AiSession"> | number
    tokenCost?: IntFilter<"AiSession"> | number
    createdAt?: DateTimeFilter<"AiSession"> | Date | string
    updatedAt?: DateTimeFilter<"AiSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AiSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    prompt?: XOR<AiPromptScalarRelationFilter, AiPromptWhereInput>
    messages?: AiSessionMessageListRelationFilter
    context?: AiContextListRelationFilter
  }, "id">

  export type AiSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrderInput | SortOrder
    promptName?: SortOrder
    promptAction?: SortOrderInput | SortOrder
    pinned?: SortOrder
    title?: SortOrderInput | SortOrder
    parentSessionId?: SortOrderInput | SortOrder
    messageCost?: SortOrder
    tokenCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AiSessionCountOrderByAggregateInput
    _avg?: AiSessionAvgOrderByAggregateInput
    _max?: AiSessionMaxOrderByAggregateInput
    _min?: AiSessionMinOrderByAggregateInput
    _sum?: AiSessionSumOrderByAggregateInput
  }

  export type AiSessionScalarWhereWithAggregatesInput = {
    AND?: AiSessionScalarWhereWithAggregatesInput | AiSessionScalarWhereWithAggregatesInput[]
    OR?: AiSessionScalarWhereWithAggregatesInput[]
    NOT?: AiSessionScalarWhereWithAggregatesInput | AiSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiSession"> | string
    userId?: StringWithAggregatesFilter<"AiSession"> | string
    workspaceId?: StringWithAggregatesFilter<"AiSession"> | string
    docId?: StringNullableWithAggregatesFilter<"AiSession"> | string | null
    promptName?: StringWithAggregatesFilter<"AiSession"> | string
    promptAction?: StringNullableWithAggregatesFilter<"AiSession"> | string | null
    pinned?: BoolWithAggregatesFilter<"AiSession"> | boolean
    title?: StringNullableWithAggregatesFilter<"AiSession"> | string | null
    parentSessionId?: StringNullableWithAggregatesFilter<"AiSession"> | string | null
    messageCost?: IntWithAggregatesFilter<"AiSession"> | number
    tokenCost?: IntWithAggregatesFilter<"AiSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AiSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiSession"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"AiSession"> | Date | string | null
  }

  export type AiContextWhereInput = {
    AND?: AiContextWhereInput | AiContextWhereInput[]
    OR?: AiContextWhereInput[]
    NOT?: AiContextWhereInput | AiContextWhereInput[]
    id?: StringFilter<"AiContext"> | string
    sessionId?: StringFilter<"AiContext"> | string
    config?: JsonFilter<"AiContext">
    createdAt?: DateTimeFilter<"AiContext"> | Date | string
    updatedAt?: DateTimeFilter<"AiContext"> | Date | string
    embeddings?: AiContextEmbeddingListRelationFilter
    session?: XOR<AiSessionScalarRelationFilter, AiSessionWhereInput>
  }

  export type AiContextOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    embeddings?: AiContextEmbeddingOrderByRelationAggregateInput
    session?: AiSessionOrderByWithRelationInput
  }

  export type AiContextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiContextWhereInput | AiContextWhereInput[]
    OR?: AiContextWhereInput[]
    NOT?: AiContextWhereInput | AiContextWhereInput[]
    sessionId?: StringFilter<"AiContext"> | string
    config?: JsonFilter<"AiContext">
    createdAt?: DateTimeFilter<"AiContext"> | Date | string
    updatedAt?: DateTimeFilter<"AiContext"> | Date | string
    embeddings?: AiContextEmbeddingListRelationFilter
    session?: XOR<AiSessionScalarRelationFilter, AiSessionWhereInput>
  }, "id">

  export type AiContextOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiContextCountOrderByAggregateInput
    _max?: AiContextMaxOrderByAggregateInput
    _min?: AiContextMinOrderByAggregateInput
  }

  export type AiContextScalarWhereWithAggregatesInput = {
    AND?: AiContextScalarWhereWithAggregatesInput | AiContextScalarWhereWithAggregatesInput[]
    OR?: AiContextScalarWhereWithAggregatesInput[]
    NOT?: AiContextScalarWhereWithAggregatesInput | AiContextScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiContext"> | string
    sessionId?: StringWithAggregatesFilter<"AiContext"> | string
    config?: JsonWithAggregatesFilter<"AiContext">
    createdAt?: DateTimeWithAggregatesFilter<"AiContext"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiContext"> | Date | string
  }

  export type AiContextEmbeddingWhereInput = {
    AND?: AiContextEmbeddingWhereInput | AiContextEmbeddingWhereInput[]
    OR?: AiContextEmbeddingWhereInput[]
    NOT?: AiContextEmbeddingWhereInput | AiContextEmbeddingWhereInput[]
    id?: StringFilter<"AiContextEmbedding"> | string
    contextId?: StringFilter<"AiContextEmbedding"> | string
    fileId?: StringFilter<"AiContextEmbedding"> | string
    chunk?: IntFilter<"AiContextEmbedding"> | number
    content?: StringFilter<"AiContextEmbedding"> | string
    createdAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
    context?: XOR<AiContextScalarRelationFilter, AiContextWhereInput>
  }

  export type AiContextEmbeddingOrderByWithRelationInput = {
    id?: SortOrder
    contextId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    context?: AiContextOrderByWithRelationInput
  }

  export type AiContextEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contextId_fileId_chunk?: AiContextEmbeddingContextIdFileIdChunkCompoundUniqueInput
    AND?: AiContextEmbeddingWhereInput | AiContextEmbeddingWhereInput[]
    OR?: AiContextEmbeddingWhereInput[]
    NOT?: AiContextEmbeddingWhereInput | AiContextEmbeddingWhereInput[]
    contextId?: StringFilter<"AiContextEmbedding"> | string
    fileId?: StringFilter<"AiContextEmbedding"> | string
    chunk?: IntFilter<"AiContextEmbedding"> | number
    content?: StringFilter<"AiContextEmbedding"> | string
    createdAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
    context?: XOR<AiContextScalarRelationFilter, AiContextWhereInput>
  }, "id" | "contextId_fileId_chunk">

  export type AiContextEmbeddingOrderByWithAggregationInput = {
    id?: SortOrder
    contextId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiContextEmbeddingCountOrderByAggregateInput
    _avg?: AiContextEmbeddingAvgOrderByAggregateInput
    _max?: AiContextEmbeddingMaxOrderByAggregateInput
    _min?: AiContextEmbeddingMinOrderByAggregateInput
    _sum?: AiContextEmbeddingSumOrderByAggregateInput
  }

  export type AiContextEmbeddingScalarWhereWithAggregatesInput = {
    AND?: AiContextEmbeddingScalarWhereWithAggregatesInput | AiContextEmbeddingScalarWhereWithAggregatesInput[]
    OR?: AiContextEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: AiContextEmbeddingScalarWhereWithAggregatesInput | AiContextEmbeddingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiContextEmbedding"> | string
    contextId?: StringWithAggregatesFilter<"AiContextEmbedding"> | string
    fileId?: StringWithAggregatesFilter<"AiContextEmbedding"> | string
    chunk?: IntWithAggregatesFilter<"AiContextEmbedding"> | number
    content?: StringWithAggregatesFilter<"AiContextEmbedding"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiContextEmbedding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiContextEmbedding"> | Date | string
  }

  export type AiWorkspaceEmbeddingWhereInput = {
    AND?: AiWorkspaceEmbeddingWhereInput | AiWorkspaceEmbeddingWhereInput[]
    OR?: AiWorkspaceEmbeddingWhereInput[]
    NOT?: AiWorkspaceEmbeddingWhereInput | AiWorkspaceEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceEmbedding"> | string
    docId?: StringFilter<"AiWorkspaceEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceEmbedding"> | number
    content?: StringFilter<"AiWorkspaceEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
    snapshot?: XOR<SnapshotScalarRelationFilter, SnapshotWhereInput>
  }

  export type AiWorkspaceEmbeddingOrderByWithRelationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    snapshot?: SnapshotOrderByWithRelationInput
  }

  export type AiWorkspaceEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_docId_chunk?: AiWorkspaceEmbeddingWorkspaceIdDocIdChunkCompoundUniqueInput
    AND?: AiWorkspaceEmbeddingWhereInput | AiWorkspaceEmbeddingWhereInput[]
    OR?: AiWorkspaceEmbeddingWhereInput[]
    NOT?: AiWorkspaceEmbeddingWhereInput | AiWorkspaceEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceEmbedding"> | string
    docId?: StringFilter<"AiWorkspaceEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceEmbedding"> | number
    content?: StringFilter<"AiWorkspaceEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
    snapshot?: XOR<SnapshotScalarRelationFilter, SnapshotWhereInput>
  }, "workspaceId_docId_chunk">

  export type AiWorkspaceEmbeddingOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AiWorkspaceEmbeddingCountOrderByAggregateInput
    _avg?: AiWorkspaceEmbeddingAvgOrderByAggregateInput
    _max?: AiWorkspaceEmbeddingMaxOrderByAggregateInput
    _min?: AiWorkspaceEmbeddingMinOrderByAggregateInput
    _sum?: AiWorkspaceEmbeddingSumOrderByAggregateInput
  }

  export type AiWorkspaceEmbeddingScalarWhereWithAggregatesInput = {
    AND?: AiWorkspaceEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceEmbeddingScalarWhereWithAggregatesInput[]
    OR?: AiWorkspaceEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: AiWorkspaceEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceEmbeddingScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"AiWorkspaceEmbedding"> | string
    docId?: StringWithAggregatesFilter<"AiWorkspaceEmbedding"> | string
    chunk?: IntWithAggregatesFilter<"AiWorkspaceEmbedding"> | number
    content?: StringWithAggregatesFilter<"AiWorkspaceEmbedding"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiWorkspaceEmbedding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AiWorkspaceEmbedding"> | Date | string
  }

  export type AiWorkspaceIgnoredDocsWhereInput = {
    AND?: AiWorkspaceIgnoredDocsWhereInput | AiWorkspaceIgnoredDocsWhereInput[]
    OR?: AiWorkspaceIgnoredDocsWhereInput[]
    NOT?: AiWorkspaceIgnoredDocsWhereInput | AiWorkspaceIgnoredDocsWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    docId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceIgnoredDocs"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type AiWorkspaceIgnoredDocsOrderByWithRelationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type AiWorkspaceIgnoredDocsWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_docId?: AiWorkspaceIgnoredDocsWorkspaceIdDocIdCompoundUniqueInput
    AND?: AiWorkspaceIgnoredDocsWhereInput | AiWorkspaceIgnoredDocsWhereInput[]
    OR?: AiWorkspaceIgnoredDocsWhereInput[]
    NOT?: AiWorkspaceIgnoredDocsWhereInput | AiWorkspaceIgnoredDocsWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    docId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceIgnoredDocs"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "workspaceId_docId">

  export type AiWorkspaceIgnoredDocsOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
    _count?: AiWorkspaceIgnoredDocsCountOrderByAggregateInput
    _max?: AiWorkspaceIgnoredDocsMaxOrderByAggregateInput
    _min?: AiWorkspaceIgnoredDocsMinOrderByAggregateInput
  }

  export type AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput = {
    AND?: AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput | AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput[]
    OR?: AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput[]
    NOT?: AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput | AiWorkspaceIgnoredDocsScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"AiWorkspaceIgnoredDocs"> | string
    docId?: StringWithAggregatesFilter<"AiWorkspaceIgnoredDocs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiWorkspaceIgnoredDocs"> | Date | string
  }

  export type AiWorkspaceFilesWhereInput = {
    AND?: AiWorkspaceFilesWhereInput | AiWorkspaceFilesWhereInput[]
    OR?: AiWorkspaceFilesWhereInput[]
    NOT?: AiWorkspaceFilesWhereInput | AiWorkspaceFilesWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFiles"> | string
    fileId?: StringFilter<"AiWorkspaceFiles"> | string
    blobId?: StringFilter<"AiWorkspaceFiles"> | string
    fileName?: StringFilter<"AiWorkspaceFiles"> | string
    mimeType?: StringFilter<"AiWorkspaceFiles"> | string
    size?: IntFilter<"AiWorkspaceFiles"> | number
    createdAt?: DateTimeFilter<"AiWorkspaceFiles"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    embeddings?: AiWorkspaceFileEmbeddingListRelationFilter
  }

  export type AiWorkspaceFilesOrderByWithRelationInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    blobId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    embeddings?: AiWorkspaceFileEmbeddingOrderByRelationAggregateInput
  }

  export type AiWorkspaceFilesWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_fileId?: AiWorkspaceFilesWorkspaceIdFileIdCompoundUniqueInput
    AND?: AiWorkspaceFilesWhereInput | AiWorkspaceFilesWhereInput[]
    OR?: AiWorkspaceFilesWhereInput[]
    NOT?: AiWorkspaceFilesWhereInput | AiWorkspaceFilesWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFiles"> | string
    fileId?: StringFilter<"AiWorkspaceFiles"> | string
    blobId?: StringFilter<"AiWorkspaceFiles"> | string
    fileName?: StringFilter<"AiWorkspaceFiles"> | string
    mimeType?: StringFilter<"AiWorkspaceFiles"> | string
    size?: IntFilter<"AiWorkspaceFiles"> | number
    createdAt?: DateTimeFilter<"AiWorkspaceFiles"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    embeddings?: AiWorkspaceFileEmbeddingListRelationFilter
  }, "workspaceId_fileId">

  export type AiWorkspaceFilesOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    blobId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    _count?: AiWorkspaceFilesCountOrderByAggregateInput
    _avg?: AiWorkspaceFilesAvgOrderByAggregateInput
    _max?: AiWorkspaceFilesMaxOrderByAggregateInput
    _min?: AiWorkspaceFilesMinOrderByAggregateInput
    _sum?: AiWorkspaceFilesSumOrderByAggregateInput
  }

  export type AiWorkspaceFilesScalarWhereWithAggregatesInput = {
    AND?: AiWorkspaceFilesScalarWhereWithAggregatesInput | AiWorkspaceFilesScalarWhereWithAggregatesInput[]
    OR?: AiWorkspaceFilesScalarWhereWithAggregatesInput[]
    NOT?: AiWorkspaceFilesScalarWhereWithAggregatesInput | AiWorkspaceFilesScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"AiWorkspaceFiles"> | string
    fileId?: StringWithAggregatesFilter<"AiWorkspaceFiles"> | string
    blobId?: StringWithAggregatesFilter<"AiWorkspaceFiles"> | string
    fileName?: StringWithAggregatesFilter<"AiWorkspaceFiles"> | string
    mimeType?: StringWithAggregatesFilter<"AiWorkspaceFiles"> | string
    size?: IntWithAggregatesFilter<"AiWorkspaceFiles"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AiWorkspaceFiles"> | Date | string
  }

  export type AiWorkspaceFileEmbeddingWhereInput = {
    AND?: AiWorkspaceFileEmbeddingWhereInput | AiWorkspaceFileEmbeddingWhereInput[]
    OR?: AiWorkspaceFileEmbeddingWhereInput[]
    NOT?: AiWorkspaceFileEmbeddingWhereInput | AiWorkspaceFileEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    fileId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceFileEmbedding"> | number
    content?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceFileEmbedding"> | Date | string
    file?: XOR<AiWorkspaceFilesScalarRelationFilter, AiWorkspaceFilesWhereInput>
  }

  export type AiWorkspaceFileEmbeddingOrderByWithRelationInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    file?: AiWorkspaceFilesOrderByWithRelationInput
  }

  export type AiWorkspaceFileEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_fileId_chunk?: AiWorkspaceFileEmbeddingWorkspaceIdFileIdChunkCompoundUniqueInput
    AND?: AiWorkspaceFileEmbeddingWhereInput | AiWorkspaceFileEmbeddingWhereInput[]
    OR?: AiWorkspaceFileEmbeddingWhereInput[]
    NOT?: AiWorkspaceFileEmbeddingWhereInput | AiWorkspaceFileEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    fileId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceFileEmbedding"> | number
    content?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceFileEmbedding"> | Date | string
    file?: XOR<AiWorkspaceFilesScalarRelationFilter, AiWorkspaceFilesWhereInput>
  }, "workspaceId_fileId_chunk">

  export type AiWorkspaceFileEmbeddingOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AiWorkspaceFileEmbeddingCountOrderByAggregateInput
    _avg?: AiWorkspaceFileEmbeddingAvgOrderByAggregateInput
    _max?: AiWorkspaceFileEmbeddingMaxOrderByAggregateInput
    _min?: AiWorkspaceFileEmbeddingMinOrderByAggregateInput
    _sum?: AiWorkspaceFileEmbeddingSumOrderByAggregateInput
  }

  export type AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput = {
    AND?: AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput[]
    OR?: AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceFileEmbeddingScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"AiWorkspaceFileEmbedding"> | string
    fileId?: StringWithAggregatesFilter<"AiWorkspaceFileEmbedding"> | string
    chunk?: IntWithAggregatesFilter<"AiWorkspaceFileEmbedding"> | number
    content?: StringWithAggregatesFilter<"AiWorkspaceFileEmbedding"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiWorkspaceFileEmbedding"> | Date | string
  }

  export type AiWorkspaceBlobEmbeddingWhereInput = {
    AND?: AiWorkspaceBlobEmbeddingWhereInput | AiWorkspaceBlobEmbeddingWhereInput[]
    OR?: AiWorkspaceBlobEmbeddingWhereInput[]
    NOT?: AiWorkspaceBlobEmbeddingWhereInput | AiWorkspaceBlobEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    blobId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceBlobEmbedding"> | number
    content?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceBlobEmbedding"> | Date | string
    blob?: XOR<BlobScalarRelationFilter, BlobWhereInput>
  }

  export type AiWorkspaceBlobEmbeddingOrderByWithRelationInput = {
    workspaceId?: SortOrder
    blobId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    blob?: BlobOrderByWithRelationInput
  }

  export type AiWorkspaceBlobEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_blobId_chunk?: AiWorkspaceBlobEmbeddingWorkspaceIdBlobIdChunkCompoundUniqueInput
    AND?: AiWorkspaceBlobEmbeddingWhereInput | AiWorkspaceBlobEmbeddingWhereInput[]
    OR?: AiWorkspaceBlobEmbeddingWhereInput[]
    NOT?: AiWorkspaceBlobEmbeddingWhereInput | AiWorkspaceBlobEmbeddingWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    blobId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceBlobEmbedding"> | number
    content?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceBlobEmbedding"> | Date | string
    blob?: XOR<BlobScalarRelationFilter, BlobWhereInput>
  }, "workspaceId_blobId_chunk">

  export type AiWorkspaceBlobEmbeddingOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    blobId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: AiWorkspaceBlobEmbeddingCountOrderByAggregateInput
    _avg?: AiWorkspaceBlobEmbeddingAvgOrderByAggregateInput
    _max?: AiWorkspaceBlobEmbeddingMaxOrderByAggregateInput
    _min?: AiWorkspaceBlobEmbeddingMinOrderByAggregateInput
    _sum?: AiWorkspaceBlobEmbeddingSumOrderByAggregateInput
  }

  export type AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput = {
    AND?: AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput[]
    OR?: AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput | AiWorkspaceBlobEmbeddingScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"AiWorkspaceBlobEmbedding"> | string
    blobId?: StringWithAggregatesFilter<"AiWorkspaceBlobEmbedding"> | string
    chunk?: IntWithAggregatesFilter<"AiWorkspaceBlobEmbedding"> | number
    content?: StringWithAggregatesFilter<"AiWorkspaceBlobEmbedding"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AiWorkspaceBlobEmbedding"> | Date | string
  }

  export type AiJobsWhereInput = {
    AND?: AiJobsWhereInput | AiJobsWhereInput[]
    OR?: AiJobsWhereInput[]
    NOT?: AiJobsWhereInput | AiJobsWhereInput[]
    id?: StringFilter<"AiJobs"> | string
    workspaceId?: StringFilter<"AiJobs"> | string
    blobId?: StringFilter<"AiJobs"> | string
    createdBy?: StringNullableFilter<"AiJobs"> | string | null
    type?: EnumAiJobTypeFilter<"AiJobs"> | $Enums.AiJobType
    status?: EnumAiJobStatusFilter<"AiJobs"> | $Enums.AiJobStatus
    payload?: JsonFilter<"AiJobs">
    startedAt?: DateTimeFilter<"AiJobs"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiJobs"> | Date | string | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AiJobsOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    blobId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdByUser?: UserOrderByWithRelationInput
  }

  export type AiJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    createdBy_workspaceId_blobId?: AiJobsCreatedByWorkspaceIdBlobIdCompoundUniqueInput
    AND?: AiJobsWhereInput | AiJobsWhereInput[]
    OR?: AiJobsWhereInput[]
    NOT?: AiJobsWhereInput | AiJobsWhereInput[]
    workspaceId?: StringFilter<"AiJobs"> | string
    blobId?: StringFilter<"AiJobs"> | string
    createdBy?: StringNullableFilter<"AiJobs"> | string | null
    type?: EnumAiJobTypeFilter<"AiJobs"> | $Enums.AiJobType
    status?: EnumAiJobStatusFilter<"AiJobs"> | $Enums.AiJobStatus
    payload?: JsonFilter<"AiJobs">
    startedAt?: DateTimeFilter<"AiJobs"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiJobs"> | Date | string | null
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "createdBy_workspaceId_blobId">

  export type AiJobsOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    blobId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    _count?: AiJobsCountOrderByAggregateInput
    _max?: AiJobsMaxOrderByAggregateInput
    _min?: AiJobsMinOrderByAggregateInput
  }

  export type AiJobsScalarWhereWithAggregatesInput = {
    AND?: AiJobsScalarWhereWithAggregatesInput | AiJobsScalarWhereWithAggregatesInput[]
    OR?: AiJobsScalarWhereWithAggregatesInput[]
    NOT?: AiJobsScalarWhereWithAggregatesInput | AiJobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiJobs"> | string
    workspaceId?: StringWithAggregatesFilter<"AiJobs"> | string
    blobId?: StringWithAggregatesFilter<"AiJobs"> | string
    createdBy?: StringNullableWithAggregatesFilter<"AiJobs"> | string | null
    type?: EnumAiJobTypeWithAggregatesFilter<"AiJobs"> | $Enums.AiJobType
    status?: EnumAiJobStatusWithAggregatesFilter<"AiJobs"> | $Enums.AiJobStatus
    payload?: JsonWithAggregatesFilter<"AiJobs">
    startedAt?: DateTimeWithAggregatesFilter<"AiJobs"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"AiJobs"> | Date | string | null
  }

  export type DataMigrationWhereInput = {
    AND?: DataMigrationWhereInput | DataMigrationWhereInput[]
    OR?: DataMigrationWhereInput[]
    NOT?: DataMigrationWhereInput | DataMigrationWhereInput[]
    id?: StringFilter<"DataMigration"> | string
    name?: StringFilter<"DataMigration"> | string
    startedAt?: DateTimeFilter<"DataMigration"> | Date | string
    finishedAt?: DateTimeNullableFilter<"DataMigration"> | Date | string | null
  }

  export type DataMigrationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
  }

  export type DataMigrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DataMigrationWhereInput | DataMigrationWhereInput[]
    OR?: DataMigrationWhereInput[]
    NOT?: DataMigrationWhereInput | DataMigrationWhereInput[]
    startedAt?: DateTimeFilter<"DataMigration"> | Date | string
    finishedAt?: DateTimeNullableFilter<"DataMigration"> | Date | string | null
  }, "id" | "name">

  export type DataMigrationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrderInput | SortOrder
    _count?: DataMigrationCountOrderByAggregateInput
    _max?: DataMigrationMaxOrderByAggregateInput
    _min?: DataMigrationMinOrderByAggregateInput
  }

  export type DataMigrationScalarWhereWithAggregatesInput = {
    AND?: DataMigrationScalarWhereWithAggregatesInput | DataMigrationScalarWhereWithAggregatesInput[]
    OR?: DataMigrationScalarWhereWithAggregatesInput[]
    NOT?: DataMigrationScalarWhereWithAggregatesInput | DataMigrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataMigration"> | string
    name?: StringWithAggregatesFilter<"DataMigration"> | string
    startedAt?: DateTimeWithAggregatesFilter<"DataMigration"> | Date | string
    finishedAt?: DateTimeNullableWithAggregatesFilter<"DataMigration"> | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsWhereInput = {
    AND?: DeprecatedAppRuntimeSettingsWhereInput | DeprecatedAppRuntimeSettingsWhereInput[]
    OR?: DeprecatedAppRuntimeSettingsWhereInput[]
    NOT?: DeprecatedAppRuntimeSettingsWhereInput | DeprecatedAppRuntimeSettingsWhereInput[]
    id?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    type?: EnumRuntimeConfigTypeFilter<"DeprecatedAppRuntimeSettings"> | $Enums.RuntimeConfigType
    module?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    key?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    value?: JsonFilter<"DeprecatedAppRuntimeSettings">
    description?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    updatedAt?: DateTimeFilter<"DeprecatedAppRuntimeSettings"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeprecatedAppRuntimeSettings"> | Date | string | null
    lastUpdatedBy?: StringNullableFilter<"DeprecatedAppRuntimeSettings"> | string | null
    lastUpdatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DeprecatedAppRuntimeSettingsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    module?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastUpdatedBy?: SortOrderInput | SortOrder
    lastUpdatedByUser?: UserOrderByWithRelationInput
  }

  export type DeprecatedAppRuntimeSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    module_key?: DeprecatedAppRuntimeSettingsModuleKeyCompoundUniqueInput
    AND?: DeprecatedAppRuntimeSettingsWhereInput | DeprecatedAppRuntimeSettingsWhereInput[]
    OR?: DeprecatedAppRuntimeSettingsWhereInput[]
    NOT?: DeprecatedAppRuntimeSettingsWhereInput | DeprecatedAppRuntimeSettingsWhereInput[]
    type?: EnumRuntimeConfigTypeFilter<"DeprecatedAppRuntimeSettings"> | $Enums.RuntimeConfigType
    module?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    key?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    value?: JsonFilter<"DeprecatedAppRuntimeSettings">
    description?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    updatedAt?: DateTimeFilter<"DeprecatedAppRuntimeSettings"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeprecatedAppRuntimeSettings"> | Date | string | null
    lastUpdatedBy?: StringNullableFilter<"DeprecatedAppRuntimeSettings"> | string | null
    lastUpdatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "module_key">

  export type DeprecatedAppRuntimeSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    module?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastUpdatedBy?: SortOrderInput | SortOrder
    _count?: DeprecatedAppRuntimeSettingsCountOrderByAggregateInput
    _max?: DeprecatedAppRuntimeSettingsMaxOrderByAggregateInput
    _min?: DeprecatedAppRuntimeSettingsMinOrderByAggregateInput
  }

  export type DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput = {
    AND?: DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput | DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput[]
    OR?: DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput[]
    NOT?: DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput | DeprecatedAppRuntimeSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | string
    type?: EnumRuntimeConfigTypeWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | $Enums.RuntimeConfigType
    module?: StringWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | string
    key?: StringWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | string
    value?: JsonWithAggregatesFilter<"DeprecatedAppRuntimeSettings">
    description?: StringWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | Date | string | null
    lastUpdatedBy?: StringNullableWithAggregatesFilter<"DeprecatedAppRuntimeSettings"> | string | null
  }

  export type AppConfigWhereInput = {
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    id?: StringFilter<"AppConfig"> | string
    value?: JsonFilter<"AppConfig">
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
    lastUpdatedBy?: StringNullableFilter<"AppConfig"> | string | null
    lastUpdatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AppConfigOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdatedBy?: SortOrderInput | SortOrder
    lastUpdatedByUser?: UserOrderByWithRelationInput
  }

  export type AppConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    value?: JsonFilter<"AppConfig">
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
    lastUpdatedBy?: StringNullableFilter<"AppConfig"> | string | null
    lastUpdatedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AppConfigOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdatedBy?: SortOrderInput | SortOrder
    _count?: AppConfigCountOrderByAggregateInput
    _max?: AppConfigMaxOrderByAggregateInput
    _min?: AppConfigMinOrderByAggregateInput
  }

  export type AppConfigScalarWhereWithAggregatesInput = {
    AND?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    OR?: AppConfigScalarWhereWithAggregatesInput[]
    NOT?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AppConfig"> | string
    value?: JsonWithAggregatesFilter<"AppConfig">
    createdAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppConfig"> | Date | string
    lastUpdatedBy?: StringNullableWithAggregatesFilter<"AppConfig"> | string | null
  }

  export type DeprecatedUserSubscriptionWhereInput = {
    AND?: DeprecatedUserSubscriptionWhereInput | DeprecatedUserSubscriptionWhereInput[]
    OR?: DeprecatedUserSubscriptionWhereInput[]
    NOT?: DeprecatedUserSubscriptionWhereInput | DeprecatedUserSubscriptionWhereInput[]
    id?: IntFilter<"DeprecatedUserSubscription"> | number
    userId?: StringFilter<"DeprecatedUserSubscription"> | string
    plan?: StringFilter<"DeprecatedUserSubscription"> | string
    recurring?: StringFilter<"DeprecatedUserSubscription"> | string
    variant?: StringNullableFilter<"DeprecatedUserSubscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"DeprecatedUserSubscription"> | string | null
    status?: StringFilter<"DeprecatedUserSubscription"> | string
    start?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
    end?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    nextBillAt?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    stripeScheduleId?: StringNullableFilter<"DeprecatedUserSubscription"> | string | null
    createdAt?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
  }

  export type DeprecatedUserSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    nextBillAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    stripeScheduleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeprecatedUserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripeSubscriptionId?: string
    userId_plan?: DeprecatedUserSubscriptionUserIdPlanCompoundUniqueInput
    AND?: DeprecatedUserSubscriptionWhereInput | DeprecatedUserSubscriptionWhereInput[]
    OR?: DeprecatedUserSubscriptionWhereInput[]
    NOT?: DeprecatedUserSubscriptionWhereInput | DeprecatedUserSubscriptionWhereInput[]
    userId?: StringFilter<"DeprecatedUserSubscription"> | string
    plan?: StringFilter<"DeprecatedUserSubscription"> | string
    recurring?: StringFilter<"DeprecatedUserSubscription"> | string
    variant?: StringNullableFilter<"DeprecatedUserSubscription"> | string | null
    status?: StringFilter<"DeprecatedUserSubscription"> | string
    start?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
    end?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    nextBillAt?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"DeprecatedUserSubscription"> | Date | string | null
    stripeScheduleId?: StringNullableFilter<"DeprecatedUserSubscription"> | string | null
    createdAt?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"DeprecatedUserSubscription"> | Date | string
  }, "id" | "stripeSubscriptionId" | "userId_plan">

  export type DeprecatedUserSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    nextBillAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    stripeScheduleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeprecatedUserSubscriptionCountOrderByAggregateInput
    _avg?: DeprecatedUserSubscriptionAvgOrderByAggregateInput
    _max?: DeprecatedUserSubscriptionMaxOrderByAggregateInput
    _min?: DeprecatedUserSubscriptionMinOrderByAggregateInput
    _sum?: DeprecatedUserSubscriptionSumOrderByAggregateInput
  }

  export type DeprecatedUserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: DeprecatedUserSubscriptionScalarWhereWithAggregatesInput | DeprecatedUserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: DeprecatedUserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: DeprecatedUserSubscriptionScalarWhereWithAggregatesInput | DeprecatedUserSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeprecatedUserSubscription"> | number
    userId?: StringWithAggregatesFilter<"DeprecatedUserSubscription"> | string
    plan?: StringWithAggregatesFilter<"DeprecatedUserSubscription"> | string
    recurring?: StringWithAggregatesFilter<"DeprecatedUserSubscription"> | string
    variant?: StringNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | string | null
    status?: StringWithAggregatesFilter<"DeprecatedUserSubscription"> | string
    start?: DateTimeWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string | null
    nextBillAt?: DateTimeNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string | null
    stripeScheduleId?: StringNullableWithAggregatesFilter<"DeprecatedUserSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeprecatedUserSubscription"> | Date | string
  }

  export type DeprecatedUserInvoiceWhereInput = {
    AND?: DeprecatedUserInvoiceWhereInput | DeprecatedUserInvoiceWhereInput[]
    OR?: DeprecatedUserInvoiceWhereInput[]
    NOT?: DeprecatedUserInvoiceWhereInput | DeprecatedUserInvoiceWhereInput[]
    id?: IntFilter<"DeprecatedUserInvoice"> | number
    userId?: StringFilter<"DeprecatedUserInvoice"> | string
    stripeInvoiceId?: StringFilter<"DeprecatedUserInvoice"> | string
    currency?: StringFilter<"DeprecatedUserInvoice"> | string
    amount?: IntFilter<"DeprecatedUserInvoice"> | number
    status?: StringFilter<"DeprecatedUserInvoice"> | string
    createdAt?: DateTimeFilter<"DeprecatedUserInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"DeprecatedUserInvoice"> | Date | string
    reason?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    lastPaymentError?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    link?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    plan?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    recurring?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
  }

  export type DeprecatedUserInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeInvoiceId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    lastPaymentError?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    recurring?: SortOrderInput | SortOrder
  }

  export type DeprecatedUserInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripeInvoiceId?: string
    AND?: DeprecatedUserInvoiceWhereInput | DeprecatedUserInvoiceWhereInput[]
    OR?: DeprecatedUserInvoiceWhereInput[]
    NOT?: DeprecatedUserInvoiceWhereInput | DeprecatedUserInvoiceWhereInput[]
    userId?: StringFilter<"DeprecatedUserInvoice"> | string
    currency?: StringFilter<"DeprecatedUserInvoice"> | string
    amount?: IntFilter<"DeprecatedUserInvoice"> | number
    status?: StringFilter<"DeprecatedUserInvoice"> | string
    createdAt?: DateTimeFilter<"DeprecatedUserInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"DeprecatedUserInvoice"> | Date | string
    reason?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    lastPaymentError?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    link?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    plan?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
    recurring?: StringNullableFilter<"DeprecatedUserInvoice"> | string | null
  }, "id" | "stripeInvoiceId">

  export type DeprecatedUserInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeInvoiceId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    lastPaymentError?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    recurring?: SortOrderInput | SortOrder
    _count?: DeprecatedUserInvoiceCountOrderByAggregateInput
    _avg?: DeprecatedUserInvoiceAvgOrderByAggregateInput
    _max?: DeprecatedUserInvoiceMaxOrderByAggregateInput
    _min?: DeprecatedUserInvoiceMinOrderByAggregateInput
    _sum?: DeprecatedUserInvoiceSumOrderByAggregateInput
  }

  export type DeprecatedUserInvoiceScalarWhereWithAggregatesInput = {
    AND?: DeprecatedUserInvoiceScalarWhereWithAggregatesInput | DeprecatedUserInvoiceScalarWhereWithAggregatesInput[]
    OR?: DeprecatedUserInvoiceScalarWhereWithAggregatesInput[]
    NOT?: DeprecatedUserInvoiceScalarWhereWithAggregatesInput | DeprecatedUserInvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeprecatedUserInvoice"> | number
    userId?: StringWithAggregatesFilter<"DeprecatedUserInvoice"> | string
    stripeInvoiceId?: StringWithAggregatesFilter<"DeprecatedUserInvoice"> | string
    currency?: StringWithAggregatesFilter<"DeprecatedUserInvoice"> | string
    amount?: IntWithAggregatesFilter<"DeprecatedUserInvoice"> | number
    status?: StringWithAggregatesFilter<"DeprecatedUserInvoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeprecatedUserInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeprecatedUserInvoice"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"DeprecatedUserInvoice"> | string | null
    lastPaymentError?: StringNullableWithAggregatesFilter<"DeprecatedUserInvoice"> | string | null
    link?: StringNullableWithAggregatesFilter<"DeprecatedUserInvoice"> | string | null
    plan?: StringNullableWithAggregatesFilter<"DeprecatedUserInvoice"> | string | null
    recurring?: StringNullableWithAggregatesFilter<"DeprecatedUserInvoice"> | string | null
  }

  export type UserStripeCustomerWhereInput = {
    AND?: UserStripeCustomerWhereInput | UserStripeCustomerWhereInput[]
    OR?: UserStripeCustomerWhereInput[]
    NOT?: UserStripeCustomerWhereInput | UserStripeCustomerWhereInput[]
    userId?: StringFilter<"UserStripeCustomer"> | string
    stripeCustomerId?: StringFilter<"UserStripeCustomer"> | string
    createdAt?: DateTimeFilter<"UserStripeCustomer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserStripeCustomerOrderByWithRelationInput = {
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStripeCustomerWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    stripeCustomerId?: string
    AND?: UserStripeCustomerWhereInput | UserStripeCustomerWhereInput[]
    OR?: UserStripeCustomerWhereInput[]
    NOT?: UserStripeCustomerWhereInput | UserStripeCustomerWhereInput[]
    createdAt?: DateTimeFilter<"UserStripeCustomer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId" | "stripeCustomerId">

  export type UserStripeCustomerOrderByWithAggregationInput = {
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    _count?: UserStripeCustomerCountOrderByAggregateInput
    _max?: UserStripeCustomerMaxOrderByAggregateInput
    _min?: UserStripeCustomerMinOrderByAggregateInput
  }

  export type UserStripeCustomerScalarWhereWithAggregatesInput = {
    AND?: UserStripeCustomerScalarWhereWithAggregatesInput | UserStripeCustomerScalarWhereWithAggregatesInput[]
    OR?: UserStripeCustomerScalarWhereWithAggregatesInput[]
    NOT?: UserStripeCustomerScalarWhereWithAggregatesInput | UserStripeCustomerScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserStripeCustomer"> | string
    stripeCustomerId?: StringWithAggregatesFilter<"UserStripeCustomer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserStripeCustomer"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    targetId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    recurring?: StringFilter<"Subscription"> | string
    variant?: StringNullableFilter<"Subscription"> | string | null
    quantity?: IntFilter<"Subscription"> | number
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeScheduleId?: StringNullableFilter<"Subscription"> | string | null
    provider?: EnumProviderFilter<"Subscription"> | $Enums.Provider
    iapStore?: EnumIapStoreNullableFilter<"Subscription"> | $Enums.IapStore | null
    rcEntitlement?: StringNullableFilter<"Subscription"> | string | null
    rcProductId?: StringNullableFilter<"Subscription"> | string | null
    rcExternalRef?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    start?: DateTimeFilter<"Subscription"> | Date | string
    end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    nextBillAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    targetId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    quantity?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeScheduleId?: SortOrderInput | SortOrder
    provider?: SortOrder
    iapStore?: SortOrderInput | SortOrder
    rcEntitlement?: SortOrderInput | SortOrder
    rcProductId?: SortOrderInput | SortOrder
    rcExternalRef?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    nextBillAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stripeSubscriptionId?: string
    targetId_plan?: SubscriptionTargetIdPlanCompoundUniqueInput
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    targetId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    recurring?: StringFilter<"Subscription"> | string
    variant?: StringNullableFilter<"Subscription"> | string | null
    quantity?: IntFilter<"Subscription"> | number
    stripeScheduleId?: StringNullableFilter<"Subscription"> | string | null
    provider?: EnumProviderFilter<"Subscription"> | $Enums.Provider
    iapStore?: EnumIapStoreNullableFilter<"Subscription"> | $Enums.IapStore | null
    rcEntitlement?: StringNullableFilter<"Subscription"> | string | null
    rcProductId?: StringNullableFilter<"Subscription"> | string | null
    rcExternalRef?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    start?: DateTimeFilter<"Subscription"> | Date | string
    end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    nextBillAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }, "id" | "stripeSubscriptionId" | "targetId_plan">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    targetId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    quantity?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeScheduleId?: SortOrderInput | SortOrder
    provider?: SortOrder
    iapStore?: SortOrderInput | SortOrder
    rcEntitlement?: SortOrderInput | SortOrder
    rcProductId?: SortOrderInput | SortOrder
    rcExternalRef?: SortOrderInput | SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    nextBillAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    targetId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    recurring?: StringWithAggregatesFilter<"Subscription"> | string
    variant?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    quantity?: IntWithAggregatesFilter<"Subscription"> | number
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeScheduleId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    provider?: EnumProviderWithAggregatesFilter<"Subscription"> | $Enums.Provider
    iapStore?: EnumIapStoreNullableWithAggregatesFilter<"Subscription"> | $Enums.IapStore | null
    rcEntitlement?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    rcProductId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    rcExternalRef?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    start?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    nextBillAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    stripeInvoiceId?: StringFilter<"Invoice"> | string
    targetId?: StringFilter<"Invoice"> | string
    currency?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    reason?: StringNullableFilter<"Invoice"> | string | null
    lastPaymentError?: StringNullableFilter<"Invoice"> | string | null
    link?: StringNullableFilter<"Invoice"> | string | null
    onetimeSubscriptionRedeemed?: BoolFilter<"Invoice"> | boolean
  }

  export type InvoiceOrderByWithRelationInput = {
    stripeInvoiceId?: SortOrder
    targetId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    lastPaymentError?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    onetimeSubscriptionRedeemed?: SortOrder
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    stripeInvoiceId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    targetId?: StringFilter<"Invoice"> | string
    currency?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    reason?: StringNullableFilter<"Invoice"> | string | null
    lastPaymentError?: StringNullableFilter<"Invoice"> | string | null
    link?: StringNullableFilter<"Invoice"> | string | null
    onetimeSubscriptionRedeemed?: BoolFilter<"Invoice"> | boolean
  }, "stripeInvoiceId">

  export type InvoiceOrderByWithAggregationInput = {
    stripeInvoiceId?: SortOrder
    targetId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrderInput | SortOrder
    lastPaymentError?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    onetimeSubscriptionRedeemed?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    stripeInvoiceId?: StringWithAggregatesFilter<"Invoice"> | string
    targetId?: StringWithAggregatesFilter<"Invoice"> | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: IntWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    lastPaymentError?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    link?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    onetimeSubscriptionRedeemed?: BoolWithAggregatesFilter<"Invoice"> | boolean
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    key?: StringFilter<"License"> | string
    createdAt?: DateTimeFilter<"License"> | Date | string
    revealedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    installedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    validateKey?: StringNullableFilter<"License"> | string | null
  }

  export type LicenseOrderByWithRelationInput = {
    key?: SortOrder
    createdAt?: SortOrder
    revealedAt?: SortOrderInput | SortOrder
    installedAt?: SortOrderInput | SortOrder
    validateKey?: SortOrderInput | SortOrder
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    createdAt?: DateTimeFilter<"License"> | Date | string
    revealedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    installedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    validateKey?: StringNullableFilter<"License"> | string | null
  }, "key">

  export type LicenseOrderByWithAggregationInput = {
    key?: SortOrder
    createdAt?: SortOrder
    revealedAt?: SortOrderInput | SortOrder
    installedAt?: SortOrderInput | SortOrder
    validateKey?: SortOrderInput | SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"License"> | string
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    revealedAt?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    installedAt?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    validateKey?: StringNullableWithAggregatesFilter<"License"> | string | null
  }

  export type InstalledLicenseWhereInput = {
    AND?: InstalledLicenseWhereInput | InstalledLicenseWhereInput[]
    OR?: InstalledLicenseWhereInput[]
    NOT?: InstalledLicenseWhereInput | InstalledLicenseWhereInput[]
    key?: StringFilter<"InstalledLicense"> | string
    workspaceId?: StringFilter<"InstalledLicense"> | string
    quantity?: IntFilter<"InstalledLicense"> | number
    recurring?: StringFilter<"InstalledLicense"> | string
    variant?: StringNullableFilter<"InstalledLicense"> | string | null
    installedAt?: DateTimeFilter<"InstalledLicense"> | Date | string
    validateKey?: StringFilter<"InstalledLicense"> | string
    validatedAt?: DateTimeFilter<"InstalledLicense"> | Date | string
    expiredAt?: DateTimeNullableFilter<"InstalledLicense"> | Date | string | null
    license?: BytesNullableFilter<"InstalledLicense"> | Uint8Array | null
  }

  export type InstalledLicenseOrderByWithRelationInput = {
    key?: SortOrder
    workspaceId?: SortOrder
    quantity?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
    validatedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
  }

  export type InstalledLicenseWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    workspaceId?: string
    AND?: InstalledLicenseWhereInput | InstalledLicenseWhereInput[]
    OR?: InstalledLicenseWhereInput[]
    NOT?: InstalledLicenseWhereInput | InstalledLicenseWhereInput[]
    quantity?: IntFilter<"InstalledLicense"> | number
    recurring?: StringFilter<"InstalledLicense"> | string
    variant?: StringNullableFilter<"InstalledLicense"> | string | null
    installedAt?: DateTimeFilter<"InstalledLicense"> | Date | string
    validateKey?: StringFilter<"InstalledLicense"> | string
    validatedAt?: DateTimeFilter<"InstalledLicense"> | Date | string
    expiredAt?: DateTimeNullableFilter<"InstalledLicense"> | Date | string | null
    license?: BytesNullableFilter<"InstalledLicense"> | Uint8Array | null
  }, "key" | "workspaceId">

  export type InstalledLicenseOrderByWithAggregationInput = {
    key?: SortOrder
    workspaceId?: SortOrder
    quantity?: SortOrder
    recurring?: SortOrder
    variant?: SortOrderInput | SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
    validatedAt?: SortOrder
    expiredAt?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    _count?: InstalledLicenseCountOrderByAggregateInput
    _avg?: InstalledLicenseAvgOrderByAggregateInput
    _max?: InstalledLicenseMaxOrderByAggregateInput
    _min?: InstalledLicenseMinOrderByAggregateInput
    _sum?: InstalledLicenseSumOrderByAggregateInput
  }

  export type InstalledLicenseScalarWhereWithAggregatesInput = {
    AND?: InstalledLicenseScalarWhereWithAggregatesInput | InstalledLicenseScalarWhereWithAggregatesInput[]
    OR?: InstalledLicenseScalarWhereWithAggregatesInput[]
    NOT?: InstalledLicenseScalarWhereWithAggregatesInput | InstalledLicenseScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"InstalledLicense"> | string
    workspaceId?: StringWithAggregatesFilter<"InstalledLicense"> | string
    quantity?: IntWithAggregatesFilter<"InstalledLicense"> | number
    recurring?: StringWithAggregatesFilter<"InstalledLicense"> | string
    variant?: StringNullableWithAggregatesFilter<"InstalledLicense"> | string | null
    installedAt?: DateTimeWithAggregatesFilter<"InstalledLicense"> | Date | string
    validateKey?: StringWithAggregatesFilter<"InstalledLicense"> | string
    validatedAt?: DateTimeWithAggregatesFilter<"InstalledLicense"> | Date | string
    expiredAt?: DateTimeNullableWithAggregatesFilter<"InstalledLicense"> | Date | string | null
    license?: BytesNullableWithAggregatesFilter<"InstalledLicense"> | Uint8Array | null
  }

  export type BlobWhereInput = {
    AND?: BlobWhereInput | BlobWhereInput[]
    OR?: BlobWhereInput[]
    NOT?: BlobWhereInput | BlobWhereInput[]
    workspaceId?: StringFilter<"Blob"> | string
    key?: StringFilter<"Blob"> | string
    size?: IntFilter<"Blob"> | number
    mime?: StringFilter<"Blob"> | string
    createdAt?: DateTimeFilter<"Blob"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Blob"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingListRelationFilter
  }

  export type BlobOrderByWithRelationInput = {
    workspaceId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingOrderByRelationAggregateInput
  }

  export type BlobWhereUniqueInput = Prisma.AtLeast<{
    workspaceId_key?: BlobWorkspaceIdKeyCompoundUniqueInput
    AND?: BlobWhereInput | BlobWhereInput[]
    OR?: BlobWhereInput[]
    NOT?: BlobWhereInput | BlobWhereInput[]
    workspaceId?: StringFilter<"Blob"> | string
    key?: StringFilter<"Blob"> | string
    size?: IntFilter<"Blob"> | number
    mime?: StringFilter<"Blob"> | string
    createdAt?: DateTimeFilter<"Blob"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Blob"> | Date | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingListRelationFilter
  }, "workspaceId_key">

  export type BlobOrderByWithAggregationInput = {
    workspaceId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BlobCountOrderByAggregateInput
    _avg?: BlobAvgOrderByAggregateInput
    _max?: BlobMaxOrderByAggregateInput
    _min?: BlobMinOrderByAggregateInput
    _sum?: BlobSumOrderByAggregateInput
  }

  export type BlobScalarWhereWithAggregatesInput = {
    AND?: BlobScalarWhereWithAggregatesInput | BlobScalarWhereWithAggregatesInput[]
    OR?: BlobScalarWhereWithAggregatesInput[]
    NOT?: BlobScalarWhereWithAggregatesInput | BlobScalarWhereWithAggregatesInput[]
    workspaceId?: StringWithAggregatesFilter<"Blob"> | string
    key?: StringWithAggregatesFilter<"Blob"> | string
    size?: IntWithAggregatesFilter<"Blob"> | number
    mime?: StringWithAggregatesFilter<"Blob"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Blob"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Blob"> | Date | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    level?: EnumNotificationLevelFilter<"Notification"> | $Enums.NotificationLevel
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    body?: JsonFilter<"Notification">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    read?: SortOrder
    type?: SortOrder
    body?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    level?: EnumNotificationLevelFilter<"Notification"> | $Enums.NotificationLevel
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    body?: JsonFilter<"Notification">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    read?: SortOrder
    type?: SortOrder
    body?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    level?: EnumNotificationLevelWithAggregatesFilter<"Notification"> | $Enums.NotificationLevel
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    body?: JsonWithAggregatesFilter<"Notification">
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    userId?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    payload?: JsonFilter<"UserSettings">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payload?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    payload?: JsonFilter<"UserSettings">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payload?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    payload?: JsonWithAggregatesFilter<"UserSettings">
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    sid?: IntFilter<"Comment"> | number
    id?: StringFilter<"Comment"> | string
    workspaceId?: StringFilter<"Comment"> | string
    docId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: JsonFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    resolved?: BoolFilter<"Comment"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    replies?: ReplyListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    sid?: SortOrder
    id?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    resolved?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    replies?: ReplyOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    sid?: number
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    workspaceId?: StringFilter<"Comment"> | string
    docId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: JsonFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    resolved?: BoolFilter<"Comment"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    replies?: ReplyListRelationFilter
  }, "id" | "sid">

  export type CommentOrderByWithAggregationInput = {
    sid?: SortOrder
    id?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    resolved?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    sid?: IntWithAggregatesFilter<"Comment"> | number
    id?: StringWithAggregatesFilter<"Comment"> | string
    workspaceId?: StringWithAggregatesFilter<"Comment"> | string
    docId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    content?: JsonWithAggregatesFilter<"Comment">
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
    resolved?: BoolWithAggregatesFilter<"Comment"> | boolean
  }

  export type ReplyWhereInput = {
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    sid?: IntFilter<"Reply"> | number
    id?: StringFilter<"Reply"> | string
    userId?: StringFilter<"Reply"> | string
    commentId?: StringFilter<"Reply"> | string
    workspaceId?: StringFilter<"Reply"> | string
    docId?: StringFilter<"Reply"> | string
    content?: JsonFilter<"Reply">
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reply"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }

  export type ReplyOrderByWithRelationInput = {
    sid?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type ReplyWhereUniqueInput = Prisma.AtLeast<{
    sid?: number
    id?: string
    AND?: ReplyWhereInput | ReplyWhereInput[]
    OR?: ReplyWhereInput[]
    NOT?: ReplyWhereInput | ReplyWhereInput[]
    userId?: StringFilter<"Reply"> | string
    commentId?: StringFilter<"Reply"> | string
    workspaceId?: StringFilter<"Reply"> | string
    docId?: StringFilter<"Reply"> | string
    content?: JsonFilter<"Reply">
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reply"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }, "id" | "sid">

  export type ReplyOrderByWithAggregationInput = {
    sid?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReplyCountOrderByAggregateInput
    _avg?: ReplyAvgOrderByAggregateInput
    _max?: ReplyMaxOrderByAggregateInput
    _min?: ReplyMinOrderByAggregateInput
    _sum?: ReplySumOrderByAggregateInput
  }

  export type ReplyScalarWhereWithAggregatesInput = {
    AND?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    OR?: ReplyScalarWhereWithAggregatesInput[]
    NOT?: ReplyScalarWhereWithAggregatesInput | ReplyScalarWhereWithAggregatesInput[]
    sid?: IntWithAggregatesFilter<"Reply"> | number
    id?: StringWithAggregatesFilter<"Reply"> | string
    userId?: StringWithAggregatesFilter<"Reply"> | string
    commentId?: StringWithAggregatesFilter<"Reply"> | string
    workspaceId?: StringWithAggregatesFilter<"Reply"> | string
    docId?: StringWithAggregatesFilter<"Reply"> | string
    content?: JsonWithAggregatesFilter<"Reply">
    createdAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reply"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Reply"> | Date | string | null
  }

  export type CommentAttachmentWhereInput = {
    AND?: CommentAttachmentWhereInput | CommentAttachmentWhereInput[]
    OR?: CommentAttachmentWhereInput[]
    NOT?: CommentAttachmentWhereInput | CommentAttachmentWhereInput[]
    sid?: IntFilter<"CommentAttachment"> | number
    workspaceId?: StringFilter<"CommentAttachment"> | string
    docId?: StringFilter<"CommentAttachment"> | string
    key?: StringFilter<"CommentAttachment"> | string
    size?: IntFilter<"CommentAttachment"> | number
    mime?: StringFilter<"CommentAttachment"> | string
    name?: StringFilter<"CommentAttachment"> | string
    createdAt?: DateTimeFilter<"CommentAttachment"> | Date | string
    createdBy?: StringNullableFilter<"CommentAttachment"> | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CommentAttachmentOrderByWithRelationInput = {
    sid?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type CommentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    sid?: number
    workspaceId_docId_key?: CommentAttachmentWorkspaceIdDocIdKeyCompoundUniqueInput
    AND?: CommentAttachmentWhereInput | CommentAttachmentWhereInput[]
    OR?: CommentAttachmentWhereInput[]
    NOT?: CommentAttachmentWhereInput | CommentAttachmentWhereInput[]
    workspaceId?: StringFilter<"CommentAttachment"> | string
    docId?: StringFilter<"CommentAttachment"> | string
    key?: StringFilter<"CommentAttachment"> | string
    size?: IntFilter<"CommentAttachment"> | number
    mime?: StringFilter<"CommentAttachment"> | string
    name?: StringFilter<"CommentAttachment"> | string
    createdAt?: DateTimeFilter<"CommentAttachment"> | Date | string
    createdBy?: StringNullableFilter<"CommentAttachment"> | string | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    createdByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "workspaceId_docId_key" | "sid">

  export type CommentAttachmentOrderByWithAggregationInput = {
    sid?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: CommentAttachmentCountOrderByAggregateInput
    _avg?: CommentAttachmentAvgOrderByAggregateInput
    _max?: CommentAttachmentMaxOrderByAggregateInput
    _min?: CommentAttachmentMinOrderByAggregateInput
    _sum?: CommentAttachmentSumOrderByAggregateInput
  }

  export type CommentAttachmentScalarWhereWithAggregatesInput = {
    AND?: CommentAttachmentScalarWhereWithAggregatesInput | CommentAttachmentScalarWhereWithAggregatesInput[]
    OR?: CommentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: CommentAttachmentScalarWhereWithAggregatesInput | CommentAttachmentScalarWhereWithAggregatesInput[]
    sid?: IntWithAggregatesFilter<"CommentAttachment"> | number
    workspaceId?: StringWithAggregatesFilter<"CommentAttachment"> | string
    docId?: StringWithAggregatesFilter<"CommentAttachment"> | string
    key?: StringWithAggregatesFilter<"CommentAttachment"> | string
    size?: IntWithAggregatesFilter<"CommentAttachment"> | number
    mime?: StringWithAggregatesFilter<"CommentAttachment"> | string
    name?: StringWithAggregatesFilter<"CommentAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentAttachment"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"CommentAttachment"> | string | null
  }

  export type AccessTokenWhereInput = {
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    id?: StringFilter<"AccessToken"> | string
    name?: StringFilter<"AccessToken"> | string
    token?: StringFilter<"AccessToken"> | string
    userId?: StringFilter<"AccessToken"> | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    name?: StringFilter<"AccessToken"> | string
    userId?: StringFilter<"AccessToken"> | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type AccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: AccessTokenCountOrderByAggregateInput
    _max?: AccessTokenMaxOrderByAggregateInput
    _min?: AccessTokenMinOrderByAggregateInput
  }

  export type AccessTokenScalarWhereWithAggregatesInput = {
    AND?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    OR?: AccessTokenScalarWhereWithAggregatesInput[]
    NOT?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessToken"> | string
    name?: StringWithAggregatesFilter<"AccessToken"> | string
    token?: StringWithAggregatesFilter<"AccessToken"> | string
    userId?: StringWithAggregatesFilter<"AccessToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccessToken"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AccessToken"> | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectedAccountCreateInput = {
    id?: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConnectedAccountsInput
  }

  export type ConnectedAccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectedAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConnectedAccountsNestedInput
  }

  export type ConnectedAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectedAccountCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectedAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectedAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    createdAt?: Date | string
    deprecated_expiresAt?: Date | string | null
    userSessions?: UserSessionCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    deprecated_expiresAt?: Date | string | null
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userSessions?: UserSessionUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userSessions?: UserSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    deprecated_expiresAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateInput = {
    id?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutUserSessionsInput
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutUserSessionsNestedInput
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    token: string
    type: number
    credential?: string | null
    expiresAt: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    token: string
    type: number
    credential?: string | null
    expiresAt: Date | string
  }

  export type VerificationTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    credential?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    credential?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    token: string
    type: number
    credential?: string | null
    expiresAt: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    credential?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    credential?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceDocCreateInput = {
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
    workspace: WorkspaceCreateNestedOneWithoutDocsInput
  }

  export type WorkspaceDocUncheckedCreateInput = {
    workspaceId: string
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
  }

  export type WorkspaceDocUpdateInput = {
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutDocsNestedInput
  }

  export type WorkspaceDocUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceDocCreateManyInput = {
    workspaceId: string
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
  }

  export type WorkspaceDocUpdateManyMutationInput = {
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceDocUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserRoleCreateInput = {
    id?: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutPermissionsInput
    inviter?: UserCreateNestedOneWithoutWorkspaceInvitationsInput
  }

  export type WorkspaceUserRoleUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutPermissionsNestedInput
    inviter?: UserUpdateOneWithoutWorkspaceInvitationsNestedInput
  }

  export type WorkspaceUserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceDocUserRoleCreateInput = {
    docId: string
    type: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDocPermissionsInput
    workspace: WorkspaceCreateNestedOneWithoutDocPermissionsInput
  }

  export type WorkspaceDocUserRoleUncheckedCreateInput = {
    workspaceId: string
    docId: string
    userId: string
    type: number
    createdAt?: Date | string
  }

  export type WorkspaceDocUserRoleUpdateInput = {
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocPermissionsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDocPermissionsNestedInput
  }

  export type WorkspaceDocUserRoleUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceDocUserRoleCreateManyInput = {
    workspaceId: string
    docId: string
    userId: string
    type: number
    createdAt?: Date | string
  }

  export type WorkspaceDocUserRoleUpdateManyMutationInput = {
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceDocUserRoleUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateInput = {
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    userFeatures?: UserFeatureCreateNestedManyWithoutFeatureInput
    workspaceFeatures?: WorkspaceFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateInput = {
    id?: number
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    userFeatures?: UserFeatureUncheckedCreateNestedManyWithoutFeatureInput
    workspaceFeatures?: WorkspaceFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    userFeatures?: UserFeatureUpdateManyWithoutFeatureNestedInput
    workspaceFeatures?: WorkspaceFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    userFeatures?: UserFeatureUncheckedUpdateManyWithoutFeatureNestedInput
    workspaceFeatures?: WorkspaceFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureCreateManyInput = {
    id?: number
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
  }

  export type FeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
  }

  export type UserFeatureCreateInput = {
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
    feature: FeatureCreateNestedOneWithoutUserFeaturesInput
    user: UserCreateNestedOneWithoutFeaturesInput
  }

  export type UserFeatureUncheckedCreateInput = {
    id?: number
    userId: string
    featureId: number
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type UserFeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutUserFeaturesNestedInput
    user?: UserUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type UserFeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeatureCreateManyInput = {
    id?: number
    userId: string
    featureId: number
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type UserFeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceFeatureCreateInput = {
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
    feature: FeatureCreateNestedOneWithoutWorkspaceFeaturesInput
    workspace: WorkspaceCreateNestedOneWithoutFeaturesInput
  }

  export type WorkspaceFeatureUncheckedCreateInput = {
    id?: number
    workspaceId: string
    featureId: number
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type WorkspaceFeatureUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature?: FeatureUpdateOneRequiredWithoutWorkspaceFeaturesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type WorkspaceFeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceFeatureCreateManyInput = {
    id?: number
    workspaceId: string
    featureId: number
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type WorkspaceFeatureUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceFeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SnapshotCreateInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    seq?: number | null
    createdByUser?: UserCreateNestedOneWithoutCreatedSnapshotInput
    updatedByUser?: UserCreateNestedOneWithoutUpdatedSnapshotInput
    embedding?: AiWorkspaceEmbeddingCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotUncheckedCreateInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    seq?: number | null
    embedding?: AiWorkspaceEmbeddingUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUser?: UserUpdateOneWithoutCreatedSnapshotNestedInput
    updatedByUser?: UserUpdateOneWithoutUpdatedSnapshotNestedInput
    embedding?: AiWorkspaceEmbeddingUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    embedding?: AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotCreateManyInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    seq?: number | null
  }

  export type SnapshotUpdateManyMutationInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SnapshotUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSnapshotCreateInput = {
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSnapshotsInput
  }

  export type UserSnapshotUncheckedCreateInput = {
    userId: string
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSnapshotsNestedInput
  }

  export type UserSnapshotUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSnapshotCreateManyInput = {
    userId: string
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSnapshotUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UpdateCreateInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    seq?: number | null
    createdByUser?: UserCreateNestedOneWithoutCreatedUpdateInput
  }

  export type UpdateUncheckedCreateInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    createdBy?: string | null
    seq?: number | null
  }

  export type UpdateUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUser?: UserUpdateOneWithoutCreatedUpdateNestedInput
  }

  export type UpdateUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UpdateCreateManyInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    createdBy?: string | null
    seq?: number | null
  }

  export type UpdateUpdateManyMutationInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UpdateUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SnapshotHistoryCreateInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedHistoryInput
  }

  export type SnapshotHistoryUncheckedCreateInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
    createdBy?: string | null
  }

  export type SnapshotHistoryUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedHistoryNestedInput
  }

  export type SnapshotHistoryUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SnapshotHistoryCreateManyInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
    createdBy?: string | null
  }

  export type SnapshotHistoryUpdateManyMutationInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnapshotHistoryUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiPromptMessageCreateInput = {
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    prompt: AiPromptCreateNestedOneWithoutMessagesInput
  }

  export type AiPromptMessageUncheckedCreateInput = {
    promptId: number
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiPromptMessageUpdateInput = {
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: AiPromptUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AiPromptMessageUncheckedUpdateInput = {
    promptId?: IntFieldUpdateOperationsInput | number
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptMessageCreateManyInput = {
    promptId: number
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiPromptMessageUpdateManyMutationInput = {
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptMessageUncheckedUpdateManyInput = {
    promptId?: IntFieldUpdateOperationsInput | number
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptCreateInput = {
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    messages?: AiPromptMessageCreateNestedManyWithoutPromptInput
    sessions?: AiSessionCreateNestedManyWithoutPromptInput
  }

  export type AiPromptUncheckedCreateInput = {
    id?: number
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    messages?: AiPromptMessageUncheckedCreateNestedManyWithoutPromptInput
    sessions?: AiSessionUncheckedCreateNestedManyWithoutPromptInput
  }

  export type AiPromptUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    messages?: AiPromptMessageUpdateManyWithoutPromptNestedInput
    sessions?: AiSessionUpdateManyWithoutPromptNestedInput
  }

  export type AiPromptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    messages?: AiPromptMessageUncheckedUpdateManyWithoutPromptNestedInput
    sessions?: AiSessionUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type AiPromptCreateManyInput = {
    id?: number
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
  }

  export type AiPromptUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiPromptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AiSessionMessageCreateInput = {
    id?: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AiSessionCreateNestedOneWithoutMessagesInput
  }

  export type AiSessionMessageUncheckedCreateInput = {
    id?: string
    sessionId: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiSessionMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AiSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type AiSessionMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionMessageCreateManyInput = {
    id?: string
    sessionId: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiSessionMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionCreateInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAiSessionsInput
    prompt: AiPromptCreateNestedOneWithoutSessionsInput
    messages?: AiSessionMessageCreateNestedManyWithoutSessionInput
    context?: AiContextCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: AiSessionMessageUncheckedCreateNestedManyWithoutSessionInput
    context?: AiContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAiSessionsNestedInput
    prompt?: AiPromptUpdateOneRequiredWithoutSessionsNestedInput
    messages?: AiSessionMessageUpdateManyWithoutSessionNestedInput
    context?: AiContextUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: AiSessionMessageUncheckedUpdateManyWithoutSessionNestedInput
    context?: AiContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AiSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiContextCreateInput = {
    id?: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: AiContextEmbeddingCreateNestedManyWithoutContextInput
    session: AiSessionCreateNestedOneWithoutContextInput
  }

  export type AiContextUncheckedCreateInput = {
    id?: string
    sessionId: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: AiContextEmbeddingUncheckedCreateNestedManyWithoutContextInput
  }

  export type AiContextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiContextEmbeddingUpdateManyWithoutContextNestedInput
    session?: AiSessionUpdateOneRequiredWithoutContextNestedInput
  }

  export type AiContextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiContextEmbeddingUncheckedUpdateManyWithoutContextNestedInput
  }

  export type AiContextCreateManyInput = {
    id?: string
    sessionId: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiContextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: AiContextUpdateOneRequiredWithoutEmbeddingsNestedInput
  }

  export type AiContextEmbeddingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contextId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contextId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceEmbeddingUpdateInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: SnapshotUpdateOneRequiredWithoutEmbeddingNestedInput
  }

  export type AiWorkspaceEmbeddingUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceEmbeddingUpdateManyMutationInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceEmbeddingUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceIgnoredDocsCreateInput = {
    docId: string
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutIgnoredDocsInput
  }

  export type AiWorkspaceIgnoredDocsUncheckedCreateInput = {
    workspaceId: string
    docId: string
    createdAt?: Date | string
  }

  export type AiWorkspaceIgnoredDocsUpdateInput = {
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutIgnoredDocsNestedInput
  }

  export type AiWorkspaceIgnoredDocsUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceIgnoredDocsCreateManyInput = {
    workspaceId: string
    docId: string
    createdAt?: Date | string
  }

  export type AiWorkspaceIgnoredDocsUpdateManyMutationInput = {
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceIgnoredDocsUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFilesCreateInput = {
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutEmbedFilesInput
    embeddings?: AiWorkspaceFileEmbeddingCreateNestedManyWithoutFileInput
  }

  export type AiWorkspaceFilesUncheckedCreateInput = {
    workspaceId: string
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
    embeddings?: AiWorkspaceFileEmbeddingUncheckedCreateNestedManyWithoutFileInput
  }

  export type AiWorkspaceFilesUpdateInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutEmbedFilesNestedInput
    embeddings?: AiWorkspaceFileEmbeddingUpdateManyWithoutFileNestedInput
  }

  export type AiWorkspaceFilesUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiWorkspaceFileEmbeddingUncheckedUpdateManyWithoutFileNestedInput
  }

  export type AiWorkspaceFilesCreateManyInput = {
    workspaceId: string
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
  }

  export type AiWorkspaceFilesUpdateManyMutationInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFilesUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUpdateInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: AiWorkspaceFilesUpdateOneRequiredWithoutEmbeddingsNestedInput
  }

  export type AiWorkspaceFileEmbeddingUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUpdateManyMutationInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUpdateInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BlobUpdateOneRequiredWithoutAiWorkspaceBlobEmbeddingNestedInput
  }

  export type AiWorkspaceBlobEmbeddingUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUpdateManyMutationInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiJobsCreateInput = {
    id?: string
    workspaceId: string
    blobId: string
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
    createdByUser?: UserCreateNestedOneWithoutCreatedAiJobsInput
  }

  export type AiJobsUncheckedCreateInput = {
    id?: string
    workspaceId: string
    blobId: string
    createdBy?: string | null
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiJobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUser?: UserUpdateOneWithoutCreatedAiJobsNestedInput
  }

  export type AiJobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiJobsCreateManyInput = {
    id?: string
    workspaceId: string
    blobId: string
    createdBy?: string | null
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiJobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiJobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataMigrationCreateInput = {
    id?: string
    name: string
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type DataMigrationUncheckedCreateInput = {
    id?: string
    name: string
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type DataMigrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataMigrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataMigrationCreateManyInput = {
    id?: string
    name: string
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type DataMigrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DataMigrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsCreateInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastUpdatedByUser?: UserCreateNestedOneWithoutDeprecatedAppRuntimeSettingsInput
  }

  export type DeprecatedAppRuntimeSettingsUncheckedCreateInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastUpdatedBy?: string | null
  }

  export type DeprecatedAppRuntimeSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedByUser?: UserUpdateOneWithoutDeprecatedAppRuntimeSettingsNestedInput
  }

  export type DeprecatedAppRuntimeSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeprecatedAppRuntimeSettingsCreateManyInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastUpdatedBy?: string | null
  }

  export type DeprecatedAppRuntimeSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppConfigCreateInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdatedByUser?: UserCreateNestedOneWithoutAppConfigsInput
  }

  export type AppConfigUncheckedCreateInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdatedBy?: string | null
  }

  export type AppConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedByUser?: UserUpdateOneWithoutAppConfigsNestedInput
  }

  export type AppConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppConfigCreateManyInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUpdatedBy?: string | null
  }

  export type AppConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeprecatedUserSubscriptionCreateInput = {
    userId: string
    plan: string
    recurring: string
    variant?: string | null
    stripeSubscriptionId?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    stripeScheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeprecatedUserSubscriptionUncheckedCreateInput = {
    id?: number
    userId: string
    plan: string
    recurring: string
    variant?: string | null
    stripeSubscriptionId?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    stripeScheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeprecatedUserSubscriptionUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeprecatedUserSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeprecatedUserSubscriptionCreateManyInput = {
    id?: number
    userId: string
    plan: string
    recurring: string
    variant?: string | null
    stripeSubscriptionId?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    stripeScheduleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeprecatedUserSubscriptionUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeprecatedUserSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeprecatedUserInvoiceCreateInput = {
    userId: string
    stripeInvoiceId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    plan?: string | null
    recurring?: string | null
  }

  export type DeprecatedUserInvoiceUncheckedCreateInput = {
    id?: number
    userId: string
    stripeInvoiceId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    plan?: string | null
    recurring?: string | null
  }

  export type DeprecatedUserInvoiceUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeprecatedUserInvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeprecatedUserInvoiceCreateManyInput = {
    id?: number
    userId: string
    stripeInvoiceId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    plan?: string | null
    recurring?: string | null
  }

  export type DeprecatedUserInvoiceUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeprecatedUserInvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    recurring?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserStripeCustomerCreateInput = {
    stripeCustomerId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserStripeCustomerInput
  }

  export type UserStripeCustomerUncheckedCreateInput = {
    userId: string
    stripeCustomerId: string
    createdAt?: Date | string
  }

  export type UserStripeCustomerUpdateInput = {
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserStripeCustomerNestedInput
  }

  export type UserStripeCustomerUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStripeCustomerCreateManyInput = {
    userId: string
    stripeCustomerId: string
    createdAt?: Date | string
  }

  export type UserStripeCustomerUpdateManyMutationInput = {
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStripeCustomerUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    targetId: string
    plan: string
    recurring: string
    variant?: string | null
    quantity?: number
    stripeSubscriptionId?: string | null
    stripeScheduleId?: string | null
    provider?: $Enums.Provider
    iapStore?: $Enums.IapStore | null
    rcEntitlement?: string | null
    rcProductId?: string | null
    rcExternalRef?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    targetId: string
    plan: string
    recurring: string
    variant?: string | null
    quantity?: number
    stripeSubscriptionId?: string | null
    stripeScheduleId?: string | null
    provider?: $Enums.Provider
    iapStore?: $Enums.IapStore | null
    rcEntitlement?: string | null
    rcProductId?: string | null
    rcExternalRef?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    targetId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    iapStore?: NullableEnumIapStoreFieldUpdateOperationsInput | $Enums.IapStore | null
    rcEntitlement?: NullableStringFieldUpdateOperationsInput | string | null
    rcProductId?: NullableStringFieldUpdateOperationsInput | string | null
    rcExternalRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    iapStore?: NullableEnumIapStoreFieldUpdateOperationsInput | $Enums.IapStore | null
    rcEntitlement?: NullableStringFieldUpdateOperationsInput | string | null
    rcProductId?: NullableStringFieldUpdateOperationsInput | string | null
    rcExternalRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    targetId: string
    plan: string
    recurring: string
    variant?: string | null
    quantity?: number
    stripeSubscriptionId?: string | null
    stripeScheduleId?: string | null
    provider?: $Enums.Provider
    iapStore?: $Enums.IapStore | null
    rcEntitlement?: string | null
    rcProductId?: string | null
    rcExternalRef?: string | null
    status: string
    start: Date | string
    end?: Date | string | null
    nextBillAt?: Date | string | null
    canceledAt?: Date | string | null
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    targetId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    iapStore?: NullableEnumIapStoreFieldUpdateOperationsInput | $Enums.IapStore | null
    rcEntitlement?: NullableStringFieldUpdateOperationsInput | string | null
    rcProductId?: NullableStringFieldUpdateOperationsInput | string | null
    rcExternalRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    iapStore?: NullableEnumIapStoreFieldUpdateOperationsInput | $Enums.IapStore | null
    rcEntitlement?: NullableStringFieldUpdateOperationsInput | string | null
    rcProductId?: NullableStringFieldUpdateOperationsInput | string | null
    rcExternalRef?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    stripeInvoiceId: string
    targetId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    onetimeSubscriptionRedeemed?: boolean
  }

  export type InvoiceUncheckedCreateInput = {
    stripeInvoiceId: string
    targetId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    onetimeSubscriptionRedeemed?: boolean
  }

  export type InvoiceUpdateInput = {
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    onetimeSubscriptionRedeemed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateInput = {
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    onetimeSubscriptionRedeemed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateManyInput = {
    stripeInvoiceId: string
    targetId: string
    currency: string
    amount: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reason?: string | null
    lastPaymentError?: string | null
    link?: string | null
    onetimeSubscriptionRedeemed?: boolean
  }

  export type InvoiceUpdateManyMutationInput = {
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    onetimeSubscriptionRedeemed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateManyInput = {
    stripeInvoiceId?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    lastPaymentError?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    onetimeSubscriptionRedeemed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LicenseCreateInput = {
    key: string
    createdAt?: Date | string
    revealedAt?: Date | string | null
    installedAt?: Date | string | null
    validateKey?: string | null
  }

  export type LicenseUncheckedCreateInput = {
    key: string
    createdAt?: Date | string
    revealedAt?: Date | string | null
    installedAt?: Date | string | null
    validateKey?: string | null
  }

  export type LicenseUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revealedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validateKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revealedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validateKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseCreateManyInput = {
    key: string
    createdAt?: Date | string
    revealedAt?: Date | string | null
    installedAt?: Date | string | null
    validateKey?: string | null
  }

  export type LicenseUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revealedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validateKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revealedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validateKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstalledLicenseCreateInput = {
    key: string
    workspaceId: string
    quantity?: number
    recurring: string
    variant?: string | null
    installedAt?: Date | string
    validateKey: string
    validatedAt: Date | string
    expiredAt?: Date | string | null
    license?: Uint8Array | null
  }

  export type InstalledLicenseUncheckedCreateInput = {
    key: string
    workspaceId: string
    quantity?: number
    recurring: string
    variant?: string | null
    installedAt?: Date | string
    validateKey: string
    validatedAt: Date | string
    expiredAt?: Date | string | null
    license?: Uint8Array | null
  }

  export type InstalledLicenseUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validateKey?: StringFieldUpdateOperationsInput | string
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type InstalledLicenseUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validateKey?: StringFieldUpdateOperationsInput | string
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type InstalledLicenseCreateManyInput = {
    key: string
    workspaceId: string
    quantity?: number
    recurring: string
    variant?: string | null
    installedAt?: Date | string
    validateKey: string
    validatedAt: Date | string
    expiredAt?: Date | string | null
    license?: Uint8Array | null
  }

  export type InstalledLicenseUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validateKey?: StringFieldUpdateOperationsInput | string
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type InstalledLicenseUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    recurring?: StringFieldUpdateOperationsInput | string
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    installedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validateKey?: StringFieldUpdateOperationsInput | string
    validatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    license?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type BlobCreateInput = {
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutBlobsInput
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingCreateNestedManyWithoutBlobInput
  }

  export type BlobUncheckedCreateInput = {
    workspaceId: string
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUncheckedCreateNestedManyWithoutBlobInput
  }

  export type BlobUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutBlobsNestedInput
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUpdateManyWithoutBlobNestedInput
  }

  export type BlobUncheckedUpdateInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUncheckedUpdateManyWithoutBlobNestedInput
  }

  export type BlobCreateManyInput = {
    workspaceId: string
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BlobUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlobUncheckedUpdateManyInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    payload: JsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsCreateManyInput = {
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateInput = {
    sid?: number
    id?: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    user: UserCreateNestedOneWithoutCommentsInput
    workspace: WorkspaceCreateNestedOneWithoutCommentsInput
    replies?: ReplyCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    replies?: ReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentUncheckedUpdateManyInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyCreateInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRepliesInput
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type ReplyUncheckedCreateInput = {
    sid?: number
    id?: string
    userId: string
    commentId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyUncheckedUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReplyCreateManyInput = {
    sid?: number
    id?: string
    userId: string
    commentId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReplyUncheckedUpdateManyInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentAttachmentCreateInput = {
    sid?: number
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCommentAttachmentsInput
    createdByUser?: UserCreateNestedOneWithoutCommentAttachmentsInput
  }

  export type CommentAttachmentUncheckedCreateInput = {
    sid?: number
    workspaceId: string
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type CommentAttachmentUpdateInput = {
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCommentAttachmentsNestedInput
    createdByUser?: UserUpdateOneWithoutCommentAttachmentsNestedInput
  }

  export type CommentAttachmentUncheckedUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentAttachmentCreateManyInput = {
    sid?: number
    workspaceId: string
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type CommentAttachmentUpdateManyMutationInput = {
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentAttachmentUncheckedUpdateManyInput = {
    sid?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessTokenCreateInput = {
    id?: string
    name: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutAccessTokenInput
  }

  export type AccessTokenUncheckedCreateInput = {
    id?: string
    name: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AccessTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAccessTokenNestedInput
  }

  export type AccessTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessTokenCreateManyInput = {
    id?: string
    name: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AccessTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserFeatureListRelationFilter = {
    every?: UserFeatureWhereInput
    some?: UserFeatureWhereInput
    none?: UserFeatureWhereInput
  }

  export type UserStripeCustomerNullableScalarRelationFilter = {
    is?: UserStripeCustomerWhereInput | null
    isNot?: UserStripeCustomerWhereInput | null
  }

  export type WorkspaceUserRoleListRelationFilter = {
    every?: WorkspaceUserRoleWhereInput
    some?: WorkspaceUserRoleWhereInput
    none?: WorkspaceUserRoleWhereInput
  }

  export type WorkspaceDocUserRoleListRelationFilter = {
    every?: WorkspaceDocUserRoleWhereInput
    some?: WorkspaceDocUserRoleWhereInput
    none?: WorkspaceDocUserRoleWhereInput
  }

  export type ConnectedAccountListRelationFilter = {
    every?: ConnectedAccountWhereInput
    some?: ConnectedAccountWhereInput
    none?: ConnectedAccountWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type AiSessionListRelationFilter = {
    every?: AiSessionWhereInput
    some?: AiSessionWhereInput
    none?: AiSessionWhereInput
  }

  export type DeprecatedAppRuntimeSettingsListRelationFilter = {
    every?: DeprecatedAppRuntimeSettingsWhereInput
    some?: DeprecatedAppRuntimeSettingsWhereInput
    none?: DeprecatedAppRuntimeSettingsWhereInput
  }

  export type AppConfigListRelationFilter = {
    every?: AppConfigWhereInput
    some?: AppConfigWhereInput
    none?: AppConfigWhereInput
  }

  export type UserSnapshotListRelationFilter = {
    every?: UserSnapshotWhereInput
    some?: UserSnapshotWhereInput
    none?: UserSnapshotWhereInput
  }

  export type SnapshotListRelationFilter = {
    every?: SnapshotWhereInput
    some?: SnapshotWhereInput
    none?: SnapshotWhereInput
  }

  export type UpdateListRelationFilter = {
    every?: UpdateWhereInput
    some?: UpdateWhereInput
    none?: UpdateWhereInput
  }

  export type SnapshotHistoryListRelationFilter = {
    every?: SnapshotHistoryWhereInput
    some?: SnapshotHistoryWhereInput
    none?: SnapshotHistoryWhereInput
  }

  export type AiJobsListRelationFilter = {
    every?: AiJobsWhereInput
    some?: AiJobsWhereInput
    none?: AiJobsWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReplyListRelationFilter = {
    every?: ReplyWhereInput
    some?: ReplyWhereInput
    none?: ReplyWhereInput
  }

  export type CommentAttachmentListRelationFilter = {
    every?: CommentAttachmentWhereInput
    some?: CommentAttachmentWhereInput
    none?: CommentAttachmentWhereInput
  }

  export type AccessTokenListRelationFilter = {
    every?: AccessTokenWhereInput
    some?: AccessTokenWhereInput
    none?: AccessTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceUserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceDocUserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectedAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeprecatedAppRuntimeSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnapshotHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    password?: SortOrder
    registered?: SortOrder
    disabled?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    password?: SortOrder
    registered?: SortOrder
    disabled?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerifiedAt?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    password?: SortOrder
    registered?: SortOrder
    disabled?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ConnectedAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    scope?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectedAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    scope?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConnectedAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    scope?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    deprecated_expiresAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    deprecated_expiresAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    deprecated_expiresAt?: SortOrder
  }

  export type SessionScalarRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type UserSessionSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VerificationTokenTypeTokenCompoundUniqueInput = {
    type: number
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    token?: SortOrder
    type?: SortOrder
    credential?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationTokenAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    token?: SortOrder
    type?: SortOrder
    credential?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    token?: SortOrder
    type?: SortOrder
    credential?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationTokenSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WorkspaceFeatureListRelationFilter = {
    every?: WorkspaceFeatureWhereInput
    some?: WorkspaceFeatureWhereInput
    none?: WorkspaceFeatureWhereInput
  }

  export type WorkspaceDocListRelationFilter = {
    every?: WorkspaceDocWhereInput
    some?: WorkspaceDocWhereInput
    none?: WorkspaceDocWhereInput
  }

  export type BlobListRelationFilter = {
    every?: BlobWhereInput
    some?: BlobWhereInput
    none?: BlobWhereInput
  }

  export type AiWorkspaceIgnoredDocsListRelationFilter = {
    every?: AiWorkspaceIgnoredDocsWhereInput
    some?: AiWorkspaceIgnoredDocsWhereInput
    none?: AiWorkspaceIgnoredDocsWhereInput
  }

  export type AiWorkspaceFilesListRelationFilter = {
    every?: AiWorkspaceFilesWhereInput
    some?: AiWorkspaceFilesWhereInput
    none?: AiWorkspaceFilesWhereInput
  }

  export type WorkspaceFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceDocOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiWorkspaceIgnoredDocsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiWorkspaceFilesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    enableAi?: SortOrder
    enableUrlPreview?: SortOrder
    enableDocEmbedding?: SortOrder
    name?: SortOrder
    avatarKey?: SortOrder
    indexed?: SortOrder
    lastCheckEmbeddings?: SortOrder
  }

  export type WorkspaceAvgOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    enableAi?: SortOrder
    enableUrlPreview?: SortOrder
    enableDocEmbedding?: SortOrder
    name?: SortOrder
    avatarKey?: SortOrder
    indexed?: SortOrder
    lastCheckEmbeddings?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    public?: SortOrder
    createdAt?: SortOrder
    enableAi?: SortOrder
    enableUrlPreview?: SortOrder
    enableDocEmbedding?: SortOrder
    name?: SortOrder
    avatarKey?: SortOrder
    indexed?: SortOrder
    lastCheckEmbeddings?: SortOrder
  }

  export type WorkspaceSumOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceDocWorkspaceIdDocIdCompoundUniqueInput = {
    workspaceId: string
    docId: string
  }

  export type WorkspaceDocCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    public?: SortOrder
    defaultRole?: SortOrder
    mode?: SortOrder
    blocked?: SortOrder
    title?: SortOrder
    summary?: SortOrder
  }

  export type WorkspaceDocAvgOrderByAggregateInput = {
    defaultRole?: SortOrder
    mode?: SortOrder
  }

  export type WorkspaceDocMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    public?: SortOrder
    defaultRole?: SortOrder
    mode?: SortOrder
    blocked?: SortOrder
    title?: SortOrder
    summary?: SortOrder
  }

  export type WorkspaceDocMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    public?: SortOrder
    defaultRole?: SortOrder
    mode?: SortOrder
    blocked?: SortOrder
    title?: SortOrder
    summary?: SortOrder
  }

  export type WorkspaceDocSumOrderByAggregateInput = {
    defaultRole?: SortOrder
    mode?: SortOrder
  }

  export type EnumWorkspaceMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberStatus | EnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel> | $Enums.WorkspaceMemberStatus
  }

  export type EnumWorkspaceMemberSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberSource | EnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel> | $Enums.WorkspaceMemberSource
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkspaceUserRoleWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: string
    userId: string
  }

  export type WorkspaceUserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accepted?: SortOrder
  }

  export type WorkspaceUserRoleAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type WorkspaceUserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accepted?: SortOrder
  }

  export type WorkspaceUserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    inviterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accepted?: SortOrder
  }

  export type WorkspaceUserRoleSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type EnumWorkspaceMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberStatus | EnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel>
  }

  export type EnumWorkspaceMemberSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberSource | EnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberSourceWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceMemberSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel>
  }

  export type WorkspaceDocUserRoleWorkspaceIdDocIdUserIdCompoundUniqueInput = {
    workspaceId: string
    docId: string
    userId: string
  }

  export type WorkspaceDocUserRoleCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkspaceDocUserRoleAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type WorkspaceDocUserRoleMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkspaceDocUserRoleMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkspaceDocUserRoleSumOrderByAggregateInput = {
    type?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeatureNameDeprecatedVersionCompoundUniqueInput = {
    name: string
    deprecatedVersion: number
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    configs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
  }

  export type FeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
  }

  export type FeatureSumOrderByAggregateInput = {
    id?: SortOrder
    deprecatedVersion?: SortOrder
    deprecatedType?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FeatureScalarRelationFilter = {
    is?: FeatureWhereInput
    isNot?: FeatureWhereInput
  }

  export type UserFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    activated?: SortOrder
  }

  export type UserFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    type?: SortOrder
  }

  export type UserFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    activated?: SortOrder
  }

  export type UserFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    activated?: SortOrder
  }

  export type UserFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    type?: SortOrder
  }

  export type WorkspaceFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    configs?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    activated?: SortOrder
    expiredAt?: SortOrder
  }

  export type WorkspaceFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    type?: SortOrder
  }

  export type WorkspaceFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    activated?: SortOrder
    expiredAt?: SortOrder
  }

  export type WorkspaceFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    featureId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    activated?: SortOrder
    expiredAt?: SortOrder
  }

  export type WorkspaceFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    featureId?: SortOrder
    type?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AiWorkspaceEmbeddingListRelationFilter = {
    every?: AiWorkspaceEmbeddingWhereInput
    some?: AiWorkspaceEmbeddingWhereInput
    none?: AiWorkspaceEmbeddingWhereInput
  }

  export type AiWorkspaceEmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnapshotWorkspaceIdIdCompoundUniqueInput = {
    workspaceId: string
    id: string
  }

  export type SnapshotCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    seq?: SortOrder
  }

  export type SnapshotAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SnapshotMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    seq?: SortOrder
  }

  export type SnapshotMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    seq?: SortOrder
  }

  export type SnapshotSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserSnapshotUserIdIdCompoundUniqueInput = {
    userId: string
    id: string
  }

  export type UserSnapshotCountOrderByAggregateInput = {
    userId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSnapshotMaxOrderByAggregateInput = {
    userId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSnapshotMinOrderByAggregateInput = {
    userId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UpdateWorkspaceIdIdCreatedAtCompoundUniqueInput = {
    workspaceId: string
    id: string
    createdAt: Date | string
  }

  export type UpdateCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    seq?: SortOrder
  }

  export type UpdateAvgOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type UpdateMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    seq?: SortOrder
  }

  export type UpdateMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    blob?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    seq?: SortOrder
  }

  export type UpdateSumOrderByAggregateInput = {
    seq?: SortOrder
  }

  export type SnapshotHistoryWorkspaceIdIdTimestampCompoundUniqueInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
  }

  export type SnapshotHistoryCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    timestamp?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    expiredAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SnapshotHistoryMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    timestamp?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    expiredAt?: SortOrder
    createdBy?: SortOrder
  }

  export type SnapshotHistoryMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    id?: SortOrder
    timestamp?: SortOrder
    blob?: SortOrder
    state?: SortOrder
    expiredAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumAiPromptRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPromptRole | EnumAiPromptRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPromptRoleFilter<$PrismaModel> | $Enums.AiPromptRole
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AiPromptScalarRelationFilter = {
    is?: AiPromptWhereInput
    isNot?: AiPromptWhereInput
  }

  export type AiPromptMessagePromptIdIdxCompoundUniqueInput = {
    promptId: number
    idx: number
  }

  export type AiPromptMessageCountOrderByAggregateInput = {
    promptId?: SortOrder
    idx?: SortOrder
    role?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    params?: SortOrder
    createdAt?: SortOrder
  }

  export type AiPromptMessageAvgOrderByAggregateInput = {
    promptId?: SortOrder
    idx?: SortOrder
  }

  export type AiPromptMessageMaxOrderByAggregateInput = {
    promptId?: SortOrder
    idx?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiPromptMessageMinOrderByAggregateInput = {
    promptId?: SortOrder
    idx?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiPromptMessageSumOrderByAggregateInput = {
    promptId?: SortOrder
    idx?: SortOrder
  }

  export type EnumAiPromptRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPromptRole | EnumAiPromptRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPromptRoleWithAggregatesFilter<$PrismaModel> | $Enums.AiPromptRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiPromptRoleFilter<$PrismaModel>
    _max?: NestedEnumAiPromptRoleFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AiPromptMessageListRelationFilter = {
    every?: AiPromptMessageWhereInput
    some?: AiPromptMessageWhereInput
    none?: AiPromptMessageWhereInput
  }

  export type AiPromptMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiPromptCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    model?: SortOrder
    optionalModels?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modified?: SortOrder
  }

  export type AiPromptAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AiPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modified?: SortOrder
  }

  export type AiPromptMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    action?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modified?: SortOrder
  }

  export type AiPromptSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AiSessionScalarRelationFilter = {
    is?: AiSessionWhereInput
    isNot?: AiSessionWhereInput
  }

  export type AiSessionMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    streamObjects?: SortOrder
    attachments?: SortOrder
    params?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSessionMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSessionMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiSessionMessageListRelationFilter = {
    every?: AiSessionMessageWhereInput
    some?: AiSessionMessageWhereInput
    none?: AiSessionMessageWhereInput
  }

  export type AiContextListRelationFilter = {
    every?: AiContextWhereInput
    some?: AiContextWhereInput
    none?: AiContextWhereInput
  }

  export type AiSessionMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiContextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    promptName?: SortOrder
    promptAction?: SortOrder
    pinned?: SortOrder
    title?: SortOrder
    parentSessionId?: SortOrder
    messageCost?: SortOrder
    tokenCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AiSessionAvgOrderByAggregateInput = {
    messageCost?: SortOrder
    tokenCost?: SortOrder
  }

  export type AiSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    promptName?: SortOrder
    promptAction?: SortOrder
    pinned?: SortOrder
    title?: SortOrder
    parentSessionId?: SortOrder
    messageCost?: SortOrder
    tokenCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AiSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    promptName?: SortOrder
    promptAction?: SortOrder
    pinned?: SortOrder
    title?: SortOrder
    parentSessionId?: SortOrder
    messageCost?: SortOrder
    tokenCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AiSessionSumOrderByAggregateInput = {
    messageCost?: SortOrder
    tokenCost?: SortOrder
  }

  export type AiContextEmbeddingListRelationFilter = {
    every?: AiContextEmbeddingWhereInput
    some?: AiContextEmbeddingWhereInput
    none?: AiContextEmbeddingWhereInput
  }

  export type AiContextEmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiContextCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextScalarRelationFilter = {
    is?: AiContextWhereInput
    isNot?: AiContextWhereInput
  }

  export type AiContextEmbeddingContextIdFileIdChunkCompoundUniqueInput = {
    contextId: string
    fileId: string
    chunk: number
  }

  export type AiContextEmbeddingCountOrderByAggregateInput = {
    id?: SortOrder
    contextId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextEmbeddingAvgOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type AiContextEmbeddingMaxOrderByAggregateInput = {
    id?: SortOrder
    contextId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextEmbeddingMinOrderByAggregateInput = {
    id?: SortOrder
    contextId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiContextEmbeddingSumOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type SnapshotScalarRelationFilter = {
    is?: SnapshotWhereInput
    isNot?: SnapshotWhereInput
  }

  export type AiWorkspaceEmbeddingWorkspaceIdDocIdChunkCompoundUniqueInput = {
    workspaceId: string
    docId: string
    chunk: number
  }

  export type AiWorkspaceEmbeddingCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiWorkspaceEmbeddingAvgOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type AiWorkspaceEmbeddingMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiWorkspaceEmbeddingMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AiWorkspaceEmbeddingSumOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type AiWorkspaceIgnoredDocsWorkspaceIdDocIdCompoundUniqueInput = {
    workspaceId: string
    docId: string
  }

  export type AiWorkspaceIgnoredDocsCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceIgnoredDocsMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceIgnoredDocsMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFileEmbeddingListRelationFilter = {
    every?: AiWorkspaceFileEmbeddingWhereInput
    some?: AiWorkspaceFileEmbeddingWhereInput
    none?: AiWorkspaceFileEmbeddingWhereInput
  }

  export type AiWorkspaceFileEmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiWorkspaceFilesWorkspaceIdFileIdCompoundUniqueInput = {
    workspaceId: string
    fileId: string
  }

  export type AiWorkspaceFilesCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    blobId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFilesAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AiWorkspaceFilesMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    blobId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFilesMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    blobId?: SortOrder
    fileName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFilesSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AiWorkspaceFilesScalarRelationFilter = {
    is?: AiWorkspaceFilesWhereInput
    isNot?: AiWorkspaceFilesWhereInput
  }

  export type AiWorkspaceFileEmbeddingWorkspaceIdFileIdChunkCompoundUniqueInput = {
    workspaceId: string
    fileId: string
    chunk: number
  }

  export type AiWorkspaceFileEmbeddingCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFileEmbeddingAvgOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type AiWorkspaceFileEmbeddingMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFileEmbeddingMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    fileId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceFileEmbeddingSumOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type BlobScalarRelationFilter = {
    is?: BlobWhereInput
    isNot?: BlobWhereInput
  }

  export type AiWorkspaceBlobEmbeddingWorkspaceIdBlobIdChunkCompoundUniqueInput = {
    workspaceId: string
    blobId: string
    chunk: number
  }

  export type AiWorkspaceBlobEmbeddingCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    blobId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceBlobEmbeddingAvgOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type AiWorkspaceBlobEmbeddingMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    blobId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceBlobEmbeddingMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    blobId?: SortOrder
    chunk?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AiWorkspaceBlobEmbeddingSumOrderByAggregateInput = {
    chunk?: SortOrder
  }

  export type EnumAiJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobType | EnumAiJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobTypeFilter<$PrismaModel> | $Enums.AiJobType
  }

  export type EnumAiJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobStatus | EnumAiJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobStatusFilter<$PrismaModel> | $Enums.AiJobStatus
  }

  export type AiJobsCreatedByWorkspaceIdBlobIdCompoundUniqueInput = {
    createdBy: string
    workspaceId: string
    blobId: string
  }

  export type AiJobsCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    blobId?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type AiJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    blobId?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type AiJobsMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    blobId?: SortOrder
    createdBy?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type EnumAiJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobType | EnumAiJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.AiJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiJobTypeFilter<$PrismaModel>
    _max?: NestedEnumAiJobTypeFilter<$PrismaModel>
  }

  export type EnumAiJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobStatus | EnumAiJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.AiJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiJobStatusFilter<$PrismaModel>
    _max?: NestedEnumAiJobStatusFilter<$PrismaModel>
  }

  export type DataMigrationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type DataMigrationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type DataMigrationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
  }

  export type EnumRuntimeConfigTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RuntimeConfigType | EnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel> | $Enums.RuntimeConfigType
  }

  export type DeprecatedAppRuntimeSettingsModuleKeyCompoundUniqueInput = {
    module: string
    key: string
  }

  export type DeprecatedAppRuntimeSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    module?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type DeprecatedAppRuntimeSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    module?: SortOrder
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type DeprecatedAppRuntimeSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    module?: SortOrder
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type EnumRuntimeConfigTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuntimeConfigType | EnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuntimeConfigTypeWithAggregatesFilter<$PrismaModel> | $Enums.RuntimeConfigType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel>
    _max?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel>
  }

  export type AppConfigCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type AppConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type AppConfigMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUpdatedBy?: SortOrder
  }

  export type DeprecatedUserSubscriptionUserIdPlanCompoundUniqueInput = {
    userId: string
    plan: string
  }

  export type DeprecatedUserSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    stripeScheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeprecatedUserSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeprecatedUserSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    stripeScheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeprecatedUserSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    stripeScheduleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeprecatedUserSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeprecatedUserInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeInvoiceId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
  }

  export type DeprecatedUserInvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type DeprecatedUserInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeInvoiceId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
  }

  export type DeprecatedUserInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeInvoiceId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
  }

  export type DeprecatedUserInvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
  }

  export type UserStripeCustomerCountOrderByAggregateInput = {
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserStripeCustomerMaxOrderByAggregateInput = {
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserStripeCustomerMinOrderByAggregateInput = {
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type EnumIapStoreNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IapStore | EnumIapStoreFieldRefInput<$PrismaModel> | null
    in?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIapStoreNullableFilter<$PrismaModel> | $Enums.IapStore | null
  }

  export type SubscriptionTargetIdPlanCompoundUniqueInput = {
    targetId: string
    plan: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    quantity?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeScheduleId?: SortOrder
    provider?: SortOrder
    iapStore?: SortOrder
    rcEntitlement?: SortOrder
    rcProductId?: SortOrder
    rcExternalRef?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    quantity?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeScheduleId?: SortOrder
    provider?: SortOrder
    iapStore?: SortOrder
    rcEntitlement?: SortOrder
    rcProductId?: SortOrder
    rcExternalRef?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    plan?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    quantity?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeScheduleId?: SortOrder
    provider?: SortOrder
    iapStore?: SortOrder
    rcEntitlement?: SortOrder
    rcProductId?: SortOrder
    rcExternalRef?: SortOrder
    status?: SortOrder
    start?: SortOrder
    end?: SortOrder
    nextBillAt?: SortOrder
    canceledAt?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
  }

  export type EnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type EnumIapStoreNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IapStore | EnumIapStoreFieldRefInput<$PrismaModel> | null
    in?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIapStoreNullableWithAggregatesFilter<$PrismaModel> | $Enums.IapStore | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIapStoreNullableFilter<$PrismaModel>
    _max?: NestedEnumIapStoreNullableFilter<$PrismaModel>
  }

  export type InvoiceCountOrderByAggregateInput = {
    stripeInvoiceId?: SortOrder
    targetId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    onetimeSubscriptionRedeemed?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    stripeInvoiceId?: SortOrder
    targetId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    onetimeSubscriptionRedeemed?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    stripeInvoiceId?: SortOrder
    targetId?: SortOrder
    currency?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reason?: SortOrder
    lastPaymentError?: SortOrder
    link?: SortOrder
    onetimeSubscriptionRedeemed?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type LicenseCountOrderByAggregateInput = {
    key?: SortOrder
    createdAt?: SortOrder
    revealedAt?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    key?: SortOrder
    createdAt?: SortOrder
    revealedAt?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    key?: SortOrder
    createdAt?: SortOrder
    revealedAt?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
  }

  export type InstalledLicenseCountOrderByAggregateInput = {
    key?: SortOrder
    workspaceId?: SortOrder
    quantity?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
    validatedAt?: SortOrder
    expiredAt?: SortOrder
    license?: SortOrder
  }

  export type InstalledLicenseAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InstalledLicenseMaxOrderByAggregateInput = {
    key?: SortOrder
    workspaceId?: SortOrder
    quantity?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
    validatedAt?: SortOrder
    expiredAt?: SortOrder
    license?: SortOrder
  }

  export type InstalledLicenseMinOrderByAggregateInput = {
    key?: SortOrder
    workspaceId?: SortOrder
    quantity?: SortOrder
    recurring?: SortOrder
    variant?: SortOrder
    installedAt?: SortOrder
    validateKey?: SortOrder
    validatedAt?: SortOrder
    expiredAt?: SortOrder
    license?: SortOrder
  }

  export type InstalledLicenseSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AiWorkspaceBlobEmbeddingListRelationFilter = {
    every?: AiWorkspaceBlobEmbeddingWhereInput
    some?: AiWorkspaceBlobEmbeddingWhereInput
    none?: AiWorkspaceBlobEmbeddingWhereInput
  }

  export type AiWorkspaceBlobEmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlobWorkspaceIdKeyCompoundUniqueInput = {
    workspaceId: string
    key: string
  }

  export type BlobCountOrderByAggregateInput = {
    workspaceId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BlobAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BlobMaxOrderByAggregateInput = {
    workspaceId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BlobMinOrderByAggregateInput = {
    workspaceId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BlobSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumNotificationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationLevel | EnumNotificationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationLevelFilter<$PrismaModel> | $Enums.NotificationLevel
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    read?: SortOrder
    type?: SortOrder
    body?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    read?: SortOrder
    type?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    read?: SortOrder
    type?: SortOrder
  }

  export type EnumNotificationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationLevel | EnumNotificationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationLevelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationLevelFilter<$PrismaModel>
    _max?: NestedEnumNotificationLevelFilter<$PrismaModel>
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payload?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    resolved?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    resolved?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    resolved?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type ReplyCountOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReplyAvgOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type ReplyMaxOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReplyMinOrderByAggregateInput = {
    sid?: SortOrder
    id?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReplySumOrderByAggregateInput = {
    sid?: SortOrder
  }

  export type CommentAttachmentWorkspaceIdDocIdKeyCompoundUniqueInput = {
    workspaceId: string
    docId: string
    key: string
  }

  export type CommentAttachmentCountOrderByAggregateInput = {
    sid?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CommentAttachmentAvgOrderByAggregateInput = {
    sid?: SortOrder
    size?: SortOrder
  }

  export type CommentAttachmentMaxOrderByAggregateInput = {
    sid?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CommentAttachmentMinOrderByAggregateInput = {
    sid?: SortOrder
    workspaceId?: SortOrder
    docId?: SortOrder
    key?: SortOrder
    size?: SortOrder
    mime?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type CommentAttachmentSumOrderByAggregateInput = {
    sid?: SortOrder
    size?: SortOrder
  }

  export type AccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type AccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserFeatureCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput> | UserFeatureCreateWithoutUserInput[] | UserFeatureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutUserInput | UserFeatureCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureCreateManyUserInputEnvelope
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
  }

  export type UserStripeCustomerCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStripeCustomerCreateOrConnectWithoutUserInput
    connect?: UserStripeCustomerWhereUniqueInput
  }

  export type WorkspaceUserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput> | WorkspaceUserRoleCreateWithoutUserInput[] | WorkspaceUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutUserInput | WorkspaceUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserRoleCreateManyUserInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceUserRoleCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput> | WorkspaceUserRoleCreateWithoutInviterInput[] | WorkspaceUserRoleUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutInviterInput | WorkspaceUserRoleCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceUserRoleCreateManyInviterInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceDocUserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput> | WorkspaceDocUserRoleCreateWithoutUserInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutUserInput | WorkspaceDocUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceDocUserRoleCreateManyUserInputEnvelope
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
  }

  export type ConnectedAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput> | ConnectedAccountCreateWithoutUserInput[] | ConnectedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectedAccountCreateOrConnectWithoutUserInput | ConnectedAccountCreateOrConnectWithoutUserInput[]
    createMany?: ConnectedAccountCreateManyUserInputEnvelope
    connect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AiSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput> | AiSessionCreateWithoutUserInput[] | AiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutUserInput | AiSessionCreateOrConnectWithoutUserInput[]
    createMany?: AiSessionCreateManyUserInputEnvelope
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
  }

  export type DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput = {
    create?: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput> | DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput[] | DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput[]
    createMany?: DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInputEnvelope
    connect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
  }

  export type AppConfigCreateNestedManyWithoutLastUpdatedByUserInput = {
    create?: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput> | AppConfigCreateWithoutLastUpdatedByUserInput[] | AppConfigUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: AppConfigCreateOrConnectWithoutLastUpdatedByUserInput | AppConfigCreateOrConnectWithoutLastUpdatedByUserInput[]
    createMany?: AppConfigCreateManyLastUpdatedByUserInputEnvelope
    connect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
  }

  export type UserSnapshotCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput> | UserSnapshotCreateWithoutUserInput[] | UserSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSnapshotCreateOrConnectWithoutUserInput | UserSnapshotCreateOrConnectWithoutUserInput[]
    createMany?: UserSnapshotCreateManyUserInputEnvelope
    connect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
  }

  export type SnapshotCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput> | SnapshotCreateWithoutCreatedByUserInput[] | SnapshotUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutCreatedByUserInput | SnapshotCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SnapshotCreateManyCreatedByUserInputEnvelope
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
  }

  export type SnapshotCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput> | SnapshotCreateWithoutUpdatedByUserInput[] | SnapshotUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutUpdatedByUserInput | SnapshotCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SnapshotCreateManyUpdatedByUserInputEnvelope
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
  }

  export type UpdateCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput> | UpdateCreateWithoutCreatedByUserInput[] | UpdateUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: UpdateCreateOrConnectWithoutCreatedByUserInput | UpdateCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: UpdateCreateManyCreatedByUserInputEnvelope
    connect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
  }

  export type SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput> | SnapshotHistoryCreateWithoutCreatedByUserInput[] | SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput | SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SnapshotHistoryCreateManyCreatedByUserInputEnvelope
    connect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
  }

  export type AiJobsCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput> | AiJobsCreateWithoutCreatedByUserInput[] | AiJobsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AiJobsCreateOrConnectWithoutCreatedByUserInput | AiJobsCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: AiJobsCreateManyCreatedByUserInputEnvelope
    connect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReplyCreateNestedManyWithoutUserInput = {
    create?: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput> | ReplyCreateWithoutUserInput[] | ReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutUserInput | ReplyCreateOrConnectWithoutUserInput[]
    createMany?: ReplyCreateManyUserInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type CommentAttachmentCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput> | CommentAttachmentCreateWithoutCreatedByUserInput[] | CommentAttachmentUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutCreatedByUserInput | CommentAttachmentCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: CommentAttachmentCreateManyCreatedByUserInputEnvelope
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
  }

  export type AccessTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type UserFeatureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput> | UserFeatureCreateWithoutUserInput[] | UserFeatureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutUserInput | UserFeatureCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureCreateManyUserInputEnvelope
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
  }

  export type UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStripeCustomerCreateOrConnectWithoutUserInput
    connect?: UserStripeCustomerWhereUniqueInput
  }

  export type WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput> | WorkspaceUserRoleCreateWithoutUserInput[] | WorkspaceUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutUserInput | WorkspaceUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceUserRoleCreateManyUserInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput> | WorkspaceUserRoleCreateWithoutInviterInput[] | WorkspaceUserRoleUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutInviterInput | WorkspaceUserRoleCreateOrConnectWithoutInviterInput[]
    createMany?: WorkspaceUserRoleCreateManyInviterInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput> | WorkspaceDocUserRoleCreateWithoutUserInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutUserInput | WorkspaceDocUserRoleCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceDocUserRoleCreateManyUserInputEnvelope
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
  }

  export type ConnectedAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput> | ConnectedAccountCreateWithoutUserInput[] | ConnectedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectedAccountCreateOrConnectWithoutUserInput | ConnectedAccountCreateOrConnectWithoutUserInput[]
    createMany?: ConnectedAccountCreateManyUserInputEnvelope
    connect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type AiSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput> | AiSessionCreateWithoutUserInput[] | AiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutUserInput | AiSessionCreateOrConnectWithoutUserInput[]
    createMany?: AiSessionCreateManyUserInputEnvelope
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
  }

  export type DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput = {
    create?: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput> | DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput[] | DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput[]
    createMany?: DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInputEnvelope
    connect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
  }

  export type AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput = {
    create?: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput> | AppConfigCreateWithoutLastUpdatedByUserInput[] | AppConfigUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: AppConfigCreateOrConnectWithoutLastUpdatedByUserInput | AppConfigCreateOrConnectWithoutLastUpdatedByUserInput[]
    createMany?: AppConfigCreateManyLastUpdatedByUserInputEnvelope
    connect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
  }

  export type UserSnapshotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput> | UserSnapshotCreateWithoutUserInput[] | UserSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSnapshotCreateOrConnectWithoutUserInput | UserSnapshotCreateOrConnectWithoutUserInput[]
    createMany?: UserSnapshotCreateManyUserInputEnvelope
    connect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
  }

  export type SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput> | SnapshotCreateWithoutCreatedByUserInput[] | SnapshotUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutCreatedByUserInput | SnapshotCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SnapshotCreateManyCreatedByUserInputEnvelope
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
  }

  export type SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput> | SnapshotCreateWithoutUpdatedByUserInput[] | SnapshotUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutUpdatedByUserInput | SnapshotCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SnapshotCreateManyUpdatedByUserInputEnvelope
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
  }

  export type UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput> | UpdateCreateWithoutCreatedByUserInput[] | UpdateUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: UpdateCreateOrConnectWithoutCreatedByUserInput | UpdateCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: UpdateCreateManyCreatedByUserInputEnvelope
    connect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
  }

  export type SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput> | SnapshotHistoryCreateWithoutCreatedByUserInput[] | SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput | SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: SnapshotHistoryCreateManyCreatedByUserInputEnvelope
    connect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
  }

  export type AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput> | AiJobsCreateWithoutCreatedByUserInput[] | AiJobsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AiJobsCreateOrConnectWithoutCreatedByUserInput | AiJobsCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: AiJobsCreateManyCreatedByUserInputEnvelope
    connect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReplyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput> | ReplyCreateWithoutUserInput[] | ReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutUserInput | ReplyCreateOrConnectWithoutUserInput[]
    createMany?: ReplyCreateManyUserInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput> | CommentAttachmentCreateWithoutCreatedByUserInput[] | CommentAttachmentUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutCreatedByUserInput | CommentAttachmentCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: CommentAttachmentCreateManyCreatedByUserInputEnvelope
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
  }

  export type AccessTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserFeatureUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput> | UserFeatureCreateWithoutUserInput[] | UserFeatureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutUserInput | UserFeatureCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureUpsertWithWhereUniqueWithoutUserInput | UserFeatureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureCreateManyUserInputEnvelope
    set?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    disconnect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    delete?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    update?: UserFeatureUpdateWithWhereUniqueWithoutUserInput | UserFeatureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureUpdateManyWithWhereWithoutUserInput | UserFeatureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
  }

  export type UserStripeCustomerUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStripeCustomerCreateOrConnectWithoutUserInput
    upsert?: UserStripeCustomerUpsertWithoutUserInput
    disconnect?: UserStripeCustomerWhereInput | boolean
    delete?: UserStripeCustomerWhereInput | boolean
    connect?: UserStripeCustomerWhereUniqueInput
    update?: XOR<XOR<UserStripeCustomerUpdateToOneWithWhereWithoutUserInput, UserStripeCustomerUpdateWithoutUserInput>, UserStripeCustomerUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput> | WorkspaceUserRoleCreateWithoutUserInput[] | WorkspaceUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutUserInput | WorkspaceUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserRoleCreateManyUserInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutUserInput | WorkspaceUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceUserRoleUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput> | WorkspaceUserRoleCreateWithoutInviterInput[] | WorkspaceUserRoleUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutInviterInput | WorkspaceUserRoleCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutInviterInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceUserRoleCreateManyInviterInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutInviterInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutInviterInput | WorkspaceUserRoleUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput> | WorkspaceDocUserRoleCreateWithoutUserInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutUserInput | WorkspaceDocUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutUserInput | WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceDocUserRoleCreateManyUserInputEnvelope
    set?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    delete?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    update?: WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutUserInput | WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceDocUserRoleUpdateManyWithWhereWithoutUserInput | WorkspaceDocUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
  }

  export type ConnectedAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput> | ConnectedAccountCreateWithoutUserInput[] | ConnectedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectedAccountCreateOrConnectWithoutUserInput | ConnectedAccountCreateOrConnectWithoutUserInput[]
    upsert?: ConnectedAccountUpsertWithWhereUniqueWithoutUserInput | ConnectedAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConnectedAccountCreateManyUserInputEnvelope
    set?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    disconnect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    delete?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    connect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    update?: ConnectedAccountUpdateWithWhereUniqueWithoutUserInput | ConnectedAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConnectedAccountUpdateManyWithWhereWithoutUserInput | ConnectedAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConnectedAccountScalarWhereInput | ConnectedAccountScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AiSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput> | AiSessionCreateWithoutUserInput[] | AiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutUserInput | AiSessionCreateOrConnectWithoutUserInput[]
    upsert?: AiSessionUpsertWithWhereUniqueWithoutUserInput | AiSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiSessionCreateManyUserInputEnvelope
    set?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    disconnect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    delete?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    update?: AiSessionUpdateWithWhereUniqueWithoutUserInput | AiSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiSessionUpdateManyWithWhereWithoutUserInput | AiSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
  }

  export type DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput = {
    create?: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput> | DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput[] | DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput[]
    upsert?: DeprecatedAppRuntimeSettingsUpsertWithWhereUniqueWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpsertWithWhereUniqueWithoutLastUpdatedByUserInput[]
    createMany?: DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInputEnvelope
    set?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    disconnect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    delete?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    connect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    update?: DeprecatedAppRuntimeSettingsUpdateWithWhereUniqueWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpdateWithWhereUniqueWithoutLastUpdatedByUserInput[]
    updateMany?: DeprecatedAppRuntimeSettingsUpdateManyWithWhereWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpdateManyWithWhereWithoutLastUpdatedByUserInput[]
    deleteMany?: DeprecatedAppRuntimeSettingsScalarWhereInput | DeprecatedAppRuntimeSettingsScalarWhereInput[]
  }

  export type AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput = {
    create?: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput> | AppConfigCreateWithoutLastUpdatedByUserInput[] | AppConfigUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: AppConfigCreateOrConnectWithoutLastUpdatedByUserInput | AppConfigCreateOrConnectWithoutLastUpdatedByUserInput[]
    upsert?: AppConfigUpsertWithWhereUniqueWithoutLastUpdatedByUserInput | AppConfigUpsertWithWhereUniqueWithoutLastUpdatedByUserInput[]
    createMany?: AppConfigCreateManyLastUpdatedByUserInputEnvelope
    set?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    disconnect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    delete?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    connect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    update?: AppConfigUpdateWithWhereUniqueWithoutLastUpdatedByUserInput | AppConfigUpdateWithWhereUniqueWithoutLastUpdatedByUserInput[]
    updateMany?: AppConfigUpdateManyWithWhereWithoutLastUpdatedByUserInput | AppConfigUpdateManyWithWhereWithoutLastUpdatedByUserInput[]
    deleteMany?: AppConfigScalarWhereInput | AppConfigScalarWhereInput[]
  }

  export type UserSnapshotUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput> | UserSnapshotCreateWithoutUserInput[] | UserSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSnapshotCreateOrConnectWithoutUserInput | UserSnapshotCreateOrConnectWithoutUserInput[]
    upsert?: UserSnapshotUpsertWithWhereUniqueWithoutUserInput | UserSnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSnapshotCreateManyUserInputEnvelope
    set?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    disconnect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    delete?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    connect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    update?: UserSnapshotUpdateWithWhereUniqueWithoutUserInput | UserSnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSnapshotUpdateManyWithWhereWithoutUserInput | UserSnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSnapshotScalarWhereInput | UserSnapshotScalarWhereInput[]
  }

  export type SnapshotUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput> | SnapshotCreateWithoutCreatedByUserInput[] | SnapshotUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutCreatedByUserInput | SnapshotCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SnapshotUpsertWithWhereUniqueWithoutCreatedByUserInput | SnapshotUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SnapshotCreateManyCreatedByUserInputEnvelope
    set?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    disconnect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    delete?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    update?: SnapshotUpdateWithWhereUniqueWithoutCreatedByUserInput | SnapshotUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SnapshotUpdateManyWithWhereWithoutCreatedByUserInput | SnapshotUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
  }

  export type SnapshotUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput> | SnapshotCreateWithoutUpdatedByUserInput[] | SnapshotUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutUpdatedByUserInput | SnapshotCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SnapshotUpsertWithWhereUniqueWithoutUpdatedByUserInput | SnapshotUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SnapshotCreateManyUpdatedByUserInputEnvelope
    set?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    disconnect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    delete?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    update?: SnapshotUpdateWithWhereUniqueWithoutUpdatedByUserInput | SnapshotUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SnapshotUpdateManyWithWhereWithoutUpdatedByUserInput | SnapshotUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
  }

  export type UpdateUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput> | UpdateCreateWithoutCreatedByUserInput[] | UpdateUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: UpdateCreateOrConnectWithoutCreatedByUserInput | UpdateCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: UpdateUpsertWithWhereUniqueWithoutCreatedByUserInput | UpdateUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: UpdateCreateManyCreatedByUserInputEnvelope
    set?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    disconnect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    delete?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    connect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    update?: UpdateUpdateWithWhereUniqueWithoutCreatedByUserInput | UpdateUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: UpdateUpdateManyWithWhereWithoutCreatedByUserInput | UpdateUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: UpdateScalarWhereInput | UpdateScalarWhereInput[]
  }

  export type SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput> | SnapshotHistoryCreateWithoutCreatedByUserInput[] | SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput | SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SnapshotHistoryUpsertWithWhereUniqueWithoutCreatedByUserInput | SnapshotHistoryUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SnapshotHistoryCreateManyCreatedByUserInputEnvelope
    set?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    disconnect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    delete?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    connect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    update?: SnapshotHistoryUpdateWithWhereUniqueWithoutCreatedByUserInput | SnapshotHistoryUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SnapshotHistoryUpdateManyWithWhereWithoutCreatedByUserInput | SnapshotHistoryUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SnapshotHistoryScalarWhereInput | SnapshotHistoryScalarWhereInput[]
  }

  export type AiJobsUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput> | AiJobsCreateWithoutCreatedByUserInput[] | AiJobsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AiJobsCreateOrConnectWithoutCreatedByUserInput | AiJobsCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: AiJobsUpsertWithWhereUniqueWithoutCreatedByUserInput | AiJobsUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: AiJobsCreateManyCreatedByUserInputEnvelope
    set?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    disconnect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    delete?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    connect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    update?: AiJobsUpdateWithWhereUniqueWithoutCreatedByUserInput | AiJobsUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: AiJobsUpdateManyWithWhereWithoutCreatedByUserInput | AiJobsUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: AiJobsScalarWhereInput | AiJobsScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReplyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput> | ReplyCreateWithoutUserInput[] | ReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutUserInput | ReplyCreateOrConnectWithoutUserInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutUserInput | ReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReplyCreateManyUserInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutUserInput | ReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutUserInput | ReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput> | CommentAttachmentCreateWithoutCreatedByUserInput[] | CommentAttachmentUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutCreatedByUserInput | CommentAttachmentCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: CommentAttachmentUpsertWithWhereUniqueWithoutCreatedByUserInput | CommentAttachmentUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: CommentAttachmentCreateManyCreatedByUserInputEnvelope
    set?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    disconnect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    delete?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    update?: CommentAttachmentUpdateWithWhereUniqueWithoutCreatedByUserInput | CommentAttachmentUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: CommentAttachmentUpdateManyWithWhereWithoutCreatedByUserInput | CommentAttachmentUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
  }

  export type AccessTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type UserFeatureUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput> | UserFeatureCreateWithoutUserInput[] | UserFeatureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutUserInput | UserFeatureCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureUpsertWithWhereUniqueWithoutUserInput | UserFeatureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureCreateManyUserInputEnvelope
    set?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    disconnect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    delete?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    update?: UserFeatureUpdateWithWhereUniqueWithoutUserInput | UserFeatureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureUpdateManyWithWhereWithoutUserInput | UserFeatureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
  }

  export type UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStripeCustomerCreateOrConnectWithoutUserInput
    upsert?: UserStripeCustomerUpsertWithoutUserInput
    disconnect?: UserStripeCustomerWhereInput | boolean
    delete?: UserStripeCustomerWhereInput | boolean
    connect?: UserStripeCustomerWhereUniqueInput
    update?: XOR<XOR<UserStripeCustomerUpdateToOneWithWhereWithoutUserInput, UserStripeCustomerUpdateWithoutUserInput>, UserStripeCustomerUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput> | WorkspaceUserRoleCreateWithoutUserInput[] | WorkspaceUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutUserInput | WorkspaceUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutUserInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceUserRoleCreateManyUserInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutUserInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutUserInput | WorkspaceUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput> | WorkspaceUserRoleCreateWithoutInviterInput[] | WorkspaceUserRoleUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutInviterInput | WorkspaceUserRoleCreateOrConnectWithoutInviterInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutInviterInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: WorkspaceUserRoleCreateManyInviterInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutInviterInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutInviterInput | WorkspaceUserRoleUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput> | WorkspaceDocUserRoleCreateWithoutUserInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutUserInput | WorkspaceDocUserRoleCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutUserInput | WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceDocUserRoleCreateManyUserInputEnvelope
    set?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    delete?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    update?: WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutUserInput | WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceDocUserRoleUpdateManyWithWhereWithoutUserInput | WorkspaceDocUserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
  }

  export type ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput> | ConnectedAccountCreateWithoutUserInput[] | ConnectedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConnectedAccountCreateOrConnectWithoutUserInput | ConnectedAccountCreateOrConnectWithoutUserInput[]
    upsert?: ConnectedAccountUpsertWithWhereUniqueWithoutUserInput | ConnectedAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConnectedAccountCreateManyUserInputEnvelope
    set?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    disconnect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    delete?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    connect?: ConnectedAccountWhereUniqueInput | ConnectedAccountWhereUniqueInput[]
    update?: ConnectedAccountUpdateWithWhereUniqueWithoutUserInput | ConnectedAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConnectedAccountUpdateManyWithWhereWithoutUserInput | ConnectedAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConnectedAccountScalarWhereInput | ConnectedAccountScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type AiSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput> | AiSessionCreateWithoutUserInput[] | AiSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutUserInput | AiSessionCreateOrConnectWithoutUserInput[]
    upsert?: AiSessionUpsertWithWhereUniqueWithoutUserInput | AiSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiSessionCreateManyUserInputEnvelope
    set?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    disconnect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    delete?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    update?: AiSessionUpdateWithWhereUniqueWithoutUserInput | AiSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiSessionUpdateManyWithWhereWithoutUserInput | AiSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
  }

  export type DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput = {
    create?: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput> | DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput[] | DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput[]
    upsert?: DeprecatedAppRuntimeSettingsUpsertWithWhereUniqueWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpsertWithWhereUniqueWithoutLastUpdatedByUserInput[]
    createMany?: DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInputEnvelope
    set?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    disconnect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    delete?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    connect?: DeprecatedAppRuntimeSettingsWhereUniqueInput | DeprecatedAppRuntimeSettingsWhereUniqueInput[]
    update?: DeprecatedAppRuntimeSettingsUpdateWithWhereUniqueWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpdateWithWhereUniqueWithoutLastUpdatedByUserInput[]
    updateMany?: DeprecatedAppRuntimeSettingsUpdateManyWithWhereWithoutLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsUpdateManyWithWhereWithoutLastUpdatedByUserInput[]
    deleteMany?: DeprecatedAppRuntimeSettingsScalarWhereInput | DeprecatedAppRuntimeSettingsScalarWhereInput[]
  }

  export type AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput = {
    create?: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput> | AppConfigCreateWithoutLastUpdatedByUserInput[] | AppConfigUncheckedCreateWithoutLastUpdatedByUserInput[]
    connectOrCreate?: AppConfigCreateOrConnectWithoutLastUpdatedByUserInput | AppConfigCreateOrConnectWithoutLastUpdatedByUserInput[]
    upsert?: AppConfigUpsertWithWhereUniqueWithoutLastUpdatedByUserInput | AppConfigUpsertWithWhereUniqueWithoutLastUpdatedByUserInput[]
    createMany?: AppConfigCreateManyLastUpdatedByUserInputEnvelope
    set?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    disconnect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    delete?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    connect?: AppConfigWhereUniqueInput | AppConfigWhereUniqueInput[]
    update?: AppConfigUpdateWithWhereUniqueWithoutLastUpdatedByUserInput | AppConfigUpdateWithWhereUniqueWithoutLastUpdatedByUserInput[]
    updateMany?: AppConfigUpdateManyWithWhereWithoutLastUpdatedByUserInput | AppConfigUpdateManyWithWhereWithoutLastUpdatedByUserInput[]
    deleteMany?: AppConfigScalarWhereInput | AppConfigScalarWhereInput[]
  }

  export type UserSnapshotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput> | UserSnapshotCreateWithoutUserInput[] | UserSnapshotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSnapshotCreateOrConnectWithoutUserInput | UserSnapshotCreateOrConnectWithoutUserInput[]
    upsert?: UserSnapshotUpsertWithWhereUniqueWithoutUserInput | UserSnapshotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSnapshotCreateManyUserInputEnvelope
    set?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    disconnect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    delete?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    connect?: UserSnapshotWhereUniqueInput | UserSnapshotWhereUniqueInput[]
    update?: UserSnapshotUpdateWithWhereUniqueWithoutUserInput | UserSnapshotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSnapshotUpdateManyWithWhereWithoutUserInput | UserSnapshotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSnapshotScalarWhereInput | UserSnapshotScalarWhereInput[]
  }

  export type SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput> | SnapshotCreateWithoutCreatedByUserInput[] | SnapshotUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutCreatedByUserInput | SnapshotCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SnapshotUpsertWithWhereUniqueWithoutCreatedByUserInput | SnapshotUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SnapshotCreateManyCreatedByUserInputEnvelope
    set?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    disconnect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    delete?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    update?: SnapshotUpdateWithWhereUniqueWithoutCreatedByUserInput | SnapshotUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SnapshotUpdateManyWithWhereWithoutCreatedByUserInput | SnapshotUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
  }

  export type SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput> | SnapshotCreateWithoutUpdatedByUserInput[] | SnapshotUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SnapshotCreateOrConnectWithoutUpdatedByUserInput | SnapshotCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SnapshotUpsertWithWhereUniqueWithoutUpdatedByUserInput | SnapshotUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SnapshotCreateManyUpdatedByUserInputEnvelope
    set?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    disconnect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    delete?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    connect?: SnapshotWhereUniqueInput | SnapshotWhereUniqueInput[]
    update?: SnapshotUpdateWithWhereUniqueWithoutUpdatedByUserInput | SnapshotUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SnapshotUpdateManyWithWhereWithoutUpdatedByUserInput | SnapshotUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
  }

  export type UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput> | UpdateCreateWithoutCreatedByUserInput[] | UpdateUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: UpdateCreateOrConnectWithoutCreatedByUserInput | UpdateCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: UpdateUpsertWithWhereUniqueWithoutCreatedByUserInput | UpdateUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: UpdateCreateManyCreatedByUserInputEnvelope
    set?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    disconnect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    delete?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    connect?: UpdateWhereUniqueInput | UpdateWhereUniqueInput[]
    update?: UpdateUpdateWithWhereUniqueWithoutCreatedByUserInput | UpdateUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: UpdateUpdateManyWithWhereWithoutCreatedByUserInput | UpdateUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: UpdateScalarWhereInput | UpdateScalarWhereInput[]
  }

  export type SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput> | SnapshotHistoryCreateWithoutCreatedByUserInput[] | SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput | SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: SnapshotHistoryUpsertWithWhereUniqueWithoutCreatedByUserInput | SnapshotHistoryUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: SnapshotHistoryCreateManyCreatedByUserInputEnvelope
    set?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    disconnect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    delete?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    connect?: SnapshotHistoryWhereUniqueInput | SnapshotHistoryWhereUniqueInput[]
    update?: SnapshotHistoryUpdateWithWhereUniqueWithoutCreatedByUserInput | SnapshotHistoryUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: SnapshotHistoryUpdateManyWithWhereWithoutCreatedByUserInput | SnapshotHistoryUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: SnapshotHistoryScalarWhereInput | SnapshotHistoryScalarWhereInput[]
  }

  export type AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput> | AiJobsCreateWithoutCreatedByUserInput[] | AiJobsUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AiJobsCreateOrConnectWithoutCreatedByUserInput | AiJobsCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: AiJobsUpsertWithWhereUniqueWithoutCreatedByUserInput | AiJobsUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: AiJobsCreateManyCreatedByUserInputEnvelope
    set?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    disconnect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    delete?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    connect?: AiJobsWhereUniqueInput | AiJobsWhereUniqueInput[]
    update?: AiJobsUpdateWithWhereUniqueWithoutCreatedByUserInput | AiJobsUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: AiJobsUpdateManyWithWhereWithoutCreatedByUserInput | AiJobsUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: AiJobsScalarWhereInput | AiJobsScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReplyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput> | ReplyCreateWithoutUserInput[] | ReplyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutUserInput | ReplyCreateOrConnectWithoutUserInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutUserInput | ReplyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReplyCreateManyUserInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutUserInput | ReplyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutUserInput | ReplyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput> | CommentAttachmentCreateWithoutCreatedByUserInput[] | CommentAttachmentUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutCreatedByUserInput | CommentAttachmentCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: CommentAttachmentUpsertWithWhereUniqueWithoutCreatedByUserInput | CommentAttachmentUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: CommentAttachmentCreateManyCreatedByUserInputEnvelope
    set?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    disconnect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    delete?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    update?: CommentAttachmentUpdateWithWhereUniqueWithoutCreatedByUserInput | CommentAttachmentUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: CommentAttachmentUpdateManyWithWhereWithoutCreatedByUserInput | CommentAttachmentUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConnectedAccountsInput = {
    create?: XOR<UserCreateWithoutConnectedAccountsInput, UserUncheckedCreateWithoutConnectedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConnectedAccountsNestedInput = {
    create?: XOR<UserCreateWithoutConnectedAccountsInput, UserUncheckedCreateWithoutConnectedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedAccountsInput
    upsert?: UserUpsertWithoutConnectedAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectedAccountsInput, UserUpdateWithoutConnectedAccountsInput>, UserUncheckedUpdateWithoutConnectedAccountsInput>
  }

  export type UserSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput> | UserSessionCreateWithoutSessionInput[] | UserSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutSessionInput | UserSessionCreateOrConnectWithoutSessionInput[]
    createMany?: UserSessionCreateManySessionInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput> | UserSessionCreateWithoutSessionInput[] | UserSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutSessionInput | UserSessionCreateOrConnectWithoutSessionInput[]
    createMany?: UserSessionCreateManySessionInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput> | UserSessionCreateWithoutSessionInput[] | UserSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutSessionInput | UserSessionCreateOrConnectWithoutSessionInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutSessionInput | UserSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserSessionCreateManySessionInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutSessionInput | UserSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutSessionInput | UserSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput> | UserSessionCreateWithoutSessionInput[] | UserSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutSessionInput | UserSessionCreateOrConnectWithoutSessionInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutSessionInput | UserSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserSessionCreateManySessionInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutSessionInput | UserSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutSessionInput | UserSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<SessionCreateWithoutUserSessionsInput, SessionUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutUserSessionsInput
    connect?: SessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<SessionCreateWithoutUserSessionsInput, SessionUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutUserSessionsInput
    upsert?: SessionUpsertWithoutUserSessionsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutUserSessionsInput, SessionUpdateWithoutUserSessionsInput>, SessionUncheckedUpdateWithoutUserSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput> | WorkspaceFeatureCreateWithoutWorkspaceInput[] | WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput | WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceFeatureCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
  }

  export type WorkspaceDocCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocCreateWithoutWorkspaceInput[] | WorkspaceDocUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocCreateOrConnectWithoutWorkspaceInput | WorkspaceDocCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceDocCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
  }

  export type WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserRoleCreateWithoutWorkspaceInput[] | WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserRoleCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocUserRoleCreateWithoutWorkspaceInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceDocUserRoleCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
  }

  export type BlobCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput> | BlobCreateWithoutWorkspaceInput[] | BlobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BlobCreateOrConnectWithoutWorkspaceInput | BlobCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BlobCreateManyWorkspaceInputEnvelope
    connect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
  }

  export type AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput[] | AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput | AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiWorkspaceIgnoredDocsCreateManyWorkspaceInputEnvelope
    connect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
  }

  export type AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceFilesCreateWithoutWorkspaceInput[] | AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput | AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiWorkspaceFilesCreateManyWorkspaceInputEnvelope
    connect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput> | CommentCreateWithoutWorkspaceInput[] | CommentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkspaceInput | CommentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CommentCreateManyWorkspaceInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentAttachmentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput> | CommentAttachmentCreateWithoutWorkspaceInput[] | CommentAttachmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutWorkspaceInput | CommentAttachmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CommentAttachmentCreateManyWorkspaceInputEnvelope
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
  }

  export type WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput> | WorkspaceFeatureCreateWithoutWorkspaceInput[] | WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput | WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceFeatureCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
  }

  export type WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocCreateWithoutWorkspaceInput[] | WorkspaceDocUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocCreateOrConnectWithoutWorkspaceInput | WorkspaceDocCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceDocCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
  }

  export type WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserRoleCreateWithoutWorkspaceInput[] | WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceUserRoleCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
  }

  export type WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocUserRoleCreateWithoutWorkspaceInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceDocUserRoleCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
  }

  export type BlobUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput> | BlobCreateWithoutWorkspaceInput[] | BlobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BlobCreateOrConnectWithoutWorkspaceInput | BlobCreateOrConnectWithoutWorkspaceInput[]
    createMany?: BlobCreateManyWorkspaceInputEnvelope
    connect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
  }

  export type AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput[] | AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput | AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiWorkspaceIgnoredDocsCreateManyWorkspaceInputEnvelope
    connect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
  }

  export type AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceFilesCreateWithoutWorkspaceInput[] | AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput | AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AiWorkspaceFilesCreateManyWorkspaceInputEnvelope
    connect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput> | CommentCreateWithoutWorkspaceInput[] | CommentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkspaceInput | CommentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CommentCreateManyWorkspaceInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput> | CommentAttachmentCreateWithoutWorkspaceInput[] | CommentAttachmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutWorkspaceInput | CommentAttachmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: CommentAttachmentCreateManyWorkspaceInputEnvelope
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
  }

  export type WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput> | WorkspaceFeatureCreateWithoutWorkspaceInput[] | WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput | WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceFeatureUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceFeatureUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceFeatureCreateManyWorkspaceInputEnvelope
    set?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    disconnect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    delete?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    update?: WorkspaceFeatureUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceFeatureUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceFeatureUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceFeatureUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
  }

  export type WorkspaceDocUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocCreateWithoutWorkspaceInput[] | WorkspaceDocUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocCreateOrConnectWithoutWorkspaceInput | WorkspaceDocCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceDocUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceDocCreateManyWorkspaceInputEnvelope
    set?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    disconnect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    delete?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    connect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    update?: WorkspaceDocUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceDocUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceDocUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceDocScalarWhereInput | WorkspaceDocScalarWhereInput[]
  }

  export type WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserRoleCreateWithoutWorkspaceInput[] | WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserRoleCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocUserRoleCreateWithoutWorkspaceInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceDocUserRoleCreateManyWorkspaceInputEnvelope
    set?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    delete?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    update?: WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceDocUserRoleUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceDocUserRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
  }

  export type BlobUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput> | BlobCreateWithoutWorkspaceInput[] | BlobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BlobCreateOrConnectWithoutWorkspaceInput | BlobCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BlobUpsertWithWhereUniqueWithoutWorkspaceInput | BlobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BlobCreateManyWorkspaceInputEnvelope
    set?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    disconnect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    delete?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    connect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    update?: BlobUpdateWithWhereUniqueWithoutWorkspaceInput | BlobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BlobUpdateManyWithWhereWithoutWorkspaceInput | BlobUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BlobScalarWhereInput | BlobScalarWhereInput[]
  }

  export type AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput[] | AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput | AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiWorkspaceIgnoredDocsUpsertWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiWorkspaceIgnoredDocsCreateManyWorkspaceInputEnvelope
    set?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    disconnect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    delete?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    connect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    update?: AiWorkspaceIgnoredDocsUpdateWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiWorkspaceIgnoredDocsUpdateManyWithWhereWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiWorkspaceIgnoredDocsScalarWhereInput | AiWorkspaceIgnoredDocsScalarWhereInput[]
  }

  export type AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceFilesCreateWithoutWorkspaceInput[] | AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput | AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiWorkspaceFilesUpsertWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceFilesUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiWorkspaceFilesCreateManyWorkspaceInputEnvelope
    set?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    disconnect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    delete?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    connect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    update?: AiWorkspaceFilesUpdateWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceFilesUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiWorkspaceFilesUpdateManyWithWhereWithoutWorkspaceInput | AiWorkspaceFilesUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiWorkspaceFilesScalarWhereInput | AiWorkspaceFilesScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput> | CommentCreateWithoutWorkspaceInput[] | CommentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkspaceInput | CommentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutWorkspaceInput | CommentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CommentCreateManyWorkspaceInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutWorkspaceInput | CommentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutWorkspaceInput | CommentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentAttachmentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput> | CommentAttachmentCreateWithoutWorkspaceInput[] | CommentAttachmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutWorkspaceInput | CommentAttachmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CommentAttachmentUpsertWithWhereUniqueWithoutWorkspaceInput | CommentAttachmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CommentAttachmentCreateManyWorkspaceInputEnvelope
    set?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    disconnect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    delete?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    update?: CommentAttachmentUpdateWithWhereUniqueWithoutWorkspaceInput | CommentAttachmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CommentAttachmentUpdateManyWithWhereWithoutWorkspaceInput | CommentAttachmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
  }

  export type WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput> | WorkspaceFeatureCreateWithoutWorkspaceInput[] | WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput | WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceFeatureUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceFeatureUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceFeatureCreateManyWorkspaceInputEnvelope
    set?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    disconnect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    delete?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    update?: WorkspaceFeatureUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceFeatureUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceFeatureUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceFeatureUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
  }

  export type WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocCreateWithoutWorkspaceInput[] | WorkspaceDocUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocCreateOrConnectWithoutWorkspaceInput | WorkspaceDocCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceDocUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceDocCreateManyWorkspaceInputEnvelope
    set?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    disconnect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    delete?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    connect?: WorkspaceDocWhereUniqueInput | WorkspaceDocWhereUniqueInput[]
    update?: WorkspaceDocUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceDocUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceDocUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceDocScalarWhereInput | WorkspaceDocScalarWhereInput[]
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceUserRoleCreateWithoutWorkspaceInput[] | WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceUserRoleCreateManyWorkspaceInputEnvelope
    set?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    delete?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    connect?: WorkspaceUserRoleWhereUniqueInput | WorkspaceUserRoleWhereUniqueInput[]
    update?: WorkspaceUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceUserRoleUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceUserRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
  }

  export type WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput> | WorkspaceDocUserRoleCreateWithoutWorkspaceInput[] | WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput | WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceDocUserRoleCreateManyWorkspaceInputEnvelope
    set?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    disconnect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    delete?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    connect?: WorkspaceDocUserRoleWhereUniqueInput | WorkspaceDocUserRoleWhereUniqueInput[]
    update?: WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceDocUserRoleUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceDocUserRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
  }

  export type BlobUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput> | BlobCreateWithoutWorkspaceInput[] | BlobUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: BlobCreateOrConnectWithoutWorkspaceInput | BlobCreateOrConnectWithoutWorkspaceInput[]
    upsert?: BlobUpsertWithWhereUniqueWithoutWorkspaceInput | BlobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: BlobCreateManyWorkspaceInputEnvelope
    set?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    disconnect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    delete?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    connect?: BlobWhereUniqueInput | BlobWhereUniqueInput[]
    update?: BlobUpdateWithWhereUniqueWithoutWorkspaceInput | BlobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: BlobUpdateManyWithWhereWithoutWorkspaceInput | BlobUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: BlobScalarWhereInput | BlobScalarWhereInput[]
  }

  export type AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput[] | AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput | AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiWorkspaceIgnoredDocsUpsertWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiWorkspaceIgnoredDocsCreateManyWorkspaceInputEnvelope
    set?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    disconnect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    delete?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    connect?: AiWorkspaceIgnoredDocsWhereUniqueInput | AiWorkspaceIgnoredDocsWhereUniqueInput[]
    update?: AiWorkspaceIgnoredDocsUpdateWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiWorkspaceIgnoredDocsUpdateManyWithWhereWithoutWorkspaceInput | AiWorkspaceIgnoredDocsUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiWorkspaceIgnoredDocsScalarWhereInput | AiWorkspaceIgnoredDocsScalarWhereInput[]
  }

  export type AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput> | AiWorkspaceFilesCreateWithoutWorkspaceInput[] | AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput | AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AiWorkspaceFilesUpsertWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceFilesUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AiWorkspaceFilesCreateManyWorkspaceInputEnvelope
    set?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    disconnect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    delete?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    connect?: AiWorkspaceFilesWhereUniqueInput | AiWorkspaceFilesWhereUniqueInput[]
    update?: AiWorkspaceFilesUpdateWithWhereUniqueWithoutWorkspaceInput | AiWorkspaceFilesUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AiWorkspaceFilesUpdateManyWithWhereWithoutWorkspaceInput | AiWorkspaceFilesUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AiWorkspaceFilesScalarWhereInput | AiWorkspaceFilesScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput> | CommentCreateWithoutWorkspaceInput[] | CommentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkspaceInput | CommentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutWorkspaceInput | CommentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CommentCreateManyWorkspaceInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutWorkspaceInput | CommentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutWorkspaceInput | CommentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput> | CommentAttachmentCreateWithoutWorkspaceInput[] | CommentAttachmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: CommentAttachmentCreateOrConnectWithoutWorkspaceInput | CommentAttachmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: CommentAttachmentUpsertWithWhereUniqueWithoutWorkspaceInput | CommentAttachmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: CommentAttachmentCreateManyWorkspaceInputEnvelope
    set?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    disconnect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    delete?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    connect?: CommentAttachmentWhereUniqueInput | CommentAttachmentWhereUniqueInput[]
    update?: CommentAttachmentUpdateWithWhereUniqueWithoutWorkspaceInput | CommentAttachmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: CommentAttachmentUpdateManyWithWhereWithoutWorkspaceInput | CommentAttachmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutDocsInput = {
    create?: XOR<WorkspaceCreateWithoutDocsInput, WorkspaceUncheckedCreateWithoutDocsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutDocsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDocsInput, WorkspaceUncheckedCreateWithoutDocsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocsInput
    upsert?: WorkspaceUpsertWithoutDocsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDocsInput, WorkspaceUpdateWithoutDocsInput>, WorkspaceUncheckedUpdateWithoutDocsInput>
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<WorkspaceCreateWithoutPermissionsInput, WorkspaceUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPermissionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspaceInvitationsInput = {
    create?: XOR<UserCreateWithoutWorkspaceInvitationsInput, UserUncheckedCreateWithoutWorkspaceInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumWorkspaceMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceMemberStatus
  }

  export type EnumWorkspaceMemberSourceFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceMemberSource
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutPermissionsInput, WorkspaceUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPermissionsInput
    upsert?: WorkspaceUpsertWithoutPermissionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutPermissionsInput, WorkspaceUpdateWithoutPermissionsInput>, WorkspaceUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneWithoutWorkspaceInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutWorkspaceInvitationsInput, UserUncheckedCreateWithoutWorkspaceInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceInvitationsInput
    upsert?: UserUpsertWithoutWorkspaceInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspaceInvitationsInput, UserUpdateWithoutWorkspaceInvitationsInput>, UserUncheckedUpdateWithoutWorkspaceInvitationsInput>
  }

  export type UserCreateNestedOneWithoutDocPermissionsInput = {
    create?: XOR<UserCreateWithoutDocPermissionsInput, UserUncheckedCreateWithoutDocPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutDocPermissionsInput = {
    create?: XOR<WorkspaceCreateWithoutDocPermissionsInput, WorkspaceUncheckedCreateWithoutDocPermissionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocPermissionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDocPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutDocPermissionsInput, UserUncheckedCreateWithoutDocPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocPermissionsInput
    upsert?: UserUpsertWithoutDocPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocPermissionsInput, UserUpdateWithoutDocPermissionsInput>, UserUncheckedUpdateWithoutDocPermissionsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutDocPermissionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDocPermissionsInput, WorkspaceUncheckedCreateWithoutDocPermissionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDocPermissionsInput
    upsert?: WorkspaceUpsertWithoutDocPermissionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDocPermissionsInput, WorkspaceUpdateWithoutDocPermissionsInput>, WorkspaceUncheckedUpdateWithoutDocPermissionsInput>
  }

  export type UserFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput> | UserFeatureCreateWithoutFeatureInput[] | UserFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutFeatureInput | UserFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: UserFeatureCreateManyFeatureInputEnvelope
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
  }

  export type WorkspaceFeatureCreateNestedManyWithoutFeatureInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput> | WorkspaceFeatureCreateWithoutFeatureInput[] | WorkspaceFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutFeatureInput | WorkspaceFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: WorkspaceFeatureCreateManyFeatureInputEnvelope
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
  }

  export type UserFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput> | UserFeatureCreateWithoutFeatureInput[] | UserFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutFeatureInput | UserFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: UserFeatureCreateManyFeatureInputEnvelope
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
  }

  export type WorkspaceFeatureUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput> | WorkspaceFeatureCreateWithoutFeatureInput[] | WorkspaceFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutFeatureInput | WorkspaceFeatureCreateOrConnectWithoutFeatureInput[]
    createMany?: WorkspaceFeatureCreateManyFeatureInputEnvelope
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
  }

  export type UserFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput> | UserFeatureCreateWithoutFeatureInput[] | UserFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutFeatureInput | UserFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: UserFeatureUpsertWithWhereUniqueWithoutFeatureInput | UserFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: UserFeatureCreateManyFeatureInputEnvelope
    set?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    disconnect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    delete?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    update?: UserFeatureUpdateWithWhereUniqueWithoutFeatureInput | UserFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: UserFeatureUpdateManyWithWhereWithoutFeatureInput | UserFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
  }

  export type WorkspaceFeatureUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput> | WorkspaceFeatureCreateWithoutFeatureInput[] | WorkspaceFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutFeatureInput | WorkspaceFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: WorkspaceFeatureUpsertWithWhereUniqueWithoutFeatureInput | WorkspaceFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: WorkspaceFeatureCreateManyFeatureInputEnvelope
    set?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    disconnect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    delete?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    update?: WorkspaceFeatureUpdateWithWhereUniqueWithoutFeatureInput | WorkspaceFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: WorkspaceFeatureUpdateManyWithWhereWithoutFeatureInput | WorkspaceFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
  }

  export type UserFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput> | UserFeatureCreateWithoutFeatureInput[] | UserFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: UserFeatureCreateOrConnectWithoutFeatureInput | UserFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: UserFeatureUpsertWithWhereUniqueWithoutFeatureInput | UserFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: UserFeatureCreateManyFeatureInputEnvelope
    set?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    disconnect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    delete?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    connect?: UserFeatureWhereUniqueInput | UserFeatureWhereUniqueInput[]
    update?: UserFeatureUpdateWithWhereUniqueWithoutFeatureInput | UserFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: UserFeatureUpdateManyWithWhereWithoutFeatureInput | UserFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
  }

  export type WorkspaceFeatureUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput> | WorkspaceFeatureCreateWithoutFeatureInput[] | WorkspaceFeatureUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: WorkspaceFeatureCreateOrConnectWithoutFeatureInput | WorkspaceFeatureCreateOrConnectWithoutFeatureInput[]
    upsert?: WorkspaceFeatureUpsertWithWhereUniqueWithoutFeatureInput | WorkspaceFeatureUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: WorkspaceFeatureCreateManyFeatureInputEnvelope
    set?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    disconnect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    delete?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    connect?: WorkspaceFeatureWhereUniqueInput | WorkspaceFeatureWhereUniqueInput[]
    update?: WorkspaceFeatureUpdateWithWhereUniqueWithoutFeatureInput | WorkspaceFeatureUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: WorkspaceFeatureUpdateManyWithWhereWithoutFeatureInput | WorkspaceFeatureUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
  }

  export type FeatureCreateNestedOneWithoutUserFeaturesInput = {
    create?: XOR<FeatureCreateWithoutUserFeaturesInput, FeatureUncheckedCreateWithoutUserFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutUserFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<UserCreateWithoutFeaturesInput, UserUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeaturesInput
    connect?: UserWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutUserFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutUserFeaturesInput, FeatureUncheckedCreateWithoutUserFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutUserFeaturesInput
    upsert?: FeatureUpsertWithoutUserFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutUserFeaturesInput, FeatureUpdateWithoutUserFeaturesInput>, FeatureUncheckedUpdateWithoutUserFeaturesInput>
  }

  export type UserUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<UserCreateWithoutFeaturesInput, UserUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeaturesInput
    upsert?: UserUpsertWithoutFeaturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeaturesInput, UserUpdateWithoutFeaturesInput>, UserUncheckedUpdateWithoutFeaturesInput>
  }

  export type FeatureCreateNestedOneWithoutWorkspaceFeaturesInput = {
    create?: XOR<FeatureCreateWithoutWorkspaceFeaturesInput, FeatureUncheckedCreateWithoutWorkspaceFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutWorkspaceFeaturesInput
    connect?: FeatureWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<WorkspaceCreateWithoutFeaturesInput, WorkspaceUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFeaturesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type FeatureUpdateOneRequiredWithoutWorkspaceFeaturesNestedInput = {
    create?: XOR<FeatureCreateWithoutWorkspaceFeaturesInput, FeatureUncheckedCreateWithoutWorkspaceFeaturesInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutWorkspaceFeaturesInput
    upsert?: FeatureUpsertWithoutWorkspaceFeaturesInput
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutWorkspaceFeaturesInput, FeatureUpdateWithoutWorkspaceFeaturesInput>, FeatureUncheckedUpdateWithoutWorkspaceFeaturesInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFeaturesInput, WorkspaceUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFeaturesInput
    upsert?: WorkspaceUpsertWithoutFeaturesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFeaturesInput, WorkspaceUpdateWithoutFeaturesInput>, WorkspaceUncheckedUpdateWithoutFeaturesInput>
  }

  export type UserCreateNestedOneWithoutCreatedSnapshotInput = {
    create?: XOR<UserCreateWithoutCreatedSnapshotInput, UserUncheckedCreateWithoutCreatedSnapshotInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSnapshotInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedSnapshotInput = {
    create?: XOR<UserCreateWithoutUpdatedSnapshotInput, UserUncheckedCreateWithoutUpdatedSnapshotInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSnapshotInput
    connect?: UserWhereUniqueInput
  }

  export type AiWorkspaceEmbeddingCreateNestedManyWithoutSnapshotInput = {
    connect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
  }

  export type AiWorkspaceEmbeddingUncheckedCreateNestedManyWithoutSnapshotInput = {
    connect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutCreatedSnapshotNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSnapshotInput, UserUncheckedCreateWithoutCreatedSnapshotInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSnapshotInput
    upsert?: UserUpsertWithoutCreatedSnapshotInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSnapshotInput, UserUpdateWithoutCreatedSnapshotInput>, UserUncheckedUpdateWithoutCreatedSnapshotInput>
  }

  export type UserUpdateOneWithoutUpdatedSnapshotNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedSnapshotInput, UserUncheckedCreateWithoutUpdatedSnapshotInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSnapshotInput
    upsert?: UserUpsertWithoutUpdatedSnapshotInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedSnapshotInput, UserUpdateWithoutUpdatedSnapshotInput>, UserUncheckedUpdateWithoutUpdatedSnapshotInput>
  }

  export type AiWorkspaceEmbeddingUpdateManyWithoutSnapshotNestedInput = {
    set?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceEmbeddingUpdateWithWhereUniqueWithoutSnapshotInput | AiWorkspaceEmbeddingUpdateWithWhereUniqueWithoutSnapshotInput[]
    updateMany?: AiWorkspaceEmbeddingUpdateManyWithWhereWithoutSnapshotInput | AiWorkspaceEmbeddingUpdateManyWithWhereWithoutSnapshotInput[]
    deleteMany?: AiWorkspaceEmbeddingScalarWhereInput | AiWorkspaceEmbeddingScalarWhereInput[]
  }

  export type AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotNestedInput = {
    set?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceEmbeddingWhereUniqueInput | AiWorkspaceEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceEmbeddingUpdateWithWhereUniqueWithoutSnapshotInput | AiWorkspaceEmbeddingUpdateWithWhereUniqueWithoutSnapshotInput[]
    updateMany?: AiWorkspaceEmbeddingUpdateManyWithWhereWithoutSnapshotInput | AiWorkspaceEmbeddingUpdateManyWithWhereWithoutSnapshotInput[]
    deleteMany?: AiWorkspaceEmbeddingScalarWhereInput | AiWorkspaceEmbeddingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserSnapshotsInput = {
    create?: XOR<UserCreateWithoutUserSnapshotsInput, UserUncheckedCreateWithoutUserSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSnapshotsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSnapshotsNestedInput = {
    create?: XOR<UserCreateWithoutUserSnapshotsInput, UserUncheckedCreateWithoutUserSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSnapshotsInput
    upsert?: UserUpsertWithoutUserSnapshotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSnapshotsInput, UserUpdateWithoutUserSnapshotsInput>, UserUncheckedUpdateWithoutUserSnapshotsInput>
  }

  export type UserCreateNestedOneWithoutCreatedUpdateInput = {
    create?: XOR<UserCreateWithoutCreatedUpdateInput, UserUncheckedCreateWithoutCreatedUpdateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUpdateInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutCreatedUpdateNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUpdateInput, UserUncheckedCreateWithoutCreatedUpdateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUpdateInput
    upsert?: UserUpsertWithoutCreatedUpdateInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedUpdateInput, UserUpdateWithoutCreatedUpdateInput>, UserUncheckedUpdateWithoutCreatedUpdateInput>
  }

  export type UserCreateNestedOneWithoutCreatedHistoryInput = {
    create?: XOR<UserCreateWithoutCreatedHistoryInput, UserUncheckedCreateWithoutCreatedHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutCreatedHistoryNestedInput = {
    create?: XOR<UserCreateWithoutCreatedHistoryInput, UserUncheckedCreateWithoutCreatedHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedHistoryInput
    upsert?: UserUpsertWithoutCreatedHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedHistoryInput, UserUpdateWithoutCreatedHistoryInput>, UserUncheckedUpdateWithoutCreatedHistoryInput>
  }

  export type AiPromptCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AiPromptCreateWithoutMessagesInput, AiPromptUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiPromptCreateOrConnectWithoutMessagesInput
    connect?: AiPromptWhereUniqueInput
  }

  export type EnumAiPromptRoleFieldUpdateOperationsInput = {
    set?: $Enums.AiPromptRole
  }

  export type AiPromptUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AiPromptCreateWithoutMessagesInput, AiPromptUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiPromptCreateOrConnectWithoutMessagesInput
    upsert?: AiPromptUpsertWithoutMessagesInput
    connect?: AiPromptWhereUniqueInput
    update?: XOR<XOR<AiPromptUpdateToOneWithWhereWithoutMessagesInput, AiPromptUpdateWithoutMessagesInput>, AiPromptUncheckedUpdateWithoutMessagesInput>
  }

  export type AiPromptCreateoptionalModelsInput = {
    set: string[]
  }

  export type AiPromptMessageCreateNestedManyWithoutPromptInput = {
    create?: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput> | AiPromptMessageCreateWithoutPromptInput[] | AiPromptMessageUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiPromptMessageCreateOrConnectWithoutPromptInput | AiPromptMessageCreateOrConnectWithoutPromptInput[]
    createMany?: AiPromptMessageCreateManyPromptInputEnvelope
    connect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
  }

  export type AiSessionCreateNestedManyWithoutPromptInput = {
    create?: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput> | AiSessionCreateWithoutPromptInput[] | AiSessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutPromptInput | AiSessionCreateOrConnectWithoutPromptInput[]
    createMany?: AiSessionCreateManyPromptInputEnvelope
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
  }

  export type AiPromptMessageUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput> | AiPromptMessageCreateWithoutPromptInput[] | AiPromptMessageUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiPromptMessageCreateOrConnectWithoutPromptInput | AiPromptMessageCreateOrConnectWithoutPromptInput[]
    createMany?: AiPromptMessageCreateManyPromptInputEnvelope
    connect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
  }

  export type AiSessionUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput> | AiSessionCreateWithoutPromptInput[] | AiSessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutPromptInput | AiSessionCreateOrConnectWithoutPromptInput[]
    createMany?: AiSessionCreateManyPromptInputEnvelope
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
  }

  export type AiPromptUpdateoptionalModelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AiPromptMessageUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput> | AiPromptMessageCreateWithoutPromptInput[] | AiPromptMessageUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiPromptMessageCreateOrConnectWithoutPromptInput | AiPromptMessageCreateOrConnectWithoutPromptInput[]
    upsert?: AiPromptMessageUpsertWithWhereUniqueWithoutPromptInput | AiPromptMessageUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AiPromptMessageCreateManyPromptInputEnvelope
    set?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    disconnect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    delete?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    connect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    update?: AiPromptMessageUpdateWithWhereUniqueWithoutPromptInput | AiPromptMessageUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AiPromptMessageUpdateManyWithWhereWithoutPromptInput | AiPromptMessageUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AiPromptMessageScalarWhereInput | AiPromptMessageScalarWhereInput[]
  }

  export type AiSessionUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput> | AiSessionCreateWithoutPromptInput[] | AiSessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutPromptInput | AiSessionCreateOrConnectWithoutPromptInput[]
    upsert?: AiSessionUpsertWithWhereUniqueWithoutPromptInput | AiSessionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AiSessionCreateManyPromptInputEnvelope
    set?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    disconnect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    delete?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    update?: AiSessionUpdateWithWhereUniqueWithoutPromptInput | AiSessionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AiSessionUpdateManyWithWhereWithoutPromptInput | AiSessionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
  }

  export type AiPromptMessageUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput> | AiPromptMessageCreateWithoutPromptInput[] | AiPromptMessageUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiPromptMessageCreateOrConnectWithoutPromptInput | AiPromptMessageCreateOrConnectWithoutPromptInput[]
    upsert?: AiPromptMessageUpsertWithWhereUniqueWithoutPromptInput | AiPromptMessageUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AiPromptMessageCreateManyPromptInputEnvelope
    set?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    disconnect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    delete?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    connect?: AiPromptMessageWhereUniqueInput | AiPromptMessageWhereUniqueInput[]
    update?: AiPromptMessageUpdateWithWhereUniqueWithoutPromptInput | AiPromptMessageUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AiPromptMessageUpdateManyWithWhereWithoutPromptInput | AiPromptMessageUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AiPromptMessageScalarWhereInput | AiPromptMessageScalarWhereInput[]
  }

  export type AiSessionUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput> | AiSessionCreateWithoutPromptInput[] | AiSessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: AiSessionCreateOrConnectWithoutPromptInput | AiSessionCreateOrConnectWithoutPromptInput[]
    upsert?: AiSessionUpsertWithWhereUniqueWithoutPromptInput | AiSessionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: AiSessionCreateManyPromptInputEnvelope
    set?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    disconnect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    delete?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    connect?: AiSessionWhereUniqueInput | AiSessionWhereUniqueInput[]
    update?: AiSessionUpdateWithWhereUniqueWithoutPromptInput | AiSessionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: AiSessionUpdateManyWithWhereWithoutPromptInput | AiSessionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
  }

  export type AiSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<AiSessionCreateWithoutMessagesInput, AiSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiSessionCreateOrConnectWithoutMessagesInput
    connect?: AiSessionWhereUniqueInput
  }

  export type AiSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<AiSessionCreateWithoutMessagesInput, AiSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: AiSessionCreateOrConnectWithoutMessagesInput
    upsert?: AiSessionUpsertWithoutMessagesInput
    connect?: AiSessionWhereUniqueInput
    update?: XOR<XOR<AiSessionUpdateToOneWithWhereWithoutMessagesInput, AiSessionUpdateWithoutMessagesInput>, AiSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutAiSessionsInput = {
    create?: XOR<UserCreateWithoutAiSessionsInput, UserUncheckedCreateWithoutAiSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type AiPromptCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AiPromptCreateWithoutSessionsInput, AiPromptUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AiPromptCreateOrConnectWithoutSessionsInput
    connect?: AiPromptWhereUniqueInput
  }

  export type AiSessionMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput> | AiSessionMessageCreateWithoutSessionInput[] | AiSessionMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiSessionMessageCreateOrConnectWithoutSessionInput | AiSessionMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AiSessionMessageCreateManySessionInputEnvelope
    connect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
  }

  export type AiContextCreateNestedManyWithoutSessionInput = {
    create?: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput> | AiContextCreateWithoutSessionInput[] | AiContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiContextCreateOrConnectWithoutSessionInput | AiContextCreateOrConnectWithoutSessionInput[]
    createMany?: AiContextCreateManySessionInputEnvelope
    connect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
  }

  export type AiSessionMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput> | AiSessionMessageCreateWithoutSessionInput[] | AiSessionMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiSessionMessageCreateOrConnectWithoutSessionInput | AiSessionMessageCreateOrConnectWithoutSessionInput[]
    createMany?: AiSessionMessageCreateManySessionInputEnvelope
    connect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
  }

  export type AiContextUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput> | AiContextCreateWithoutSessionInput[] | AiContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiContextCreateOrConnectWithoutSessionInput | AiContextCreateOrConnectWithoutSessionInput[]
    createMany?: AiContextCreateManySessionInputEnvelope
    connect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAiSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAiSessionsInput, UserUncheckedCreateWithoutAiSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiSessionsInput
    upsert?: UserUpsertWithoutAiSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiSessionsInput, UserUpdateWithoutAiSessionsInput>, UserUncheckedUpdateWithoutAiSessionsInput>
  }

  export type AiPromptUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AiPromptCreateWithoutSessionsInput, AiPromptUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AiPromptCreateOrConnectWithoutSessionsInput
    upsert?: AiPromptUpsertWithoutSessionsInput
    connect?: AiPromptWhereUniqueInput
    update?: XOR<XOR<AiPromptUpdateToOneWithWhereWithoutSessionsInput, AiPromptUpdateWithoutSessionsInput>, AiPromptUncheckedUpdateWithoutSessionsInput>
  }

  export type AiSessionMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput> | AiSessionMessageCreateWithoutSessionInput[] | AiSessionMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiSessionMessageCreateOrConnectWithoutSessionInput | AiSessionMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AiSessionMessageUpsertWithWhereUniqueWithoutSessionInput | AiSessionMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AiSessionMessageCreateManySessionInputEnvelope
    set?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    disconnect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    delete?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    connect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    update?: AiSessionMessageUpdateWithWhereUniqueWithoutSessionInput | AiSessionMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AiSessionMessageUpdateManyWithWhereWithoutSessionInput | AiSessionMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AiSessionMessageScalarWhereInput | AiSessionMessageScalarWhereInput[]
  }

  export type AiContextUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput> | AiContextCreateWithoutSessionInput[] | AiContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiContextCreateOrConnectWithoutSessionInput | AiContextCreateOrConnectWithoutSessionInput[]
    upsert?: AiContextUpsertWithWhereUniqueWithoutSessionInput | AiContextUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AiContextCreateManySessionInputEnvelope
    set?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    disconnect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    delete?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    connect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    update?: AiContextUpdateWithWhereUniqueWithoutSessionInput | AiContextUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AiContextUpdateManyWithWhereWithoutSessionInput | AiContextUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AiContextScalarWhereInput | AiContextScalarWhereInput[]
  }

  export type AiSessionMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput> | AiSessionMessageCreateWithoutSessionInput[] | AiSessionMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiSessionMessageCreateOrConnectWithoutSessionInput | AiSessionMessageCreateOrConnectWithoutSessionInput[]
    upsert?: AiSessionMessageUpsertWithWhereUniqueWithoutSessionInput | AiSessionMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AiSessionMessageCreateManySessionInputEnvelope
    set?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    disconnect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    delete?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    connect?: AiSessionMessageWhereUniqueInput | AiSessionMessageWhereUniqueInput[]
    update?: AiSessionMessageUpdateWithWhereUniqueWithoutSessionInput | AiSessionMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AiSessionMessageUpdateManyWithWhereWithoutSessionInput | AiSessionMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AiSessionMessageScalarWhereInput | AiSessionMessageScalarWhereInput[]
  }

  export type AiContextUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput> | AiContextCreateWithoutSessionInput[] | AiContextUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AiContextCreateOrConnectWithoutSessionInput | AiContextCreateOrConnectWithoutSessionInput[]
    upsert?: AiContextUpsertWithWhereUniqueWithoutSessionInput | AiContextUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AiContextCreateManySessionInputEnvelope
    set?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    disconnect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    delete?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    connect?: AiContextWhereUniqueInput | AiContextWhereUniqueInput[]
    update?: AiContextUpdateWithWhereUniqueWithoutSessionInput | AiContextUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AiContextUpdateManyWithWhereWithoutSessionInput | AiContextUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AiContextScalarWhereInput | AiContextScalarWhereInput[]
  }

  export type AiContextEmbeddingCreateNestedManyWithoutContextInput = {
    connect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
  }

  export type AiSessionCreateNestedOneWithoutContextInput = {
    create?: XOR<AiSessionCreateWithoutContextInput, AiSessionUncheckedCreateWithoutContextInput>
    connectOrCreate?: AiSessionCreateOrConnectWithoutContextInput
    connect?: AiSessionWhereUniqueInput
  }

  export type AiContextEmbeddingUncheckedCreateNestedManyWithoutContextInput = {
    connect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
  }

  export type AiContextEmbeddingUpdateManyWithoutContextNestedInput = {
    set?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    disconnect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    delete?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    connect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    update?: AiContextEmbeddingUpdateWithWhereUniqueWithoutContextInput | AiContextEmbeddingUpdateWithWhereUniqueWithoutContextInput[]
    updateMany?: AiContextEmbeddingUpdateManyWithWhereWithoutContextInput | AiContextEmbeddingUpdateManyWithWhereWithoutContextInput[]
    deleteMany?: AiContextEmbeddingScalarWhereInput | AiContextEmbeddingScalarWhereInput[]
  }

  export type AiSessionUpdateOneRequiredWithoutContextNestedInput = {
    create?: XOR<AiSessionCreateWithoutContextInput, AiSessionUncheckedCreateWithoutContextInput>
    connectOrCreate?: AiSessionCreateOrConnectWithoutContextInput
    upsert?: AiSessionUpsertWithoutContextInput
    connect?: AiSessionWhereUniqueInput
    update?: XOR<XOR<AiSessionUpdateToOneWithWhereWithoutContextInput, AiSessionUpdateWithoutContextInput>, AiSessionUncheckedUpdateWithoutContextInput>
  }

  export type AiContextEmbeddingUncheckedUpdateManyWithoutContextNestedInput = {
    set?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    disconnect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    delete?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    connect?: AiContextEmbeddingWhereUniqueInput | AiContextEmbeddingWhereUniqueInput[]
    update?: AiContextEmbeddingUpdateWithWhereUniqueWithoutContextInput | AiContextEmbeddingUpdateWithWhereUniqueWithoutContextInput[]
    updateMany?: AiContextEmbeddingUpdateManyWithWhereWithoutContextInput | AiContextEmbeddingUpdateManyWithWhereWithoutContextInput[]
    deleteMany?: AiContextEmbeddingScalarWhereInput | AiContextEmbeddingScalarWhereInput[]
  }

  export type AiContextUpdateOneRequiredWithoutEmbeddingsNestedInput = {
    create?: XOR<AiContextCreateWithoutEmbeddingsInput, AiContextUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: AiContextCreateOrConnectWithoutEmbeddingsInput
    upsert?: AiContextUpsertWithoutEmbeddingsInput
    connect?: AiContextWhereUniqueInput
    update?: XOR<XOR<AiContextUpdateToOneWithWhereWithoutEmbeddingsInput, AiContextUpdateWithoutEmbeddingsInput>, AiContextUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type SnapshotUpdateOneRequiredWithoutEmbeddingNestedInput = {
    create?: XOR<SnapshotCreateWithoutEmbeddingInput, SnapshotUncheckedCreateWithoutEmbeddingInput>
    connectOrCreate?: SnapshotCreateOrConnectWithoutEmbeddingInput
    upsert?: SnapshotUpsertWithoutEmbeddingInput
    connect?: SnapshotWhereUniqueInput
    update?: XOR<XOR<SnapshotUpdateToOneWithWhereWithoutEmbeddingInput, SnapshotUpdateWithoutEmbeddingInput>, SnapshotUncheckedUpdateWithoutEmbeddingInput>
  }

  export type WorkspaceCreateNestedOneWithoutIgnoredDocsInput = {
    create?: XOR<WorkspaceCreateWithoutIgnoredDocsInput, WorkspaceUncheckedCreateWithoutIgnoredDocsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIgnoredDocsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutIgnoredDocsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutIgnoredDocsInput, WorkspaceUncheckedCreateWithoutIgnoredDocsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIgnoredDocsInput
    upsert?: WorkspaceUpsertWithoutIgnoredDocsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutIgnoredDocsInput, WorkspaceUpdateWithoutIgnoredDocsInput>, WorkspaceUncheckedUpdateWithoutIgnoredDocsInput>
  }

  export type WorkspaceCreateNestedOneWithoutEmbedFilesInput = {
    create?: XOR<WorkspaceCreateWithoutEmbedFilesInput, WorkspaceUncheckedCreateWithoutEmbedFilesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEmbedFilesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AiWorkspaceFileEmbeddingCreateNestedManyWithoutFileInput = {
    connect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
  }

  export type AiWorkspaceFileEmbeddingUncheckedCreateNestedManyWithoutFileInput = {
    connect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutEmbedFilesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutEmbedFilesInput, WorkspaceUncheckedCreateWithoutEmbedFilesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEmbedFilesInput
    upsert?: WorkspaceUpsertWithoutEmbedFilesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutEmbedFilesInput, WorkspaceUpdateWithoutEmbedFilesInput>, WorkspaceUncheckedUpdateWithoutEmbedFilesInput>
  }

  export type AiWorkspaceFileEmbeddingUpdateManyWithoutFileNestedInput = {
    set?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceFileEmbeddingUpdateWithWhereUniqueWithoutFileInput | AiWorkspaceFileEmbeddingUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: AiWorkspaceFileEmbeddingUpdateManyWithWhereWithoutFileInput | AiWorkspaceFileEmbeddingUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: AiWorkspaceFileEmbeddingScalarWhereInput | AiWorkspaceFileEmbeddingScalarWhereInput[]
  }

  export type AiWorkspaceFileEmbeddingUncheckedUpdateManyWithoutFileNestedInput = {
    set?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceFileEmbeddingWhereUniqueInput | AiWorkspaceFileEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceFileEmbeddingUpdateWithWhereUniqueWithoutFileInput | AiWorkspaceFileEmbeddingUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: AiWorkspaceFileEmbeddingUpdateManyWithWhereWithoutFileInput | AiWorkspaceFileEmbeddingUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: AiWorkspaceFileEmbeddingScalarWhereInput | AiWorkspaceFileEmbeddingScalarWhereInput[]
  }

  export type AiWorkspaceFilesUpdateOneRequiredWithoutEmbeddingsNestedInput = {
    create?: XOR<AiWorkspaceFilesCreateWithoutEmbeddingsInput, AiWorkspaceFilesUncheckedCreateWithoutEmbeddingsInput>
    connectOrCreate?: AiWorkspaceFilesCreateOrConnectWithoutEmbeddingsInput
    upsert?: AiWorkspaceFilesUpsertWithoutEmbeddingsInput
    connect?: AiWorkspaceFilesWhereUniqueInput
    update?: XOR<XOR<AiWorkspaceFilesUpdateToOneWithWhereWithoutEmbeddingsInput, AiWorkspaceFilesUpdateWithoutEmbeddingsInput>, AiWorkspaceFilesUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type BlobUpdateOneRequiredWithoutAiWorkspaceBlobEmbeddingNestedInput = {
    create?: XOR<BlobCreateWithoutAiWorkspaceBlobEmbeddingInput, BlobUncheckedCreateWithoutAiWorkspaceBlobEmbeddingInput>
    connectOrCreate?: BlobCreateOrConnectWithoutAiWorkspaceBlobEmbeddingInput
    upsert?: BlobUpsertWithoutAiWorkspaceBlobEmbeddingInput
    connect?: BlobWhereUniqueInput
    update?: XOR<XOR<BlobUpdateToOneWithWhereWithoutAiWorkspaceBlobEmbeddingInput, BlobUpdateWithoutAiWorkspaceBlobEmbeddingInput>, BlobUncheckedUpdateWithoutAiWorkspaceBlobEmbeddingInput>
  }

  export type UserCreateNestedOneWithoutCreatedAiJobsInput = {
    create?: XOR<UserCreateWithoutCreatedAiJobsInput, UserUncheckedCreateWithoutCreatedAiJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAiJobsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAiJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.AiJobType
  }

  export type EnumAiJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.AiJobStatus
  }

  export type UserUpdateOneWithoutCreatedAiJobsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedAiJobsInput, UserUncheckedCreateWithoutCreatedAiJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedAiJobsInput
    upsert?: UserUpsertWithoutCreatedAiJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedAiJobsInput, UserUpdateWithoutCreatedAiJobsInput>, UserUncheckedUpdateWithoutCreatedAiJobsInput>
  }

  export type UserCreateNestedOneWithoutDeprecatedAppRuntimeSettingsInput = {
    create?: XOR<UserCreateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedCreateWithoutDeprecatedAppRuntimeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeprecatedAppRuntimeSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRuntimeConfigTypeFieldUpdateOperationsInput = {
    set?: $Enums.RuntimeConfigType
  }

  export type UserUpdateOneWithoutDeprecatedAppRuntimeSettingsNestedInput = {
    create?: XOR<UserCreateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedCreateWithoutDeprecatedAppRuntimeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeprecatedAppRuntimeSettingsInput
    upsert?: UserUpsertWithoutDeprecatedAppRuntimeSettingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeprecatedAppRuntimeSettingsInput, UserUpdateWithoutDeprecatedAppRuntimeSettingsInput>, UserUncheckedUpdateWithoutDeprecatedAppRuntimeSettingsInput>
  }

  export type UserCreateNestedOneWithoutAppConfigsInput = {
    create?: XOR<UserCreateWithoutAppConfigsInput, UserUncheckedCreateWithoutAppConfigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppConfigsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAppConfigsNestedInput = {
    create?: XOR<UserCreateWithoutAppConfigsInput, UserUncheckedCreateWithoutAppConfigsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppConfigsInput
    upsert?: UserUpsertWithoutAppConfigsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppConfigsInput, UserUpdateWithoutAppConfigsInput>, UserUncheckedUpdateWithoutAppConfigsInput>
  }

  export type UserCreateNestedOneWithoutUserStripeCustomerInput = {
    create?: XOR<UserCreateWithoutUserStripeCustomerInput, UserUncheckedCreateWithoutUserStripeCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStripeCustomerInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserStripeCustomerNestedInput = {
    create?: XOR<UserCreateWithoutUserStripeCustomerInput, UserUncheckedCreateWithoutUserStripeCustomerInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStripeCustomerInput
    upsert?: UserUpsertWithoutUserStripeCustomerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserStripeCustomerInput, UserUpdateWithoutUserStripeCustomerInput>, UserUncheckedUpdateWithoutUserStripeCustomerInput>
  }

  export type EnumProviderFieldUpdateOperationsInput = {
    set?: $Enums.Provider
  }

  export type NullableEnumIapStoreFieldUpdateOperationsInput = {
    set?: $Enums.IapStore | null
  }

  export type WorkspaceCreateNestedOneWithoutBlobsInput = {
    create?: XOR<WorkspaceCreateWithoutBlobsInput, WorkspaceUncheckedCreateWithoutBlobsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBlobsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AiWorkspaceBlobEmbeddingCreateNestedManyWithoutBlobInput = {
    connect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
  }

  export type AiWorkspaceBlobEmbeddingUncheckedCreateNestedManyWithoutBlobInput = {
    connect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutBlobsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutBlobsInput, WorkspaceUncheckedCreateWithoutBlobsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutBlobsInput
    upsert?: WorkspaceUpsertWithoutBlobsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutBlobsInput, WorkspaceUpdateWithoutBlobsInput>, WorkspaceUncheckedUpdateWithoutBlobsInput>
  }

  export type AiWorkspaceBlobEmbeddingUpdateManyWithoutBlobNestedInput = {
    set?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceBlobEmbeddingUpdateWithWhereUniqueWithoutBlobInput | AiWorkspaceBlobEmbeddingUpdateWithWhereUniqueWithoutBlobInput[]
    updateMany?: AiWorkspaceBlobEmbeddingUpdateManyWithWhereWithoutBlobInput | AiWorkspaceBlobEmbeddingUpdateManyWithWhereWithoutBlobInput[]
    deleteMany?: AiWorkspaceBlobEmbeddingScalarWhereInput | AiWorkspaceBlobEmbeddingScalarWhereInput[]
  }

  export type AiWorkspaceBlobEmbeddingUncheckedUpdateManyWithoutBlobNestedInput = {
    set?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    disconnect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    delete?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    connect?: AiWorkspaceBlobEmbeddingWhereUniqueInput | AiWorkspaceBlobEmbeddingWhereUniqueInput[]
    update?: AiWorkspaceBlobEmbeddingUpdateWithWhereUniqueWithoutBlobInput | AiWorkspaceBlobEmbeddingUpdateWithWhereUniqueWithoutBlobInput[]
    updateMany?: AiWorkspaceBlobEmbeddingUpdateManyWithWhereWithoutBlobInput | AiWorkspaceBlobEmbeddingUpdateManyWithWhereWithoutBlobInput[]
    deleteMany?: AiWorkspaceBlobEmbeddingScalarWhereInput | AiWorkspaceBlobEmbeddingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationLevelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationLevel
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutCommentsInput = {
    create?: XOR<WorkspaceCreateWithoutCommentsInput, WorkspaceUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ReplyCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput> | ReplyCreateWithoutCommentInput[] | ReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutCommentInput | ReplyCreateOrConnectWithoutCommentInput[]
    createMany?: ReplyCreateManyCommentInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type ReplyUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput> | ReplyCreateWithoutCommentInput[] | ReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutCommentInput | ReplyCreateOrConnectWithoutCommentInput[]
    createMany?: ReplyCreateManyCommentInputEnvelope
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCommentsInput, WorkspaceUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentsInput
    upsert?: WorkspaceUpsertWithoutCommentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCommentsInput, WorkspaceUpdateWithoutCommentsInput>, WorkspaceUncheckedUpdateWithoutCommentsInput>
  }

  export type ReplyUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput> | ReplyCreateWithoutCommentInput[] | ReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutCommentInput | ReplyCreateOrConnectWithoutCommentInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutCommentInput | ReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReplyCreateManyCommentInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutCommentInput | ReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutCommentInput | ReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type ReplyUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput> | ReplyCreateWithoutCommentInput[] | ReplyUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCreateOrConnectWithoutCommentInput | ReplyCreateOrConnectWithoutCommentInput[]
    upsert?: ReplyUpsertWithWhereUniqueWithoutCommentInput | ReplyUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReplyCreateManyCommentInputEnvelope
    set?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    disconnect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    delete?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    connect?: ReplyWhereUniqueInput | ReplyWhereUniqueInput[]
    update?: ReplyUpdateWithWhereUniqueWithoutCommentInput | ReplyUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReplyUpdateManyWithWhereWithoutCommentInput | ReplyUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRepliesInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    upsert?: UserUpsertWithoutRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRepliesInput, UserUpdateWithoutRepliesInput>, UserUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type WorkspaceCreateNestedOneWithoutCommentAttachmentsInput = {
    create?: XOR<WorkspaceCreateWithoutCommentAttachmentsInput, WorkspaceUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentAttachmentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentAttachmentsInput = {
    create?: XOR<UserCreateWithoutCommentAttachmentsInput, UserUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentAttachmentsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutCommentAttachmentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutCommentAttachmentsInput, WorkspaceUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutCommentAttachmentsInput
    upsert?: WorkspaceUpsertWithoutCommentAttachmentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutCommentAttachmentsInput, WorkspaceUpdateWithoutCommentAttachmentsInput>, WorkspaceUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type UserUpdateOneWithoutCommentAttachmentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentAttachmentsInput, UserUncheckedCreateWithoutCommentAttachmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentAttachmentsInput
    upsert?: UserUpsertWithoutCommentAttachmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentAttachmentsInput, UserUpdateWithoutCommentAttachmentsInput>, UserUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type UserCreateNestedOneWithoutAccessTokenInput = {
    create?: XOR<UserCreateWithoutAccessTokenInput, UserUncheckedCreateWithoutAccessTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccessTokenNestedInput = {
    create?: XOR<UserCreateWithoutAccessTokenInput, UserUncheckedCreateWithoutAccessTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessTokenInput
    upsert?: UserUpsertWithoutAccessTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccessTokenInput, UserUpdateWithoutAccessTokenInput>, UserUncheckedUpdateWithoutAccessTokenInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumWorkspaceMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberStatus | EnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel> | $Enums.WorkspaceMemberStatus
  }

  export type NestedEnumWorkspaceMemberSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberSource | EnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel> | $Enums.WorkspaceMemberSource
  }

  export type NestedEnumWorkspaceMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberStatus | EnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberStatus[] | ListEnumWorkspaceMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceMemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceMemberStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceMemberSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceMemberSource | EnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceMemberSource[] | ListEnumWorkspaceMemberSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceMemberSourceWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceMemberSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceMemberSourceFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAiPromptRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPromptRole | EnumAiPromptRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPromptRoleFilter<$PrismaModel> | $Enums.AiPromptRole
  }

  export type NestedEnumAiPromptRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiPromptRole | EnumAiPromptRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiPromptRole[] | ListEnumAiPromptRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAiPromptRoleWithAggregatesFilter<$PrismaModel> | $Enums.AiPromptRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiPromptRoleFilter<$PrismaModel>
    _max?: NestedEnumAiPromptRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAiJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobType | EnumAiJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobTypeFilter<$PrismaModel> | $Enums.AiJobType
  }

  export type NestedEnumAiJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobStatus | EnumAiJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobStatusFilter<$PrismaModel> | $Enums.AiJobStatus
  }

  export type NestedEnumAiJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobType | EnumAiJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobType[] | ListEnumAiJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.AiJobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiJobTypeFilter<$PrismaModel>
    _max?: NestedEnumAiJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumAiJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AiJobStatus | EnumAiJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AiJobStatus[] | ListEnumAiJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAiJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.AiJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAiJobStatusFilter<$PrismaModel>
    _max?: NestedEnumAiJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumRuntimeConfigTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RuntimeConfigType | EnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel> | $Enums.RuntimeConfigType
  }

  export type NestedEnumRuntimeConfigTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuntimeConfigType | EnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuntimeConfigType[] | ListEnumRuntimeConfigTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuntimeConfigTypeWithAggregatesFilter<$PrismaModel> | $Enums.RuntimeConfigType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel>
    _max?: NestedEnumRuntimeConfigTypeFilter<$PrismaModel>
  }

  export type NestedEnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type NestedEnumIapStoreNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IapStore | EnumIapStoreFieldRefInput<$PrismaModel> | null
    in?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIapStoreNullableFilter<$PrismaModel> | $Enums.IapStore | null
  }

  export type NestedEnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type NestedEnumIapStoreNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IapStore | EnumIapStoreFieldRefInput<$PrismaModel> | null
    in?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IapStore[] | ListEnumIapStoreFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIapStoreNullableWithAggregatesFilter<$PrismaModel> | $Enums.IapStore | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIapStoreNullableFilter<$PrismaModel>
    _max?: NestedEnumIapStoreNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationLevel | EnumNotificationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationLevelFilter<$PrismaModel> | $Enums.NotificationLevel
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationLevel | EnumNotificationLevelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationLevel[] | ListEnumNotificationLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationLevelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationLevelFilter<$PrismaModel>
    _max?: NestedEnumNotificationLevelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserFeatureCreateWithoutUserInput = {
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
    feature: FeatureCreateNestedOneWithoutUserFeaturesInput
  }

  export type UserFeatureUncheckedCreateWithoutUserInput = {
    id?: number
    featureId: number
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type UserFeatureCreateOrConnectWithoutUserInput = {
    where: UserFeatureWhereUniqueInput
    create: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureCreateManyUserInputEnvelope = {
    data: UserFeatureCreateManyUserInput | UserFeatureCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStripeCustomerCreateWithoutUserInput = {
    stripeCustomerId: string
    createdAt?: Date | string
  }

  export type UserStripeCustomerUncheckedCreateWithoutUserInput = {
    stripeCustomerId: string
    createdAt?: Date | string
  }

  export type UserStripeCustomerCreateOrConnectWithoutUserInput = {
    where: UserStripeCustomerWhereUniqueInput
    create: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserRoleCreateWithoutUserInput = {
    id?: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
    workspace: WorkspaceCreateNestedOneWithoutPermissionsInput
    inviter?: UserCreateNestedOneWithoutWorkspaceInvitationsInput
  }

  export type WorkspaceUserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleCreateOrConnectWithoutUserInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    create: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserRoleCreateManyUserInputEnvelope = {
    data: WorkspaceUserRoleCreateManyUserInput | WorkspaceUserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserRoleCreateWithoutInviterInput = {
    id?: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
    user: UserCreateNestedOneWithoutWorkspacesInput
    workspace: WorkspaceCreateNestedOneWithoutPermissionsInput
  }

  export type WorkspaceUserRoleUncheckedCreateWithoutInviterInput = {
    id?: string
    workspaceId: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleCreateOrConnectWithoutInviterInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    create: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceUserRoleCreateManyInviterInputEnvelope = {
    data: WorkspaceUserRoleCreateManyInviterInput | WorkspaceUserRoleCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceDocUserRoleCreateWithoutUserInput = {
    docId: string
    type: number
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDocPermissionsInput
  }

  export type WorkspaceDocUserRoleUncheckedCreateWithoutUserInput = {
    workspaceId: string
    docId: string
    type: number
    createdAt?: Date | string
  }

  export type WorkspaceDocUserRoleCreateOrConnectWithoutUserInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    create: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceDocUserRoleCreateManyUserInputEnvelope = {
    data: WorkspaceDocUserRoleCreateManyUserInput | WorkspaceDocUserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConnectedAccountCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectedAccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConnectedAccountCreateOrConnectWithoutUserInput = {
    where: ConnectedAccountWhereUniqueInput
    create: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput>
  }

  export type ConnectedAccountCreateManyUserInputEnvelope = {
    data: ConnectedAccountCreateManyUserInput | ConnectedAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AiSessionCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    prompt: AiPromptCreateNestedOneWithoutSessionsInput
    messages?: AiSessionMessageCreateNestedManyWithoutSessionInput
    context?: AiContextCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: AiSessionMessageUncheckedCreateNestedManyWithoutSessionInput
    context?: AiContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AiSessionCreateOrConnectWithoutUserInput = {
    where: AiSessionWhereUniqueInput
    create: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput>
  }

  export type AiSessionCreateManyUserInputEnvelope = {
    data: AiSessionCreateManyUserInput | AiSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsCreateOrConnectWithoutLastUpdatedByUserInput = {
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    create: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput>
  }

  export type DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInputEnvelope = {
    data: DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInput | DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AppConfigCreateWithoutLastUpdatedByUserInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigUncheckedCreateWithoutLastUpdatedByUserInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppConfigCreateOrConnectWithoutLastUpdatedByUserInput = {
    where: AppConfigWhereUniqueInput
    create: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput>
  }

  export type AppConfigCreateManyLastUpdatedByUserInputEnvelope = {
    data: AppConfigCreateManyLastUpdatedByUserInput | AppConfigCreateManyLastUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSnapshotCreateWithoutUserInput = {
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSnapshotUncheckedCreateWithoutUserInput = {
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSnapshotCreateOrConnectWithoutUserInput = {
    where: UserSnapshotWhereUniqueInput
    create: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput>
  }

  export type UserSnapshotCreateManyUserInputEnvelope = {
    data: UserSnapshotCreateManyUserInput | UserSnapshotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SnapshotCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    seq?: number | null
    updatedByUser?: UserCreateNestedOneWithoutUpdatedSnapshotInput
    embedding?: AiWorkspaceEmbeddingCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotUncheckedCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    updatedBy?: string | null
    seq?: number | null
    embedding?: AiWorkspaceEmbeddingUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotCreateOrConnectWithoutCreatedByUserInput = {
    where: SnapshotWhereUniqueInput
    create: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SnapshotCreateManyCreatedByUserInputEnvelope = {
    data: SnapshotCreateManyCreatedByUserInput | SnapshotCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SnapshotCreateWithoutUpdatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    seq?: number | null
    createdByUser?: UserCreateNestedOneWithoutCreatedSnapshotInput
    embedding?: AiWorkspaceEmbeddingCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotUncheckedCreateWithoutUpdatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: string | null
    seq?: number | null
    embedding?: AiWorkspaceEmbeddingUncheckedCreateNestedManyWithoutSnapshotInput
  }

  export type SnapshotCreateOrConnectWithoutUpdatedByUserInput = {
    where: SnapshotWhereUniqueInput
    create: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SnapshotCreateManyUpdatedByUserInputEnvelope = {
    data: SnapshotCreateManyUpdatedByUserInput | SnapshotCreateManyUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type UpdateCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    seq?: number | null
  }

  export type UpdateUncheckedCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    seq?: number | null
  }

  export type UpdateCreateOrConnectWithoutCreatedByUserInput = {
    where: UpdateWhereUniqueInput
    create: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput>
  }

  export type UpdateCreateManyCreatedByUserInputEnvelope = {
    data: UpdateCreateManyCreatedByUserInput | UpdateCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SnapshotHistoryCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
  }

  export type SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
  }

  export type SnapshotHistoryCreateOrConnectWithoutCreatedByUserInput = {
    where: SnapshotHistoryWhereUniqueInput
    create: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SnapshotHistoryCreateManyCreatedByUserInputEnvelope = {
    data: SnapshotHistoryCreateManyCreatedByUserInput | SnapshotHistoryCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AiJobsCreateWithoutCreatedByUserInput = {
    id?: string
    workspaceId: string
    blobId: string
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiJobsUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    workspaceId: string
    blobId: string
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type AiJobsCreateOrConnectWithoutCreatedByUserInput = {
    where: AiJobsWhereUniqueInput
    create: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput>
  }

  export type AiJobsCreateManyCreatedByUserInputEnvelope = {
    data: AiJobsCreateManyCreatedByUserInput | AiJobsCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateWithoutUserInput = {
    sid?: number
    id?: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    workspace: WorkspaceCreateNestedOneWithoutCommentsInput
    replies?: ReplyCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    replies?: ReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReplyCreateWithoutUserInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type ReplyUncheckedCreateWithoutUserInput = {
    sid?: number
    id?: string
    commentId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReplyCreateOrConnectWithoutUserInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput>
  }

  export type ReplyCreateManyUserInputEnvelope = {
    data: ReplyCreateManyUserInput | ReplyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentAttachmentCreateWithoutCreatedByUserInput = {
    sid?: number
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutCommentAttachmentsInput
  }

  export type CommentAttachmentUncheckedCreateWithoutCreatedByUserInput = {
    sid?: number
    workspaceId: string
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
  }

  export type CommentAttachmentCreateOrConnectWithoutCreatedByUserInput = {
    where: CommentAttachmentWhereUniqueInput
    create: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput>
  }

  export type CommentAttachmentCreateManyCreatedByUserInputEnvelope = {
    data: CommentAttachmentCreateManyCreatedByUserInput | CommentAttachmentCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AccessTokenCreateWithoutUserInput = {
    id?: string
    name: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AccessTokenUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type AccessTokenCreateOrConnectWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenCreateManyUserInputEnvelope = {
    data: AccessTokenCreateManyUserInput | AccessTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFeatureUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFeatureWhereUniqueInput
    update: XOR<UserFeatureUpdateWithoutUserInput, UserFeatureUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeatureCreateWithoutUserInput, UserFeatureUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFeatureWhereUniqueInput
    data: XOR<UserFeatureUpdateWithoutUserInput, UserFeatureUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureUpdateManyWithWhereWithoutUserInput = {
    where: UserFeatureScalarWhereInput
    data: XOR<UserFeatureUpdateManyMutationInput, UserFeatureUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFeatureScalarWhereInput = {
    AND?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
    OR?: UserFeatureScalarWhereInput[]
    NOT?: UserFeatureScalarWhereInput | UserFeatureScalarWhereInput[]
    id?: IntFilter<"UserFeature"> | number
    userId?: StringFilter<"UserFeature"> | string
    featureId?: IntFilter<"UserFeature"> | number
    name?: StringFilter<"UserFeature"> | string
    type?: IntFilter<"UserFeature"> | number
    reason?: StringFilter<"UserFeature"> | string
    createdAt?: DateTimeFilter<"UserFeature"> | Date | string
    expiredAt?: DateTimeNullableFilter<"UserFeature"> | Date | string | null
    activated?: BoolFilter<"UserFeature"> | boolean
  }

  export type UserStripeCustomerUpsertWithoutUserInput = {
    update: XOR<UserStripeCustomerUpdateWithoutUserInput, UserStripeCustomerUncheckedUpdateWithoutUserInput>
    create: XOR<UserStripeCustomerCreateWithoutUserInput, UserStripeCustomerUncheckedCreateWithoutUserInput>
    where?: UserStripeCustomerWhereInput
  }

  export type UserStripeCustomerUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStripeCustomerWhereInput
    data: XOR<UserStripeCustomerUpdateWithoutUserInput, UserStripeCustomerUncheckedUpdateWithoutUserInput>
  }

  export type UserStripeCustomerUpdateWithoutUserInput = {
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStripeCustomerUncheckedUpdateWithoutUserInput = {
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    update: XOR<WorkspaceUserRoleUpdateWithoutUserInput, WorkspaceUserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceUserRoleCreateWithoutUserInput, WorkspaceUserRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    data: XOR<WorkspaceUserRoleUpdateWithoutUserInput, WorkspaceUserRoleUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUserRoleUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceUserRoleScalarWhereInput
    data: XOR<WorkspaceUserRoleUpdateManyMutationInput, WorkspaceUserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUserRoleScalarWhereInput = {
    AND?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
    OR?: WorkspaceUserRoleScalarWhereInput[]
    NOT?: WorkspaceUserRoleScalarWhereInput | WorkspaceUserRoleScalarWhereInput[]
    id?: StringFilter<"WorkspaceUserRole"> | string
    workspaceId?: StringFilter<"WorkspaceUserRole"> | string
    userId?: StringFilter<"WorkspaceUserRole"> | string
    type?: IntFilter<"WorkspaceUserRole"> | number
    status?: EnumWorkspaceMemberStatusFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFilter<"WorkspaceUserRole"> | $Enums.WorkspaceMemberSource
    inviterId?: StringNullableFilter<"WorkspaceUserRole"> | string | null
    createdAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    updatedAt?: DateTimeFilter<"WorkspaceUserRole"> | Date | string
    accepted?: BoolFilter<"WorkspaceUserRole"> | boolean
  }

  export type WorkspaceUserRoleUpsertWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    update: XOR<WorkspaceUserRoleUpdateWithoutInviterInput, WorkspaceUserRoleUncheckedUpdateWithoutInviterInput>
    create: XOR<WorkspaceUserRoleCreateWithoutInviterInput, WorkspaceUserRoleUncheckedCreateWithoutInviterInput>
  }

  export type WorkspaceUserRoleUpdateWithWhereUniqueWithoutInviterInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    data: XOR<WorkspaceUserRoleUpdateWithoutInviterInput, WorkspaceUserRoleUncheckedUpdateWithoutInviterInput>
  }

  export type WorkspaceUserRoleUpdateManyWithWhereWithoutInviterInput = {
    where: WorkspaceUserRoleScalarWhereInput
    data: XOR<WorkspaceUserRoleUpdateManyMutationInput, WorkspaceUserRoleUncheckedUpdateManyWithoutInviterInput>
  }

  export type WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    update: XOR<WorkspaceDocUserRoleUpdateWithoutUserInput, WorkspaceDocUserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceDocUserRoleCreateWithoutUserInput, WorkspaceDocUserRoleUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    data: XOR<WorkspaceDocUserRoleUpdateWithoutUserInput, WorkspaceDocUserRoleUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceDocUserRoleUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceDocUserRoleScalarWhereInput
    data: XOR<WorkspaceDocUserRoleUpdateManyMutationInput, WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceDocUserRoleScalarWhereInput = {
    AND?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
    OR?: WorkspaceDocUserRoleScalarWhereInput[]
    NOT?: WorkspaceDocUserRoleScalarWhereInput | WorkspaceDocUserRoleScalarWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDocUserRole"> | string
    docId?: StringFilter<"WorkspaceDocUserRole"> | string
    userId?: StringFilter<"WorkspaceDocUserRole"> | string
    type?: IntFilter<"WorkspaceDocUserRole"> | number
    createdAt?: DateTimeFilter<"WorkspaceDocUserRole"> | Date | string
  }

  export type ConnectedAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: ConnectedAccountWhereUniqueInput
    update: XOR<ConnectedAccountUpdateWithoutUserInput, ConnectedAccountUncheckedUpdateWithoutUserInput>
    create: XOR<ConnectedAccountCreateWithoutUserInput, ConnectedAccountUncheckedCreateWithoutUserInput>
  }

  export type ConnectedAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: ConnectedAccountWhereUniqueInput
    data: XOR<ConnectedAccountUpdateWithoutUserInput, ConnectedAccountUncheckedUpdateWithoutUserInput>
  }

  export type ConnectedAccountUpdateManyWithWhereWithoutUserInput = {
    where: ConnectedAccountScalarWhereInput
    data: XOR<ConnectedAccountUpdateManyMutationInput, ConnectedAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type ConnectedAccountScalarWhereInput = {
    AND?: ConnectedAccountScalarWhereInput | ConnectedAccountScalarWhereInput[]
    OR?: ConnectedAccountScalarWhereInput[]
    NOT?: ConnectedAccountScalarWhereInput | ConnectedAccountScalarWhereInput[]
    id?: StringFilter<"ConnectedAccount"> | string
    userId?: StringFilter<"ConnectedAccount"> | string
    provider?: StringFilter<"ConnectedAccount"> | string
    providerAccountId?: StringFilter<"ConnectedAccount"> | string
    scope?: StringNullableFilter<"ConnectedAccount"> | string | null
    accessToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    refreshToken?: StringNullableFilter<"ConnectedAccount"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConnectedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"ConnectedAccount"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    sessionId?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type AiSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AiSessionWhereUniqueInput
    update: XOR<AiSessionUpdateWithoutUserInput, AiSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AiSessionCreateWithoutUserInput, AiSessionUncheckedCreateWithoutUserInput>
  }

  export type AiSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AiSessionWhereUniqueInput
    data: XOR<AiSessionUpdateWithoutUserInput, AiSessionUncheckedUpdateWithoutUserInput>
  }

  export type AiSessionUpdateManyWithWhereWithoutUserInput = {
    where: AiSessionScalarWhereInput
    data: XOR<AiSessionUpdateManyMutationInput, AiSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AiSessionScalarWhereInput = {
    AND?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
    OR?: AiSessionScalarWhereInput[]
    NOT?: AiSessionScalarWhereInput | AiSessionScalarWhereInput[]
    id?: StringFilter<"AiSession"> | string
    userId?: StringFilter<"AiSession"> | string
    workspaceId?: StringFilter<"AiSession"> | string
    docId?: StringNullableFilter<"AiSession"> | string | null
    promptName?: StringFilter<"AiSession"> | string
    promptAction?: StringNullableFilter<"AiSession"> | string | null
    pinned?: BoolFilter<"AiSession"> | boolean
    title?: StringNullableFilter<"AiSession"> | string | null
    parentSessionId?: StringNullableFilter<"AiSession"> | string | null
    messageCost?: IntFilter<"AiSession"> | number
    tokenCost?: IntFilter<"AiSession"> | number
    createdAt?: DateTimeFilter<"AiSession"> | Date | string
    updatedAt?: DateTimeFilter<"AiSession"> | Date | string
    deletedAt?: DateTimeNullableFilter<"AiSession"> | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUpsertWithWhereUniqueWithoutLastUpdatedByUserInput = {
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    update: XOR<DeprecatedAppRuntimeSettingsUpdateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedUpdateWithoutLastUpdatedByUserInput>
    create: XOR<DeprecatedAppRuntimeSettingsCreateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedCreateWithoutLastUpdatedByUserInput>
  }

  export type DeprecatedAppRuntimeSettingsUpdateWithWhereUniqueWithoutLastUpdatedByUserInput = {
    where: DeprecatedAppRuntimeSettingsWhereUniqueInput
    data: XOR<DeprecatedAppRuntimeSettingsUpdateWithoutLastUpdatedByUserInput, DeprecatedAppRuntimeSettingsUncheckedUpdateWithoutLastUpdatedByUserInput>
  }

  export type DeprecatedAppRuntimeSettingsUpdateManyWithWhereWithoutLastUpdatedByUserInput = {
    where: DeprecatedAppRuntimeSettingsScalarWhereInput
    data: XOR<DeprecatedAppRuntimeSettingsUpdateManyMutationInput, DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserInput>
  }

  export type DeprecatedAppRuntimeSettingsScalarWhereInput = {
    AND?: DeprecatedAppRuntimeSettingsScalarWhereInput | DeprecatedAppRuntimeSettingsScalarWhereInput[]
    OR?: DeprecatedAppRuntimeSettingsScalarWhereInput[]
    NOT?: DeprecatedAppRuntimeSettingsScalarWhereInput | DeprecatedAppRuntimeSettingsScalarWhereInput[]
    id?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    type?: EnumRuntimeConfigTypeFilter<"DeprecatedAppRuntimeSettings"> | $Enums.RuntimeConfigType
    module?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    key?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    value?: JsonFilter<"DeprecatedAppRuntimeSettings">
    description?: StringFilter<"DeprecatedAppRuntimeSettings"> | string
    updatedAt?: DateTimeFilter<"DeprecatedAppRuntimeSettings"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DeprecatedAppRuntimeSettings"> | Date | string | null
    lastUpdatedBy?: StringNullableFilter<"DeprecatedAppRuntimeSettings"> | string | null
  }

  export type AppConfigUpsertWithWhereUniqueWithoutLastUpdatedByUserInput = {
    where: AppConfigWhereUniqueInput
    update: XOR<AppConfigUpdateWithoutLastUpdatedByUserInput, AppConfigUncheckedUpdateWithoutLastUpdatedByUserInput>
    create: XOR<AppConfigCreateWithoutLastUpdatedByUserInput, AppConfigUncheckedCreateWithoutLastUpdatedByUserInput>
  }

  export type AppConfigUpdateWithWhereUniqueWithoutLastUpdatedByUserInput = {
    where: AppConfigWhereUniqueInput
    data: XOR<AppConfigUpdateWithoutLastUpdatedByUserInput, AppConfigUncheckedUpdateWithoutLastUpdatedByUserInput>
  }

  export type AppConfigUpdateManyWithWhereWithoutLastUpdatedByUserInput = {
    where: AppConfigScalarWhereInput
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserInput>
  }

  export type AppConfigScalarWhereInput = {
    AND?: AppConfigScalarWhereInput | AppConfigScalarWhereInput[]
    OR?: AppConfigScalarWhereInput[]
    NOT?: AppConfigScalarWhereInput | AppConfigScalarWhereInput[]
    id?: StringFilter<"AppConfig"> | string
    value?: JsonFilter<"AppConfig">
    createdAt?: DateTimeFilter<"AppConfig"> | Date | string
    updatedAt?: DateTimeFilter<"AppConfig"> | Date | string
    lastUpdatedBy?: StringNullableFilter<"AppConfig"> | string | null
  }

  export type UserSnapshotUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSnapshotWhereUniqueInput
    update: XOR<UserSnapshotUpdateWithoutUserInput, UserSnapshotUncheckedUpdateWithoutUserInput>
    create: XOR<UserSnapshotCreateWithoutUserInput, UserSnapshotUncheckedCreateWithoutUserInput>
  }

  export type UserSnapshotUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSnapshotWhereUniqueInput
    data: XOR<UserSnapshotUpdateWithoutUserInput, UserSnapshotUncheckedUpdateWithoutUserInput>
  }

  export type UserSnapshotUpdateManyWithWhereWithoutUserInput = {
    where: UserSnapshotScalarWhereInput
    data: XOR<UserSnapshotUpdateManyMutationInput, UserSnapshotUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSnapshotScalarWhereInput = {
    AND?: UserSnapshotScalarWhereInput | UserSnapshotScalarWhereInput[]
    OR?: UserSnapshotScalarWhereInput[]
    NOT?: UserSnapshotScalarWhereInput | UserSnapshotScalarWhereInput[]
    userId?: StringFilter<"UserSnapshot"> | string
    id?: StringFilter<"UserSnapshot"> | string
    blob?: BytesFilter<"UserSnapshot"> | Uint8Array
    createdAt?: DateTimeFilter<"UserSnapshot"> | Date | string
    updatedAt?: DateTimeFilter<"UserSnapshot"> | Date | string
  }

  export type SnapshotUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: SnapshotWhereUniqueInput
    update: XOR<SnapshotUpdateWithoutCreatedByUserInput, SnapshotUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<SnapshotCreateWithoutCreatedByUserInput, SnapshotUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SnapshotUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: SnapshotWhereUniqueInput
    data: XOR<SnapshotUpdateWithoutCreatedByUserInput, SnapshotUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type SnapshotUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: SnapshotScalarWhereInput
    data: XOR<SnapshotUpdateManyMutationInput, SnapshotUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type SnapshotScalarWhereInput = {
    AND?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
    OR?: SnapshotScalarWhereInput[]
    NOT?: SnapshotScalarWhereInput | SnapshotScalarWhereInput[]
    workspaceId?: StringFilter<"Snapshot"> | string
    id?: StringFilter<"Snapshot"> | string
    blob?: BytesFilter<"Snapshot"> | Uint8Array
    state?: BytesNullableFilter<"Snapshot"> | Uint8Array | null
    createdAt?: DateTimeFilter<"Snapshot"> | Date | string
    updatedAt?: DateTimeFilter<"Snapshot"> | Date | string
    createdBy?: StringNullableFilter<"Snapshot"> | string | null
    updatedBy?: StringNullableFilter<"Snapshot"> | string | null
    seq?: IntNullableFilter<"Snapshot"> | number | null
  }

  export type SnapshotUpsertWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SnapshotWhereUniqueInput
    update: XOR<SnapshotUpdateWithoutUpdatedByUserInput, SnapshotUncheckedUpdateWithoutUpdatedByUserInput>
    create: XOR<SnapshotCreateWithoutUpdatedByUserInput, SnapshotUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SnapshotUpdateWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SnapshotWhereUniqueInput
    data: XOR<SnapshotUpdateWithoutUpdatedByUserInput, SnapshotUncheckedUpdateWithoutUpdatedByUserInput>
  }

  export type SnapshotUpdateManyWithWhereWithoutUpdatedByUserInput = {
    where: SnapshotScalarWhereInput
    data: XOR<SnapshotUpdateManyMutationInput, SnapshotUncheckedUpdateManyWithoutUpdatedByUserInput>
  }

  export type UpdateUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: UpdateWhereUniqueInput
    update: XOR<UpdateUpdateWithoutCreatedByUserInput, UpdateUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<UpdateCreateWithoutCreatedByUserInput, UpdateUncheckedCreateWithoutCreatedByUserInput>
  }

  export type UpdateUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: UpdateWhereUniqueInput
    data: XOR<UpdateUpdateWithoutCreatedByUserInput, UpdateUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type UpdateUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: UpdateScalarWhereInput
    data: XOR<UpdateUpdateManyMutationInput, UpdateUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type UpdateScalarWhereInput = {
    AND?: UpdateScalarWhereInput | UpdateScalarWhereInput[]
    OR?: UpdateScalarWhereInput[]
    NOT?: UpdateScalarWhereInput | UpdateScalarWhereInput[]
    workspaceId?: StringFilter<"Update"> | string
    id?: StringFilter<"Update"> | string
    blob?: BytesFilter<"Update"> | Uint8Array
    createdAt?: DateTimeFilter<"Update"> | Date | string
    createdBy?: StringNullableFilter<"Update"> | string | null
    seq?: IntNullableFilter<"Update"> | number | null
  }

  export type SnapshotHistoryUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: SnapshotHistoryWhereUniqueInput
    update: XOR<SnapshotHistoryUpdateWithoutCreatedByUserInput, SnapshotHistoryUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<SnapshotHistoryCreateWithoutCreatedByUserInput, SnapshotHistoryUncheckedCreateWithoutCreatedByUserInput>
  }

  export type SnapshotHistoryUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: SnapshotHistoryWhereUniqueInput
    data: XOR<SnapshotHistoryUpdateWithoutCreatedByUserInput, SnapshotHistoryUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type SnapshotHistoryUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: SnapshotHistoryScalarWhereInput
    data: XOR<SnapshotHistoryUpdateManyMutationInput, SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type SnapshotHistoryScalarWhereInput = {
    AND?: SnapshotHistoryScalarWhereInput | SnapshotHistoryScalarWhereInput[]
    OR?: SnapshotHistoryScalarWhereInput[]
    NOT?: SnapshotHistoryScalarWhereInput | SnapshotHistoryScalarWhereInput[]
    workspaceId?: StringFilter<"SnapshotHistory"> | string
    id?: StringFilter<"SnapshotHistory"> | string
    timestamp?: DateTimeFilter<"SnapshotHistory"> | Date | string
    blob?: BytesFilter<"SnapshotHistory"> | Uint8Array
    state?: BytesNullableFilter<"SnapshotHistory"> | Uint8Array | null
    expiredAt?: DateTimeFilter<"SnapshotHistory"> | Date | string
    createdBy?: StringNullableFilter<"SnapshotHistory"> | string | null
  }

  export type AiJobsUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: AiJobsWhereUniqueInput
    update: XOR<AiJobsUpdateWithoutCreatedByUserInput, AiJobsUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<AiJobsCreateWithoutCreatedByUserInput, AiJobsUncheckedCreateWithoutCreatedByUserInput>
  }

  export type AiJobsUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: AiJobsWhereUniqueInput
    data: XOR<AiJobsUpdateWithoutCreatedByUserInput, AiJobsUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type AiJobsUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: AiJobsScalarWhereInput
    data: XOR<AiJobsUpdateManyMutationInput, AiJobsUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type AiJobsScalarWhereInput = {
    AND?: AiJobsScalarWhereInput | AiJobsScalarWhereInput[]
    OR?: AiJobsScalarWhereInput[]
    NOT?: AiJobsScalarWhereInput | AiJobsScalarWhereInput[]
    id?: StringFilter<"AiJobs"> | string
    workspaceId?: StringFilter<"AiJobs"> | string
    blobId?: StringFilter<"AiJobs"> | string
    createdBy?: StringNullableFilter<"AiJobs"> | string | null
    type?: EnumAiJobTypeFilter<"AiJobs"> | $Enums.AiJobType
    status?: EnumAiJobStatusFilter<"AiJobs"> | $Enums.AiJobStatus
    payload?: JsonFilter<"AiJobs">
    startedAt?: DateTimeFilter<"AiJobs"> | Date | string
    finishedAt?: DateTimeNullableFilter<"AiJobs"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    level?: EnumNotificationLevelFilter<"Notification"> | $Enums.NotificationLevel
    read?: BoolFilter<"Notification"> | boolean
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    body?: JsonFilter<"Notification">
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    sid?: IntFilter<"Comment"> | number
    id?: StringFilter<"Comment"> | string
    workspaceId?: StringFilter<"Comment"> | string
    docId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    content?: JsonFilter<"Comment">
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    resolved?: BoolFilter<"Comment"> | boolean
  }

  export type ReplyUpsertWithWhereUniqueWithoutUserInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutUserInput, ReplyUncheckedUpdateWithoutUserInput>
    create: XOR<ReplyCreateWithoutUserInput, ReplyUncheckedCreateWithoutUserInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutUserInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutUserInput, ReplyUncheckedUpdateWithoutUserInput>
  }

  export type ReplyUpdateManyWithWhereWithoutUserInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutUserInput>
  }

  export type ReplyScalarWhereInput = {
    AND?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    OR?: ReplyScalarWhereInput[]
    NOT?: ReplyScalarWhereInput | ReplyScalarWhereInput[]
    sid?: IntFilter<"Reply"> | number
    id?: StringFilter<"Reply"> | string
    userId?: StringFilter<"Reply"> | string
    commentId?: StringFilter<"Reply"> | string
    workspaceId?: StringFilter<"Reply"> | string
    docId?: StringFilter<"Reply"> | string
    content?: JsonFilter<"Reply">
    createdAt?: DateTimeFilter<"Reply"> | Date | string
    updatedAt?: DateTimeFilter<"Reply"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reply"> | Date | string | null
  }

  export type CommentAttachmentUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: CommentAttachmentWhereUniqueInput
    update: XOR<CommentAttachmentUpdateWithoutCreatedByUserInput, CommentAttachmentUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<CommentAttachmentCreateWithoutCreatedByUserInput, CommentAttachmentUncheckedCreateWithoutCreatedByUserInput>
  }

  export type CommentAttachmentUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: CommentAttachmentWhereUniqueInput
    data: XOR<CommentAttachmentUpdateWithoutCreatedByUserInput, CommentAttachmentUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type CommentAttachmentUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: CommentAttachmentScalarWhereInput
    data: XOR<CommentAttachmentUpdateManyMutationInput, CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type CommentAttachmentScalarWhereInput = {
    AND?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
    OR?: CommentAttachmentScalarWhereInput[]
    NOT?: CommentAttachmentScalarWhereInput | CommentAttachmentScalarWhereInput[]
    sid?: IntFilter<"CommentAttachment"> | number
    workspaceId?: StringFilter<"CommentAttachment"> | string
    docId?: StringFilter<"CommentAttachment"> | string
    key?: StringFilter<"CommentAttachment"> | string
    size?: IntFilter<"CommentAttachment"> | number
    mime?: StringFilter<"CommentAttachment"> | string
    name?: StringFilter<"CommentAttachment"> | string
    createdAt?: DateTimeFilter<"CommentAttachment"> | Date | string
    createdBy?: StringNullableFilter<"CommentAttachment"> | string | null
  }

  export type AccessTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    update: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    data: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
  }

  export type AccessTokenUpdateManyWithWhereWithoutUserInput = {
    where: AccessTokenScalarWhereInput
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type AccessTokenScalarWhereInput = {
    AND?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    OR?: AccessTokenScalarWhereInput[]
    NOT?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    id?: StringFilter<"AccessToken"> | string
    name?: StringFilter<"AccessToken"> | string
    token?: StringFilter<"AccessToken"> | string
    userId?: StringFilter<"AccessToken"> | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    expiresAt?: DateTimeNullableFilter<"AccessToken"> | Date | string | null
  }

  export type UserCreateWithoutConnectedAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConnectedAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConnectedAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectedAccountsInput, UserUncheckedCreateWithoutConnectedAccountsInput>
  }

  export type UserUpsertWithoutConnectedAccountsInput = {
    update: XOR<UserUpdateWithoutConnectedAccountsInput, UserUncheckedUpdateWithoutConnectedAccountsInput>
    create: XOR<UserCreateWithoutConnectedAccountsInput, UserUncheckedCreateWithoutConnectedAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectedAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectedAccountsInput, UserUncheckedUpdateWithoutConnectedAccountsInput>
  }

  export type UserUpdateWithoutConnectedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSessionCreateWithoutSessionInput = {
    id?: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutSessionInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput>
  }

  export type UserSessionCreateManySessionInputEnvelope = {
    data: UserSessionCreateManySessionInput | UserSessionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutSessionInput, UserSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<UserSessionCreateWithoutSessionInput, UserSessionUncheckedCreateWithoutSessionInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutSessionInput, UserSessionUncheckedUpdateWithoutSessionInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutSessionInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionCreateWithoutUserSessionsInput = {
    id?: string
    createdAt?: Date | string
    deprecated_expiresAt?: Date | string | null
  }

  export type SessionUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    createdAt?: Date | string
    deprecated_expiresAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutUserSessionsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserSessionsInput, SessionUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutUserSessionsInput = {
    update: XOR<SessionUpdateWithoutUserSessionsInput, SessionUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<SessionCreateWithoutUserSessionsInput, SessionUncheckedCreateWithoutUserSessionsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutUserSessionsInput, SessionUncheckedUpdateWithoutUserSessionsInput>
  }

  export type SessionUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecated_expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceFeatureCreateWithoutWorkspaceInput = {
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
    feature: FeatureCreateNestedOneWithoutWorkspaceFeaturesInput
  }

  export type WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput = {
    id?: number
    featureId: number
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type WorkspaceFeatureCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceFeatureWhereUniqueInput
    create: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceFeatureCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceFeatureCreateManyWorkspaceInput | WorkspaceFeatureCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceDocCreateWithoutWorkspaceInput = {
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
  }

  export type WorkspaceDocUncheckedCreateWithoutWorkspaceInput = {
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
  }

  export type WorkspaceDocCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceDocWhereUniqueInput
    create: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceDocCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceDocCreateManyWorkspaceInput | WorkspaceDocCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUserRoleCreateWithoutWorkspaceInput = {
    id?: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
    user: UserCreateNestedOneWithoutWorkspacesInput
    inviter?: UserCreateNestedOneWithoutWorkspaceInvitationsInput
  }

  export type WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    create: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserRoleCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceUserRoleCreateManyWorkspaceInput | WorkspaceUserRoleCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceDocUserRoleCreateWithoutWorkspaceInput = {
    docId: string
    type: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDocPermissionsInput
  }

  export type WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput = {
    docId: string
    userId: string
    type: number
    createdAt?: Date | string
  }

  export type WorkspaceDocUserRoleCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    create: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceDocUserRoleCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceDocUserRoleCreateManyWorkspaceInput | WorkspaceDocUserRoleCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type BlobCreateWithoutWorkspaceInput = {
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingCreateNestedManyWithoutBlobInput
  }

  export type BlobUncheckedCreateWithoutWorkspaceInput = {
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUncheckedCreateNestedManyWithoutBlobInput
  }

  export type BlobCreateOrConnectWithoutWorkspaceInput = {
    where: BlobWhereUniqueInput
    create: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput>
  }

  export type BlobCreateManyWorkspaceInputEnvelope = {
    data: BlobCreateManyWorkspaceInput | BlobCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput = {
    docId: string
    createdAt?: Date | string
  }

  export type AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput = {
    docId: string
    createdAt?: Date | string
  }

  export type AiWorkspaceIgnoredDocsCreateOrConnectWithoutWorkspaceInput = {
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    create: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiWorkspaceIgnoredDocsCreateManyWorkspaceInputEnvelope = {
    data: AiWorkspaceIgnoredDocsCreateManyWorkspaceInput | AiWorkspaceIgnoredDocsCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AiWorkspaceFilesCreateWithoutWorkspaceInput = {
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
    embeddings?: AiWorkspaceFileEmbeddingCreateNestedManyWithoutFileInput
  }

  export type AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput = {
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
    embeddings?: AiWorkspaceFileEmbeddingUncheckedCreateNestedManyWithoutFileInput
  }

  export type AiWorkspaceFilesCreateOrConnectWithoutWorkspaceInput = {
    where: AiWorkspaceFilesWhereUniqueInput
    create: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiWorkspaceFilesCreateManyWorkspaceInputEnvelope = {
    data: AiWorkspaceFilesCreateManyWorkspaceInput | AiWorkspaceFilesCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutWorkspaceInput = {
    sid?: number
    id?: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: ReplyCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutWorkspaceInput = {
    sid?: number
    id?: string
    docId: string
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    replies?: ReplyUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutWorkspaceInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput>
  }

  export type CommentCreateManyWorkspaceInputEnvelope = {
    data: CommentCreateManyWorkspaceInput | CommentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type CommentAttachmentCreateWithoutWorkspaceInput = {
    sid?: number
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCommentAttachmentsInput
  }

  export type CommentAttachmentUncheckedCreateWithoutWorkspaceInput = {
    sid?: number
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type CommentAttachmentCreateOrConnectWithoutWorkspaceInput = {
    where: CommentAttachmentWhereUniqueInput
    create: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type CommentAttachmentCreateManyWorkspaceInputEnvelope = {
    data: CommentAttachmentCreateManyWorkspaceInput | CommentAttachmentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceFeatureUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceFeatureWhereUniqueInput
    update: XOR<WorkspaceFeatureUpdateWithoutWorkspaceInput, WorkspaceFeatureUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceFeatureCreateWithoutWorkspaceInput, WorkspaceFeatureUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceFeatureUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceFeatureWhereUniqueInput
    data: XOR<WorkspaceFeatureUpdateWithoutWorkspaceInput, WorkspaceFeatureUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceFeatureUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceFeatureScalarWhereInput
    data: XOR<WorkspaceFeatureUpdateManyMutationInput, WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceFeatureScalarWhereInput = {
    AND?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
    OR?: WorkspaceFeatureScalarWhereInput[]
    NOT?: WorkspaceFeatureScalarWhereInput | WorkspaceFeatureScalarWhereInput[]
    id?: IntFilter<"WorkspaceFeature"> | number
    workspaceId?: StringFilter<"WorkspaceFeature"> | string
    featureId?: IntFilter<"WorkspaceFeature"> | number
    name?: StringFilter<"WorkspaceFeature"> | string
    type?: IntFilter<"WorkspaceFeature"> | number
    configs?: JsonFilter<"WorkspaceFeature">
    reason?: StringFilter<"WorkspaceFeature"> | string
    createdAt?: DateTimeFilter<"WorkspaceFeature"> | Date | string
    activated?: BoolFilter<"WorkspaceFeature"> | boolean
    expiredAt?: DateTimeNullableFilter<"WorkspaceFeature"> | Date | string | null
  }

  export type WorkspaceDocUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceDocWhereUniqueInput
    update: XOR<WorkspaceDocUpdateWithoutWorkspaceInput, WorkspaceDocUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceDocCreateWithoutWorkspaceInput, WorkspaceDocUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceDocUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceDocWhereUniqueInput
    data: XOR<WorkspaceDocUpdateWithoutWorkspaceInput, WorkspaceDocUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceDocUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceDocScalarWhereInput
    data: XOR<WorkspaceDocUpdateManyMutationInput, WorkspaceDocUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceDocScalarWhereInput = {
    AND?: WorkspaceDocScalarWhereInput | WorkspaceDocScalarWhereInput[]
    OR?: WorkspaceDocScalarWhereInput[]
    NOT?: WorkspaceDocScalarWhereInput | WorkspaceDocScalarWhereInput[]
    workspaceId?: StringFilter<"WorkspaceDoc"> | string
    docId?: StringFilter<"WorkspaceDoc"> | string
    public?: BoolFilter<"WorkspaceDoc"> | boolean
    defaultRole?: IntFilter<"WorkspaceDoc"> | number
    mode?: IntFilter<"WorkspaceDoc"> | number
    blocked?: BoolFilter<"WorkspaceDoc"> | boolean
    title?: StringNullableFilter<"WorkspaceDoc"> | string | null
    summary?: StringNullableFilter<"WorkspaceDoc"> | string | null
  }

  export type WorkspaceUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    update: XOR<WorkspaceUserRoleUpdateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceUserRoleCreateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceUserRoleWhereUniqueInput
    data: XOR<WorkspaceUserRoleUpdateWithoutWorkspaceInput, WorkspaceUserRoleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceUserRoleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceUserRoleScalarWhereInput
    data: XOR<WorkspaceUserRoleUpdateManyMutationInput, WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceDocUserRoleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    update: XOR<WorkspaceDocUserRoleUpdateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceDocUserRoleCreateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceDocUserRoleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceDocUserRoleWhereUniqueInput
    data: XOR<WorkspaceDocUserRoleUpdateWithoutWorkspaceInput, WorkspaceDocUserRoleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceDocUserRoleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceDocUserRoleScalarWhereInput
    data: XOR<WorkspaceDocUserRoleUpdateManyMutationInput, WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BlobUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: BlobWhereUniqueInput
    update: XOR<BlobUpdateWithoutWorkspaceInput, BlobUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<BlobCreateWithoutWorkspaceInput, BlobUncheckedCreateWithoutWorkspaceInput>
  }

  export type BlobUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: BlobWhereUniqueInput
    data: XOR<BlobUpdateWithoutWorkspaceInput, BlobUncheckedUpdateWithoutWorkspaceInput>
  }

  export type BlobUpdateManyWithWhereWithoutWorkspaceInput = {
    where: BlobScalarWhereInput
    data: XOR<BlobUpdateManyMutationInput, BlobUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type BlobScalarWhereInput = {
    AND?: BlobScalarWhereInput | BlobScalarWhereInput[]
    OR?: BlobScalarWhereInput[]
    NOT?: BlobScalarWhereInput | BlobScalarWhereInput[]
    workspaceId?: StringFilter<"Blob"> | string
    key?: StringFilter<"Blob"> | string
    size?: IntFilter<"Blob"> | number
    mime?: StringFilter<"Blob"> | string
    createdAt?: DateTimeFilter<"Blob"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Blob"> | Date | string | null
  }

  export type AiWorkspaceIgnoredDocsUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    update: XOR<AiWorkspaceIgnoredDocsUpdateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AiWorkspaceIgnoredDocsCreateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiWorkspaceIgnoredDocsUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AiWorkspaceIgnoredDocsWhereUniqueInput
    data: XOR<AiWorkspaceIgnoredDocsUpdateWithoutWorkspaceInput, AiWorkspaceIgnoredDocsUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AiWorkspaceIgnoredDocsUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AiWorkspaceIgnoredDocsScalarWhereInput
    data: XOR<AiWorkspaceIgnoredDocsUpdateManyMutationInput, AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AiWorkspaceIgnoredDocsScalarWhereInput = {
    AND?: AiWorkspaceIgnoredDocsScalarWhereInput | AiWorkspaceIgnoredDocsScalarWhereInput[]
    OR?: AiWorkspaceIgnoredDocsScalarWhereInput[]
    NOT?: AiWorkspaceIgnoredDocsScalarWhereInput | AiWorkspaceIgnoredDocsScalarWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    docId?: StringFilter<"AiWorkspaceIgnoredDocs"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceIgnoredDocs"> | Date | string
  }

  export type AiWorkspaceFilesUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AiWorkspaceFilesWhereUniqueInput
    update: XOR<AiWorkspaceFilesUpdateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AiWorkspaceFilesCreateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedCreateWithoutWorkspaceInput>
  }

  export type AiWorkspaceFilesUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AiWorkspaceFilesWhereUniqueInput
    data: XOR<AiWorkspaceFilesUpdateWithoutWorkspaceInput, AiWorkspaceFilesUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AiWorkspaceFilesUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AiWorkspaceFilesScalarWhereInput
    data: XOR<AiWorkspaceFilesUpdateManyMutationInput, AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AiWorkspaceFilesScalarWhereInput = {
    AND?: AiWorkspaceFilesScalarWhereInput | AiWorkspaceFilesScalarWhereInput[]
    OR?: AiWorkspaceFilesScalarWhereInput[]
    NOT?: AiWorkspaceFilesScalarWhereInput | AiWorkspaceFilesScalarWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFiles"> | string
    fileId?: StringFilter<"AiWorkspaceFiles"> | string
    blobId?: StringFilter<"AiWorkspaceFiles"> | string
    fileName?: StringFilter<"AiWorkspaceFiles"> | string
    mimeType?: StringFilter<"AiWorkspaceFiles"> | string
    size?: IntFilter<"AiWorkspaceFiles"> | number
    createdAt?: DateTimeFilter<"AiWorkspaceFiles"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutWorkspaceInput, CommentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CommentCreateWithoutWorkspaceInput, CommentUncheckedCreateWithoutWorkspaceInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutWorkspaceInput, CommentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CommentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type CommentAttachmentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: CommentAttachmentWhereUniqueInput
    update: XOR<CommentAttachmentUpdateWithoutWorkspaceInput, CommentAttachmentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<CommentAttachmentCreateWithoutWorkspaceInput, CommentAttachmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type CommentAttachmentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: CommentAttachmentWhereUniqueInput
    data: XOR<CommentAttachmentUpdateWithoutWorkspaceInput, CommentAttachmentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type CommentAttachmentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: CommentAttachmentScalarWhereInput
    data: XOR<CommentAttachmentUpdateManyMutationInput, CommentAttachmentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceCreateWithoutDocsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDocsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDocsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDocsInput, WorkspaceUncheckedCreateWithoutDocsInput>
  }

  export type WorkspaceUpsertWithoutDocsInput = {
    update: XOR<WorkspaceUpdateWithoutDocsInput, WorkspaceUncheckedUpdateWithoutDocsInput>
    create: XOR<WorkspaceCreateWithoutDocsInput, WorkspaceUncheckedCreateWithoutDocsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDocsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDocsInput, WorkspaceUncheckedUpdateWithoutDocsInput>
  }

  export type WorkspaceUpdateWithoutDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDocsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type WorkspaceCreateWithoutPermissionsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutPermissionsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutPermissionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutPermissionsInput, WorkspaceUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutWorkspaceInvitationsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspaceInvitationsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspaceInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspaceInvitationsInput, UserUncheckedCreateWithoutWorkspaceInvitationsInput>
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutPermissionsInput = {
    update: XOR<WorkspaceUpdateWithoutPermissionsInput, WorkspaceUncheckedUpdateWithoutPermissionsInput>
    create: XOR<WorkspaceCreateWithoutPermissionsInput, WorkspaceUncheckedCreateWithoutPermissionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutPermissionsInput, WorkspaceUncheckedUpdateWithoutPermissionsInput>
  }

  export type WorkspaceUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutPermissionsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspaceInvitationsInput = {
    update: XOR<UserUpdateWithoutWorkspaceInvitationsInput, UserUncheckedUpdateWithoutWorkspaceInvitationsInput>
    create: XOR<UserCreateWithoutWorkspaceInvitationsInput, UserUncheckedCreateWithoutWorkspaceInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspaceInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspaceInvitationsInput, UserUncheckedUpdateWithoutWorkspaceInvitationsInput>
  }

  export type UserUpdateWithoutWorkspaceInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspaceInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDocPermissionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocPermissionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocPermissionsInput, UserUncheckedCreateWithoutDocPermissionsInput>
  }

  export type WorkspaceCreateWithoutDocPermissionsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDocPermissionsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDocPermissionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDocPermissionsInput, WorkspaceUncheckedCreateWithoutDocPermissionsInput>
  }

  export type UserUpsertWithoutDocPermissionsInput = {
    update: XOR<UserUpdateWithoutDocPermissionsInput, UserUncheckedUpdateWithoutDocPermissionsInput>
    create: XOR<UserCreateWithoutDocPermissionsInput, UserUncheckedCreateWithoutDocPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocPermissionsInput, UserUncheckedUpdateWithoutDocPermissionsInput>
  }

  export type UserUpdateWithoutDocPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutDocPermissionsInput = {
    update: XOR<WorkspaceUpdateWithoutDocPermissionsInput, WorkspaceUncheckedUpdateWithoutDocPermissionsInput>
    create: XOR<WorkspaceCreateWithoutDocPermissionsInput, WorkspaceUncheckedCreateWithoutDocPermissionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDocPermissionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDocPermissionsInput, WorkspaceUncheckedUpdateWithoutDocPermissionsInput>
  }

  export type WorkspaceUpdateWithoutDocPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDocPermissionsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserFeatureCreateWithoutFeatureInput = {
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
    user: UserCreateNestedOneWithoutFeaturesInput
  }

  export type UserFeatureUncheckedCreateWithoutFeatureInput = {
    id?: number
    userId: string
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type UserFeatureCreateOrConnectWithoutFeatureInput = {
    where: UserFeatureWhereUniqueInput
    create: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type UserFeatureCreateManyFeatureInputEnvelope = {
    data: UserFeatureCreateManyFeatureInput | UserFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceFeatureCreateWithoutFeatureInput = {
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutFeaturesInput
  }

  export type WorkspaceFeatureUncheckedCreateWithoutFeatureInput = {
    id?: number
    workspaceId: string
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type WorkspaceFeatureCreateOrConnectWithoutFeatureInput = {
    where: WorkspaceFeatureWhereUniqueInput
    create: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type WorkspaceFeatureCreateManyFeatureInputEnvelope = {
    data: WorkspaceFeatureCreateManyFeatureInput | WorkspaceFeatureCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type UserFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: UserFeatureWhereUniqueInput
    update: XOR<UserFeatureUpdateWithoutFeatureInput, UserFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<UserFeatureCreateWithoutFeatureInput, UserFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type UserFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: UserFeatureWhereUniqueInput
    data: XOR<UserFeatureUpdateWithoutFeatureInput, UserFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type UserFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: UserFeatureScalarWhereInput
    data: XOR<UserFeatureUpdateManyMutationInput, UserFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type WorkspaceFeatureUpsertWithWhereUniqueWithoutFeatureInput = {
    where: WorkspaceFeatureWhereUniqueInput
    update: XOR<WorkspaceFeatureUpdateWithoutFeatureInput, WorkspaceFeatureUncheckedUpdateWithoutFeatureInput>
    create: XOR<WorkspaceFeatureCreateWithoutFeatureInput, WorkspaceFeatureUncheckedCreateWithoutFeatureInput>
  }

  export type WorkspaceFeatureUpdateWithWhereUniqueWithoutFeatureInput = {
    where: WorkspaceFeatureWhereUniqueInput
    data: XOR<WorkspaceFeatureUpdateWithoutFeatureInput, WorkspaceFeatureUncheckedUpdateWithoutFeatureInput>
  }

  export type WorkspaceFeatureUpdateManyWithWhereWithoutFeatureInput = {
    where: WorkspaceFeatureScalarWhereInput
    data: XOR<WorkspaceFeatureUpdateManyMutationInput, WorkspaceFeatureUncheckedUpdateManyWithoutFeatureInput>
  }

  export type FeatureCreateWithoutUserFeaturesInput = {
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    workspaceFeatures?: WorkspaceFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutUserFeaturesInput = {
    id?: number
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    workspaceFeatures?: WorkspaceFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutUserFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutUserFeaturesInput, FeatureUncheckedCreateWithoutUserFeaturesInput>
  }

  export type UserCreateWithoutFeaturesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeaturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeaturesInput, UserUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureUpsertWithoutUserFeaturesInput = {
    update: XOR<FeatureUpdateWithoutUserFeaturesInput, FeatureUncheckedUpdateWithoutUserFeaturesInput>
    create: XOR<FeatureCreateWithoutUserFeaturesInput, FeatureUncheckedCreateWithoutUserFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutUserFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutUserFeaturesInput, FeatureUncheckedUpdateWithoutUserFeaturesInput>
  }

  export type FeatureUpdateWithoutUserFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    workspaceFeatures?: WorkspaceFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutUserFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    workspaceFeatures?: WorkspaceFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type UserUpsertWithoutFeaturesInput = {
    update: XOR<UserUpdateWithoutFeaturesInput, UserUncheckedUpdateWithoutFeaturesInput>
    create: XOR<UserCreateWithoutFeaturesInput, UserUncheckedCreateWithoutFeaturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeaturesInput, UserUncheckedUpdateWithoutFeaturesInput>
  }

  export type UserUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeatureCreateWithoutWorkspaceFeaturesInput = {
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    userFeatures?: UserFeatureCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutWorkspaceFeaturesInput = {
    id?: number
    name: string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deprecatedVersion?: number
    deprecatedType?: number
    userFeatures?: UserFeatureUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutWorkspaceFeaturesInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutWorkspaceFeaturesInput, FeatureUncheckedCreateWithoutWorkspaceFeaturesInput>
  }

  export type WorkspaceCreateWithoutFeaturesInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutFeaturesInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutFeaturesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFeaturesInput, WorkspaceUncheckedCreateWithoutFeaturesInput>
  }

  export type FeatureUpsertWithoutWorkspaceFeaturesInput = {
    update: XOR<FeatureUpdateWithoutWorkspaceFeaturesInput, FeatureUncheckedUpdateWithoutWorkspaceFeaturesInput>
    create: XOR<FeatureCreateWithoutWorkspaceFeaturesInput, FeatureUncheckedCreateWithoutWorkspaceFeaturesInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutWorkspaceFeaturesInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutWorkspaceFeaturesInput, FeatureUncheckedUpdateWithoutWorkspaceFeaturesInput>
  }

  export type FeatureUpdateWithoutWorkspaceFeaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    userFeatures?: UserFeatureUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutWorkspaceFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    configs?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deprecatedVersion?: IntFieldUpdateOperationsInput | number
    deprecatedType?: IntFieldUpdateOperationsInput | number
    userFeatures?: UserFeatureUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type WorkspaceUpsertWithoutFeaturesInput = {
    update: XOR<WorkspaceUpdateWithoutFeaturesInput, WorkspaceUncheckedUpdateWithoutFeaturesInput>
    create: XOR<WorkspaceCreateWithoutFeaturesInput, WorkspaceUncheckedCreateWithoutFeaturesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutFeaturesInput, WorkspaceUncheckedUpdateWithoutFeaturesInput>
  }

  export type WorkspaceUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutFeaturesInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutCreatedSnapshotInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedSnapshotInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedSnapshotInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSnapshotInput, UserUncheckedCreateWithoutCreatedSnapshotInput>
  }

  export type UserCreateWithoutUpdatedSnapshotInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUpdatedSnapshotInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUpdatedSnapshotInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedSnapshotInput, UserUncheckedCreateWithoutUpdatedSnapshotInput>
  }

  export type UserUpsertWithoutCreatedSnapshotInput = {
    update: XOR<UserUpdateWithoutCreatedSnapshotInput, UserUncheckedUpdateWithoutCreatedSnapshotInput>
    create: XOR<UserCreateWithoutCreatedSnapshotInput, UserUncheckedCreateWithoutCreatedSnapshotInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSnapshotInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSnapshotInput, UserUncheckedUpdateWithoutCreatedSnapshotInput>
  }

  export type UserUpdateWithoutCreatedSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutUpdatedSnapshotInput = {
    update: XOR<UserUpdateWithoutUpdatedSnapshotInput, UserUncheckedUpdateWithoutUpdatedSnapshotInput>
    create: XOR<UserCreateWithoutUpdatedSnapshotInput, UserUncheckedCreateWithoutUpdatedSnapshotInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedSnapshotInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedSnapshotInput, UserUncheckedUpdateWithoutUpdatedSnapshotInput>
  }

  export type UserUpdateWithoutUpdatedSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiWorkspaceEmbeddingUpdateWithWhereUniqueWithoutSnapshotInput = {
    where: AiWorkspaceEmbeddingWhereUniqueInput
    data: XOR<AiWorkspaceEmbeddingUpdateWithoutSnapshotInput, AiWorkspaceEmbeddingUncheckedUpdateWithoutSnapshotInput>
  }

  export type AiWorkspaceEmbeddingUpdateManyWithWhereWithoutSnapshotInput = {
    where: AiWorkspaceEmbeddingScalarWhereInput
    data: XOR<AiWorkspaceEmbeddingUpdateManyMutationInput, AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotInput>
  }

  export type AiWorkspaceEmbeddingScalarWhereInput = {
    AND?: AiWorkspaceEmbeddingScalarWhereInput | AiWorkspaceEmbeddingScalarWhereInput[]
    OR?: AiWorkspaceEmbeddingScalarWhereInput[]
    NOT?: AiWorkspaceEmbeddingScalarWhereInput | AiWorkspaceEmbeddingScalarWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceEmbedding"> | string
    docId?: StringFilter<"AiWorkspaceEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceEmbedding"> | number
    content?: StringFilter<"AiWorkspaceEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiWorkspaceEmbedding"> | Date | string
  }

  export type UserCreateWithoutUserSnapshotsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSnapshotsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSnapshotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSnapshotsInput, UserUncheckedCreateWithoutUserSnapshotsInput>
  }

  export type UserUpsertWithoutUserSnapshotsInput = {
    update: XOR<UserUpdateWithoutUserSnapshotsInput, UserUncheckedUpdateWithoutUserSnapshotsInput>
    create: XOR<UserCreateWithoutUserSnapshotsInput, UserUncheckedCreateWithoutUserSnapshotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSnapshotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSnapshotsInput, UserUncheckedUpdateWithoutUserSnapshotsInput>
  }

  export type UserUpdateWithoutUserSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedUpdateInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedUpdateInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedUpdateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedUpdateInput, UserUncheckedCreateWithoutCreatedUpdateInput>
  }

  export type UserUpsertWithoutCreatedUpdateInput = {
    update: XOR<UserUpdateWithoutCreatedUpdateInput, UserUncheckedUpdateWithoutCreatedUpdateInput>
    create: XOR<UserCreateWithoutCreatedUpdateInput, UserUncheckedCreateWithoutCreatedUpdateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedUpdateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedUpdateInput, UserUncheckedUpdateWithoutCreatedUpdateInput>
  }

  export type UserUpdateWithoutCreatedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedHistoryInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedHistoryInput, UserUncheckedCreateWithoutCreatedHistoryInput>
  }

  export type UserUpsertWithoutCreatedHistoryInput = {
    update: XOR<UserUpdateWithoutCreatedHistoryInput, UserUncheckedUpdateWithoutCreatedHistoryInput>
    create: XOR<UserCreateWithoutCreatedHistoryInput, UserUncheckedCreateWithoutCreatedHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedHistoryInput, UserUncheckedUpdateWithoutCreatedHistoryInput>
  }

  export type UserUpdateWithoutCreatedHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiPromptCreateWithoutMessagesInput = {
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    sessions?: AiSessionCreateNestedManyWithoutPromptInput
  }

  export type AiPromptUncheckedCreateWithoutMessagesInput = {
    id?: number
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    sessions?: AiSessionUncheckedCreateNestedManyWithoutPromptInput
  }

  export type AiPromptCreateOrConnectWithoutMessagesInput = {
    where: AiPromptWhereUniqueInput
    create: XOR<AiPromptCreateWithoutMessagesInput, AiPromptUncheckedCreateWithoutMessagesInput>
  }

  export type AiPromptUpsertWithoutMessagesInput = {
    update: XOR<AiPromptUpdateWithoutMessagesInput, AiPromptUncheckedUpdateWithoutMessagesInput>
    create: XOR<AiPromptCreateWithoutMessagesInput, AiPromptUncheckedCreateWithoutMessagesInput>
    where?: AiPromptWhereInput
  }

  export type AiPromptUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AiPromptWhereInput
    data: XOR<AiPromptUpdateWithoutMessagesInput, AiPromptUncheckedUpdateWithoutMessagesInput>
  }

  export type AiPromptUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AiSessionUpdateManyWithoutPromptNestedInput
  }

  export type AiPromptUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    sessions?: AiSessionUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type AiPromptMessageCreateWithoutPromptInput = {
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiPromptMessageUncheckedCreateWithoutPromptInput = {
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiPromptMessageCreateOrConnectWithoutPromptInput = {
    where: AiPromptMessageWhereUniqueInput
    create: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput>
  }

  export type AiPromptMessageCreateManyPromptInputEnvelope = {
    data: AiPromptMessageCreateManyPromptInput | AiPromptMessageCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type AiSessionCreateWithoutPromptInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAiSessionsInput
    messages?: AiSessionMessageCreateNestedManyWithoutSessionInput
    context?: AiContextCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUncheckedCreateWithoutPromptInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: AiSessionMessageUncheckedCreateNestedManyWithoutSessionInput
    context?: AiContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AiSessionCreateOrConnectWithoutPromptInput = {
    where: AiSessionWhereUniqueInput
    create: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput>
  }

  export type AiSessionCreateManyPromptInputEnvelope = {
    data: AiSessionCreateManyPromptInput | AiSessionCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type AiPromptMessageUpsertWithWhereUniqueWithoutPromptInput = {
    where: AiPromptMessageWhereUniqueInput
    update: XOR<AiPromptMessageUpdateWithoutPromptInput, AiPromptMessageUncheckedUpdateWithoutPromptInput>
    create: XOR<AiPromptMessageCreateWithoutPromptInput, AiPromptMessageUncheckedCreateWithoutPromptInput>
  }

  export type AiPromptMessageUpdateWithWhereUniqueWithoutPromptInput = {
    where: AiPromptMessageWhereUniqueInput
    data: XOR<AiPromptMessageUpdateWithoutPromptInput, AiPromptMessageUncheckedUpdateWithoutPromptInput>
  }

  export type AiPromptMessageUpdateManyWithWhereWithoutPromptInput = {
    where: AiPromptMessageScalarWhereInput
    data: XOR<AiPromptMessageUpdateManyMutationInput, AiPromptMessageUncheckedUpdateManyWithoutPromptInput>
  }

  export type AiPromptMessageScalarWhereInput = {
    AND?: AiPromptMessageScalarWhereInput | AiPromptMessageScalarWhereInput[]
    OR?: AiPromptMessageScalarWhereInput[]
    NOT?: AiPromptMessageScalarWhereInput | AiPromptMessageScalarWhereInput[]
    promptId?: IntFilter<"AiPromptMessage"> | number
    idx?: IntFilter<"AiPromptMessage"> | number
    role?: EnumAiPromptRoleFilter<"AiPromptMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiPromptMessage"> | string
    attachments?: JsonNullableFilter<"AiPromptMessage">
    params?: JsonNullableFilter<"AiPromptMessage">
    createdAt?: DateTimeFilter<"AiPromptMessage"> | Date | string
  }

  export type AiSessionUpsertWithWhereUniqueWithoutPromptInput = {
    where: AiSessionWhereUniqueInput
    update: XOR<AiSessionUpdateWithoutPromptInput, AiSessionUncheckedUpdateWithoutPromptInput>
    create: XOR<AiSessionCreateWithoutPromptInput, AiSessionUncheckedCreateWithoutPromptInput>
  }

  export type AiSessionUpdateWithWhereUniqueWithoutPromptInput = {
    where: AiSessionWhereUniqueInput
    data: XOR<AiSessionUpdateWithoutPromptInput, AiSessionUncheckedUpdateWithoutPromptInput>
  }

  export type AiSessionUpdateManyWithWhereWithoutPromptInput = {
    where: AiSessionScalarWhereInput
    data: XOR<AiSessionUpdateManyMutationInput, AiSessionUncheckedUpdateManyWithoutPromptInput>
  }

  export type AiSessionCreateWithoutMessagesInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAiSessionsInput
    prompt: AiPromptCreateNestedOneWithoutSessionsInput
    context?: AiContextCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    context?: AiContextUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AiSessionCreateOrConnectWithoutMessagesInput = {
    where: AiSessionWhereUniqueInput
    create: XOR<AiSessionCreateWithoutMessagesInput, AiSessionUncheckedCreateWithoutMessagesInput>
  }

  export type AiSessionUpsertWithoutMessagesInput = {
    update: XOR<AiSessionUpdateWithoutMessagesInput, AiSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<AiSessionCreateWithoutMessagesInput, AiSessionUncheckedCreateWithoutMessagesInput>
    where?: AiSessionWhereInput
  }

  export type AiSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: AiSessionWhereInput
    data: XOR<AiSessionUpdateWithoutMessagesInput, AiSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type AiSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAiSessionsNestedInput
    prompt?: AiPromptUpdateOneRequiredWithoutSessionsNestedInput
    context?: AiContextUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    context?: AiContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutAiSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiSessionsInput, UserUncheckedCreateWithoutAiSessionsInput>
  }

  export type AiPromptCreateWithoutSessionsInput = {
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    messages?: AiPromptMessageCreateNestedManyWithoutPromptInput
  }

  export type AiPromptUncheckedCreateWithoutSessionsInput = {
    id?: number
    name: string
    action?: string | null
    model: string
    optionalModels?: AiPromptCreateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modified?: boolean
    messages?: AiPromptMessageUncheckedCreateNestedManyWithoutPromptInput
  }

  export type AiPromptCreateOrConnectWithoutSessionsInput = {
    where: AiPromptWhereUniqueInput
    create: XOR<AiPromptCreateWithoutSessionsInput, AiPromptUncheckedCreateWithoutSessionsInput>
  }

  export type AiSessionMessageCreateWithoutSessionInput = {
    id?: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiSessionMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiSessionMessageCreateOrConnectWithoutSessionInput = {
    where: AiSessionMessageWhereUniqueInput
    create: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput>
  }

  export type AiSessionMessageCreateManySessionInputEnvelope = {
    data: AiSessionMessageCreateManySessionInput | AiSessionMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AiContextCreateWithoutSessionInput = {
    id?: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: AiContextEmbeddingCreateNestedManyWithoutContextInput
  }

  export type AiContextUncheckedCreateWithoutSessionInput = {
    id?: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    embeddings?: AiContextEmbeddingUncheckedCreateNestedManyWithoutContextInput
  }

  export type AiContextCreateOrConnectWithoutSessionInput = {
    where: AiContextWhereUniqueInput
    create: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput>
  }

  export type AiContextCreateManySessionInputEnvelope = {
    data: AiContextCreateManySessionInput | AiContextCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAiSessionsInput = {
    update: XOR<UserUpdateWithoutAiSessionsInput, UserUncheckedUpdateWithoutAiSessionsInput>
    create: XOR<UserCreateWithoutAiSessionsInput, UserUncheckedCreateWithoutAiSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiSessionsInput, UserUncheckedUpdateWithoutAiSessionsInput>
  }

  export type UserUpdateWithoutAiSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AiPromptUpsertWithoutSessionsInput = {
    update: XOR<AiPromptUpdateWithoutSessionsInput, AiPromptUncheckedUpdateWithoutSessionsInput>
    create: XOR<AiPromptCreateWithoutSessionsInput, AiPromptUncheckedCreateWithoutSessionsInput>
    where?: AiPromptWhereInput
  }

  export type AiPromptUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AiPromptWhereInput
    data: XOR<AiPromptUpdateWithoutSessionsInput, AiPromptUncheckedUpdateWithoutSessionsInput>
  }

  export type AiPromptUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    messages?: AiPromptMessageUpdateManyWithoutPromptNestedInput
  }

  export type AiPromptUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    action?: NullableStringFieldUpdateOperationsInput | string | null
    model?: StringFieldUpdateOperationsInput | string
    optionalModels?: AiPromptUpdateoptionalModelsInput | string[]
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modified?: BoolFieldUpdateOperationsInput | boolean
    messages?: AiPromptMessageUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type AiSessionMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: AiSessionMessageWhereUniqueInput
    update: XOR<AiSessionMessageUpdateWithoutSessionInput, AiSessionMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<AiSessionMessageCreateWithoutSessionInput, AiSessionMessageUncheckedCreateWithoutSessionInput>
  }

  export type AiSessionMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: AiSessionMessageWhereUniqueInput
    data: XOR<AiSessionMessageUpdateWithoutSessionInput, AiSessionMessageUncheckedUpdateWithoutSessionInput>
  }

  export type AiSessionMessageUpdateManyWithWhereWithoutSessionInput = {
    where: AiSessionMessageScalarWhereInput
    data: XOR<AiSessionMessageUpdateManyMutationInput, AiSessionMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type AiSessionMessageScalarWhereInput = {
    AND?: AiSessionMessageScalarWhereInput | AiSessionMessageScalarWhereInput[]
    OR?: AiSessionMessageScalarWhereInput[]
    NOT?: AiSessionMessageScalarWhereInput | AiSessionMessageScalarWhereInput[]
    id?: StringFilter<"AiSessionMessage"> | string
    sessionId?: StringFilter<"AiSessionMessage"> | string
    role?: EnumAiPromptRoleFilter<"AiSessionMessage"> | $Enums.AiPromptRole
    content?: StringFilter<"AiSessionMessage"> | string
    streamObjects?: JsonNullableFilter<"AiSessionMessage">
    attachments?: JsonNullableFilter<"AiSessionMessage">
    params?: JsonNullableFilter<"AiSessionMessage">
    createdAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
    updatedAt?: DateTimeFilter<"AiSessionMessage"> | Date | string
  }

  export type AiContextUpsertWithWhereUniqueWithoutSessionInput = {
    where: AiContextWhereUniqueInput
    update: XOR<AiContextUpdateWithoutSessionInput, AiContextUncheckedUpdateWithoutSessionInput>
    create: XOR<AiContextCreateWithoutSessionInput, AiContextUncheckedCreateWithoutSessionInput>
  }

  export type AiContextUpdateWithWhereUniqueWithoutSessionInput = {
    where: AiContextWhereUniqueInput
    data: XOR<AiContextUpdateWithoutSessionInput, AiContextUncheckedUpdateWithoutSessionInput>
  }

  export type AiContextUpdateManyWithWhereWithoutSessionInput = {
    where: AiContextScalarWhereInput
    data: XOR<AiContextUpdateManyMutationInput, AiContextUncheckedUpdateManyWithoutSessionInput>
  }

  export type AiContextScalarWhereInput = {
    AND?: AiContextScalarWhereInput | AiContextScalarWhereInput[]
    OR?: AiContextScalarWhereInput[]
    NOT?: AiContextScalarWhereInput | AiContextScalarWhereInput[]
    id?: StringFilter<"AiContext"> | string
    sessionId?: StringFilter<"AiContext"> | string
    config?: JsonFilter<"AiContext">
    createdAt?: DateTimeFilter<"AiContext"> | Date | string
    updatedAt?: DateTimeFilter<"AiContext"> | Date | string
  }

  export type AiSessionCreateWithoutContextInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAiSessionsInput
    prompt: AiPromptCreateNestedOneWithoutSessionsInput
    messages?: AiSessionMessageCreateNestedManyWithoutSessionInput
  }

  export type AiSessionUncheckedCreateWithoutContextInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    messages?: AiSessionMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type AiSessionCreateOrConnectWithoutContextInput = {
    where: AiSessionWhereUniqueInput
    create: XOR<AiSessionCreateWithoutContextInput, AiSessionUncheckedCreateWithoutContextInput>
  }

  export type AiContextEmbeddingUpdateWithWhereUniqueWithoutContextInput = {
    where: AiContextEmbeddingWhereUniqueInput
    data: XOR<AiContextEmbeddingUpdateWithoutContextInput, AiContextEmbeddingUncheckedUpdateWithoutContextInput>
  }

  export type AiContextEmbeddingUpdateManyWithWhereWithoutContextInput = {
    where: AiContextEmbeddingScalarWhereInput
    data: XOR<AiContextEmbeddingUpdateManyMutationInput, AiContextEmbeddingUncheckedUpdateManyWithoutContextInput>
  }

  export type AiContextEmbeddingScalarWhereInput = {
    AND?: AiContextEmbeddingScalarWhereInput | AiContextEmbeddingScalarWhereInput[]
    OR?: AiContextEmbeddingScalarWhereInput[]
    NOT?: AiContextEmbeddingScalarWhereInput | AiContextEmbeddingScalarWhereInput[]
    id?: StringFilter<"AiContextEmbedding"> | string
    contextId?: StringFilter<"AiContextEmbedding"> | string
    fileId?: StringFilter<"AiContextEmbedding"> | string
    chunk?: IntFilter<"AiContextEmbedding"> | number
    content?: StringFilter<"AiContextEmbedding"> | string
    createdAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"AiContextEmbedding"> | Date | string
  }

  export type AiSessionUpsertWithoutContextInput = {
    update: XOR<AiSessionUpdateWithoutContextInput, AiSessionUncheckedUpdateWithoutContextInput>
    create: XOR<AiSessionCreateWithoutContextInput, AiSessionUncheckedCreateWithoutContextInput>
    where?: AiSessionWhereInput
  }

  export type AiSessionUpdateToOneWithWhereWithoutContextInput = {
    where?: AiSessionWhereInput
    data: XOR<AiSessionUpdateWithoutContextInput, AiSessionUncheckedUpdateWithoutContextInput>
  }

  export type AiSessionUpdateWithoutContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAiSessionsNestedInput
    prompt?: AiPromptUpdateOneRequiredWithoutSessionsNestedInput
    messages?: AiSessionMessageUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateWithoutContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: AiSessionMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AiContextCreateWithoutEmbeddingsInput = {
    id?: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session: AiSessionCreateNestedOneWithoutContextInput
  }

  export type AiContextUncheckedCreateWithoutEmbeddingsInput = {
    id?: string
    sessionId: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiContextCreateOrConnectWithoutEmbeddingsInput = {
    where: AiContextWhereUniqueInput
    create: XOR<AiContextCreateWithoutEmbeddingsInput, AiContextUncheckedCreateWithoutEmbeddingsInput>
  }

  export type AiContextUpsertWithoutEmbeddingsInput = {
    update: XOR<AiContextUpdateWithoutEmbeddingsInput, AiContextUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<AiContextCreateWithoutEmbeddingsInput, AiContextUncheckedCreateWithoutEmbeddingsInput>
    where?: AiContextWhereInput
  }

  export type AiContextUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: AiContextWhereInput
    data: XOR<AiContextUpdateWithoutEmbeddingsInput, AiContextUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type AiContextUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: AiSessionUpdateOneRequiredWithoutContextNestedInput
  }

  export type AiContextUncheckedUpdateWithoutEmbeddingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnapshotCreateWithoutEmbeddingInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    seq?: number | null
    createdByUser?: UserCreateNestedOneWithoutCreatedSnapshotInput
    updatedByUser?: UserCreateNestedOneWithoutUpdatedSnapshotInput
  }

  export type SnapshotUncheckedCreateWithoutEmbeddingInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    seq?: number | null
  }

  export type SnapshotCreateOrConnectWithoutEmbeddingInput = {
    where: SnapshotWhereUniqueInput
    create: XOR<SnapshotCreateWithoutEmbeddingInput, SnapshotUncheckedCreateWithoutEmbeddingInput>
  }

  export type SnapshotUpsertWithoutEmbeddingInput = {
    update: XOR<SnapshotUpdateWithoutEmbeddingInput, SnapshotUncheckedUpdateWithoutEmbeddingInput>
    create: XOR<SnapshotCreateWithoutEmbeddingInput, SnapshotUncheckedCreateWithoutEmbeddingInput>
    where?: SnapshotWhereInput
  }

  export type SnapshotUpdateToOneWithWhereWithoutEmbeddingInput = {
    where?: SnapshotWhereInput
    data: XOR<SnapshotUpdateWithoutEmbeddingInput, SnapshotUncheckedUpdateWithoutEmbeddingInput>
  }

  export type SnapshotUpdateWithoutEmbeddingInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUser?: UserUpdateOneWithoutCreatedSnapshotNestedInput
    updatedByUser?: UserUpdateOneWithoutUpdatedSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateWithoutEmbeddingInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkspaceCreateWithoutIgnoredDocsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutIgnoredDocsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutIgnoredDocsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutIgnoredDocsInput, WorkspaceUncheckedCreateWithoutIgnoredDocsInput>
  }

  export type WorkspaceUpsertWithoutIgnoredDocsInput = {
    update: XOR<WorkspaceUpdateWithoutIgnoredDocsInput, WorkspaceUncheckedUpdateWithoutIgnoredDocsInput>
    create: XOR<WorkspaceCreateWithoutIgnoredDocsInput, WorkspaceUncheckedCreateWithoutIgnoredDocsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutIgnoredDocsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutIgnoredDocsInput, WorkspaceUncheckedUpdateWithoutIgnoredDocsInput>
  }

  export type WorkspaceUpdateWithoutIgnoredDocsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutIgnoredDocsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutEmbedFilesInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutEmbedFilesInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutEmbedFilesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutEmbedFilesInput, WorkspaceUncheckedCreateWithoutEmbedFilesInput>
  }

  export type WorkspaceUpsertWithoutEmbedFilesInput = {
    update: XOR<WorkspaceUpdateWithoutEmbedFilesInput, WorkspaceUncheckedUpdateWithoutEmbedFilesInput>
    create: XOR<WorkspaceCreateWithoutEmbedFilesInput, WorkspaceUncheckedCreateWithoutEmbedFilesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutEmbedFilesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutEmbedFilesInput, WorkspaceUncheckedUpdateWithoutEmbedFilesInput>
  }

  export type WorkspaceUpdateWithoutEmbedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutEmbedFilesInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AiWorkspaceFileEmbeddingUpdateWithWhereUniqueWithoutFileInput = {
    where: AiWorkspaceFileEmbeddingWhereUniqueInput
    data: XOR<AiWorkspaceFileEmbeddingUpdateWithoutFileInput, AiWorkspaceFileEmbeddingUncheckedUpdateWithoutFileInput>
  }

  export type AiWorkspaceFileEmbeddingUpdateManyWithWhereWithoutFileInput = {
    where: AiWorkspaceFileEmbeddingScalarWhereInput
    data: XOR<AiWorkspaceFileEmbeddingUpdateManyMutationInput, AiWorkspaceFileEmbeddingUncheckedUpdateManyWithoutFileInput>
  }

  export type AiWorkspaceFileEmbeddingScalarWhereInput = {
    AND?: AiWorkspaceFileEmbeddingScalarWhereInput | AiWorkspaceFileEmbeddingScalarWhereInput[]
    OR?: AiWorkspaceFileEmbeddingScalarWhereInput[]
    NOT?: AiWorkspaceFileEmbeddingScalarWhereInput | AiWorkspaceFileEmbeddingScalarWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    fileId?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceFileEmbedding"> | number
    content?: StringFilter<"AiWorkspaceFileEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceFileEmbedding"> | Date | string
  }

  export type AiWorkspaceFilesCreateWithoutEmbeddingsInput = {
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutEmbedFilesInput
  }

  export type AiWorkspaceFilesUncheckedCreateWithoutEmbeddingsInput = {
    workspaceId: string
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
  }

  export type AiWorkspaceFilesCreateOrConnectWithoutEmbeddingsInput = {
    where: AiWorkspaceFilesWhereUniqueInput
    create: XOR<AiWorkspaceFilesCreateWithoutEmbeddingsInput, AiWorkspaceFilesUncheckedCreateWithoutEmbeddingsInput>
  }

  export type AiWorkspaceFilesUpsertWithoutEmbeddingsInput = {
    update: XOR<AiWorkspaceFilesUpdateWithoutEmbeddingsInput, AiWorkspaceFilesUncheckedUpdateWithoutEmbeddingsInput>
    create: XOR<AiWorkspaceFilesCreateWithoutEmbeddingsInput, AiWorkspaceFilesUncheckedCreateWithoutEmbeddingsInput>
    where?: AiWorkspaceFilesWhereInput
  }

  export type AiWorkspaceFilesUpdateToOneWithWhereWithoutEmbeddingsInput = {
    where?: AiWorkspaceFilesWhereInput
    data: XOR<AiWorkspaceFilesUpdateWithoutEmbeddingsInput, AiWorkspaceFilesUncheckedUpdateWithoutEmbeddingsInput>
  }

  export type AiWorkspaceFilesUpdateWithoutEmbeddingsInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutEmbedFilesNestedInput
  }

  export type AiWorkspaceFilesUncheckedUpdateWithoutEmbeddingsInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlobCreateWithoutAiWorkspaceBlobEmbeddingInput = {
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutBlobsInput
  }

  export type BlobUncheckedCreateWithoutAiWorkspaceBlobEmbeddingInput = {
    workspaceId: string
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BlobCreateOrConnectWithoutAiWorkspaceBlobEmbeddingInput = {
    where: BlobWhereUniqueInput
    create: XOR<BlobCreateWithoutAiWorkspaceBlobEmbeddingInput, BlobUncheckedCreateWithoutAiWorkspaceBlobEmbeddingInput>
  }

  export type BlobUpsertWithoutAiWorkspaceBlobEmbeddingInput = {
    update: XOR<BlobUpdateWithoutAiWorkspaceBlobEmbeddingInput, BlobUncheckedUpdateWithoutAiWorkspaceBlobEmbeddingInput>
    create: XOR<BlobCreateWithoutAiWorkspaceBlobEmbeddingInput, BlobUncheckedCreateWithoutAiWorkspaceBlobEmbeddingInput>
    where?: BlobWhereInput
  }

  export type BlobUpdateToOneWithWhereWithoutAiWorkspaceBlobEmbeddingInput = {
    where?: BlobWhereInput
    data: XOR<BlobUpdateWithoutAiWorkspaceBlobEmbeddingInput, BlobUncheckedUpdateWithoutAiWorkspaceBlobEmbeddingInput>
  }

  export type BlobUpdateWithoutAiWorkspaceBlobEmbeddingInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutBlobsNestedInput
  }

  export type BlobUncheckedUpdateWithoutAiWorkspaceBlobEmbeddingInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutCreatedAiJobsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedAiJobsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedAiJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedAiJobsInput, UserUncheckedCreateWithoutCreatedAiJobsInput>
  }

  export type UserUpsertWithoutCreatedAiJobsInput = {
    update: XOR<UserUpdateWithoutCreatedAiJobsInput, UserUncheckedUpdateWithoutCreatedAiJobsInput>
    create: XOR<UserCreateWithoutCreatedAiJobsInput, UserUncheckedCreateWithoutCreatedAiJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedAiJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedAiJobsInput, UserUncheckedUpdateWithoutCreatedAiJobsInput>
  }

  export type UserUpdateWithoutCreatedAiJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedAiJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDeprecatedAppRuntimeSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeprecatedAppRuntimeSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeprecatedAppRuntimeSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedCreateWithoutDeprecatedAppRuntimeSettingsInput>
  }

  export type UserUpsertWithoutDeprecatedAppRuntimeSettingsInput = {
    update: XOR<UserUpdateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedUpdateWithoutDeprecatedAppRuntimeSettingsInput>
    create: XOR<UserCreateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedCreateWithoutDeprecatedAppRuntimeSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeprecatedAppRuntimeSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeprecatedAppRuntimeSettingsInput, UserUncheckedUpdateWithoutDeprecatedAppRuntimeSettingsInput>
  }

  export type UserUpdateWithoutDeprecatedAppRuntimeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeprecatedAppRuntimeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAppConfigsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppConfigsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppConfigsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppConfigsInput, UserUncheckedCreateWithoutAppConfigsInput>
  }

  export type UserUpsertWithoutAppConfigsInput = {
    update: XOR<UserUpdateWithoutAppConfigsInput, UserUncheckedUpdateWithoutAppConfigsInput>
    create: XOR<UserCreateWithoutAppConfigsInput, UserUncheckedCreateWithoutAppConfigsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppConfigsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppConfigsInput, UserUncheckedUpdateWithoutAppConfigsInput>
  }

  export type UserUpdateWithoutAppConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserStripeCustomerInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserStripeCustomerInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserStripeCustomerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserStripeCustomerInput, UserUncheckedCreateWithoutUserStripeCustomerInput>
  }

  export type UserUpsertWithoutUserStripeCustomerInput = {
    update: XOR<UserUpdateWithoutUserStripeCustomerInput, UserUncheckedUpdateWithoutUserStripeCustomerInput>
    create: XOR<UserCreateWithoutUserStripeCustomerInput, UserUncheckedCreateWithoutUserStripeCustomerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserStripeCustomerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserStripeCustomerInput, UserUncheckedUpdateWithoutUserStripeCustomerInput>
  }

  export type UserUpdateWithoutUserStripeCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserStripeCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutBlobsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutBlobsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutBlobsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutBlobsInput, WorkspaceUncheckedCreateWithoutBlobsInput>
  }

  export type WorkspaceUpsertWithoutBlobsInput = {
    update: XOR<WorkspaceUpdateWithoutBlobsInput, WorkspaceUncheckedUpdateWithoutBlobsInput>
    create: XOR<WorkspaceCreateWithoutBlobsInput, WorkspaceUncheckedCreateWithoutBlobsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutBlobsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutBlobsInput, WorkspaceUncheckedUpdateWithoutBlobsInput>
  }

  export type WorkspaceUpdateWithoutBlobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutBlobsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AiWorkspaceBlobEmbeddingUpdateWithWhereUniqueWithoutBlobInput = {
    where: AiWorkspaceBlobEmbeddingWhereUniqueInput
    data: XOR<AiWorkspaceBlobEmbeddingUpdateWithoutBlobInput, AiWorkspaceBlobEmbeddingUncheckedUpdateWithoutBlobInput>
  }

  export type AiWorkspaceBlobEmbeddingUpdateManyWithWhereWithoutBlobInput = {
    where: AiWorkspaceBlobEmbeddingScalarWhereInput
    data: XOR<AiWorkspaceBlobEmbeddingUpdateManyMutationInput, AiWorkspaceBlobEmbeddingUncheckedUpdateManyWithoutBlobInput>
  }

  export type AiWorkspaceBlobEmbeddingScalarWhereInput = {
    AND?: AiWorkspaceBlobEmbeddingScalarWhereInput | AiWorkspaceBlobEmbeddingScalarWhereInput[]
    OR?: AiWorkspaceBlobEmbeddingScalarWhereInput[]
    NOT?: AiWorkspaceBlobEmbeddingScalarWhereInput | AiWorkspaceBlobEmbeddingScalarWhereInput[]
    workspaceId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    blobId?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    chunk?: IntFilter<"AiWorkspaceBlobEmbedding"> | number
    content?: StringFilter<"AiWorkspaceBlobEmbedding"> | string
    createdAt?: DateTimeFilter<"AiWorkspaceBlobEmbedding"> | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type WorkspaceCreateWithoutCommentsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCommentsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCommentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCommentsInput, WorkspaceUncheckedCreateWithoutCommentsInput>
  }

  export type ReplyCreateWithoutCommentInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutRepliesInput
  }

  export type ReplyUncheckedCreateWithoutCommentInput = {
    sid?: number
    id?: string
    userId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReplyCreateOrConnectWithoutCommentInput = {
    where: ReplyWhereUniqueInput
    create: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput>
  }

  export type ReplyCreateManyCommentInputEnvelope = {
    data: ReplyCreateManyCommentInput | ReplyCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutCommentsInput = {
    update: XOR<WorkspaceUpdateWithoutCommentsInput, WorkspaceUncheckedUpdateWithoutCommentsInput>
    create: XOR<WorkspaceCreateWithoutCommentsInput, WorkspaceUncheckedCreateWithoutCommentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCommentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCommentsInput, WorkspaceUncheckedUpdateWithoutCommentsInput>
  }

  export type WorkspaceUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCommentsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ReplyUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReplyWhereUniqueInput
    update: XOR<ReplyUpdateWithoutCommentInput, ReplyUncheckedUpdateWithoutCommentInput>
    create: XOR<ReplyCreateWithoutCommentInput, ReplyUncheckedCreateWithoutCommentInput>
  }

  export type ReplyUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReplyWhereUniqueInput
    data: XOR<ReplyUpdateWithoutCommentInput, ReplyUncheckedUpdateWithoutCommentInput>
  }

  export type ReplyUpdateManyWithWhereWithoutCommentInput = {
    where: ReplyScalarWhereInput
    data: XOR<ReplyUpdateManyMutationInput, ReplyUncheckedUpdateManyWithoutCommentInput>
  }

  export type UserCreateWithoutRepliesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRepliesInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    sid?: number
    id?: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
    user: UserCreateNestedOneWithoutCommentsInput
    workspace: WorkspaceCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type UserUpsertWithoutRepliesInput = {
    update: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceCreateWithoutCommentAttachmentsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesCreateNestedManyWithoutWorkspaceInput
    comments?: CommentCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutCommentAttachmentsInput = {
    sid?: number
    id?: string
    public: boolean
    createdAt?: Date | string
    enableAi?: boolean
    enableUrlPreview?: boolean
    enableDocEmbedding?: boolean
    name?: string | null
    avatarKey?: string | null
    indexed?: boolean
    lastCheckEmbeddings?: Date | string
    features?: WorkspaceFeatureUncheckedCreateNestedManyWithoutWorkspaceInput
    docs?: WorkspaceDocUncheckedCreateNestedManyWithoutWorkspaceInput
    permissions?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    blobs?: BlobUncheckedCreateNestedManyWithoutWorkspaceInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedCreateNestedManyWithoutWorkspaceInput
    embedFiles?: AiWorkspaceFilesUncheckedCreateNestedManyWithoutWorkspaceInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutCommentAttachmentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutCommentAttachmentsInput, WorkspaceUncheckedCreateWithoutCommentAttachmentsInput>
  }

  export type UserCreateWithoutCommentAttachmentsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    AccessToken?: AccessTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentAttachmentsInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    AccessToken?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentAttachmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentAttachmentsInput, UserUncheckedCreateWithoutCommentAttachmentsInput>
  }

  export type WorkspaceUpsertWithoutCommentAttachmentsInput = {
    update: XOR<WorkspaceUpdateWithoutCommentAttachmentsInput, WorkspaceUncheckedUpdateWithoutCommentAttachmentsInput>
    create: XOR<WorkspaceCreateWithoutCommentAttachmentsInput, WorkspaceUncheckedCreateWithoutCommentAttachmentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutCommentAttachmentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutCommentAttachmentsInput, WorkspaceUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type WorkspaceUpdateWithoutCommentAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutCommentAttachmentsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enableAi?: BoolFieldUpdateOperationsInput | boolean
    enableUrlPreview?: BoolFieldUpdateOperationsInput | boolean
    enableDocEmbedding?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    indexed?: BoolFieldUpdateOperationsInput | boolean
    lastCheckEmbeddings?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceNestedInput
    docs?: WorkspaceDocUncheckedUpdateManyWithoutWorkspaceNestedInput
    permissions?: WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    blobs?: BlobUncheckedUpdateManyWithoutWorkspaceNestedInput
    ignoredDocs?: AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceNestedInput
    embedFiles?: AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutCommentAttachmentsInput = {
    update: XOR<UserUpdateWithoutCommentAttachmentsInput, UserUncheckedUpdateWithoutCommentAttachmentsInput>
    create: XOR<UserCreateWithoutCommentAttachmentsInput, UserUncheckedCreateWithoutCommentAttachmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentAttachmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentAttachmentsInput, UserUncheckedUpdateWithoutCommentAttachmentsInput>
  }

  export type UserUpdateWithoutCommentAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    AccessToken?: AccessTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    AccessToken?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccessTokenInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    replies?: ReplyCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAccessTokenInput = {
    id?: string
    name: string
    email: string
    emailVerifiedAt?: Date | string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    password?: string | null
    registered?: boolean
    disabled?: boolean
    features?: UserFeatureUncheckedCreateNestedManyWithoutUserInput
    userStripeCustomer?: UserStripeCustomerUncheckedCreateNestedOneWithoutUserInput
    workspaces?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutUserInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedCreateNestedManyWithoutInviterInput
    docPermissions?: WorkspaceDocUserRoleUncheckedCreateNestedManyWithoutUserInput
    connectedAccounts?: ConnectedAccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    aiSessions?: AiSessionUncheckedCreateNestedManyWithoutUserInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    appConfigs?: AppConfigUncheckedCreateNestedManyWithoutLastUpdatedByUserInput
    userSnapshots?: UserSnapshotUncheckedCreateNestedManyWithoutUserInput
    createdSnapshot?: SnapshotUncheckedCreateNestedManyWithoutCreatedByUserInput
    updatedSnapshot?: SnapshotUncheckedCreateNestedManyWithoutUpdatedByUserInput
    createdUpdate?: UpdateUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdHistory?: SnapshotHistoryUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdAiJobs?: AiJobsUncheckedCreateNestedManyWithoutCreatedByUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyUncheckedCreateNestedManyWithoutUserInput
    commentAttachments?: CommentAttachmentUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAccessTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessTokenInput, UserUncheckedCreateWithoutAccessTokenInput>
  }

  export type UserUpsertWithoutAccessTokenInput = {
    update: XOR<UserUpdateWithoutAccessTokenInput, UserUncheckedUpdateWithoutAccessTokenInput>
    create: XOR<UserCreateWithoutAccessTokenInput, UserUncheckedCreateWithoutAccessTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccessTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccessTokenInput, UserUncheckedUpdateWithoutAccessTokenInput>
  }

  export type UserUpdateWithoutAccessTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    replies?: ReplyUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccessTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    registered?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    features?: UserFeatureUncheckedUpdateManyWithoutUserNestedInput
    userStripeCustomer?: UserStripeCustomerUncheckedUpdateOneWithoutUserNestedInput
    workspaces?: WorkspaceUserRoleUncheckedUpdateManyWithoutUserNestedInput
    WorkspaceInvitations?: WorkspaceUserRoleUncheckedUpdateManyWithoutInviterNestedInput
    docPermissions?: WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserNestedInput
    connectedAccounts?: ConnectedAccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    aiSessions?: AiSessionUncheckedUpdateManyWithoutUserNestedInput
    deprecatedAppRuntimeSettings?: DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    appConfigs?: AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserNestedInput
    userSnapshots?: UserSnapshotUncheckedUpdateManyWithoutUserNestedInput
    createdSnapshot?: SnapshotUncheckedUpdateManyWithoutCreatedByUserNestedInput
    updatedSnapshot?: SnapshotUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    createdUpdate?: UpdateUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdHistory?: SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdAiJobs?: AiJobsUncheckedUpdateManyWithoutCreatedByUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyUncheckedUpdateManyWithoutUserNestedInput
    commentAttachments?: CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserFeatureCreateManyUserInput = {
    id?: number
    featureId: number
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type WorkspaceUserRoleCreateManyUserInput = {
    id?: string
    workspaceId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceUserRoleCreateManyInviterInput = {
    id?: string
    workspaceId: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceDocUserRoleCreateManyUserInput = {
    workspaceId: string
    docId: string
    type: number
    createdAt?: Date | string
  }

  export type ConnectedAccountCreateManyUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    scope?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    sessionId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AiSessionCreateManyUserInput = {
    id?: string
    workspaceId: string
    docId?: string | null
    promptName: string
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsCreateManyLastUpdatedByUserInput = {
    id: string
    type: $Enums.RuntimeConfigType
    module: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description: string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AppConfigCreateManyLastUpdatedByUserInput = {
    id: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSnapshotCreateManyUserInput = {
    id: string
    blob: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SnapshotCreateManyCreatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    updatedBy?: string | null
    seq?: number | null
  }

  export type SnapshotCreateManyUpdatedByUserInput = {
    workspaceId: string
    id?: string
    blob: Uint8Array
    state?: Uint8Array | null
    createdAt?: Date | string
    updatedAt: Date | string
    createdBy?: string | null
    seq?: number | null
  }

  export type UpdateCreateManyCreatedByUserInput = {
    workspaceId: string
    id: string
    blob: Uint8Array
    createdAt: Date | string
    seq?: number | null
  }

  export type SnapshotHistoryCreateManyCreatedByUserInput = {
    workspaceId: string
    id: string
    timestamp: Date | string
    blob: Uint8Array
    state?: Uint8Array | null
    expiredAt: Date | string
  }

  export type AiJobsCreateManyCreatedByUserInput = {
    id?: string
    workspaceId: string
    blobId: string
    type: $Enums.AiJobType
    status?: $Enums.AiJobStatus
    payload: JsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    finishedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level: $Enums.NotificationLevel
    read?: boolean
    type: $Enums.NotificationType
    body: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateManyUserInput = {
    sid?: number
    id?: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
  }

  export type ReplyCreateManyUserInput = {
    sid?: number
    id?: string
    commentId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CommentAttachmentCreateManyCreatedByUserInput = {
    sid?: number
    workspaceId: string
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
  }

  export type AccessTokenCreateManyUserInput = {
    id?: string
    name: string
    token: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type UserFeatureUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
    feature?: FeatureUpdateOneRequiredWithoutUserFeaturesNestedInput
  }

  export type UserFeatureUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeatureUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    workspace?: WorkspaceUpdateOneRequiredWithoutPermissionsNestedInput
    inviter?: UserUpdateOneWithoutWorkspaceInvitationsNestedInput
  }

  export type WorkspaceUserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type WorkspaceUserRoleUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceDocUserRoleUpdateWithoutUserInput = {
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDocPermissionsNestedInput
  }

  export type WorkspaceDocUserRoleUncheckedUpdateWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceDocUserRoleUncheckedUpdateManyWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectedAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectedAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectedAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prompt?: AiPromptUpdateOneRequiredWithoutSessionsNestedInput
    messages?: AiSessionMessageUpdateManyWithoutSessionNestedInput
    context?: AiContextUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: AiSessionMessageUncheckedUpdateManyWithoutSessionNestedInput
    context?: AiContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptName?: StringFieldUpdateOperationsInput | string
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUpdateWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUncheckedUpdateWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeprecatedAppRuntimeSettingsUncheckedUpdateManyWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumRuntimeConfigTypeFieldUpdateOperationsInput | $Enums.RuntimeConfigType
    module?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppConfigUpdateWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigUncheckedUpdateManyWithoutLastUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSnapshotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSnapshotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSnapshotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnapshotUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    updatedByUser?: UserUpdateOneWithoutUpdatedSnapshotNestedInput
    embedding?: AiWorkspaceEmbeddingUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    embedding?: AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateManyWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SnapshotUpdateWithoutUpdatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUser?: UserUpdateOneWithoutCreatedSnapshotNestedInput
    embedding?: AiWorkspaceEmbeddingUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateWithoutUpdatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
    embedding?: AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotNestedInput
  }

  export type SnapshotUncheckedUpdateManyWithoutUpdatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UpdateUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UpdateUncheckedUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UpdateUncheckedUpdateManyWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seq?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SnapshotHistoryUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnapshotHistoryUncheckedUpdateWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnapshotHistoryUncheckedUpdateManyWithoutCreatedByUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    blob?: BytesFieldUpdateOperationsInput | Uint8Array
    state?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiJobsUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiJobsUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiJobsUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    type?: EnumAiJobTypeFieldUpdateOperationsInput | $Enums.AiJobType
    status?: EnumAiJobStatusFieldUpdateOperationsInput | $Enums.AiJobStatus
    payload?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: EnumNotificationLevelFieldUpdateOperationsInput | $Enums.NotificationLevel
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    body?: JsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    workspace?: WorkspaceUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReplyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyUncheckedUpdateWithoutUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReplyUncheckedUpdateManyWithoutUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentAttachmentUpdateWithoutCreatedByUserInput = {
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutCommentAttachmentsNestedInput
  }

  export type CommentAttachmentUncheckedUpdateWithoutCreatedByUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentAttachmentUncheckedUpdateManyWithoutCreatedByUserInput = {
    sid?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateManySessionInput = {
    id?: string
    userId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserSessionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceFeatureCreateManyWorkspaceInput = {
    id?: number
    featureId: number
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type WorkspaceDocCreateManyWorkspaceInput = {
    docId: string
    public?: boolean
    defaultRole?: number
    mode?: number
    blocked?: boolean
    title?: string | null
    summary?: string | null
  }

  export type WorkspaceUserRoleCreateManyWorkspaceInput = {
    id?: string
    userId: string
    type: number
    status?: $Enums.WorkspaceMemberStatus
    source?: $Enums.WorkspaceMemberSource
    inviterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accepted?: boolean
  }

  export type WorkspaceDocUserRoleCreateManyWorkspaceInput = {
    docId: string
    userId: string
    type: number
    createdAt?: Date | string
  }

  export type BlobCreateManyWorkspaceInput = {
    key: string
    size: number
    mime: string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AiWorkspaceIgnoredDocsCreateManyWorkspaceInput = {
    docId: string
    createdAt?: Date | string
  }

  export type AiWorkspaceFilesCreateManyWorkspaceInput = {
    fileId: string
    blobId?: string
    fileName: string
    mimeType: string
    size: number
    createdAt?: Date | string
  }

  export type CommentCreateManyWorkspaceInput = {
    sid?: number
    id?: string
    docId: string
    userId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    resolved?: boolean
  }

  export type CommentAttachmentCreateManyWorkspaceInput = {
    sid?: number
    docId: string
    key: string
    size: number
    mime: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
  }

  export type WorkspaceFeatureUpdateWithoutWorkspaceInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feature?: FeatureUpdateOneRequiredWithoutWorkspaceFeaturesNestedInput
  }

  export type WorkspaceFeatureUncheckedUpdateWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceFeatureUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    featureId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceDocUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceDocUncheckedUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceDocUncheckedUpdateManyWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    public?: BoolFieldUpdateOperationsInput | boolean
    defaultRole?: IntFieldUpdateOperationsInput | number
    mode?: IntFieldUpdateOperationsInput | number
    blocked?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceUserRoleUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    inviter?: UserUpdateOneWithoutWorkspaceInvitationsNestedInput
  }

  export type WorkspaceUserRoleUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceUserRoleUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    status?: EnumWorkspaceMemberStatusFieldUpdateOperationsInput | $Enums.WorkspaceMemberStatus
    source?: EnumWorkspaceMemberSourceFieldUpdateOperationsInput | $Enums.WorkspaceMemberSource
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceDocUserRoleUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocPermissionsNestedInput
  }

  export type WorkspaceDocUserRoleUncheckedUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceDocUserRoleUncheckedUpdateManyWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlobUpdateWithoutWorkspaceInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUpdateManyWithoutBlobNestedInput
  }

  export type BlobUncheckedUpdateWithoutWorkspaceInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AiWorkspaceBlobEmbedding?: AiWorkspaceBlobEmbeddingUncheckedUpdateManyWithoutBlobNestedInput
  }

  export type BlobUncheckedUpdateManyWithoutWorkspaceInput = {
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiWorkspaceIgnoredDocsUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceIgnoredDocsUncheckedUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceIgnoredDocsUncheckedUpdateManyWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFilesUpdateWithoutWorkspaceInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiWorkspaceFileEmbeddingUpdateManyWithoutFileNestedInput
  }

  export type AiWorkspaceFilesUncheckedUpdateWithoutWorkspaceInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiWorkspaceFileEmbeddingUncheckedUpdateManyWithoutFileNestedInput
  }

  export type AiWorkspaceFilesUncheckedUpdateManyWithoutWorkspaceInput = {
    fileId?: StringFieldUpdateOperationsInput | string
    blobId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutWorkspaceInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
    replies?: ReplyUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutWorkspaceInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolved?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentAttachmentUpdateWithoutWorkspaceInput = {
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCommentAttachmentsNestedInput
  }

  export type CommentAttachmentUncheckedUpdateWithoutWorkspaceInput = {
    sid?: IntFieldUpdateOperationsInput | number
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentAttachmentUncheckedUpdateManyWithoutWorkspaceInput = {
    sid?: IntFieldUpdateOperationsInput | number
    docId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    mime?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserFeatureCreateManyFeatureInput = {
    id?: number
    userId: string
    name?: string
    type?: number
    reason: string
    createdAt?: Date | string
    expiredAt?: Date | string | null
    activated?: boolean
  }

  export type WorkspaceFeatureCreateManyFeatureInput = {
    id?: number
    workspaceId: string
    name?: string
    type?: number
    configs?: JsonNullValueInput | InputJsonValue
    reason: string
    createdAt?: Date | string
    activated?: boolean
    expiredAt?: Date | string | null
  }

  export type UserFeatureUpdateWithoutFeatureInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type UserFeatureUncheckedUpdateWithoutFeatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFeatureUncheckedUpdateManyWithoutFeatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkspaceFeatureUpdateWithoutFeatureInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type WorkspaceFeatureUncheckedUpdateWithoutFeatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceFeatureUncheckedUpdateManyWithoutFeatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    configs?: JsonNullValueInput | InputJsonValue
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activated?: BoolFieldUpdateOperationsInput | boolean
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiWorkspaceEmbeddingUpdateWithoutSnapshotInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceEmbeddingUncheckedUpdateWithoutSnapshotInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceEmbeddingUncheckedUpdateManyWithoutSnapshotInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptMessageCreateManyPromptInput = {
    idx: number
    role: $Enums.AiPromptRole
    content: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiSessionCreateManyPromptInput = {
    id?: string
    userId: string
    workspaceId: string
    docId?: string | null
    promptAction?: string | null
    pinned?: boolean
    title?: string | null
    parentSessionId?: string | null
    messageCost?: number
    tokenCost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AiPromptMessageUpdateWithoutPromptInput = {
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptMessageUncheckedUpdateWithoutPromptInput = {
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiPromptMessageUncheckedUpdateManyWithoutPromptInput = {
    idx?: IntFieldUpdateOperationsInput | number
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAiSessionsNestedInput
    messages?: AiSessionMessageUpdateManyWithoutSessionNestedInput
    context?: AiContextUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: AiSessionMessageUncheckedUpdateManyWithoutSessionNestedInput
    context?: AiContextUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AiSessionUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: NullableStringFieldUpdateOperationsInput | string | null
    promptAction?: NullableStringFieldUpdateOperationsInput | string | null
    pinned?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    parentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageCost?: IntFieldUpdateOperationsInput | number
    tokenCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AiSessionMessageCreateManySessionInput = {
    id?: string
    role: $Enums.AiPromptRole
    content: string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiContextCreateManySessionInput = {
    id?: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiSessionMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiSessionMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAiPromptRoleFieldUpdateOperationsInput | $Enums.AiPromptRole
    content?: StringFieldUpdateOperationsInput | string
    streamObjects?: NullableJsonNullValueInput | InputJsonValue
    attachments?: NullableJsonNullValueInput | InputJsonValue
    params?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiContextEmbeddingUpdateManyWithoutContextNestedInput
  }

  export type AiContextUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embeddings?: AiContextEmbeddingUncheckedUpdateManyWithoutContextNestedInput
  }

  export type AiContextUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUpdateWithoutContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUncheckedUpdateWithoutContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiContextEmbeddingUncheckedUpdateManyWithoutContextInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUpdateWithoutFileInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUncheckedUpdateWithoutFileInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceFileEmbeddingUncheckedUpdateManyWithoutFileInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUpdateWithoutBlobInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUncheckedUpdateWithoutBlobInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiWorkspaceBlobEmbeddingUncheckedUpdateManyWithoutBlobInput = {
    chunk?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCreateManyCommentInput = {
    sid?: number
    id?: string
    userId: string
    workspaceId: string
    docId: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReplyUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyUncheckedUpdateWithoutCommentInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReplyUncheckedUpdateManyWithoutCommentInput = {
    sid?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    docId?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}