"use strict";
/*
Copyright 2022 ByteDance and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatsParser = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const lodash_1 = require("lodash");
const bundle_extractor_1 = require("../bundle-extractor");
const install_scripts_1 = require("../install-scripts");
const module_1 = require("../module");
const stats_1 = require("../stats");
const utils_1 = require("../utils");
const asset_parser_1 = require("./asset-parser");
const audit_1 = require("./audit");
const tree_1 = require("./tree");
const types_1 = require("./types");
const defaultLogger = (0, utils_1.getConsoleLogger)();
class StatsParser {
    constructor(stats, assetsPath, logger) {
        this.stats = stats;
        this.assetsPath = assetsPath;
        this.logger = logger;
        this.assetsMap = new Map();
        this.packageVersionMap = new Map();
        this.chunksMap = new Map();
        this.auditsForLocal = [];
        this.modulesMap = new Map();
        this.entryPointsMap = new Map();
        this.packagePathRefMap = new Map();
        // Used to collect module sources before upload.
        this.reasonsMap = new Map();
        // Used to find reasons of a module
        this.moduleReasonsMap = new Map();
        // side effects of a module
        this.sideEffectsMap = new Map();
        // Used to find reasons of a package. The two dimension array is used to record reasons from different pacakages.
        this.packageReasonsMap = new Map();
        this.strictChunkRelationsMap = new Map();
        this.getIssuers = (m, meta) => {
            return (0, lodash_1.chain)(m.reasons)
                .filter((reason) => !!reason.moduleName)
                .map((reason) => {
                const meta = this.getPackageMeta(reason.moduleName);
                if (!meta) {
                    return;
                }
                const moduleId = (0, utils_1.hashCode)(reason.resolvedModule || '');
                return {
                    name: meta.name,
                    path: meta.path,
                    type: reason.type,
                    loc: reason.loc,
                    moduleId,
                };
            })
                .filter((value) => !!value)
                .groupBy('path')
                .mapValues((issuers, path) => {
                const reasons = (0, lodash_1.chain)(issuers)
                    .map((issuer) => ({
                    type: issuer.type,
                    loc: issuer.loc,
                    moduleId: issuer.moduleId,
                }))
                    .uniqWith((a, b) => a.loc === b.loc && a.moduleId === b.moduleId && a.type === b.type)
                    .slice(0, 10000)
                    .groupBy('moduleId')
                    .mapValues((issuers) => {
                    issuers = issuers.filter((i) => i.type !== 'cjs self exports reference');
                    if (issuers.some((i) => i.type !== 'harmony import specifier')) {
                        return issuers.filter((i) => i.type !== 'harmony import specifier');
                    }
                    return issuers.slice(0, 1);
                })
                    .values()
                    .flatten()
                    .map((r) => [stats_1.ModuleReasonTypes.indexOf(r.type), r.loc, r.moduleId])
                    .value();
                // Record reasons that module's source need to be collected
                reasons.forEach((reason) => {
                    let reasons = this.reasonsMap.get(reason[2]);
                    if (!reasons) {
                        reasons = [];
                        this.reasonsMap.set(reason[2], reasons);
                    }
                    reasons.push(reason);
                });
                // Record reasons of all modules
                const id = this.getModuleId(m);
                if (id) {
                    let reasonsToSet = this.moduleReasonsMap.get(id);
                    if (!reasonsToSet) {
                        reasonsToSet = [];
                        this.moduleReasonsMap.set(id, reasonsToSet);
                    }
                    reasonsToSet.push(...reasons);
                }
                // Important. Only count modules from different packages as issuers.
                // Avoid package import trace chart to draw infinite loop.
                if (path === meta.path) {
                    return null;
                }
                return {
                    name: issuers[0].name,
                    path: issuers[0].path,
                    reasons,
                };
            })
                .reduce((issuers, issuer) => issuers.concat(issuer || []), [])
                .value();
        };
    }
    static async FromStatsFile(statsFilePath, logger = defaultLogger) {
        let stats;
        try {
            stats = await (0, bundle_extractor_1.readStatsFile)(statsFilePath);
        }
        catch (e) {
            throw new Error(`Failed to read and parse webpack stats.\nInternal Error: ${e.stack}`);
        }
        return new StatsParser(stats, (0, path_1.parse)(statsFilePath).dir, logger);
    }
    static FromStats(stats, assetsPath, logger = defaultLogger) {
        return new StatsParser(stats, assetsPath, logger);
    }
    async parse() {
        this.logger.info('Start parsing stats file.');
        if (!this.stats.entrypoints || !this.stats.assets || typeof this.stats.publicPath === 'undefined') {
            throw new Error('No entrypoints or built assets found in webpack stats.');
        }
        this.packageVersionMap = new Map(this.stats.packageVersions?.map(({ name, version, sideEffects }) => [name, [version, sideEffects]]));
        await this.parseAssets();
        this.parseChunks();
        await this.parseEntryPoints();
        const bundleContent = this.parseBundleContent();
        this.logger.info('Finish parsing stats file.');
        return {
            report: this.serializeResult(),
            moduleTree: bundleContent,
            assets: Array.from(this.assetsMap.values()),
            moduleMap: this.serializeModuleMap(),
            moduleReasons: this.stats.moduleReasons?.moduleSource
                ? {
                    ...this.stats.moduleReasons,
                    packageReasons: Object.fromEntries(this.packageReasonsMap.entries()),
                    moduleReasons: Object.fromEntries(this.moduleReasonsMap.entries()),
                    sideEffects: Object.fromEntries(this.sideEffectsMap.entries()),
                }
                : undefined,
        };
    }
    initAuditFetcher(fetch, cacheDir) {
        this.auditFetcher = async (rule) => {
            const jobType = `extension.bundleAudit.${rule}`;
            let runnerScriptEntry = await (0, install_scripts_1.installActivatedRunnerScript)(this.logger, fetch, cacheDir)(jobType);
            this.logger.info(`runner script entry ${runnerScriptEntry}`, runnerScriptEntry);
            if (runnerScriptEntry) {
                runnerScriptEntry = require.resolve(runnerScriptEntry);
                return (0, fs_1.readFileSync)(runnerScriptEntry, 'utf-8');
            }
            return undefined;
        };
        return this;
    }
    appendAuditsForLocal(audits) {
        this.auditsForLocal.push(...audits);
        return this;
    }
    parseReasons() {
        this.parseChunks();
        return this.reasonsMap;
    }
    serializeModuleMap() {
        const moduleMap = {};
        for (const module of this.modulesMap.values()) {
            moduleMap[String(module.id)] = {
                path: module.realPath,
                packageRef: module.ref,
                concatenatingLength: module.concatenating.length,
            };
        }
        return moduleMap;
    }
    serializeResult() {
        const entryPoints = Array.from(this.entryPointsMap.values());
        return {
            score: (0, audit_1.calcBundleScore)(entryPoints),
            entryPoints,
            assets: Array.from(this.assetsMap.values()).map(({ modules, content, sourcemap, ...properties }) => {
                const packages = new Map();
                modules.forEach(({ ref, size, path, concatenating }) => {
                    if (!ref) {
                        return;
                    }
                    packages.set(ref, (0, utils_1.addSize)(size, packages.get(ref) ?? (0, utils_1.getDefaultSize)()));
                    if (concatenating.length) {
                        concatenating.forEach((child) => {
                            if (child.path !== path) {
                                packages.set(child.ref, (0, utils_1.addSize)(child.size, packages.get(child.ref) ?? (0, utils_1.getDefaultSize)()));
                            }
                        });
                    }
                });
                return {
                    ...properties,
                    packageRefs: Array.from(packages)
                        .map(([ref, size]) => ({
                        ref,
                        size,
                    }))
                        .sort((a, b) => b.size.raw - a.size.raw),
                    moduleRefs: modules.map((m) => m.id),
                };
            }),
            chunks: Array.from(this.chunksMap.values()).map(({ id, modules, assets, children, names, reason, ...chunk }) => ({
                ...chunk,
                assetRefs: (0, utils_1.mapRefs)(assets),
            })),
            packages: Array.from(this.packagePathRefMap.values()),
            repoPath: this.stats.repoPath,
            buildPath: this.stats.buildPath,
            buildTool: this.stats.buildTool,
        };
    }
    async parseEntryPoints() {
        this.logger.info('Start parsing entry points');
        const refMappedAssets = new Map(Array.from(this.assetsMap).map(([, asset]) => [asset.ref, asset]));
        const entryChunksMap = new Map();
        const chunkCountMap = new Map();
        const htmls = Array.from(this.assetsMap.values()).filter((asset) => asset.type === types_1.AssetTypeEnum.Html);
        for (const [name, entrypoint] of Object.entries(this.stats.entrypoints)) {
            const chunks = (0, lodash_1.uniqBy)(this.flatChunks(entrypoint.chunks), 'ref');
            chunks.forEach((chunk) => chunkCountMap.set(chunk.id, (chunkCountMap.get(chunk.id) || 0) + 1));
            entryChunksMap.set(name, chunks);
        }
        for (const chunk of this.chunksMap.values()) {
            const exclusive = chunkCountMap.get(chunk.id) === 1;
            chunk.exclusive = exclusive && Object.keys(this.stats.entrypoints).length > 1 ? true : undefined;
            const chunkAssetsSet = new Set(chunk.assets.map((a) => a.name));
            // edge case: html webpack plugin's output won't be tracked in chunks reference
            // if initial chunk's assets exists in html's script tags, treat it as entry html.
            if (!chunk.async) {
                htmls.forEach((html) => {
                    if (html.content) {
                        const scripts = (0, utils_1.getHtmlScripts)(html.content);
                        if (!chunkAssetsSet.has(html.name) &&
                            scripts.some((script) => chunkAssetsSet.has(script.replace(this.stats.publicPath, ''))) &&
                            (!this.stats.htmlExclusive || exclusive) // only treat it as entry html when chunk is exclusive in `htmlExclusive` mode
                        ) {
                            chunk.assets.push(html);
                        }
                    }
                });
            }
        }
        for (const [name, entrypoint] of Object.entries(this.stats.entrypoints)) {
            this.logger.verbose(`entry: '${name}'`);
            const chunks = entryChunksMap.get(name);
            const assets = (0, lodash_1.uniq)(chunks.map((chunk) => (0, utils_1.mapRefs)(chunk.assets)).flat()).map((ref) => refMappedAssets.get(ref));
            const packages = this.reduceModules(chunks);
            const initialChunks = (0, lodash_1.uniqBy)(this.flatChunks(entrypoint.chunks, new Set(), true), 'ref');
            const assetSizeReducer = (acc, asset) => (asset.intermediate ? acc : (0, utils_1.addSize)(acc, asset.size));
            const size = assets.reduce(assetSizeReducer, (0, utils_1.getDefaultSize)());
            const initialSize = (0, lodash_1.uniq)(initialChunks.flatMap((chunk) => chunk.assets).filter((asset) => (0, utils_1.isInitialFileType)(asset.type))).reduce(assetSizeReducer, (0, utils_1.getDefaultSize)());
            const audits = await (0, audit_1.audit)({
                chunks: chunks.map((chunk) => ({
                    ...chunk,
                    assets: chunk.assets.filter((asset) => !asset.intermediate),
                })),
                assets: assets.filter((asset) => !asset.intermediate),
                packages,
                size,
                stats: this.stats,
                assetsPath: this.assetsPath,
                entryName: name,
            }, this.logger, this.stats.rules, this.auditsForLocal, this.auditFetcher);
            this.entryPointsMap.set(name, {
                // get nextjs entry name
                // https://github.com/vercel/next.js/blob/3dec50001e/packages/next/build/entries.ts#L107
                name: name.replace(/(.*)\/pages\/(.+)$/, '$2'),
                size,
                initialSize,
                assetRefs: (0, utils_1.mapRefs)(assets),
                chunkRefs: (0, utils_1.mapRefs)(chunks),
                initialChunkRefs: (0, utils_1.mapRefs)(initialChunks),
                packageAppendixes: packages.map(({ ref, issuers, assets, size, notes }) => {
                    const reasons = issuers
                        .filter((issuer) => (0, utils_1.isNotNil)(this.packagePathRefMap.get(issuer.path)?.ref))
                        .map((issuer) => issuer.reasons);
                    this.packageReasonsMap.set(ref, reasons);
                    return {
                        ref,
                        size,
                        issuerRefs: issuers
                            .map((issuer) => this.packagePathRefMap.get(issuer.path)?.ref)
                            .filter(utils_1.isNotNil),
                        assetRefs: (0, utils_1.mapRefs)(assets),
                        notes,
                    };
                }),
                audits,
                score: (0, audit_1.calcEntryPointScore)(audits),
            });
        }
    }
    async parseAssets() {
        if (!this.stats.assets) {
            return;
        }
        this.logger.info('Start parsing assets.');
        try {
            let ref = 1;
            const assets = [];
            const { buildTool } = this.stats;
            for (const outputAsset of this.stats.assets) {
                // @ts-expect-error
                const { name, size: parsedSize, intermediate, path, chunks } = outputAsset;
                const realName = name.replace(/(\?.*)?(#.*)?$/, '');
                const type = (0, utils_1.detectFileType)(realName);
                if ((type === types_1.AssetTypeEnum.Js && !chunks.length) || /\.(map|license\.txt)$/i.test(realName)) {
                    continue;
                }
                const modules = [];
                const filepath = (0, path_1.join)(this.assetsPath, realName);
                const asset = {
                    ref,
                    size: { raw: parsedSize, gzip: parsedSize, brotli: parsedSize },
                    name,
                    path: realName,
                    type,
                    modules,
                    intermediate,
                    sourcemap: (0, fs_1.existsSync)(filepath + '.map'),
                    packageRefs: [],
                    moduleRefs: [],
                };
                if ((0, fs_1.existsSync)(filepath) && (0, utils_1.isStringContentType)(type)) {
                    const content = (0, fs_1.readFileSync)(filepath, 'utf-8');
                    asset.content = content;
                    asset.size = await (0, utils_1.calcStringCompressedSize)(content);
                    if (type === types_1.AssetTypeEnum.Js) {
                        try {
                            const parser = asset_parser_1.assetModulesParser[buildTool || stats_1.BundleToolkit.Webpack] || asset_parser_1.assetModulesParser[stats_1.BundleToolkit.Webpack];
                            const assetModules = parser(content, path || name, this.stats);
                            if (this.stats.strictChunkRelations) {
                                const requiredChunkIds = new Set();
                                for (const [_id, moduleContentOrLength] of assetModules) {
                                    if (typeof moduleContentOrLength === 'string') {
                                        (0, asset_parser_1.parseModuleRequiredChunks)(moduleContentOrLength).forEach((chunkId) => {
                                            requiredChunkIds.add(chunkId);
                                        });
                                    }
                                }
                                chunks.forEach((chunkId) => {
                                    if (!this.strictChunkRelationsMap.get(chunkId)) {
                                        this.strictChunkRelationsMap.set(chunkId, []);
                                    }
                                    this.strictChunkRelationsMap.get(chunkId).push(...requiredChunkIds.values());
                                });
                            }
                            for (const [id, moduleContentOrLength] of assetModules) {
                                const stringifiedId = String(id);
                                const moduleSize = typeof moduleContentOrLength === 'number'
                                    ? { raw: moduleContentOrLength, gzip: 0, brotli: 0 }
                                    : await (0, utils_1.calcStringCompressedSize)(moduleContentOrLength);
                                if (!this.modulesMap.has(stringifiedId)) {
                                    const m = { id, size: moduleSize, assets: [asset], concatenating: [] };
                                    this.modulesMap.set(stringifiedId, m);
                                }
                                else {
                                    // some module maybe duplicated in more then 1 chunks,
                                    // controlled by `minChunks`
                                    const existedModule = this.modulesMap.get(stringifiedId);
                                    existedModule.assets.push(asset);
                                }
                                modules.push(this.modulesMap.get(stringifiedId));
                            }
                        }
                        catch (e) {
                            this.logger.error(`Failed to parse modules of asset '${name}'`);
                            this.logger.error(e);
                        }
                    }
                }
                assets.push(asset);
                ref++;
                this.logger.verbose(`Asset parsed '${name}'`);
            }
            this.assetsMap = new Map(assets.map((asset) => [asset.name, asset]));
            this.logger.info('Assets parsing finished');
        }
        catch (e) {
            throw new Error(`Failed to parse assets.\nInternal Error: ${e.message}`);
        }
    }
    parseChunks() {
        this.logger.info('Start parsing chunks');
        let moduleRef = 1;
        const chunks = this.stats.chunks.map(({ id, initial, names, entry, reason, files, children, modules: chunkModules, auxiliaryFiles }, i) => {
            const chunkAssetsMap = new Map();
            files.concat((this.stats.includeAuxiliary && auxiliaryFiles) || []).forEach((file) => {
                const asset = this.assetsMap.get(file);
                if (asset) {
                    chunkAssetsMap.set(file, asset);
                }
            });
            const parseModules = (rawModules = [], concatenatedWith = '') => {
                return rawModules
                    .map((fnModule) => {
                    let m;
                    if ((0, utils_1.isNotNil)(fnModule.id)) {
                        m = this.modulesMap.get(String(fnModule.id));
                    }
                    else {
                        // concatenated module
                        m = {
                            id: fnModule.identifier,
                            size: (0, utils_1.getDefaultSize)(),
                            assets: [],
                            concatenating: [],
                        };
                        this.modulesMap.set(fnModule.identifier, m);
                    }
                    if (!m) {
                        m = {
                            id: fnModule.identifier,
                            size: (0, utils_1.getDefaultSize)(),
                            assets: [],
                            concatenating: [],
                        };
                        this.modulesMap.set(fnModule.identifier, m);
                    }
                    const meta = this.getPackageMeta(fnModule.name);
                    if (!meta) {
                        m.name = fnModule.name;
                        m.path = fnModule.name;
                        m.ignored = true;
                        return;
                    }
                    m.name = meta.name;
                    m.path = meta.path;
                    m.issuers = this.getIssuers(fnModule, meta);
                    m.ignored = false;
                    m.version = this.packageVersionMap.get(m.path)?.[0];
                    m.realPath = fnModule.name;
                    m.dynamic = (0, utils_1.isDynamicModule)(fnModule);
                    m.treeShaking = (0, utils_1.parseTreeshaking)(fnModule, meta, this.packageVersionMap.get(m.path)?.[1]);
                    m.esm = (0, utils_1.isEsmModule)(fnModule);
                    this.parseModuleSideEffects(fnModule);
                    if (this.packagePathRefMap.has(m.path)) {
                        m.ref = this.packagePathRefMap.get(m.path).ref;
                    }
                    else {
                        m.ref = moduleRef;
                        this.packagePathRefMap.set(m.path, { ...meta, ref: moduleRef, version: m.version });
                        moduleRef++;
                    }
                    // has concatenated modules
                    if (fnModule.modules?.length) {
                        m.concatenating = (0, lodash_1.uniqBy)(parseModules(fnModule.modules, meta.path), 'realPath');
                    }
                    if (concatenatedWith && concatenatedWith !== meta.path && this.packagePathRefMap.has(concatenatedWith)) {
                        m.notes = [{ type: 'concat', targetRef: this.packagePathRefMap.get(concatenatedWith).ref }];
                    }
                    if (fnModule.assets?.length) {
                        fnModule.assets.forEach((file) => {
                            const asset = this.assetsMap.get(file);
                            if (asset) {
                                chunkAssetsMap.set(file, asset);
                            }
                        });
                    }
                    return m;
                })
                    .filter(utils_1.isNotNil);
            };
            const modules = parseModules(chunkModules?.filter(utils_1.isNotNil)).filter(utils_1.isNotNil);
            this.logger.verbose(`Chunk parsed: '${id}'`);
            return {
                id,
                ref: i + 1,
                entry,
                async: !initial,
                names,
                reason,
                assets: Array.from(chunkAssetsMap.values()),
                children,
                modules,
            };
        });
        this.chunksMap = new Map(chunks.map((chunk) => [chunk.id, chunk]));
        this.logger.info(`Chunks parsing finished. Found total ${this.chunksMap.size} chunks`);
    }
    reduceModules(chunks) {
        const packagesMap = new Map();
        const ids = chunks.flatMap(({ modules }) => modules?.map((m) => m.id) || []);
        const existingPackages = new Set();
        for (const id of ids) {
            const m = this.modulesMap.get(String(id));
            if (m?.size.raw) {
                const existedPkg = packagesMap.get(m.path);
                if (existedPkg) {
                    existedPkg.size = (0, utils_1.addSize)(existedPkg.size, m.size);
                    for (const issuer of m.issuers) {
                        existedPkg.issuers.push(issuer);
                    }
                    for (const asset of m.assets) {
                        existedPkg.assets.push(asset);
                    }
                }
                else {
                    existingPackages.add(m.path);
                    packagesMap.set(m.path, {
                        ...(0, lodash_1.omit)(m, 'id', 'realPath'),
                        // clone issuers and assets for later push
                        issuers: m.issuers.concat(),
                        assets: m.assets.concat(),
                    });
                }
                m.concatenating.forEach((child) => {
                    if (child.path === m.path) {
                        return;
                    }
                    const existedPkg = packagesMap.get(child.path);
                    if (existedPkg) {
                        existedPkg.notes = [...(existedPkg.notes ?? []), ...(child.notes ?? [])];
                    }
                    else {
                        existingPackages.add(child.path);
                        packagesMap.set(child.path, {
                            ...(0, lodash_1.omit)(child, 'id', 'realPath'),
                            // clone issuers and assets for later push
                            issuers: child.issuers.concat(),
                            assets: child.assets.concat(),
                        });
                    }
                });
            }
        }
        const result = [];
        for (const pkg of packagesMap.values()) {
            if (!existingPackages.has(pkg.path)) {
                continue;
            }
            pkg.assets = (0, lodash_1.uniqBy)(pkg.assets, 'ref');
            pkg.issuers = (0, lodash_1.uniqBy)(pkg.issuers.filter((issuer) => existingPackages.has(issuer.path)), 'path');
            pkg.notes = (0, lodash_1.uniqBy)(pkg.notes, 'targetRef');
            result.push(pkg);
        }
        return result;
    }
    flatChunks(chunks, existed = new Set(), onlyInitial) {
        return chunks
            .filter((id) => !existed.has(id))
            .map((id) => {
            existed.add(id);
            const chunk = this.chunksMap.get(id);
            if (chunk) {
                if (onlyInitial && chunk.async) {
                    return [];
                }
                const children = (this.stats.strictChunkRelations
                    ? chunk.children?.filter((chunkId) => this.strictChunkRelationsMap.get(id)?.includes(chunkId))
                    : chunk.children) || [];
                return [chunk, ...this.flatChunks(children, existed, onlyInitial)].filter(utils_1.isNotNil);
            }
            return [];
        })
            .flat();
    }
    getPackageMeta(name) {
        return (0, module_1.getPackageMeta)(name, this.stats.repoPath ?? '/', this.stats.buildPath ?? '/');
    }
    getModuleId(module) {
        if (this.stats.buildPath) {
            let relativePath = (0, path_1.relative)(this.stats.buildPath, module.nameForCondition || (0, module_1.trimModuleName)(module.name));
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }
            return (0, utils_1.hashCode)(relativePath);
        }
        return 0;
    }
    parseModuleSideEffects(module) {
        const moduleId = this.getModuleId(module);
        const sideEffects = module.optimizationBailout
            ?.filter((o) => o.includes('with side effects in source code at'))
            .map((o) => [-1, o.split('with side effects in source code at')[1], moduleId]);
        if (!sideEffects) {
            return;
        }
        this.sideEffectsMap.set(moduleId, [...sideEffects]);
        if (this.reasonsMap.has(moduleId)) {
            this.reasonsMap.get(moduleId).push(...sideEffects);
        }
        else {
            this.reasonsMap.set(moduleId, [...sideEffects]);
        }
    }
    parseBundleContent() {
        this.logger.info('Start parsing bundle content.');
        try {
            const assetRefEntryPointsMap = new Map();
            for (const entryPoint of this.entryPointsMap.values()) {
                for (const assetRef of entryPoint.assetRefs) {
                    const e = assetRefEntryPointsMap.get(assetRef);
                    if (e) {
                        e.push(entryPoint.name);
                    }
                    else {
                        assetRefEntryPointsMap.set(assetRef, [entryPoint.name]);
                    }
                }
            }
            const res = [];
            for (const [key, asset] of this.assetsMap) {
                if (asset.type !== types_1.AssetTypeEnum.Js || asset.intermediate) {
                    continue;
                }
                const root = new tree_1.Folder('.');
                const { modules } = asset;
                modules.forEach((module) => {
                    if (!module.realPath) {
                        return;
                    }
                    root.addModule(module);
                });
                root.mergeNestedFolders();
                const entryPoints = assetRefEntryPointsMap.get(asset.ref);
                res.push({
                    name: key,
                    value: asset.size.raw,
                    gzip: asset.size.gzip,
                    brotli: asset.size.brotli,
                    children: Object.values(root.children).map((child) => child.toChartData()),
                    entryPoints,
                });
            }
            this.logger.info('Bundle content parsing finished.');
            return res;
        }
        catch (e) {
            this.logger.error('Bundle content parsing failed.', e);
            return [];
        }
    }
}
exports.StatsParser = StatsParser;
//# sourceMappingURL=index.js.map