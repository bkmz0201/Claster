"use strict";
/*
Copyright 2022 ByteDance and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEsmModule = exports.isDynamicModule = exports.parseTreeshaking = exports.hashCode = exports.getConsoleLogger = exports.getHtmlScripts = exports.mapRefs = exports.isNotNil = exports.getDefaultSize = exports.addSize = exports.isStringContentType = exports.isInitialFileType = exports.calcBrorliedSize = exports.calcGzippedSize = exports.calcStringCompressedSize = exports.detectFileType = exports.readJSONFile = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const stream_1 = require("stream");
const zlib_1 = require("zlib");
const htmlparser2_1 = require("htmlparser2");
const lodash_1 = require("lodash");
const minimatch_1 = require("minimatch");
const module_1 = require("./module");
const stats_1 = require("./stats");
const types_1 = require("./types");
function readJSONFile(path) {
    return JSON.parse((0, fs_1.readFileSync)(path, 'utf-8'));
}
exports.readJSONFile = readJSONFile;
function detectFileType(name) {
    const regexps = {
        [types_1.AssetTypeEnum.Js]: /\.m?js$/i,
        [types_1.AssetTypeEnum.Css]: /\.css$/i,
        [types_1.AssetTypeEnum.Html]: /\.html?$/i,
        [types_1.AssetTypeEnum.Image]: /\.(jpe?g|png|svg|gif|webp|heif|bmp|avif|cur|tiff?|apng|jxl)$/i,
        [types_1.AssetTypeEnum.Font]: /\.(otf|ttf|eot|woff2?)$/i,
        [types_1.AssetTypeEnum.Media]: /\.(mp4|webm|mkv|flv|avi|wmv|ogv|mp3|wav|ogg|m4a|aac)$/i,
    };
    for (const [type, regexp] of Object.entries(regexps)) {
        if (regexp?.test(name)) {
            return type;
        }
    }
    return types_1.AssetTypeEnum.Other;
}
exports.detectFileType = detectFileType;
async function calcStringCompressedSize(str) {
    const size = {
        raw: str.length,
        gzip: 0,
        brotli: 0,
    };
    const stream = stream_1.Readable.from([str]);
    const [gzip, brotli] = await Promise.all([calcGzippedSize(stream), calcBrorliedSize(stream)]);
    size.gzip = gzip;
    size.brotli = brotli;
    return size;
}
exports.calcStringCompressedSize = calcStringCompressedSize;
async function calcGzippedSize(input) {
    return new Promise((resolve) => {
        const chunks = [];
        const gzip = (0, zlib_1.createGzip)({
            level: 4,
        });
        input.pipe(gzip);
        gzip.on('data', (chunk) => {
            chunks.push(chunk);
        });
        gzip.on('end', () => {
            resolve(Buffer.concat(chunks).toString().length);
        });
        gzip.on('error', (e) => {
            console.error('Failed to calculate file gzip compressed size', e);
            resolve(0);
        });
    });
}
exports.calcGzippedSize = calcGzippedSize;
async function calcBrorliedSize(input) {
    return new Promise((resolve) => {
        const chunks = [];
        const brotli = (0, zlib_1.createBrotliCompress)({
            params: {
                [zlib_1.constants.BROTLI_PARAM_QUALITY]: 6,
            },
        });
        input.pipe(brotli);
        brotli.on('data', (chunk) => {
            chunks.push(chunk);
        });
        brotli.on('end', () => {
            resolve(Buffer.concat(chunks).toString().length);
        });
        brotli.on('error', (e) => {
            console.error('Failed to calculate file brotli compressed size', e);
            resolve(0);
        });
    });
}
exports.calcBrorliedSize = calcBrorliedSize;
function isInitialFileType(type) {
    return type === types_1.AssetTypeEnum.Js || type === types_1.AssetTypeEnum.Css || type === types_1.AssetTypeEnum.Font;
}
exports.isInitialFileType = isInitialFileType;
const stringContentTypes = [types_1.AssetTypeEnum.Js, types_1.AssetTypeEnum.Css, types_1.AssetTypeEnum.Html, types_1.AssetTypeEnum.Other];
function isStringContentType(type) {
    return stringContentTypes.includes(type);
}
exports.isStringContentType = isStringContentType;
function addSize(size1, size2) {
    return {
        raw: size1.raw + size2.raw,
        gzip: size1.gzip + size2.gzip,
        brotli: size1.brotli + size2.brotli,
    };
}
exports.addSize = addSize;
function getDefaultSize() {
    return {
        raw: 0,
        gzip: 0,
        brotli: 0,
    };
}
exports.getDefaultSize = getDefaultSize;
function isNotNil(value) {
    return value !== undefined && value !== null;
}
exports.isNotNil = isNotNil;
function mapRefs(items) {
    return items.map(({ ref }) => ref);
}
exports.mapRefs = mapRefs;
function getHtmlScripts(content) {
    const scripts = [];
    const parser = new htmlparser2_1.Parser({
        onopentag(tag, attrs) {
            if (tag === 'script' && attrs['src']) {
                scripts.push(attrs['src']);
            }
        },
    });
    parser.end(content);
    return scripts;
}
exports.getHtmlScripts = getHtmlScripts;
function getConsoleLogger() {
    // @ts-expect-error
    // eslint-disable-next-line no-console
    console.verbose = console.log;
    // @ts-expect-error
    return console;
}
exports.getConsoleLogger = getConsoleLogger;
/**
 * Returns a hash code from a string
 * @param  {String} str The string to hash.
 * @return {Number}    A 32bit integer
 */
function hashCode(str) {
    let hash = 0;
    for (let i = 0, len = str.length; i < len; i++) {
        const chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}
exports.hashCode = hashCode;
function parseTreeshaking(module, meta, packageSideEffects) {
    const { usedExports, providedExports } = module;
    let markedSideEffects = false;
    if (packageSideEffects === true || packageSideEffects === 'implicitly') {
        markedSideEffects = meta?.path !== stats_1.SOURCE_CODE_PATH;
    }
    else if (Array.isArray(packageSideEffects) && meta && meta.path !== stats_1.SOURCE_CODE_PATH) {
        markedSideEffects = packageSideEffects.some((pattern) => {
            const relativePath = (0, path_1.relative)(meta.path, module.nameForCondition || (0, module_1.trimModuleName)(module.name));
            return (0, minimatch_1.minimatch)(relativePath.startsWith('.') ? relativePath : `./${relativePath}`, pattern);
        });
    }
    if (((Array.isArray(usedExports) || usedExports === false) &&
        Array.isArray(providedExports) &&
        providedExports.length > usedExports?.length) ||
        0) {
        return {
            unused: (0, lodash_1.difference)(providedExports, usedExports || []),
            sideEffects: module.optimizationBailout?.filter((o) => o.includes('with side effects in source code at ')),
            markedSideEffects,
        };
    }
    return {
        markedSideEffects,
    };
}
exports.parseTreeshaking = parseTreeshaking;
function isDynamicModule(module) {
    return module.reasons?.every((reason) => stats_1.dynamicModuleReasonTypes.includes(reason.type)) || false;
}
exports.isDynamicModule = isDynamicModule;
function isEsmModule(module) {
    return !(module.providedExports === null && module.usedExports === null);
}
exports.isEsmModule = isEsmModule;
//# sourceMappingURL=utils.js.map