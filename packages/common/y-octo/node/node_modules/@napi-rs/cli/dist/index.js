import { createRequire } from "node:module";
import path, { join, parse, resolve } from "node:path";
import * as colors$2 from "colorette";
import * as colors$1 from "colorette";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import { Command, Option } from "clipanion";
import rawDebug from "debug";
import fs, { copyFile, existsSync, mkdir, mkdirSync, promises, readFile, readdir, rmSync, stat, statSync, unlink, writeFile } from "node:fs";
import { promisify } from "node:util";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import { isNil, merge, omit, omitBy, pick, sortBy } from "lodash-es";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { include, lib } from "wasm-sjlj";
import { parse as parse$1 } from "semver";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { rename } from "node:fs/promises";
import { findUp } from "find-up";
import { Octokit } from "@octokit/rest";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/typeof.js
var require_typeof = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/typeof.js"(exports, module) {
	function _typeof$2(o) {
		"@babel/helpers - typeof";
		return module.exports = _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
			return typeof o$1;
		} : function(o$1) {
			return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
		}, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof$2(o);
	}
	module.exports = _typeof$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js"(exports, module) {
	var _typeof$1 = require_typeof()["default"];
	function toPrimitive$1(t, r) {
		if ("object" != _typeof$1(t) || !t) return t;
		var e = t[Symbol.toPrimitive];
		if (void 0 !== e) {
			var i = e.call(t, r || "default");
			if ("object" != _typeof$1(i)) return i;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return ("string" === r ? String : Number)(t);
	}
	module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js"(exports, module) {
	var _typeof = require_typeof()["default"];
	var toPrimitive = require_toPrimitive();
	function toPropertyKey$1(t) {
		var i = toPrimitive(t, "string");
		return "symbol" == _typeof(i) ? i : i + "";
	}
	module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/defineProperty.js
var require_defineProperty = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/defineProperty.js"(exports, module) {
	var toPropertyKey = require_toPropertyKey();
	function _defineProperty$10(e, r, t) {
		return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
			value: t,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[r] = t, e;
	}
	module.exports = _defineProperty$10, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region src/def/artifacts.ts
var import_defineProperty$9 = __toESM(require_defineProperty(), 1);
var BaseArtifactsCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$9.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$9.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$9.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$9.default)(this, "outputDir", Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" }));
		(0, import_defineProperty$9.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$9.default)(this, "buildOutputDir", Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
(0, import_defineProperty$9.default)(BaseArtifactsCommand, "paths", [["artifacts"]]);
(0, import_defineProperty$9.default)(BaseArtifactsCommand, "usage", Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" }));
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
rawDebug.formatters.i = (v) => {
	return colors$2.green(v);
};
const debugFactory = (namespace) => {
	const debug$8 = rawDebug(`napi:${namespace}`);
	debug$8.info = (...args) => console.error(colors$2.black(colors$2.bgGreen(" INFO ")), ...args);
	debug$8.warn = (...args) => console.error(colors$2.black(colors$2.bgYellow(" WARNING ")), ...args);
	debug$8.error = (...args) => console.error(colors$2.white(colors$2.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$8;
};
const debug$7 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.0.0";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module$1 = "./dist/index.js";
var exports = {
	".": {
		"import": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.js"
		},
		"require": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.cjs"
		}
	},
	"./package.json": {
		"import": "./package.json",
		"require": "./package.json"
	}
};
var files = ["dist", "src"];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.4.0",
	"@napi-rs/cross-toolchain": "^0.0.19",
	"@napi-rs/wasm-tools": "^0.0.3",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.0",
	"emnapi": "^1.4.0",
	"find-up": "^7.0.0",
	"js-yaml": "^4.1.0",
	"lodash-es": "^4.17.21",
	"semver": "^7.7.1",
	"typanion": "^3.14.0",
	"wasm-sjlj": "^1.0.6"
};
var devDependencies = {
	"@emnapi/core": "^1.4.0",
	"@emnapi/runtime": "^1.4.0",
	"@oxc-node/core": "^0.0.29",
	"@std/toml": "npm:@jsr/std__toml@^1.0.8",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.7",
	"@types/js-yaml": "^4.0.9",
	"@types/lodash-es": "^4.17.12",
	"@types/node": "^22.13.16",
	"@types/semver": "^7.7.0",
	"ava": "^6.2.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.5.3",
	"rolldown": "^1.0.0-beta.23",
	"tslib": "^2.8.1",
	"typescript": "^5.8.2"
};
var peerDependencies = {
	"@emnapi/runtime": "^1.1.0",
	"emnapi": "^1.1.0"
};
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"clean": "node --import @oxc-node/core/register ./clean.ts",
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsc && yarn clean && rolldown -c rolldown.config.js",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "1m",
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var gitHead = "cdbf2bc43945175eabe56b19a6bb0f8584dbc34c";
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module: module$1,
	exports,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava,
	gitHead
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = promisify(readFile);
const writeFileAsync = promisify(writeFile);
const unlinkAsync = promisify(unlink);
const copyFileAsync = promisify(copyFile);
const mkdirAsync = promisify(mkdir);
const statAsync = promisify(stat);
const readdirAsync = promisify(readdir);
async function fileExists(path$1) {
	const exists = await statAsync(path$1).then(() => true).catch(() => false);
	return exists;
}
async function dirExistsAsync(path$1) {
	try {
		const stats = await statAsync(path$1);
		return stats.isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	const exists = await fileExists(path$1);
	if (!exists) {
		debug$7(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triple = rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple;
	const triples = triple.split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	if (rawTriple.includes("ohos")) return {
		triple: rawTriple,
		platformArchABI: `linux-${arch}-ohos`,
		platform: "openharmony",
		arch,
		abi: null
	};
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host?.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	let error = null;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (error) throw new Error("cargo metadata failed to run", { cause: error });
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, "targets"));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig?.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if (userNapiConfig.triples?.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if (userNapiConfig.triples?.additional?.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	const uniqueTargets = new Set(targets);
	if (uniqueTargets.size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$7("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$7("Installing cargo binary: %s", name$1);
		execSync(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$7("Detecting cargo binary: %s", bin$1);
	try {
		execSync(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$7("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$7("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			s += `${exportDeclare(ambient)} class ${line.name} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$1 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	const dts = sortBy(Array.from(groupedDefs), ([namespace]) => namespace).map(([namespace, defs$1]) => {
		if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
			switch (def.kind) {
				case TypeDefKind.Const:
				case TypeDefKind.Enum:
				case TypeDefKind.StringEnum:
				case TypeDefKind.Fn:
				case TypeDefKind.Struct: {
					exports$1.push(def.name);
					if (def.original_name && def.original_name !== def.name) exports$1.push(def.original_name);
					break;
				}
				default: break;
			}
			return prettyPrint(def, constEnum, 0);
		}).join("\n\n");
		else {
			exports$1.push(namespace);
			let declaration = "";
			declaration += `export declare namespace ${namespace} {\n`;
			for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
			declaration += "}";
			return declaration;
		}
	}).join("\n\n") + "\n";
	return {
		dts,
		exports: exports$1
	};
}
async function readIntermediateTypeFile(file) {
	const content = await readFileAsync(file, "utf8");
	const defs = content.split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	});
	return defs.sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = new Map();
	const classDefs = new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	const result = src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		const s = `${" ".repeat(rightIndent)}${line}`;
		return s;
	}).join("\n");
	return result;
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return config;
}

//#endregion
//#region src/api/artifacts.ts
const debug$6 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => UniArchsByPlatform[p.platform]?.map((a) => `${p.platform}-${a}`)).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$6.info(`Read [${colors$1.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$6.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir = distDirs.find((dir$1) => dir$1.includes(platformArchABI));
		if (!dir && universalSourceBins.has(platformArchABI)) {
			debug$6.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir, parsedName.base);
		debug$6.info(`Write file content to [${colors$1.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$6.info(`Write file content to [${colors$1.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$6.info(`Move wasi binding file [${colors$1.yellowBright(cjsFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$6.info(`Move wasi worker file [${colors$1.yellowBright(workerFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$6.info(`Move wasi browser entry file [${colors$1.yellowBright(browserEntry)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$6.info(`Move wasi browser worker file [${colors$1.yellowBright(browserWorkerFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files$1 = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir of dirs) if (dir.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir.name)));
	return nodeBinaries;
}

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents) {
	return `${bindingHeader}
const { createRequire } = require('node:module')
require = createRequire(__filename)

${createCommonBinding(localName, pkgName)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      ${requireTuple("win32-x64-msvc")}
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("linux-arm64-ohos")}
    } else if (process.arch === 'x64') {
      ${requireTuple("linux-x64-ohos")}
    } else if (process.arch === 'arm') {
      ${requireTuple("linux-arm-ohos")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./${localName}.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('${pkgName}-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	const fsImport = fs$1 ? `import { memfs } from '@napi-rs/wasm-runtime/fs'` : "";
	const bufferImport = buffer ? fs$1 ? `` : `import { Buffer } from 'buffer'` : "";
	const wasiCreation = fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`;
	const workerFsHandler = fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : "";
	const emnapiInjectBuffer = buffer ? "__emnapiContext.feature.Buffer = Buffer" : "";
	const emnapiInstantiateImport = asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`;
	const emnapiInstantiateCall = asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`;
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${emnapiInstantiateImport},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fsImport}
${bufferImport}
${wasiCreation}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${emnapiInjectBuffer}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${emnapiInstantiateCall}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${workerFsHandler}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	const fsImport = fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`;
	const wasiCreation = fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`;
	return `${fsImport}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${wasiCreation}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
var import_defineProperty$8 = __toESM(require_defineProperty(), 1);
const debug$5 = debugFactory("build");
const require$1 = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$5("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	const builder = new Builder(metadata, crate, config, options);
	return builder.build();
}
var Builder = class {
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		(0, import_defineProperty$8.default)(this, "args", []);
		(0, import_defineProperty$8.default)(this, "envs", {});
		(0, import_defineProperty$8.default)(this, "outputs", []);
		(0, import_defineProperty$8.default)(this, "target", void 0);
		(0, import_defineProperty$8.default)(this, "crateDir", void 0);
		(0, import_defineProperty$8.default)(this, "outputDir", void 0);
		(0, import_defineProperty$8.default)(this, "targetDir", void 0);
		(0, import_defineProperty$8.default)(this, "enableTypeDef", false);
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$5.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$5.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		return this.crate.targets.find((t) => t.crate_types.includes("cdylib"))?.name;
	}
	get binName() {
		return this.options.bin ?? (this.cdyLibName ? null : this.crate.targets.find((t) => t.crate_types.includes("bin"))?.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$5.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$5.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$5.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			const { version: version$2, download } = require$1("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$5(`Toolchain ${toolchainPath} exists, skip extracting`);
			else {
				const tarArchive = download(process.arch, this.target.triple);
				tarArchive.unpack(toolchainPath);
			}
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.envs[linkerEnv] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_SYSROOT) this.envs[`TARGET_SYSROOT`] = join(toolchainPath, crossTargetName, "sysroot");
			if (!process.env.TARGET_AR) this.envs[`TARGET_AR`] = join(toolchainPath, "bin", `${crossTargetName}-ar`);
			if (!process.env.TARGET_RANLIB) this.envs[`TARGET_RANLIB`] = join(toolchainPath, "bin", `${crossTargetName}-ranlib`);
			if (!process.env.TARGET_READELF) this.envs[`TARGET_READELF`] = join(toolchainPath, "bin", `${crossTargetName}-readelf`);
			if (!process.env.TARGET_C_INCLUDE_PATH) this.envs[`TARGET_C_INCLUDE_PATH`] = join(toolchainPath, crossTargetName, "sysroot", "usr", "include/");
			if (!process.env.TARGET_CC) this.envs[`TARGET_CC`] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_CXX) this.envs[`TARGET_CXX`] = join(toolchainPath, "bin", `${crossTargetName}-g++`);
			if (process.env.TARGET_CC?.startsWith("clang") || process.env.CC?.startsWith("clang") && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (process.env.CXX?.startsWith("clang++") && !process.env.TARGET_CXX || process.env.TARGET_CXX?.startsWith("clang++")) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$5.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$5(`Start building crate: ${this.crate.name}`);
		debug$5("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		const buildTask = new Promise((resolve$1, reject) => {
			if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
			const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
			const buildProcess = spawn(command, this.args, {
				env: {
					...process.env,
					...this.envs
				},
				stdio: watch ? [
					"inherit",
					"inherit",
					"pipe"
				] : "inherit",
				cwd: this.options.cwd,
				signal: controller.signal
			});
			buildProcess.once("exit", (code) => {
				if (code === 0) {
					debug$5("%i", `Build crate ${this.crate.name} successfully!`);
					resolve$1();
				} else reject(new Error(`Build failed with exit code ${code}`));
			});
			buildProcess.once("error", (e) => {
				reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
			});
			buildProcess.stderr?.on("data", (data) => {
				const output = data.toString();
				console.error(output);
				if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
			});
		});
		return {
			task: buildTask.then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$5.warn("Watch mode is not supported in CI environment");
		else {
			debug$5("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$5.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$5("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && function(abi) {
			const glibcVersionRuntime = process.report?.getReport()?.header?.glibcVersionRuntime;
			const libc = glibcVersionRuntime ? "gnu" : "musl";
			return abi === libc;
		}(this.target.abi)) debug$5.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$5.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$5("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$5("Set package flags: ");
			debug$5("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$5("Set compiling target to: ");
		debug$5("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (this.target.abi?.includes("musl") && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$5("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$5("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$5.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require$1.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		this.envs.SETJMP_LINK_DIR = lib;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj -I${include}`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj -I${include}`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_NATIVE}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$5.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$5("Set features flags: ");
		debug$5("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if (this.options.cargoOptions?.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$5(`Try to create output directory:`);
			debug$5("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$5(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$5(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$5("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$5("Copy artifact to:");
			debug$5("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$5("Generate debug wasm module");
				try {
					const debugWasmModule = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src));
					const debugWasmBinary = debugWasmModule.emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$5("Generate release wasm module");
					const releaseWasmModule = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary);
					const releaseWasmBinary = releaseWasmModule.emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$5.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef || !await dirExistsAsync(typeDefDir)) return [];
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		let header = "";
		let dts = "";
		let exports$1 = [];
		if (!this.options.noDtsHeader) {
			const dtsHeader = this.options.dtsHeader ?? this.config.dtsHeader;
			if (this.config.dtsHeaderFile) try {
				header = await readFileAsync(join(this.options.cwd, this.config.dtsHeaderFile), "utf-8");
			} catch (e) {
				debug$5.warn(`Failed to read dts header file ${this.config.dtsHeaderFile}`, e);
			}
			else if (dtsHeader) header = dtsHeader;
			else header = DEFAULT_TYPE_DEF_HEADER;
		}
		const files$1 = await readdirAsync(typeDefDir, { withFileTypes: true });
		if (!files$1.length) {
			debug$5("No type def files found. Skip generating dts file.");
			return [];
		}
		for (const file of files$1) {
			if (!file.isFile()) continue;
			const { dts: fileDts, exports: fileExports } = await processTypeDef(join(typeDefDir, file.name), this.options.constEnum ?? this.config.constEnum ?? true);
			dts += fileDts;
			exports$1.push(...fileExports);
		}
		if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
		if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
		dts = header + dts;
		try {
			debug$5("Writing type def to:");
			debug$5("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
			this.outputs.push({
				kind: "dts",
				path: dest
			});
		} catch (e) {
			debug$5.error("Failed to write type def file");
			debug$5.error(e);
		}
		return exports$1;
	}
	async writeJsBinding(idents) {
		if (!this.options.platform || this.options.noJsBinding || idents.length === 0) return;
		const name$1 = this.options.jsBinding ?? "index.js";
		const createBinding = this.options.esm ? createEsmBinding : createCjsBinding;
		const binding = createBinding(this.config.binaryName, this.config.packageName, idents);
		try {
			const dest = join(this.outputDir, name$1);
			debug$5("Writing js binding to:");
			debug$5("  %i", dest);
			await writeFileAsync(dest, binding, "utf-8");
			return {
				kind: "js",
				path: dest
			};
		} catch (e) {
			throw new Error("Failed to write js binding file", { cause: e });
		}
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			const { name: name$1, dir } = parse(distFileName);
			const bindingPath = join(dir, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir, "wasi-worker.mjs");
			const browserWorkerPath = join(dir, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory, this.config.wasm?.browser?.fs, this.config.wasm?.browser?.asyncInit, this.config.wasm?.browser?.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(this.config.wasm?.browser?.fs ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};

//#endregion
//#region src/def/create-npm-dirs.ts
var import_defineProperty$7 = __toESM(require_defineProperty(), 1);
var BaseCreateNpmDirsCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$7.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$7.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$7.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$7.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$7.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$7.default)(BaseCreateNpmDirsCommand, "paths", [["create-npm-dirs"]]);
(0, import_defineProperty$7.default)(BaseCreateNpmDirsCommand, "usage", Command.Usage({ description: "Create npm package dirs for different platforms" }));
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$4 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir) {
		debug$4("Try to create dir: %i", dir);
		if (options.dryRun) return;
		await mkdirAsync(dir, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$4("Writing file %i", file);
		if (options.dryRun) {
			debug$4(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$4(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			scopedPackageJson.files?.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if (scopedPackageJson.engines?.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = join(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = join(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$4.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/def/new.ts
var import_defineProperty$6 = __toESM(require_defineProperty(), 1);
var BaseNewCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$6.default)(this, "$$path", Option.String({ required: false }));
		(0, import_defineProperty$6.default)(this, "$$name", Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" }));
		(0, import_defineProperty$6.default)(this, "minNodeApiVersion", Option.String("--min-node-api,-v", "4", {
			validator: typanion.isNumber(),
			description: "The minimum Node-API version to support"
		}));
		(0, import_defineProperty$6.default)(this, "packageManager", Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." }));
		(0, import_defineProperty$6.default)(this, "license", Option.String("--license,-l", "MIT", { description: "License for open-sourced project" }));
		(0, import_defineProperty$6.default)(this, "targets", Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." }));
		(0, import_defineProperty$6.default)(this, "enableDefaultTargets", Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" }));
		(0, import_defineProperty$6.default)(this, "enableAllTargets", Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" }));
		(0, import_defineProperty$6.default)(this, "enableTypeDef", Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" }));
		(0, import_defineProperty$6.default)(this, "enableGithubActions", Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" }));
		(0, import_defineProperty$6.default)(this, "testFramework", Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" }));
		(0, import_defineProperty$6.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" }));
	}
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$6.default)(BaseNewCommand, "paths", [["new"]]);
(0, import_defineProperty$6.default)(BaseNewCommand, "usage", Command.Usage({ description: "Create a new project with pre-configured boilerplate" }));
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/checkPrivateRedeclaration.js
var require_checkPrivateRedeclaration = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/checkPrivateRedeclaration.js"(exports, module) {
	function _checkPrivateRedeclaration(e, t) {
		if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	module.exports = _checkPrivateRedeclaration, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateMethodInitSpec.js
var require_classPrivateMethodInitSpec = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateMethodInitSpec.js"(exports, module) {
	var checkPrivateRedeclaration$1 = require_checkPrivateRedeclaration();
	function _classPrivateMethodInitSpec$1(e, a) {
		checkPrivateRedeclaration$1(e, a), a.add(e);
	}
	module.exports = _classPrivateMethodInitSpec$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldInitSpec.js
var require_classPrivateFieldInitSpec = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldInitSpec.js"(exports, module) {
	var checkPrivateRedeclaration = require_checkPrivateRedeclaration();
	function _classPrivateFieldInitSpec$2(e, t, a) {
		checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	module.exports = _classPrivateFieldInitSpec$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/assertClassBrand.js
var require_assertClassBrand = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/assertClassBrand.js"(exports, module) {
	function _assertClassBrand$1(e, t, n) {
		if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
		throw new TypeError("Private element is not present on this object");
	}
	module.exports = _assertClassBrand$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldGet2.js
var require_classPrivateFieldGet2 = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldGet2.js"(exports, module) {
	var assertClassBrand$1 = require_assertClassBrand();
	function _classPrivateFieldGet2(s, a) {
		return s.get(assertClassBrand$1(s, a));
	}
	module.exports = _classPrivateFieldGet2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@std/toml/stringify.js
var import_classPrivateMethodInitSpec = __toESM(require_classPrivateMethodInitSpec(), 1);
var import_defineProperty$5 = __toESM(require_defineProperty(), 1);
var import_classPrivateFieldInitSpec$1 = __toESM(require_classPrivateFieldInitSpec(), 1);
var import_assertClassBrand = __toESM(require_assertClassBrand(), 1);
var import_classPrivateFieldGet2$1 = __toESM(require_classPrivateFieldGet2(), 1);
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var _arrayTypeCache = /* @__PURE__ */ new WeakMap();
var _Dumper_brand = /* @__PURE__ */ new WeakSet();
var Dumper = class {
	constructor(srcObjc) {
		(0, import_classPrivateMethodInitSpec.default)(this, _Dumper_brand);
		(0, import_defineProperty$5.default)(this, "maxPad", 0);
		(0, import_defineProperty$5.default)(this, "srcObject", void 0);
		(0, import_defineProperty$5.default)(this, "output", []);
		(0, import_classPrivateFieldInitSpec$1.default)(this, _arrayTypeCache, new Map());
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = (0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, this.srcObject);
		this.output = (0, import_assertClassBrand.default)(_Dumper_brand, this, _format).call(this, fmtOptions);
		return this.output;
	}
};
function _printObject(obj, keys = []) {
	const out = [];
	const props = Object.keys(obj);
	const inlineProps = [];
	const multilineProps = [];
	for (const prop of props) if ((0, import_assertClassBrand.default)(_Dumper_brand, this, _isSimplySerializable).call(this, obj[prop])) inlineProps.push(prop);
	else multilineProps.push(prop);
	const sortedProps = inlineProps.concat(multilineProps);
	for (const prop of sortedProps) {
		const value$1 = obj[prop];
		if (value$1 instanceof Date) out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _dateDeclaration).call(this, [prop], value$1));
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _strDeclaration).call(this, [prop], value$1.toString()));
		else if (typeof value$1 === "number") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _numberDeclaration).call(this, [prop], value$1));
		else if (typeof value$1 === "boolean") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _boolDeclaration).call(this, [prop], value$1));
		else if (value$1 instanceof Array) {
			const arrayType = (0, import_assertClassBrand.default)(_Dumper_brand, this, _getTypeOfArray).call(this, value$1);
			if (arrayType === "ONLY_PRIMITIVE") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _arrayDeclaration).call(this, [prop], value$1));
			else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
				out.push("");
				out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _headerGroup).call(this, [...keys, prop]));
				out.push(...(0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, value$1[i], [...keys, prop]));
			}
			else {
				const str = value$1.map((x) => (0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, x)).join(",");
				out.push(`${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, [prop])}[${str}]`);
			}
		} else if (typeof value$1 === "object") {
			out.push("");
			out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _header).call(this, [...keys, prop]));
			if (value$1) {
				const toParse = value$1;
				out.push(...(0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, toParse, [...keys, prop]));
			}
		}
	}
	out.push("");
	return out;
}
function _isPrimitive(value$1) {
	return value$1 instanceof Date || value$1 instanceof RegExp || [
		"string",
		"number",
		"boolean"
	].includes(typeof value$1);
}
function _getTypeOfArray(arr) {
	if ((0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).has(arr)) return (0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).get(arr);
	const type$1 = (0, import_assertClassBrand.default)(_Dumper_brand, this, _doGetTypeOfArray).call(this, arr);
	(0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).set(arr, type$1);
	return type$1;
}
function _doGetTypeOfArray(arr) {
	if (!arr.length) return "ONLY_PRIMITIVE";
	const onlyPrimitive = (0, import_assertClassBrand.default)(_Dumper_brand, this, _isPrimitive).call(this, arr[0]);
	if (arr[0] instanceof Array) return "MIXED";
	for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== (0, import_assertClassBrand.default)(_Dumper_brand, this, _isPrimitive).call(this, arr[i]) || arr[i] instanceof Array) return "MIXED";
	return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
}
function _printAsInlineValue(value$1) {
	if (value$1 instanceof Date) return `"${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printDate).call(this, value$1)}"`;
	else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
	else if (typeof value$1 === "number") return value$1;
	else if (typeof value$1 === "boolean") return value$1.toString();
	else if (value$1 instanceof Array) {
		const str = value$1.map((x) => (0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, x)).join(",");
		return `[${str}]`;
	} else if (typeof value$1 === "object") {
		if (!value$1) throw new Error("Should never reach");
		const str = Object.keys(value$1).map((key) => {
			return `${joinKeys([key])} = ${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, value$1[key])}`;
		}).join(",");
		return `{${str}}`;
	}
	throw new Error("Should never reach");
}
function _isSimplySerializable(value$1) {
	return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && (0, import_assertClassBrand.default)(_Dumper_brand, this, _getTypeOfArray).call(this, value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
}
function _header(keys) {
	return `[${joinKeys(keys)}]`;
}
function _headerGroup(keys) {
	return `[[${joinKeys(keys)}]]`;
}
function _declaration(keys) {
	const title = joinKeys(keys);
	if (title.length > this.maxPad) this.maxPad = title.length;
	return `${title} = `;
}
function _arrayDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${JSON.stringify(value$1)}`;
}
function _strDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${JSON.stringify(value$1)}`;
}
function _numberDeclaration(keys, value$1) {
	if (Number.isNaN(value$1)) return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}nan`;
	switch (value$1) {
		case Infinity: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}inf`;
		case -Infinity: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}-inf`;
		default: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${value$1}`;
	}
}
function _boolDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${value$1}`;
}
function _printDate(value$1) {
	function dtPad(v, lPad = 2) {
		return v.padStart(lPad, "0");
	}
	const m = dtPad((value$1.getUTCMonth() + 1).toString());
	const d = dtPad(value$1.getUTCDate().toString());
	const h = dtPad(value$1.getUTCHours().toString());
	const min = dtPad(value$1.getUTCMinutes().toString());
	const s = dtPad(value$1.getUTCSeconds().toString());
	const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
	const fData = `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
	return fData;
}
function _dateDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printDate).call(this, value$1)}`;
}
function _format(options = {}) {
	const { keyAlignment = false } = options;
	const rDeclaration = /^(\".*\"|[^=]*)\s=/;
	const out = [];
	for (let i = 0; i < this.output.length; i++) {
		const l = this.output[i];
		if (l[0] === "[" && l[1] !== "[") {
			if (this.output[i + 1] === "" && this.output[i + 2]?.slice(0, l.length) === l.slice(0, -1) + ".") {
				i += 1;
				continue;
			}
			out.push(l);
		} else if (keyAlignment) {
			const m = rDeclaration.exec(l);
			if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
			else out.push(l);
		} else out.push(l);
	}
	const cleanedOutput = [];
	for (let i = 0; i < out.length; i++) {
		const l = out[i];
		if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
	}
	return cleanedOutput;
}
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldSet2.js
var require_classPrivateFieldSet2 = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldSet2.js"(exports, module) {
	var assertClassBrand = require_assertClassBrand();
	function _classPrivateFieldSet2(s, a, r) {
		return s.set(assertClassBrand(s, a), r), r;
	}
	module.exports = _classPrivateFieldSet2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@std/toml/_parser.js
var import_classPrivateFieldInitSpec = __toESM(require_classPrivateFieldInitSpec(), 1);
var import_classPrivateFieldSet2 = __toESM(require_classPrivateFieldSet2(), 1);
var import_classPrivateFieldGet2 = __toESM(require_classPrivateFieldGet2(), 1);
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var _whitespace = /* @__PURE__ */ new WeakMap();
var _position = /* @__PURE__ */ new WeakMap();
var _source = /* @__PURE__ */ new WeakMap();
var Scanner = class {
	constructor(source) {
		(0, import_classPrivateFieldInitSpec.default)(this, _whitespace, /[ \t]/);
		(0, import_classPrivateFieldInitSpec.default)(this, _position, 0);
		(0, import_classPrivateFieldInitSpec.default)(this, _source, void 0);
		(0, import_classPrivateFieldSet2.default)(_source, this, source);
	}
	get position() {
		return (0, import_classPrivateFieldGet2.default)(_position, this);
	}
	get source() {
		return (0, import_classPrivateFieldGet2.default)(_source, this);
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return (0, import_classPrivateFieldGet2.default)(_source, this)[(0, import_classPrivateFieldGet2.default)(_position, this) + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return (0, import_classPrivateFieldGet2.default)(_source, this).slice((0, import_classPrivateFieldGet2.default)(_position, this) + start, (0, import_classPrivateFieldGet2.default)(_position, this) + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		(0, import_classPrivateFieldSet2.default)(_position, this, (0, import_classPrivateFieldGet2.default)(_position, this) + count);
	}
	skipWhitespaces() {
		while ((0, import_classPrivateFieldGet2.default)(_whitespace, this).test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = (0, import_classPrivateFieldGet2.default)(_position, this);
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if ((0, import_classPrivateFieldGet2.default)(_whitespace, this).test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return (0, import_classPrivateFieldGet2.default)(_position, this) >= (0, import_classPrivateFieldGet2.default)(_source, this).length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return (0, import_classPrivateFieldGet2.default)(_source, this).startsWith(searchString, (0, import_classPrivateFieldGet2.default)(_position, this));
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = (0, import_classPrivateFieldGet2.default)(_position, this);
		return (0, import_classPrivateFieldGet2.default)(_source, this).match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = {}) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		const last = currentValue.at(-1);
		deepAssign(last, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		currentValue.push(value$1);
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		const sep = Separator(scanner);
		if (!sep.ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = {};
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = string === "true";
	return success(value$1);
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = NaN;
	return success(value$1);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const int = parseInt(value$1, 10);
	return success(int);
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({});
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = {};
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({});
	const body = blocks.body.reduce(deepAssign, {});
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	const string = scanner.source.slice(0, scanner.position);
	const lines = string.split("\n");
	const row = lines.length;
	const column = lines.at(-1)?.length ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			const message = "Invalid error type caught";
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region src/def/rename.ts
var import_defineProperty$4 = __toESM(require_defineProperty(), 1);
var BaseRenameCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$4.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$4.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$4.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$4.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$4.default)(this, "$$name", Option.String("--name,-n", { description: "The new name of the project" }));
		(0, import_defineProperty$4.default)(this, "binaryName", Option.String("--binary-name,-b", { description: "The new binary name *.node files" }));
		(0, import_defineProperty$4.default)(this, "packageName", Option.String("--package-name", { description: "The new package name of the project" }));
		(0, import_defineProperty$4.default)(this, "manifestPath", Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" }));
		(0, import_defineProperty$4.default)(this, "repository", Option.String("--repository", { description: "The new repository of the project" }));
		(0, import_defineProperty$4.default)(this, "description", Option.String("--description", { description: "The new description of the project" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
(0, import_defineProperty$4.default)(BaseRenameCommand, "paths", [["rename"]]);
(0, import_defineProperty$4.default)(BaseRenameCommand, "usage", Command.Usage({ description: "Rename the NAPI-RS project" }));
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const napiConfig = await readConfig(options);
	const oldName = napiConfig.binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = await findUp(".github", {
			cwd: options.cwd,
			type: "directory"
		});
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = load(githubActionsContent);
				if (githubActionsData.env?.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) {
			const gitAttributesContent = await readFileAsync(gitAttributesPath, "utf8");
			const gitAttributesData = gitAttributesContent.split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$3 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$3(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$3("Template updated successfully");
		} catch (error) {
			debug$3(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$3(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$3("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if (packageJson.napi?.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const yaml = load(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml?.jobs?.build?.strategy?.matrix?.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else if (yaml?.jobs?.["test-macOS-windows-binding"]?.strategy?.matrix?.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	if (!hasLinuxTargets) {
		if (yaml?.jobs?.["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else if (yaml?.jobs?.["test-linux-binding"]?.strategy?.matrix?.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
		if (target) return enabledTargets.includes(target);
		return true;
	});
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		const job = jobConfig;
		if (job.strategy?.matrix?.settings?.[0]?.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray(yaml.jobs?.publish?.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	debug$3("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$3(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$3(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!options.targets?.length) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$3("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$3("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		const out = execSync(`rustup target list`, { encoding: "utf8" });
		if (out.includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$3("Will create napi-rs project with given options:");
	debug$3(userOptions);
	const options = processOptions(userOptions);
	debug$3("Targets to be enabled:");
	debug$3(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = path.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$3(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$3(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			const files$1 = await readdirAsync(path$1);
			if (files$1.length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$3(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region src/def/pre-publish.ts
var import_defineProperty$3 = __toESM(require_defineProperty(), 1);
var BasePrePublishCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$3.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$3.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$3.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$3.default)(this, "npmDir", Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$3.default)(this, "tagStyle", Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" }));
		(0, import_defineProperty$3.default)(this, "ghRelease", Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" }));
		(0, import_defineProperty$3.default)(this, "ghReleaseName", Option.String("--gh-release-name", { description: "GitHub release name" }));
		(0, import_defineProperty$3.default)(this, "ghReleaseId", Option.String("--gh-release-id", { description: "Existing GitHub release id" }));
		(0, import_defineProperty$3.default)(this, "skipOptionalPublish", Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" }));
		(0, import_defineProperty$3.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$3.default)(BasePrePublishCommand, "paths", [["pre-publish"], ["prepublish"]]);
(0, import_defineProperty$3.default)(BasePrePublishCommand, "usage", Command.Usage({ description: "Update package.json and copy addons into per platform packages" }));
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var import_defineProperty$2 = __toESM(require_defineProperty(), 1);
var BaseVersionCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$2.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$2.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$2.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$2.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
(0, import_defineProperty$2.default)(BaseVersionCommand, "paths", [["version"]]);
(0, import_defineProperty$2.default)(BaseVersionCommand, "usage", Command.Usage({ description: "Update version in created npm packages" }));
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$2 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$2(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$1 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$1("Receive pre-publish options:");
	debug$1("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$1(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$1(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			const packagesToPublish = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag);
			pkgInfo$1 = packagesToPublish.find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$1.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) execSync(`${npmClient} publish`, {
				cwd: pkgDir,
				env: process.env
			});
			if (options.ghRelease && repo && owner) {
				debug$1.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$1.info(`GitHub release created`);
					debug$1.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$1.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$1.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	const name$1 = segments.join("@");
	return {
		name: name$1,
		version: version$2,
		tag
	};
}

//#endregion
//#region src/def/universalize.ts
var import_defineProperty$1 = __toESM(require_defineProperty(), 1);
var BaseUniversalizeCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$1.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$1.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$1.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$1.default)(this, "outputDir", Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
(0, import_defineProperty$1.default)(BaseUniversalizeCommand, "paths", [["universalize"]]);
(0, import_defineProperty$1.default)(BaseUniversalizeCommand, "usage", Command.Usage({ description: "Combile built binaries into one universal binary" }));
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	const target = config.targets.find((t) => t.platform === process.platform && t.arch === "universal");
	if (!target) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = UniArchsByPlatform[process.platform]?.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug(`Looking up source binaries to combine: `);
	debug("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	universalizers[process.platform]?.(srcFiles, output);
	debug(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/index.ts
var import_defineProperty = __toESM(require_defineProperty(), 1);
/**
*
* @usage
*
* ```ts
* const cli = new NapiCli()
*
* cli.build({
*   cwd: '/path/to/your/project',
* })
* ```
*/
var NapiCli = class {
	constructor() {
		(0, import_defineProperty.default)(this, "artifacts", collectArtifacts);
		(0, import_defineProperty.default)(this, "new", newProject);
		(0, import_defineProperty.default)(this, "build", buildProject);
		(0, import_defineProperty.default)(this, "createNpmDirs", createNpmDirs);
		(0, import_defineProperty.default)(this, "prePublish", prePublish);
		(0, import_defineProperty.default)(this, "rename", renameProject);
		(0, import_defineProperty.default)(this, "universalize", universalizeBinaries);
		(0, import_defineProperty.default)(this, "version", version);
	}
};

//#endregion
export { NapiCli, parseTriple };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIl90eXBlb2YiLCJ0b1ByaW1pdGl2ZSIsInRvUHJvcGVydHlLZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJvcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zIiwibmFtZXNwYWNlOiBzdHJpbmciLCJkZWJ1ZyIsInBhdGg6IHN0cmluZyIsInBhdGgiLCJwaWNrIiwibzogTyIsInBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4iLCJwa2dKc29uIiwiVEFSR0VUX0xJTktFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiIsIkNwdVRvTm9kZUFyY2g6IFJlY29yZDxzdHJpbmcsIE5vZGVKU0FyY2g+IiwiU3lzVG9Ob2RlUGxhdGZvcm06IFJlY29yZDxzdHJpbmcsIFBsYXRmb3JtPiIsIlVuaUFyY2hzQnlQbGF0Zm9ybTogUGFydGlhbDxSZWNvcmQ8UGxhdGZvcm0sIE5vZGVKU0FyY2hbXT4+IiwicmF3VHJpcGxlOiBzdHJpbmciLCJjcHU6IHN0cmluZyIsInN5czogc3RyaW5nIiwiYWJpOiBzdHJpbmcgfCBudWxsIiwidGFyZ2V0OiBzdHJpbmciLCJ2OiBzdHJpbmciLCJuYXBpVmVyc2lvbjogTmFwaVZlcnNpb24iLCJ2ZXJzaW9uczogTm9kZVZlcnNpb25bXSIsInJlcXVpcmVtZW50czogc3RyaW5nW10iLCJtYW5pZmVzdFBhdGg6IHN0cmluZyIsInJlc29sdmUiLCJwYXRoOiBzdHJpbmciLCJjb25maWdQYXRoPzogc3RyaW5nIiwicGF0aCIsInNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWQiLCJuYXBpQ29uZmlnOiBOYXBpQ29uZmlnIiwidGFyZ2V0czogc3RyaW5nW10iLCJuYW1lOiBzdHJpbmciLCJiaW46IHN0cmluZyIsImJpbiIsIm5hbWUiLCJsaW5lOiBUeXBlRGVmTGluZSIsImNvbnN0RW51bTogYm9vbGVhbiIsImlkZW50OiBudW1iZXIiLCJhbWJpZW50OiBib29sZWFuIiwiaW50ZXJtZWRpYXRlVHlwZUZpbGU6IHN0cmluZyIsImV4cG9ydHM6IHN0cmluZ1tdIiwiZGVmcyIsImZpbGU6IHN0cmluZyIsImRlZnM6IFR5cGVEZWZMaW5lW10iLCJzcmM6IHN0cmluZyIsIm9wdGlvbnM6IE1pbmltYWxOYXBpT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMiLCJkaXIiLCJyb290OiBzdHJpbmciLCJmaWxlcyIsImxvY2FsTmFtZTogc3RyaW5nIiwicGtnTmFtZTogc3RyaW5nIiwiaWRlbnRzOiBzdHJpbmdbXSIsInR1cGxlOiBzdHJpbmciLCJ3YXNpRmlsZW5hbWU6IHN0cmluZyIsImZzIiwid2FzbUZpbGVOYW1lOiBzdHJpbmciLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwiZnM6IGJvb2xlYW4iLCJmcyIsImRlYnVnIiwicmVxdWlyZSIsInJhd09wdGlvbnM6IEJ1aWxkT3B0aW9ucyIsIm9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyIsIm1ldGFkYXRhOiBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhIiwiY3JhdGU6IENyYXRlIiwiY29uZmlnOiBOYXBpQ29uZmlnIiwiYWxpYXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4iLCJ2ZXJzaW9uIiwicmVzb2x2ZSIsImFiaTogc3RyaW5nIHwgbnVsbCIsInR5cGVEZWZUbXBGb2xkZXI6IHN0cmluZyIsInNldGptcExpYiIsInNldGptcEluY2x1ZGUiLCJleHBvcnRzOiBzdHJpbmdbXSIsImZpbGVzIiwiZXhwb3J0cyIsImlkZW50czogc3RyaW5nW10iLCJuYW1lIiwiZGlzdEZpbGVOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsIiwiZW52OiBzdHJpbmciLCJ2YWx1ZTogc3RyaW5nIiwidmFsdWUiLCJvcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zIiwibWtkaXJBc3luYyIsImRpcjogc3RyaW5nIiwid3JpdGVGaWxlQXN5bmMiLCJmaWxlOiBzdHJpbmciLCJjb250ZW50OiBzdHJpbmciLCJzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidGFyZ2V0OiBUYXJnZXQiLCJvcHRpb25zOiBOZXdPcHRpb25zIiwiY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJhc3NlcnRDbGFzc0JyYW5kIiwidmFsdWUiLCJ0eXBlIiwidmFsdWUiLCJ2YWx1ZSIsInRhYmxlIiwicGFyc2UiLCJqb2luIiwibWVyZ2UiLCJmbG9hdCIsInBhaXIiLCJwYXJzZSIsIm9wdGlvbnM6IFJlbmFtZU9wdGlvbnMiLCJ1c2VyT3B0aW9uczogUmVuYW1lT3B0aW9ucyIsImRlYnVnIiwicmVzb2x2ZSIsInBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciIsImNhY2hlRGlyOiBzdHJpbmciLCJzcmM6IHN0cmluZyIsImRlc3Q6IHN0cmluZyIsImluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4iLCJmaWxlUGF0aDogc3RyaW5nIiwiZW5hYmxlZFRhcmdldHM6IHN0cmluZ1tdIiwidGFyZ2V0OiBzdHJpbmciLCJzZXR0aW5nOiBhbnkiLCJqb2JzVG9SZW1vdmU6IHN0cmluZ1tdIiwibmVlZDogc3RyaW5nIiwib3B0aW9uczogUmF3TmV3T3B0aW9ucyIsInVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zIiwicGF0aDogc3RyaW5nIiwic3RhdCIsInBhdGgiLCJmaWxlcyIsIm5hbWU6IHN0cmluZyIsIm9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zIiwib3B0aW9uczogVmVyc2lvbk9wdGlvbnMiLCJkZWJ1ZyIsInVzZXJPcHRpb25zOiBWZXJzaW9uT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zIiwicGFja2FnZU5hbWU6IHN0cmluZyIsInZlcnNpb246IHN0cmluZyIsInBhY2thZ2VOYW1lIiwidmVyc2lvbiIsInJlcG8iLCJvd25lciIsInBrZ0luZm8iLCJvY3Rva2l0IiwicGtnSW5mbzogUGFja2FnZUluZm8gfCB1bmRlZmluZWQiLCJ0YWc6IHN0cmluZyIsIm5hbWUiLCJvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zIiwidW5pdmVyc2FsaXplcnM6IFBhcnRpYWw8XG4gIFJlY29yZDxOb2RlSlMuUGxhdGZvcm0sIChpbnB1dHM6IHN0cmluZ1tdLCBvdXRwdXQ6IHN0cmluZykgPT4gdm9pZD5cbj4iLCJ1c2VyT3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucyJdLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90eXBlb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9QcmltaXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL3NyYy9kZWYvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL3V0aWxzL2xvZy50cyIsIi4uL3BhY2thZ2UuanNvbiIsIi4uL3NyYy91dGlscy9taXNjLnRzIiwiLi4vc3JjL3V0aWxzL3RhcmdldC50cyIsIi4uL3NyYy91dGlscy92ZXJzaW9uLnRzIiwiLi4vc3JjL3V0aWxzL21ldGFkYXRhLnRzIiwiLi4vc3JjL3V0aWxzL2NvbmZpZy50cyIsIi4uL3NyYy91dGlscy9jYXJnby50cyIsIi4uL3NyYy91dGlscy90eXBlZ2VuLnRzIiwiLi4vc3JjL3V0aWxzL3JlYWQtY29uZmlnLnRzIiwiLi4vc3JjL2FwaS9hcnRpZmFjdHMudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy9qcy1iaW5kaW5nLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUudHMiLCIuLi9zcmMvYXBpL2J1aWxkLnRzIiwiLi4vc3JjL2RlZi9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvYXBpL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9kZWYvbmV3LnRzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3NlcnRDbGFzc0JyYW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2NsYXNzUHJpdmF0ZUZpZWxkR2V0Mi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvc3RyaW5naWZ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqc3Ivc3RkX19jb2xsZWN0aW9ucy9fdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXBfbWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlRmllbGRTZXQyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9fcGFyc2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9wYXJzZS5qcyIsIi4uL3NyYy9kZWYvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9yZW5hbWUudHMiLCIuLi9zcmMvYXBpL25ldy50cyIsIi4uL3NyYy9kZWYvcHJlLXB1Ymxpc2gudHMiLCIuLi9zcmMvZGVmL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi91bml2ZXJzYWxpemUudHMiLCIuLi9zcmMvYXBpL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX3R5cGVvZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9Qcm9wZXJ0eUtleSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydhcnRpZmFjdHMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDb3B5IGFydGlmYWN0cyBmcm9tIEdpdGh1YiBBY3Rpb25zIGludG8gbnBtIHBhY2thZ2VzIGFuZCByZWFkeSB0byBwdWJsaXNoJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBvdXRwdXREaXIgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8sLWQnLCAnLi9hcnRpZmFjdHMnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBidWlsZE91dHB1dERpcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYnVpbGQtb3V0cHV0LWRpcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBidWlsZCBvdXRwdXQgZGlyLCBvbmx5IG5lZWRlZCB3aGVuIHRhcmdldHMgY29udGFpbnMgYHdhc20zMi13YXNpLSpgJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgYnVpbGRPdXRwdXREaXI6IHRoaXMuYnVpbGRPdXRwdXREaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0c09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmRcbiAgICpcbiAgICogQGRlZmF1bHQgJy4vYXJ0aWZhY3RzJ1xuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYFxuICAgKi9cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMob3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG91dHB1dERpcjogJy4vYXJ0aWZhY3RzJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgcmF3RGVidWcgZnJvbSAnZGVidWcnXG5cbi8vIGRlYnVnKCclaScsICdUaGlzIGlzIGFuIGluZm8nKVxucmF3RGVidWcuZm9ybWF0dGVycy5pID0gKHYpID0+IHtcbiAgcmV0dXJuIGNvbG9ycy5ncmVlbih2KVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnZGVidWcnIHtcbiAgaW50ZXJmYWNlIERlYnVnZ2VyIHtcbiAgICBpbmZvOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIHdhcm46IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gICAgZXJyb3I6IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnRmFjdG9yeSA9IChuYW1lc3BhY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBkZWJ1ZyA9IHJhd0RlYnVnKGBuYXBpOiR7bmFtZXNwYWNlfWApXG5cbiAgZGVidWcuaW5mbyA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdHcmVlbignIElORk8gJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy53YXJuID0gKC4uLmFyZ3M6IGFueVtdKSA9PlxuICAgIGNvbnNvbGUuZXJyb3IoY29sb3JzLmJsYWNrKGNvbG9ycy5iZ1llbGxvdygnIFdBUk5JTkcgJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy5lcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY29sb3JzLndoaXRlKGNvbG9ycy5iZ1JlZCgnIEVSUk9SICcpKSxcbiAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gKGFyZy5zdGFjayA/PyBhcmcubWVzc2FnZSkgOiBhcmcsXG4gICAgICApLFxuICAgIClcblxuICByZXR1cm4gZGVidWdcbn1cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndXRpbHMnKVxuIiwie1xuICBcIm5hbWVcIjogXCJAbmFwaS1ycy9jbGlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMy4wLjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNsaSB0b29scyBmb3IgbmFwaS1yc1wiLFxuICBcImF1dGhvclwiOiBcIkxvbmdZaW5hbiA8bHlud2VrbG1AZ21haWwuY29tPlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1yc1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJ0eXBlXCI6IFwibW9kdWxlXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0gMTZcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJuYXBpXCI6IFwiLi9kaXN0L2NsaS5qc1wiLFxuICAgIFwibmFwaS1yYXdcIjogXCIuL2NsaS5tanNcIlxuICB9LFxuICBcIm1haW5cIjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIFwibW9kdWxlXCI6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gIFwiZXhwb3J0c1wiOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIFwiaW1wb3J0XCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlXCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiB7XG4gICAgICBcImltcG9ydFwiOiBcIi4vcGFja2FnZS5qc29uXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL3BhY2thZ2UuanNvblwiXG4gICAgfVxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcInNyY1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2xpXCIsXG4gICAgXCJydXN0XCIsXG4gICAgXCJuYXBpXCIsXG4gICAgXCJuLWFwaVwiLFxuICAgIFwibm9kZS1hcGlcIixcbiAgICBcIm5vZGUtYWRkb25cIixcbiAgICBcIm5lb25cIlxuICBdLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJMb25nWWluYW5cIixcbiAgICAgIFwiZW1haWxcIjogXCJseW53ZWtsbUBnbWFpbC5jb21cIixcbiAgICAgIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vQnJvb29vb29rbHluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImZvcmVoYWxvXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ZvcmVoYWxvXCJcbiAgICB9XG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy5naXRcIlxuICB9LFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwicmVnaXN0cnlcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cIixcbiAgICBcImFjY2Vzc1wiOiBcInB1YmxpY1wiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9uYXBpLXJzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBpbnF1aXJlci9wcm9tcHRzXCI6IFwiXjcuNC4wXCIsXG4gICAgXCJAbmFwaS1ycy9jcm9zcy10b29sY2hhaW5cIjogXCJeMC4wLjE5XCIsXG4gICAgXCJAbmFwaS1ycy93YXNtLXRvb2xzXCI6IFwiXjAuMC4zXCIsXG4gICAgXCJAb2N0b2tpdC9yZXN0XCI6IFwiXjIyLjAuMFwiLFxuICAgIFwiY2xpcGFuaW9uXCI6IFwiXjQuMC4wLXJjLjRcIixcbiAgICBcImNvbG9yZXR0ZVwiOiBcIl4yLjAuMjBcIixcbiAgICBcImRlYnVnXCI6IFwiXjQuNC4wXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS40LjBcIixcbiAgICBcImZpbmQtdXBcIjogXCJeNy4wLjBcIixcbiAgICBcImpzLXlhbWxcIjogXCJeNC4xLjBcIixcbiAgICBcImxvZGFzaC1lc1wiOiBcIl40LjE3LjIxXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNy43LjFcIixcbiAgICBcInR5cGFuaW9uXCI6IFwiXjMuMTQuMFwiLFxuICAgIFwid2FzbS1zamxqXCI6IFwiXjEuMC42XCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGVtbmFwaS9jb3JlXCI6IFwiXjEuNC4wXCIsXG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS40LjBcIixcbiAgICBcIkBveGMtbm9kZS9jb3JlXCI6IFwiXjAuMC4yOVwiLFxuICAgIFwiQHN0ZC90b21sXCI6IFwibnBtOkBqc3Ivc3RkX190b21sQF4xLjAuOFwiLFxuICAgIFwiQHR5cGVzL2RlYnVnXCI6IFwiXjQuMS4xMlwiLFxuICAgIFwiQHR5cGVzL2lucXVpcmVyXCI6IFwiXjkuMC43XCIsXG4gICAgXCJAdHlwZXMvanMteWFtbFwiOiBcIl40LjAuOVwiLFxuICAgIFwiQHR5cGVzL2xvZGFzaC1lc1wiOiBcIl40LjE3LjEyXCIsXG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIl4yMi4xMy4xNlwiLFxuICAgIFwiQHR5cGVzL3NlbXZlclwiOiBcIl43LjcuMFwiLFxuICAgIFwiYXZhXCI6IFwiXjYuMi4wXCIsXG4gICAgXCJlbnYtcGF0aHNcIjogXCJeMy4wLjBcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjMuNS4zXCIsXG4gICAgXCJyb2xsZG93blwiOiBcIl4xLjAuMC1iZXRhLjIzXCIsXG4gICAgXCJ0c2xpYlwiOiBcIl4yLjguMVwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl41LjguMlwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS4xLjBcIixcbiAgICBcImVtbmFwaVwiOiBcIl4xLjEuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc01ldGFcIjoge1xuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJlbW5hcGlcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfVxuICB9LFxuICBcImZ1bmRpbmdcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdGh1YlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3Nwb25zb3JzL0Jyb29vb29va2x5blwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJjbGVhblwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi9jbGVhbi50c1wiLFxuICAgIFwiY29kZWdlblwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi9jb2RlZ2VuL2luZGV4LnRzXCIsXG4gICAgXCJidWlsZFwiOiBcInRzYyAmJiB5YXJuIGNsZWFuICYmIHJvbGxkb3duIC1jIHJvbGxkb3duLmNvbmZpZy5qc1wiLFxuICAgIFwidGVzdFwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi4vbm9kZV9tb2R1bGVzL2F2YS9lbnRyeXBvaW50cy9jbGkubWpzXCJcbiAgfSxcbiAgXCJhdmFcIjoge1xuICAgIFwiZXh0ZW5zaW9uc1wiOiB7XG4gICAgICBcInRzXCI6IFwibW9kdWxlXCJcbiAgICB9LFxuICAgIFwidGltZW91dFwiOiBcIjFtXCIsXG4gICAgXCJmaWxlc1wiOiBbXG4gICAgICBcIioqL19fdGVzdHNfXy8qKi8qLnNwZWMudHNcIixcbiAgICAgIFwiZTJlLyoqLyouc3BlYy50c1wiXG4gICAgXVxuICB9LFxuICBcImdpdEhlYWRcIjogXCJjZGJmMmJjNDM5NDUxNzVlYWJlNTZiMTlhNmJiMGY4NTg0ZGJjMzRjXCJcbn1cbiIsImltcG9ydCB7XG4gIHJlYWRGaWxlLFxuICB3cml0ZUZpbGUsXG4gIGNvcHlGaWxlLFxuICBta2RpcixcbiAgdW5saW5rLFxuICBzdGF0LFxuICByZWFkZGlyLFxufSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAnbm9kZTp1dGlsJ1xuXG5pbXBvcnQgcGtnSnNvbiBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nIHdpdGggeyB0eXBlOiAnanNvbicgfVxuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuL2xvZy5qcydcblxuZXhwb3J0IGNvbnN0IHJlYWRGaWxlQXN5bmMgPSBwcm9taXNpZnkocmVhZEZpbGUpXG5leHBvcnQgY29uc3Qgd3JpdGVGaWxlQXN5bmMgPSBwcm9taXNpZnkod3JpdGVGaWxlKVxuZXhwb3J0IGNvbnN0IHVubGlua0FzeW5jID0gcHJvbWlzaWZ5KHVubGluaylcbmV4cG9ydCBjb25zdCBjb3B5RmlsZUFzeW5jID0gcHJvbWlzaWZ5KGNvcHlGaWxlKVxuZXhwb3J0IGNvbnN0IG1rZGlyQXN5bmMgPSBwcm9taXNpZnkobWtkaXIpXG5leHBvcnQgY29uc3Qgc3RhdEFzeW5jID0gcHJvbWlzaWZ5KHN0YXQpXG5leHBvcnQgY29uc3QgcmVhZGRpckFzeW5jID0gcHJvbWlzaWZ5KHJlYWRkaXIpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzKHBhdGg6IHN0cmluZykge1xuICBjb25zdCBleGlzdHMgPSBhd2FpdCBzdGF0QXN5bmMocGF0aClcbiAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgIC5jYXRjaCgoKSA9PiBmYWxzZSlcbiAgcmV0dXJuIGV4aXN0c1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlyRXhpc3RzQXN5bmMocGF0aDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0QXN5bmMocGF0aClcbiAgICByZXR1cm4gc3RhdHMuaXNEaXJlY3RvcnkoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljazxPLCBLIGV4dGVuZHMga2V5b2YgTz4obzogTywgLi4ua2V5czogS1tdKTogUGljazxPLCBLPiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IG9ba2V5XVxuICAgIHJldHVybiBhY2NcbiAgfSwge30gYXMgTylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhY2thZ2VKc29uKFxuICBwYXRoOiBzdHJpbmcsXG4gIHBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pIHtcbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgZmlsZUV4aXN0cyhwYXRoKVxuICBpZiAoIWV4aXN0cykge1xuICAgIGRlYnVnKGBGaWxlIG5vdCBleGlzdHMgJHtwYXRofWApXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb2xkID0gSlNPTi5wYXJzZShhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JykpXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHBhdGgsIEpTT04uc3RyaW5naWZ5KHsgLi4ub2xkLCAuLi5wYXJ0aWFsIH0sIG51bGwsIDIpKVxufVxuXG5leHBvcnQgY29uc3QgQ0xJX1ZFUlNJT04gPSBwa2dKc29uLnZlcnNpb25cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5leHBvcnQgdHlwZSBQbGF0Zm9ybSA9IE5vZGVKUy5QbGF0Zm9ybSB8ICd3YXNtJyB8ICd3YXNpJyB8ICdvcGVuaGFybW9ueSdcblxuZXhwb3J0IGNvbnN0IFVOSVZFUlNBTF9UQVJHRVRTID0ge1xuICAndW5pdmVyc2FsLWFwcGxlLWRhcndpbic6IFsnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLCAneDg2XzY0LWFwcGxlLWRhcndpbiddLFxufSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgQVZBSUxBQkxFX1RBUkdFVFMgPSBbXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWxpbnV4LWFuZHJvaWQnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtb2hvcycsXG4gICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtZ251JyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtb2hvcycsXG4gICd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJyxcbiAgJ2k2ODYtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ2FybXY3LXVua25vd24tbGludXgtZ251ZWFiaWhmJyxcbiAgJ2FybXY3LXVua25vd24tbGludXgtbXVzbGVhYmloZicsXG4gICdhcm12Ny1saW51eC1hbmRyb2lkZWFiaScsXG4gICd1bml2ZXJzYWwtYXBwbGUtZGFyd2luJyxcbiAgJ3Jpc2N2NjRnYy11bmtub3duLWxpbnV4LWdudScsXG4gICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICdzMzkweC11bmtub3duLWxpbnV4LWdudScsXG4gICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJyxcbiAgJ3dhc20zMi13YXNpcDEtdGhyZWFkcycsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFRhcmdldFRyaXBsZSA9ICh0eXBlb2YgQVZBSUxBQkxFX1RBUkdFVFMpW251bWJlcl1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEFSR0VUUyA9IFtcbiAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICAnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLFxuICAneDg2XzY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgVEFSR0VUX0xJTktFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJzogJ2FhcmNoNjQtbGludXgtbXVzbC1nY2MnLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JzogJ3Jpc2N2NjQtbGludXgtZ251LWdjYycsXG4gICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudSc6ICdwb3dlcnBjNjRsZS1saW51eC1nbnUtZ2NjJyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWxpbnV4LWdudS1nY2MnLFxufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfYXJjaFxudHlwZSBOb2RlSlNBcmNoID1cbiAgfCAnYXJtJ1xuICB8ICdhcm02NCdcbiAgfCAnaWEzMidcbiAgfCAnbWlwcydcbiAgfCAnbWlwc2VsJ1xuICB8ICdwcGMnXG4gIHwgJ3BwYzY0J1xuICB8ICdyaXNjdjY0J1xuICB8ICdzMzkwJ1xuICB8ICdzMzkweCdcbiAgfCAneDMyJ1xuICB8ICd4NjQnXG4gIHwgJ3VuaXZlcnNhbCdcbiAgfCAnd2FzbTMyJ1xuXG5jb25zdCBDcHVUb05vZGVBcmNoOiBSZWNvcmQ8c3RyaW5nLCBOb2RlSlNBcmNoPiA9IHtcbiAgeDg2XzY0OiAneDY0JyxcbiAgYWFyY2g2NDogJ2FybTY0JyxcbiAgaTY4NjogJ2lhMzInLFxuICBhcm12NzogJ2FybScsXG4gIHJpc2N2NjRnYzogJ3Jpc2N2NjQnLFxuICBwb3dlcnBjNjRsZTogJ3BwYzY0Jyxcbn1cblxuZXhwb3J0IGNvbnN0IE5vZGVBcmNoVG9DcHU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIHg2NDogJ3g4Nl82NCcsXG4gIGFybTY0OiAnYWFyY2g2NCcsXG4gIGlhMzI6ICdpNjg2JyxcbiAgYXJtOiAnYXJtdjcnLFxuICByaXNjdjY0OiAncmlzY3Y2NGdjJyxcbiAgcHBjNjQ6ICdwb3dlcnBjNjRsZScsXG59XG5cbmNvbnN0IFN5c1RvTm9kZVBsYXRmb3JtOiBSZWNvcmQ8c3RyaW5nLCBQbGF0Zm9ybT4gPSB7XG4gIGxpbnV4OiAnbGludXgnLFxuICBmcmVlYnNkOiAnZnJlZWJzZCcsXG4gIGRhcndpbjogJ2RhcndpbicsXG4gIHdpbmRvd3M6ICd3aW4zMicsXG4gIG9ob3M6ICdvcGVuaGFybW9ueScsXG59XG5cbmV4cG9ydCBjb25zdCBVbmlBcmNoc0J5UGxhdGZvcm06IFBhcnRpYWw8UmVjb3JkPFBsYXRmb3JtLCBOb2RlSlNBcmNoW10+PiA9IHtcbiAgZGFyd2luOiBbJ3g2NCcsICdhcm02NCddLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldCB7XG4gIHRyaXBsZTogc3RyaW5nXG4gIHBsYXRmb3JtQXJjaEFCSTogc3RyaW5nXG4gIHBsYXRmb3JtOiBQbGF0Zm9ybVxuICBhcmNoOiBOb2RlSlNBcmNoXG4gIGFiaTogc3RyaW5nIHwgbnVsbFxufVxuXG4vKipcbiAqIEEgdHJpcGxlIGlzIGEgc3BlY2lmaWMgZm9ybWF0IGZvciBzcGVjaWZ5aW5nIGEgdGFyZ2V0IGFyY2hpdGVjdHVyZS5cbiAqIFRyaXBsZXMgbWF5IGJlIHJlZmVycmVkIHRvIGFzIGEgdGFyZ2V0IHRyaXBsZSB3aGljaCBpcyB0aGUgYXJjaGl0ZWN0dXJlIGZvciB0aGUgYXJ0aWZhY3QgcHJvZHVjZWQsIGFuZCB0aGUgaG9zdCB0cmlwbGUgd2hpY2ggaXMgdGhlIGFyY2hpdGVjdHVyZSB0aGF0IHRoZSBjb21waWxlciBpcyBydW5uaW5nIG9uLlxuICogVGhlIGdlbmVyYWwgZm9ybWF0IG9mIHRoZSB0cmlwbGUgaXMgYDxhcmNoPjxzdWI+LTx2ZW5kb3I+LTxzeXM+LTxhYmk+YCB3aGVyZTpcbiAqICAgLSBgYXJjaGAgPSBUaGUgYmFzZSBDUFUgYXJjaGl0ZWN0dXJlLCBmb3IgZXhhbXBsZSBgeDg2XzY0YCwgYGk2ODZgLCBgYXJtYCwgYHRodW1iYCwgYG1pcHNgLCBldGMuXG4gKiAgIC0gYHN1YmAgPSBUaGUgQ1BVIHN1Yi1hcmNoaXRlY3R1cmUsIGZvciBleGFtcGxlIGBhcm1gIGhhcyBgdjdgLCBgdjdzYCwgYHY1dGVgLCBldGMuXG4gKiAgIC0gYHZlbmRvcmAgPSBUaGUgdmVuZG9yLCBmb3IgZXhhbXBsZSBgdW5rbm93bmAsIGBhcHBsZWAsIGBwY2AsIGBudmlkaWFgLCBldGMuXG4gKiAgIC0gYHN5c2AgPSBUaGUgc3lzdGVtIG5hbWUsIGZvciBleGFtcGxlIGBsaW51eGAsIGB3aW5kb3dzYCwgYGRhcndpbmAsIGV0Yy4gbm9uZSBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgYmFyZS1tZXRhbCB3aXRob3V0IGFuIE9TLlxuICogICAtIGBhYmlgID0gVGhlIEFCSSwgZm9yIGV4YW1wbGUgYGdudWAsIGBhbmRyb2lkYCwgYGVhYmlgLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyaXBsZShyYXdUcmlwbGU6IHN0cmluZyk6IFRhcmdldCB7XG4gIGlmIChcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaScgfHxcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJyB8fFxuICAgIHJhd1RyaXBsZS5zdGFydHNXaXRoKCd3YXNtMzItd2FzaXAnKVxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgICBwbGF0Zm9ybUFyY2hBQkk6ICd3YXNtMzItd2FzaScsXG4gICAgICBwbGF0Zm9ybTogJ3dhc2knLFxuICAgICAgYXJjaDogJ3dhc20zMicsXG4gICAgICBhYmk6ICd3YXNpJyxcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJpcGxlID0gcmF3VHJpcGxlLmVuZHNXaXRoKCdlYWJpJylcbiAgICA/IGAke3Jhd1RyaXBsZS5zbGljZSgwLCAtNCl9LWVhYmlgXG4gICAgOiByYXdUcmlwbGVcbiAgY29uc3QgdHJpcGxlcyA9IHRyaXBsZS5zcGxpdCgnLScpXG4gIGxldCBjcHU6IHN0cmluZ1xuICBsZXQgc3lzOiBzdHJpbmdcbiAgbGV0IGFiaTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgaWYgKHRyaXBsZXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gYWFyY2g2NC1mdWNoc2lhXG4gICAgLy8gXiBjcHUgICBeIHN5c1xuICAgIDtbY3B1LCBzeXNdID0gdHJpcGxlc1xuICB9IGVsc2Uge1xuICAgIC8vIGFhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsXG4gICAgLy8gXiBjcHUgICAgICAgICAgIF4gc3lzIF4gYWJpXG4gICAgLy8gYWFyY2g2NC1hcHBsZS1kYXJ3aW5cbiAgICAvLyBeIGNwdSAgICAgICAgIF4gc3lzICAoYWJpIGlzIE5vbmUpXG4gICAgO1tjcHUsICwgc3lzLCBhYmkgPSBudWxsXSA9IHRyaXBsZXNcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtID0gU3lzVG9Ob2RlUGxhdGZvcm1bc3lzXSA/PyAoc3lzIGFzIFBsYXRmb3JtKVxuICBjb25zdCBhcmNoID0gQ3B1VG9Ob2RlQXJjaFtjcHVdID8/IChjcHUgYXMgTm9kZUpTQXJjaClcblxuICBpZiAocmF3VHJpcGxlLmluY2x1ZGVzKCdvaG9zJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgICBwbGF0Zm9ybUFyY2hBQkk6IGBsaW51eC0ke2FyY2h9LW9ob3NgLFxuICAgICAgcGxhdGZvcm06ICdvcGVuaGFybW9ueScsXG4gICAgICBhcmNoLFxuICAgICAgYWJpOiBudWxsLFxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgIHBsYXRmb3JtQXJjaEFCSTogYWJpID8gYCR7cGxhdGZvcm19LSR7YXJjaH0tJHthYml9YCA6IGAke3BsYXRmb3JtfS0ke2FyY2h9YCxcbiAgICBwbGF0Zm9ybSxcbiAgICBhcmNoLFxuICAgIGFiaSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpOiBUYXJnZXQge1xuICBjb25zdCBob3N0ID0gZXhlY1N5bmMoYHJ1c3RjIC12VmAsIHtcbiAgICBlbnY6IHByb2Nlc3MuZW52LFxuICB9KVxuICAgIC50b1N0cmluZygndXRmOCcpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2hvc3Q6ICcpKVxuICBjb25zdCB0cmlwbGUgPSBob3N0Py5zbGljZSgnaG9zdDogJy5sZW5ndGgpXG4gIGlmICghdHJpcGxlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBwYXJzZSB0YXJnZXQgdHJpcGxlIGZyb20gaG9zdGApXG4gIH1cbiAgcmV0dXJuIHBhcnNlVHJpcGxlKHRyaXBsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldExpbmtlcih0YXJnZXQ6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBUQVJHRVRfTElOS0VSW3RhcmdldF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvRW52VmFyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRhcmdldC5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKVxufVxuIiwiZXhwb3J0IGVudW0gTmFwaVZlcnNpb24ge1xuICBOYXBpMSA9IDEsXG4gIE5hcGkyLFxuICBOYXBpMyxcbiAgTmFwaTQsXG4gIE5hcGk1LFxuICBOYXBpNixcbiAgTmFwaTcsXG4gIE5hcGk4LFxuICBOYXBpOSxcbn1cblxuLy8vIGJlY2F1c2Ugbm9kZSBzdXBwb3J0IG5ldyBuYXBpIHZlcnNpb24gaW4gc29tZSBtaW5vciB2ZXJzaW9uIHVwZGF0ZXMsIHNvIHdlIG1pZ2h0IG1lZXQgc3VjaCBzaXR1YXRpb246XG4vLy8gYG5vZGUgdjEwLjIwLjBgIHN1cHBvcnRzIGBuYXBpNWAgYW5kIGBuYXBpNmAsIGJ1dCBgbm9kZSB2MTIuMC4wYCBvbmx5IHN1cHBvcnQgYG5hcGk0YCxcbi8vLyBieSB3aGljaCwgd2UgY2FuIG5vdCB0ZWxsIGRpcmVjdGx5IG5hcGkgdmVyc2lvbiBzdXBwb3J0bGVzcyBmcm9tIG5vZGUgdmVyc2lvbiBkaXJlY3RseS5cbmNvbnN0IE5BUElfVkVSU0lPTl9NQVRSSVggPSBuZXcgTWFwPE5hcGlWZXJzaW9uLCBzdHJpbmc+KFtcbiAgW05hcGlWZXJzaW9uLk5hcGkxLCAnOC42LjAgfCA5LjAuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTIsICc4LjEwLjAgfCA5LjMuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTMsICc2LjE0LjIgfCA4LjExLjIgfCA5LjExLjAgfCAxMC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk0LCAnMTAuMTYuMCB8IDExLjguMCB8IDEyLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTUsICcxMC4xNy4wIHwgMTIuMTEuMCB8IDEzLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTYsICcxMC4yMC4wIHwgMTIuMTcuMCB8IDE0LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTcsICcxMC4yMy4wIHwgMTIuMTkuMCB8IDE0LjEyLjAgfCAxNS4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk4LCAnMTIuMjIuMCB8IDE0LjE3LjAgfCAxNS4xMi4wIHwgMTYuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpOSwgJzE4LjE3LjAgfCAyMC4zLjAgfCAyMS4xLjAnXSxcbl0pXG5cbmludGVyZmFjZSBOb2RlVmVyc2lvbiB7XG4gIG1ham9yOiBudW1iZXJcbiAgbWlub3I6IG51bWJlclxuICBwYXRjaDogbnVtYmVyXG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZVZlcnNpb24odjogc3RyaW5nKTogTm9kZVZlcnNpb24ge1xuICBjb25zdCBtYXRjaGVzID0gdi5tYXRjaCgvdj8oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykvaSlcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB2ZXJzaW9uIG51bWJlcjogJyArIHYpXG4gIH1cblxuICBjb25zdCBbLCBtYWpvciwgbWlub3IsIHBhdGNoXSA9IG1hdGNoZXNcblxuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJzZUludChtYWpvciksXG4gICAgbWlub3I6IHBhcnNlSW50KG1pbm9yKSxcbiAgICBwYXRjaDogcGFyc2VJbnQocGF0Y2gpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IE5vZGVWZXJzaW9uW10ge1xuICBjb25zdCByZXF1aXJlbWVudCA9IE5BUElfVkVSU0lPTl9NQVRSSVguZ2V0KG5hcGlWZXJzaW9uKVxuXG4gIGlmICghcmVxdWlyZW1lbnQpIHtcbiAgICByZXR1cm4gW3BhcnNlTm9kZVZlcnNpb24oJzEwLjAuMCcpXVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVtZW50LnNwbGl0KCd8JykubWFwKHBhcnNlTm9kZVZlcnNpb24pXG59XG5cbmZ1bmN0aW9uIHRvRW5naW5lUmVxdWlyZW1lbnQodmVyc2lvbnM6IE5vZGVWZXJzaW9uW10pOiBzdHJpbmcge1xuICBjb25zdCByZXF1aXJlbWVudHM6IHN0cmluZ1tdID0gW11cbiAgdmVyc2lvbnMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgIGxldCByZXEgPSAnJ1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBsYXN0VmVyc2lvbiA9IHZlcnNpb25zW2kgLSAxXVxuICAgICAgcmVxICs9IGA8ICR7bGFzdFZlcnNpb24ubWFqb3IgKyAxfWBcbiAgICB9XG5cbiAgICByZXEgKz0gYCR7aSA9PT0gMCA/ICcnIDogJyB8fCAnfT49ICR7di5tYWpvcn0uJHt2Lm1pbm9yfS4ke3YucGF0Y2h9YFxuICAgIHJlcXVpcmVtZW50cy5wdXNoKHJlcSlcbiAgfSlcblxuICByZXR1cm4gcmVxdWlyZW1lbnRzLmpvaW4oJyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IHN0cmluZyB7XG4gIHJldHVybiB0b0VuZ2luZVJlcXVpcmVtZW50KHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uKSlcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMnXG5cbmV4cG9ydCB0eXBlIENyYXRlVGFyZ2V0S2luZCA9XG4gIHwgJ2JpbidcbiAgfCAnZXhhbXBsZSdcbiAgfCAndGVzdCdcbiAgfCAnYmVuY2gnXG4gIHwgJ2xpYidcbiAgfCAncmxpYidcbiAgfCAnY2R5bGliJ1xuICB8ICdjdXN0b20tYnVpbGQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGVUYXJnZXQge1xuICBuYW1lOiBzdHJpbmdcbiAga2luZDogQ3JhdGVUYXJnZXRLaW5kW11cbiAgY3JhdGVfdHlwZXM6IENyYXRlVGFyZ2V0S2luZFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGUge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzcmNfcGF0aDogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICBlZGl0aW9uOiBzdHJpbmdcbiAgdGFyZ2V0czogQ3JhdGVUYXJnZXRbXVxuICBmZWF0dXJlczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4gIG1hbmlmZXN0X3BhdGg6IHN0cmluZ1xuICBkZXBlbmRlbmNpZXM6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBzb3VyY2U6IHN0cmluZ1xuICAgIHJlcTogc3RyaW5nXG4gICAga2luZDogc3RyaW5nIHwgbnVsbFxuICAgIHJlbmFtZTogc3RyaW5nIHwgbnVsbFxuICAgIG9wdGlvbmFsOiBib29sZWFuXG4gICAgdXNlc19kZWZhdWx0X2ZlYXR1cmVzOiBib29sZWFuXG4gICAgZmVhdHVyZXM6IHN0cmluZ1tdXG4gICAgdGFyZ2V0OiBzdHJpbmcgfCBudWxsXG4gICAgcmVnaXN0cnk6IHN0cmluZyB8IG51bGxcbiAgfT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhIHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIHBhY2thZ2VzOiBDcmF0ZVtdXG4gIHdvcmtzcGFjZV9tZW1iZXJzOiBzdHJpbmdbXVxuICB0YXJnZXRfZGlyZWN0b3J5OiBzdHJpbmdcbiAgd29ya3NwYWNlX3Jvb3Q6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YShtYW5pZmVzdFBhdGg6IHN0cmluZykge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMobWFuaWZlc3RQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gY3JhdGUgZm91bmQgaW4gbWFuaWZlc3Q6ICR7bWFuaWZlc3RQYXRofWApXG4gIH1cblxuICBjb25zdCBjaGlsZFByb2Nlc3MgPSBzcGF3bihcbiAgICAnY2FyZ28nLFxuICAgIFsnbWV0YWRhdGEnLCAnLS1tYW5pZmVzdC1wYXRoJywgbWFuaWZlc3RQYXRoLCAnLS1mb3JtYXQtdmVyc2lvbicsICcxJ10sXG4gICAgeyBzdGRpbzogJ3BpcGUnIH0sXG4gIClcblxuICBsZXQgc3Rkb3V0ID0gJydcbiAgbGV0IHN0ZGVyciA9ICcnXG4gIGxldCBzdGF0dXMgPSAwXG4gIGxldCBlcnJvciA9IG51bGxcblxuICBjaGlsZFByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICBzdGRvdXQgKz0gZGF0YVxuICB9KVxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZGVyciArPSBkYXRhXG4gIH0pXG5cbiAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjaGlsZFByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgIHN0YXR1cyA9IGNvZGUgPz8gMFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhcmdvIG1ldGFkYXRhIGZhaWxlZCB0byBydW4nLCB7IGNhdXNlOiBlcnJvciB9KVxuICB9XG4gIGlmIChzdGF0dXMgIT09IDApIHtcbiAgICBjb25zdCBzaW1wbGVNZXNzYWdlID0gYGNhcmdvIG1ldGFkYXRhIGV4aXRlZCB3aXRoIGNvZGUgJHtzdGF0dXN9YFxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaW1wbGVNZXNzYWdlfSBhbmQgZXJyb3IgbWVzc2FnZTpcXG5cXG4ke3N0ZGVycn1gLCB7XG4gICAgICBjYXVzZTogbmV3IEVycm9yKHNpbXBsZU1lc3NhZ2UpLFxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dCkgYXMgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgY2FyZ28gbWV0YWRhdGEgSlNPTicsIHsgY2F1c2U6IGUgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgdW5kZXJsaW5lLCB5ZWxsb3cgfSBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgeyBtZXJnZSwgb21pdCB9IGZyb20gJ2xvZGFzaC1lcydcblxuaW1wb3J0IHsgZmlsZUV4aXN0cywgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4vbWlzYy5qcydcbmltcG9ydCB7IERFRkFVTFRfVEFSR0VUUywgcGFyc2VUcmlwbGUsIFRhcmdldCB9IGZyb20gJy4vdGFyZ2V0LmpzJ1xuXG5leHBvcnQgdHlwZSBWYWx1ZU9mQ29uc3RBcnJheTxUPiA9IFRbRXhjbHVkZTxrZXlvZiBULCBrZXlvZiBBcnJheTxhbnk+Pl1cblxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VycyA9IFsneWFybicsICdwbnBtJ10gYXMgY29uc3RcbmV4cG9ydCBjb25zdCBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrcyA9IFsnYXZhJ10gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIgPSBWYWx1ZU9mQ29uc3RBcnJheTxcbiAgdHlwZW9mIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2Vyc1xuPlxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVGVzdEZyYW1ld29yayA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkVGVzdEZyYW1ld29ya3Ncbj5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyTmFwaUNvbmZpZyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBiaW5hcnkgdG8gYmUgZ2VuZXJhdGVkLCBkZWZhdWx0IHRvIGBpbmRleGBcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG5wbSBwYWNrYWdlLCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHJvb3QgcGFja2FnZS5qc29uIG5hbWVcbiAgICpcbiAgICogQWx3YXlzIGdpdmVuIGBAc2NvcGUvcGtnYCBhbmQgYXJjaCBzdWZmaXggd2lsbCBiZSBhcHBlbmRlZCBsaWtlIGBAc2NvcGUvcGtnLWxpbnV4LWdudS14NjRgXG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yXG4gICAqL1xuICB0YXJnZXRzPzogc3RyaW5nW11cblxuICAvKipcbiAgICogVGhlIG5wbSBjbGllbnQgcHJvamVjdCB1c2VzLlxuICAgKi9cbiAgbnBtQ2xpZW50Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZ2VuZXJhdGUgY29uc3QgZW51bSBmb3IgdHlwZXNjcmlwdCBiaW5kaW5nc1xuICAgKi9cbiAgY29uc3RFbnVtPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBkdHMgaGVhZGVyIHByZXBlbmQgdG8gdGhlIGdlbmVyYXRlZCBkdHMgZmlsZVxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgZmlsZSBwYXRoIHRvIGJlIHByZXBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqIGlmIGJvdGggZHRzSGVhZGVyIGFuZCBkdHNIZWFkZXJGaWxlIGFyZSBwcm92aWRlZCwgZHRzSGVhZGVyRmlsZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIGR0c0hlYWRlckZpbGU/OiBzdHJpbmdcblxuICAvKipcbiAgICogd2FzbSBjb21waWxhdGlvbiBvcHRpb25zXG4gICAqL1xuICB3YXNtPzoge1xuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViQXNzZW1ibHkvSmF2YVNjcmlwdF9pbnRlcmZhY2UvTWVtb3J5XG4gICAgICogQGRlZmF1bHQgNDAwMCBwYWdlcyAoMjU2TWlCKVxuICAgICAqL1xuICAgIGluaXRpYWxNZW1vcnk/OiBudW1iZXJcbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCA2NTUzNiBwYWdlcyAoNEdpQilcbiAgICAgKi9cbiAgICBtYXhpbXVtTWVtb3J5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBCcm93c2VyIHdhc20gYmluZGluZyBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYnJvd3Nlcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIHVzZSBmcyBtb2R1bGUgaW4gYnJvd3NlclxuICAgICAgICovXG4gICAgICBmcz86IGJvb2xlYW5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBpbml0aWFsaXplIHdhc20gYXN5bmNocm9ub3VzbHlcbiAgICAgICAqL1xuICAgICAgYXN5bmNJbml0PzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluamVjdCBgYnVmZmVyYCB0byBlbW5hcGkgY29udGV4dFxuICAgICAgICovXG4gICAgICBidWZmZXI/OiBib29sZWFuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGJpbmFyeU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHBhY2thZ2VOYW1lIGluc3RlYWRcbiAgICovXG4gIHBhY2thZ2U/OiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGFyZ2V0cyBpbnN0ZWFkXG4gICAqL1xuICB0cmlwbGVzPzoge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0c1xuICAgICAqL1xuICAgIGRlZmF1bHRzOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCB0YXJnZXRzIHRvIGJlIGNvbXBpbGVkIGZvclxuICAgICAqL1xuICAgIGFkZGl0aW9uYWw/OiBzdHJpbmdbXVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMge1xuICBuYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIGtleXdvcmRzPzogc3RyaW5nW11cbiAgYXV0aG9yPzogc3RyaW5nXG4gIGF1dGhvcnM/OiBzdHJpbmdbXVxuICBsaWNlbnNlPzogc3RyaW5nXG4gIGNwdT86IHN0cmluZ1tdXG4gIG9zPzogc3RyaW5nW11cbiAgbGliYz86IHN0cmluZ1tdXG4gIGZpbGVzPzogc3RyaW5nW11cbiAgcmVwb3NpdG9yeT86IGFueVxuICBob21lcGFnZT86IGFueVxuICBlbmdpbmVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwdWJsaXNoQ29uZmlnPzogYW55XG4gIGJ1Z3M/OiBhbnlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIG5hcGk/OiBVc2VyTmFwaUNvbmZpZ1xuICB0eXBlPzogJ21vZHVsZScgfCAnY29tbW9uanMnXG4gIHNjcmlwdHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLy8gbW9kdWxlc1xuICBtYWluPzogc3RyaW5nXG4gIG1vZHVsZT86IHN0cmluZ1xuICB0eXBlcz86IHN0cmluZ1xuICBicm93c2VyPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBhbnlcblxuICBkZXBlbmRlbmNpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGRldkRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICBhdmE/OiB7XG4gICAgdGltZW91dD86IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE5hcGlDb25maWcgPSBSZXF1aXJlZDxcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ2JpbmFyeU5hbWUnIHwgJ3BhY2thZ2VOYW1lJyB8ICducG1DbGllbnQnPlxuPiAmXG4gIFBpY2s8VXNlck5hcGlDb25maWcsICd3YXNtJyB8ICdkdHNIZWFkZXInIHwgJ2R0c0hlYWRlckZpbGUnIHwgJ2NvbnN0RW51bSc+ICYge1xuICAgIHRhcmdldHM6IFRhcmdldFtdXG4gICAgcGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzXG4gIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWROYXBpQ29uZmlnKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcsXG4pOiBQcm9taXNlPE5hcGlDb25maWc+IHtcbiAgaWYgKGNvbmZpZ1BhdGggJiYgIShhd2FpdCBmaWxlRXhpc3RzKGNvbmZpZ1BhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTkFQSS1SUyBjb25maWcgbm90IGZvdW5kIGF0ICR7Y29uZmlnUGF0aH1gKVxuICB9XG4gIGlmICghKGF3YWl0IGZpbGVFeGlzdHMocGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrYWdlLmpzb24gbm90IGZvdW5kIGF0ICR7cGF0aH1gKVxuICB9XG4gIC8vIE1heSBzdXBwb3J0IG11bHRpcGxlIGNvbmZpZyBzb3VyY2VzIGxhdGVyIG9uLlxuICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRoLCAndXRmOCcpXG4gIGxldCBwa2dKc29uXG4gIHRyeSB7XG4gICAgcGtnSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbiBhdCAke3BhdGh9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxuXG4gIGxldCBzZXBhcmF0ZWRDb25maWc6IFVzZXJOYXBpQ29uZmlnIHwgdW5kZWZpbmVkXG4gIGlmIChjb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY29uZmlnUGF0aCwgJ3V0ZjgnKVxuICAgIHRyeSB7XG4gICAgICBzZXBhcmF0ZWRDb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0NvbnRlbnQpIGFzIFVzZXJOYXBpQ29uZmlnXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgTkFQSS1SUyBjb25maWcgYXQgJHtjb25maWdQYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVzZXJOYXBpQ29uZmlnID0gcGtnSnNvbi5uYXBpID8/IHt9XG4gIGlmIChwa2dKc29uLm5hcGkgJiYgc2VwYXJhdGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcGtnSnNvblBhdGggPSB1bmRlcmxpbmUocGF0aClcbiAgICBjb25zdCBjb25maWdQYXRoVW5kZXJsaW5lID0gdW5kZXJsaW5lKGNvbmZpZ1BhdGghKVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYEJvdGggbmFwaSBmaWVsZCBpbiAke3BrZ0pzb25QYXRofSBhbmQgW05BUEktUlMgY29uZmlnXSgke2NvbmZpZ1BhdGhVbmRlcmxpbmV9KSBmaWxlIGFyZSBmb3VuZCwgdGhlIE5BUEktUlMgY29uZmlnIGZpbGUgd2lsbCBiZSB1c2VkLmAsXG4gICAgICApLFxuICAgIClcbiAgICBPYmplY3QuYXNzaWduKHVzZXJOYXBpQ29uZmlnLCBzZXBhcmF0ZWRDb25maWcpXG4gIH1cbiAgY29uc3QgbmFwaUNvbmZpZzogTmFwaUNvbmZpZyA9IG1lcmdlKFxuICAgIHtcbiAgICAgIGJpbmFyeU5hbWU6ICdpbmRleCcsXG4gICAgICBwYWNrYWdlTmFtZTogcGtnSnNvbi5uYW1lLFxuICAgICAgdGFyZ2V0czogW10sXG4gICAgICBwYWNrYWdlSnNvbjogcGtnSnNvbixcbiAgICAgIG5wbUNsaWVudDogJ25wbScsXG4gICAgfSxcbiAgICBvbWl0KHVzZXJOYXBpQ29uZmlnLCAndGFyZ2V0cycpLFxuICApXG5cbiAgbGV0IHRhcmdldHM6IHN0cmluZ1tdID0gdXNlck5hcGlDb25maWcudGFyZ2V0cyA/PyBbXVxuXG4gIC8vIGNvbXBhdGlibGUgd2l0aCBvbGQgY29uZmlnXG4gIGlmICh1c2VyTmFwaUNvbmZpZz8ubmFtZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYFtERVBSRUNBVEVEXSBuYXBpLm5hbWUgaXMgZGVwcmVjYXRlZCwgdXNlIG5hcGkuYmluYXJ5TmFtZSBpbnN0ZWFkLmAsXG4gICAgICApLFxuICAgIClcbiAgICBuYXBpQ29uZmlnLmJpbmFyeU5hbWUgPSB1c2VyTmFwaUNvbmZpZy5uYW1lXG4gIH1cblxuICBpZiAoIXRhcmdldHMubGVuZ3RoKSB7XG4gICAgbGV0IGRlcHJlY2F0ZWRXYXJuZWQgPSBmYWxzZVxuICAgIGNvbnN0IHdhcm5pbmcgPSB5ZWxsb3coXG4gICAgICBgW0RFUFJFQ0FURURdIG5hcGkudHJpcGxlcyBpcyBkZXByZWNhdGVkLCB1c2UgbmFwaS50YXJnZXRzIGluc3RlYWQuYCxcbiAgICApXG4gICAgaWYgKHVzZXJOYXBpQ29uZmlnLnRyaXBsZXM/LmRlZmF1bHRzKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmVkID0gdHJ1ZVxuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG4gICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoREVGQVVMVF9UQVJHRVRTKVxuICAgIH1cblxuICAgIGlmICh1c2VyTmFwaUNvbmZpZy50cmlwbGVzPy5hZGRpdGlvbmFsPy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdCh1c2VyTmFwaUNvbmZpZy50cmlwbGVzLmFkZGl0aW9uYWwpXG4gICAgICBpZiAoIWRlcHJlY2F0ZWRXYXJuZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBkdXBsaWNhdGUgdGFyZ2V0c1xuICBjb25zdCB1bmlxdWVUYXJnZXRzID0gbmV3IFNldCh0YXJnZXRzKVxuICBpZiAodW5pcXVlVGFyZ2V0cy5zaXplICE9PSB0YXJnZXRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGR1cGxpY2F0ZVRhcmdldCA9IHRhcmdldHMuZmluZChcbiAgICAgICh0YXJnZXQsIGluZGV4KSA9PiB0YXJnZXRzLmluZGV4T2YodGFyZ2V0KSAhPT0gaW5kZXgsXG4gICAgKVxuICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHRhcmdldHMgYXJlIG5vdCBhbGxvd2VkOiAke2R1cGxpY2F0ZVRhcmdldH1gKVxuICB9XG5cbiAgbmFwaUNvbmZpZy50YXJnZXRzID0gdGFyZ2V0cy5tYXAocGFyc2VUcmlwbGUpXG5cbiAgcmV0dXJuIG5hcGlDb25maWdcbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdHJ5SW5zdGFsbENhcmdvQmluYXJ5KG5hbWU6IHN0cmluZywgYmluOiBzdHJpbmcpIHtcbiAgaWYgKGRldGVjdENhcmdvQmluYXJ5KGJpbikpIHtcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IGFscmVhZHkgaW5zdGFsbGVkOiAlcycsIG5hbWUpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGRlYnVnKCdJbnN0YWxsaW5nIGNhcmdvIGJpbmFyeTogJXMnLCBuYW1lKVxuICAgIGV4ZWNTeW5jKGBjYXJnbyBpbnN0YWxsICR7bmFtZX1gLCB7XG4gICAgICBzdGRpbzogJ2luaGVyaXQnLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbnN0YWxsIGNhcmdvIGJpbmFyeTogJHtuYW1lfWAsIHtcbiAgICAgIGNhdXNlOiBlLFxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0Q2FyZ29CaW5hcnkoYmluOiBzdHJpbmcpIHtcbiAgZGVidWcoJ0RldGVjdGluZyBjYXJnbyBiaW5hcnk6ICVzJywgYmluKVxuICB0cnkge1xuICAgIGV4ZWNTeW5jKGBjYXJnbyBoZWxwICR7YmlufWAsIHtcbiAgICAgIHN0ZGlvOiAnaWdub3JlJyxcbiAgICB9KVxuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgZGV0ZWN0ZWQ6ICVzJywgYmluKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgbm90IGRldGVjdGVkOiAlcycsIGJpbilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwiaW1wb3J0IHsgc29ydEJ5IH0gZnJvbSAnbG9kYXNoLWVzJ1xuXG5pbXBvcnQgeyByZWFkRmlsZUFzeW5jIH0gZnJvbSAnLi9taXNjLmpzJ1xuXG5jb25zdCBUT1BfTEVWRUxfTkFNRVNQQUNFID0gJ19fVE9QX0xFVkVMX01PRFVMRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVFlQRV9ERUZfSEVBREVSID0gYC8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5gXG5cbmVudW0gVHlwZURlZktpbmQge1xuICBDb25zdCA9ICdjb25zdCcsXG4gIEVudW0gPSAnZW51bScsXG4gIFN0cmluZ0VudW0gPSAnc3RyaW5nX2VudW0nLFxuICBJbnRlcmZhY2UgPSAnaW50ZXJmYWNlJyxcbiAgVHlwZSA9ICd0eXBlJyxcbiAgRm4gPSAnZm4nLFxuICBTdHJ1Y3QgPSAnc3RydWN0JyxcbiAgSW1wbCA9ICdpbXBsJyxcbn1cblxuaW50ZXJmYWNlIFR5cGVEZWZMaW5lIHtcbiAga2luZDogVHlwZURlZktpbmRcbiAgbmFtZTogc3RyaW5nXG4gIG9yaWdpbmFsX25hbWU/OiBzdHJpbmdcbiAgZGVmOiBzdHJpbmdcbiAganNfZG9jPzogc3RyaW5nXG4gIGpzX21vZD86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBwcmV0dHlQcmludChcbiAgbGluZTogVHlwZURlZkxpbmUsXG4gIGNvbnN0RW51bTogYm9vbGVhbixcbiAgaWRlbnQ6IG51bWJlcixcbiAgYW1iaWVudCA9IGZhbHNlLFxuKTogc3RyaW5nIHtcbiAgbGV0IHMgPSBsaW5lLmpzX2RvYyA/PyAnJ1xuICBzd2l0Y2ggKGxpbmUua2luZCkge1xuICAgIGNhc2UgVHlwZURlZktpbmQuSW50ZXJmYWNlOlxuICAgICAgcyArPSBgZXhwb3J0IGludGVyZmFjZSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlR5cGU6XG4gICAgICBzICs9IGBleHBvcnQgdHlwZSAke2xpbmUubmFtZX0gPSBcXG4ke2xpbmUuZGVmfWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLkVudW06XG4gICAgICBjb25zdCBlbnVtTmFtZSA9IGNvbnN0RW51bSA/ICdjb25zdCBlbnVtJyA6ICdlbnVtJ1xuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSAke2VudW1OYW1lfSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cmluZ0VudW06XG4gICAgICBpZiAoY29uc3RFbnVtKSB7XG4gICAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gY29uc3QgZW51bSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgKz0gYGV4cG9ydCB0eXBlICR7bGluZS5uYW1lfSA9ICR7bGluZS5kZWYucmVwbGFjZUFsbCgvLio9L2csICcnKS5yZXBsYWNlQWxsKCcsJywgJ3wnKX07YFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuU3RydWN0OlxuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjbGFzcyAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGlmIChsaW5lLm9yaWdpbmFsX25hbWUgJiYgbGluZS5vcmlnaW5hbF9uYW1lICE9PSBsaW5lLm5hbWUpIHtcbiAgICAgICAgcyArPSBgXFxuZXhwb3J0IHR5cGUgJHtsaW5lLm9yaWdpbmFsX25hbWV9ID0gJHtsaW5lLm5hbWV9YFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuRm46XG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9ICR7bGluZS5kZWZ9YFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzICs9IGxpbmUuZGVmXG4gIH1cblxuICByZXR1cm4gY29ycmVjdFN0cmluZ0lkZW50KHMsIGlkZW50KVxufVxuXG5mdW5jdGlvbiBleHBvcnREZWNsYXJlKGFtYmllbnQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBpZiAoYW1iaWVudCkge1xuICAgIHJldHVybiAnZXhwb3J0J1xuICB9XG5cbiAgcmV0dXJuICdleHBvcnQgZGVjbGFyZSdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUeXBlRGVmKFxuICBpbnRlcm1lZGlhdGVUeXBlRmlsZTogc3RyaW5nLFxuICBjb25zdEVudW06IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgZXhwb3J0czogc3RyaW5nW10gPSBbXVxuICBjb25zdCBkZWZzID0gYXdhaXQgcmVhZEludGVybWVkaWF0ZVR5cGVGaWxlKGludGVybWVkaWF0ZVR5cGVGaWxlKVxuICBjb25zdCBncm91cGVkRGVmcyA9IHByZXByb2Nlc3NUeXBlRGVmKGRlZnMpXG5cbiAgY29uc3QgZHRzID1cbiAgICBzb3J0QnkoQXJyYXkuZnJvbShncm91cGVkRGVmcyksIChbbmFtZXNwYWNlXSkgPT4gbmFtZXNwYWNlKVxuICAgICAgLm1hcCgoW25hbWVzcGFjZSwgZGVmc10pID0+IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gVE9QX0xFVkVMX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBkZWZzXG4gICAgICAgICAgICAubWFwKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkZWYua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuQ29uc3Q6XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5FbnVtOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkZuOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RydWN0OiB7XG4gICAgICAgICAgICAgICAgICBleHBvcnRzLnB1c2goZGVmLm5hbWUpXG4gICAgICAgICAgICAgICAgICBpZiAoZGVmLm9yaWdpbmFsX25hbWUgJiYgZGVmLm9yaWdpbmFsX25hbWUgIT09IGRlZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucHVzaChkZWYub3JpZ2luYWxfbmFtZSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuXFxuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnB1c2gobmFtZXNwYWNlKVxuICAgICAgICAgIGxldCBkZWNsYXJhdGlvbiA9ICcnXG4gICAgICAgICAgZGVjbGFyYXRpb24gKz0gYGV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSAke25hbWVzcGFjZX0ge1xcbmBcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiArPSBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMiwgdHJ1ZSkgKyAnXFxuJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWNsYXJhdGlvbiArPSAnfSdcbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG5cXG4nKSArICdcXG4nXG5cbiAgcmV0dXJuIHtcbiAgICBkdHMsXG4gICAgZXhwb3J0cyxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoZmlsZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGUsICd1dGY4JylcblxuICBjb25zdCBkZWZzID0gY29udGVudFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGxpbmUpIGFzIFR5cGVEZWZMaW5lXG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgYmFjayB0byBhY3R1YWwgbmV3bGluZXMgaW4ganNfZG9jIGZpZWxkc1xuICAgICAgaWYgKHBhcnNlZC5qc19kb2MpIHtcbiAgICAgICAgcGFyc2VkLmpzX2RvYyA9IHBhcnNlZC5qc19kb2MucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgdG8gYWN0dWFsIG5ld2xpbmVzIGluIGRlZiBmaWVsZHMgZm9yIHN0cnVjdC9jbGFzcy9pbnRlcmZhY2UvdHlwZSB0eXBlc1xuICAgICAgLy8gd2hlcmUgXFxuIHJlcHJlc2VudHMgbWV0aG9kL2ZpZWxkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgYWN0dWFsIG5ld2xpbmVzXG4gICAgICBpZiAocGFyc2VkLmRlZikge1xuICAgICAgICBwYXJzZWQuZGVmID0gcGFyc2VkLmRlZi5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRcbiAgICB9KVxuXG4gIC8vIG1vdmUgYWxsIGBzdHJ1Y3RgIGRlZiB0byB0aGUgdmVyeSB0b3BcbiAgLy8gYW5kIG9yZGVyIHRoZSByZXN0IGFscGhhYmV0aWNhbGx5LlxuICByZXR1cm4gZGVmcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzVHlwZURlZihkZWZzOiBUeXBlRGVmTGluZVtdKTogTWFwPHN0cmluZywgVHlwZURlZkxpbmVbXT4ge1xuICBjb25zdCBuYW1lc3BhY2VHcm91cGVkID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lW10+KClcbiAgY29uc3QgY2xhc3NEZWZzID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lPigpXG5cbiAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGRlZi5qc19tb2QgPz8gVE9QX0xFVkVMX05BTUVTUEFDRVxuICAgIGlmICghbmFtZXNwYWNlR3JvdXBlZC5oYXMobmFtZXNwYWNlKSkge1xuICAgICAgbmFtZXNwYWNlR3JvdXBlZC5zZXQobmFtZXNwYWNlLCBbXSlcbiAgICB9XG5cbiAgICBjb25zdCBncm91cCA9IG5hbWVzcGFjZUdyb3VwZWQuZ2V0KG5hbWVzcGFjZSkhXG5cbiAgICBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgZ3JvdXAucHVzaChkZWYpXG4gICAgICBjbGFzc0RlZnMuc2V0KGRlZi5uYW1lLCBkZWYpXG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuSW1wbCkge1xuICAgICAgLy8gbWVyZ2UgYGltcGxgIGludG8gY2xhc3MgZGVmaW5pdGlvblxuICAgICAgY29uc3QgY2xhc3NEZWYgPSBjbGFzc0RlZnMuZ2V0KGRlZi5uYW1lKVxuICAgICAgaWYgKGNsYXNzRGVmKSB7XG4gICAgICAgIGlmIChjbGFzc0RlZi5kZWYpIHtcbiAgICAgICAgICBjbGFzc0RlZi5kZWYgKz0gJ1xcbidcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzRGVmLmRlZiArPSBkZWYuZGVmXG4gICAgICAgIC8vIENvbnZlcnQgYW55IHJlbWFpbmluZyBcXG4gc2VxdWVuY2VzIGluIHRoZSBtZXJnZWQgZGVmIHRvIGFjdHVhbCBuZXdsaW5lc1xuICAgICAgICBpZiAoY2xhc3NEZWYuZGVmKSB7XG4gICAgICAgICAgY2xhc3NEZWYuZGVmID0gY2xhc3NEZWYuZGVmLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnB1c2goZGVmKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VHcm91cGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3JyZWN0U3RyaW5nSWRlbnQoc3JjOiBzdHJpbmcsIGlkZW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgYnJhY2tldERlcHRoID0gMFxuICBjb25zdCByZXN1bHQgPSBzcmNcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzSW5NdWx0aWxpbmVDb21tZW50ID0gbGluZS5zdGFydHNXaXRoKCcqJylcbiAgICAgIGNvbnN0IGlzQ2xvc2luZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd9JylcbiAgICAgIGNvbnN0IGlzT3BlbmluZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd7JylcbiAgICAgIGNvbnN0IGlzVHlwZURlY2xhcmF0aW9uID0gbGluZS5lbmRzV2l0aCgnPScpXG4gICAgICBjb25zdCBpc1R5cGVWYXJpYW50ID0gbGluZS5zdGFydHNXaXRoKCd8JylcblxuICAgICAgbGV0IHJpZ2h0SW5kZW50ID0gaWRlbnRcbiAgICAgIGlmICgoaXNPcGVuaW5nQnJhY2tldCB8fCBpc1R5cGVEZWNsYXJhdGlvbikgJiYgIWlzSW5NdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgIGJyYWNrZXREZXB0aCArPSAxXG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IChicmFja2V0RGVwdGggLSAxKSAqIDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0Nsb3NpbmdCcmFja2V0ICYmXG4gICAgICAgICAgYnJhY2tldERlcHRoID4gMCAmJlxuICAgICAgICAgICFpc0luTXVsdGlsaW5lQ29tbWVudCAmJlxuICAgICAgICAgICFpc1R5cGVWYXJpYW50XG4gICAgICAgICkge1xuICAgICAgICAgIGJyYWNrZXREZXB0aCAtPSAxXG4gICAgICAgIH1cbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gYnJhY2tldERlcHRoICogMlxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbk11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gMVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzID0gYCR7JyAnLnJlcGVhdChyaWdodEluZGVudCl9JHtsaW5lfWBcblxuICAgICAgcmV0dXJuIHNcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsImltcG9ydCB7IHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi9jb25maWcuanMnXG5cbmludGVyZmFjZSBNaW5pbWFsTmFwaU9wdGlvbnMge1xuICBjd2Q6IHN0cmluZ1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENvbmZpZyhvcHRpb25zOiBNaW5pbWFsTmFwaU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZVBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKSA9PiByZXNvbHZlKG9wdGlvbnMuY3dkLCAuLi5wYXRocylcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgoXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPz8gb3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicsXG4gICAgKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG4gIHJldHVybiBjb25maWdcbn1cbiIsImltcG9ydCB7IGpvaW4sIHBhcnNlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zLFxuICBBcnRpZmFjdHNPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgcmVhZEZpbGVBc3luYyxcbiAgd3JpdGVGaWxlQXN5bmMsXG4gIFVuaUFyY2hzQnlQbGF0Zm9ybSxcbiAgcmVhZGRpckFzeW5jLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2FydGlmYWN0cycpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2xsZWN0QXJ0aWZhY3RzKHVzZXJPcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lIH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKHBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBkaXN0RGlycyA9IHRhcmdldHMubWFwKChwbGF0Zm9ybSkgPT5cbiAgICBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpciwgcGxhdGZvcm0ucGxhdGZvcm1BcmNoQUJJKSxcbiAgKVxuXG4gIGNvbnN0IHVuaXZlcnNhbFNvdXJjZUJpbnMgPSBuZXcgU2V0KFxuICAgIHRhcmdldHNcbiAgICAgIC5maWx0ZXIoKHBsYXRmb3JtKSA9PiBwbGF0Zm9ybS5hcmNoID09PSAndW5pdmVyc2FsJylcbiAgICAgIC5mbGF0TWFwKChwKSA9PlxuICAgICAgICBVbmlBcmNoc0J5UGxhdGZvcm1bcC5wbGF0Zm9ybV0/Lm1hcCgoYSkgPT4gYCR7cC5wbGF0Zm9ybX0tJHthfWApLFxuICAgICAgKVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBzdHJpbmdbXSxcbiAgKVxuXG4gIGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5vdXRwdXREaXIpKS50aGVuKFxuICAgIChvdXRwdXQpID0+XG4gICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgb3V0cHV0Lm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBSZWFkIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZmlsZVBhdGgpfV1gKVxuICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGVQYXRoKVxuICAgICAgICAgIGNvbnN0IHBhcnNlZE5hbWUgPSBwYXJzZShmaWxlUGF0aClcbiAgICAgICAgICBjb25zdCB0ZXJtcyA9IHBhcnNlZE5hbWUubmFtZS5zcGxpdCgnLicpXG4gICAgICAgICAgY29uc3QgcGxhdGZvcm1BcmNoQUJJID0gdGVybXMucG9wKCkhXG4gICAgICAgICAgY29uc3QgX2JpbmFyeU5hbWUgPSB0ZXJtcy5qb2luKCcuJylcblxuICAgICAgICAgIGlmIChfYmluYXJ5TmFtZSAhPT0gYmluYXJ5TmFtZSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske19iaW5hcnlOYW1lfV0gaXMgbm90IG1hdGNoZWQgd2l0aCBbJHtiaW5hcnlOYW1lfV0sIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpciA9IGRpc3REaXJzLmZpbmQoKGRpcikgPT4gZGlyLmluY2x1ZGVzKHBsYXRmb3JtQXJjaEFCSSkpXG4gICAgICAgICAgaWYgKCFkaXIgJiYgdW5pdmVyc2FsU291cmNlQmlucy5oYXMocGxhdGZvcm1BcmNoQUJJKSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske3BsYXRmb3JtQXJjaEFCSX1dIGhhcyBubyBkaXN0IGRpciBidXQgaXQgaXMgc291cmNlIGJpbiBmb3IgdW5pdmVyc2FsIGFyY2gsIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRpc3QgZGlyIGZvdW5kIGZvciAke2ZpbGVQYXRofWApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlzdEZpbGVQYXRoID0gam9pbihkaXIsIHBhcnNlZE5hbWUuYmFzZSlcbiAgICAgICAgICBkZWJ1Zy5pbmZvKFxuICAgICAgICAgICAgYFdyaXRlIGZpbGUgY29udGVudCB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGRpc3RGaWxlUGF0aCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aCwgc291cmNlQ29udGVudClcbiAgICAgICAgICBjb25zdCBkaXN0RmlsZVBhdGhMb2NhbCA9IGpvaW4oXG4gICAgICAgICAgICBwYXJzZShwYWNrYWdlSnNvblBhdGgpLmRpcixcbiAgICAgICAgICAgIHBhcnNlZE5hbWUuYmFzZSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcuaW5mbyhcbiAgICAgICAgICAgIGBXcml0ZSBmaWxlIGNvbnRlbnQgdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodChkaXN0RmlsZVBhdGhMb2NhbCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aExvY2FsLCBzb3VyY2VDb250ZW50KVxuICAgICAgICB9KSxcbiAgICAgICksXG4gIClcblxuICBjb25zdCB3YXNpVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKCh0KSA9PiB0LnBsYXRmb3JtID09PSAnd2FzaScpXG4gIGlmICh3YXNpVGFyZ2V0KSB7XG4gICAgY29uc3Qgd2FzaURpciA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgd2FzaVRhcmdldC5wbGF0Zm9ybUFyY2hBQkksXG4gICAgKVxuICAgIGNvbnN0IGNqc0ZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYCxcbiAgICApXG4gICAgY29uc3Qgd29ya2VyRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYHdhc2ktd29ya2VyLm1qc2AsXG4gICAgKVxuICAgIGNvbnN0IGJyb3dzZXJFbnRyeSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgY29uc3QgYnJvd3NlcldvcmtlckZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2AsXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJpbmRpbmcgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBjanNGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyhjanNGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgd29ya2VyIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgd29ya2VyRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYHdhc2ktd29ya2VyLm1qc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyh3b3JrZXJGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYnJvd3NlciBlbnRyeSBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJFbnRyeSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzg0MjdcbiAgICAgIChhd2FpdCByZWFkRmlsZUFzeW5jKGJyb3dzZXJFbnRyeSwgJ3V0ZjgnKSkucmVwbGFjZShcbiAgICAgICAgYG5ldyBVUkwoJy4vd2FzaS13b3JrZXItYnJvd3Nlci5tanMnLCBpbXBvcnQubWV0YS51cmwpYCxcbiAgICAgICAgYG5ldyBVUkwoJyR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKWAsXG4gICAgICApLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBicm93c2VyIHdvcmtlciBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMoYnJvd3NlcldvcmtlckZpbGUpLFxuICAgIClcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb2xsZWN0Tm9kZUJpbmFyaWVzKHJvb3Q6IHN0cmluZykge1xuICBjb25zdCBmaWxlcyA9IGF3YWl0IHJlYWRkaXJBc3luYyhyb290LCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgY29uc3Qgbm9kZUJpbmFyaWVzID0gZmlsZXNcbiAgICAuZmlsdGVyKFxuICAgICAgKGZpbGUpID0+XG4gICAgICAgIGZpbGUuaXNGaWxlKCkgJiZcbiAgICAgICAgKGZpbGUubmFtZS5lbmRzV2l0aCgnLm5vZGUnKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoJy53YXNtJykpLFxuICAgIClcbiAgICAubWFwKChmaWxlKSA9PiBqb2luKHJvb3QsIGZpbGUubmFtZSkpXG5cbiAgY29uc3QgZGlycyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5pc0RpcmVjdG9yeSgpKVxuICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgaWYgKGRpci5uYW1lICE9PSAnbm9kZV9tb2R1bGVzJykge1xuICAgICAgbm9kZUJpbmFyaWVzLnB1c2goLi4uKGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihyb290LCBkaXIubmFtZSkpKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVCaW5hcmllc1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNqc0JpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIGlkZW50czogc3RyaW5nW10sXG4pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7YmluZGluZ0hlYWRlcn1cbmNvbnN0IHsgY3JlYXRlUmVxdWlyZSB9ID0gcmVxdWlyZSgnbm9kZTptb2R1bGUnKVxucmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoX19maWxlbmFtZSlcblxuJHtjcmVhdGVDb21tb25CaW5kaW5nKGxvY2FsTmFtZSwgcGtnTmFtZSl9XG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUJpbmRpbmdcbiR7aWRlbnRzXG4gIC5tYXAoKGlkZW50KSA9PiBgbW9kdWxlLmV4cG9ydHMuJHtpZGVudH0gPSBuYXRpdmVCaW5kaW5nLiR7aWRlbnR9YClcbiAgLmpvaW4oJ1xcbicpfVxuYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXNtQmluZGluZyhcbiAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gIHBrZ05hbWU6IHN0cmluZyxcbiAgaWRlbnRzOiBzdHJpbmdbXSxcbik6IHN0cmluZyB7XG4gIHJldHVybiBgJHtiaW5kaW5nSGVhZGVyfVxuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ25vZGU6bW9kdWxlJ1xuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKVxuY29uc3QgX19kaXJuYW1lID0gbmV3IFVSTCgnLicsIGltcG9ydC5tZXRhLnVybCkucGF0aG5hbWVcblxuJHtjcmVhdGVDb21tb25CaW5kaW5nKGxvY2FsTmFtZSwgcGtnTmFtZSl9XG5jb25zdCB7ICR7aWRlbnRzLmpvaW4oJywgJyl9IH0gPSBuYXRpdmVCaW5kaW5nXG4ke2lkZW50cy5tYXAoKGlkZW50KSA9PiBgZXhwb3J0IHsgJHtpZGVudH0gfWApLmpvaW4oJ1xcbicpfVxuYFxufVxuXG5jb25zdCBiaW5kaW5nSGVhZGVyID0gYC8vIHByZXR0aWVyLWlnbm9yZVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vKiBhdXRvLWdlbmVyYXRlZCBieSBOQVBJLVJTICovXG5gXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lOiBzdHJpbmcsIHBrZ05hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGZ1bmN0aW9uIHJlcXVpcmVUdXBsZSh0dXBsZTogc3RyaW5nLCBpZGVudFNpemUgPSA4KSB7XG4gICAgY29uc3QgaWRlbnRMb3cgPSAnICcucmVwZWF0KGlkZW50U2l6ZSAtIDIpXG4gICAgY29uc3QgaWRlbnQgPSAnICcucmVwZWF0KGlkZW50U2l6ZSlcbiAgICByZXR1cm4gYHRyeSB7XG4ke2lkZW50fXJldHVybiByZXF1aXJlKCcuLyR7bG9jYWxOYW1lfS4ke3R1cGxlfS5ub2RlJylcbiR7aWRlbnRMb3d9fSBjYXRjaCAoZSkge1xuJHtpZGVudH1sb2FkRXJyb3JzLnB1c2goZSlcbiR7aWRlbnRMb3d9fVxuJHtpZGVudExvd310cnkge1xuJHtpZGVudH1yZXR1cm4gcmVxdWlyZSgnJHtwa2dOYW1lfS0ke3R1cGxlfScpXG4ke2lkZW50TG93fX0gY2F0Y2ggKGUpIHtcbiR7aWRlbnR9bG9hZEVycm9ycy5wdXNoKGUpXG4ke2lkZW50TG93fX1gXG4gIH1cblxuICByZXR1cm4gYGNvbnN0IHsgcmVhZEZpbGVTeW5jIH0gPSByZXF1aXJlKCdub2RlOmZzJylcbmxldCBuYXRpdmVCaW5kaW5nID0gbnVsbFxuY29uc3QgbG9hZEVycm9ycyA9IFtdXG5cbmNvbnN0IGlzTXVzbCA9ICgpID0+IHtcbiAgbGV0IG11c2wgPSBmYWxzZVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIG11c2wgPSBpc011c2xGcm9tRmlsZXN5c3RlbSgpXG4gICAgaWYgKG11c2wgPT09IG51bGwpIHtcbiAgICAgIG11c2wgPSBpc011c2xGcm9tUmVwb3J0KClcbiAgICB9XG4gICAgaWYgKG11c2wgPT09IG51bGwpIHtcbiAgICAgIG11c2wgPSBpc011c2xGcm9tQ2hpbGRQcm9jZXNzKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG11c2xcbn1cblxuY29uc3QgaXNGaWxlTXVzbCA9IChmKSA9PiBmLmluY2x1ZGVzKCdsaWJjLm11c2wtJykgfHwgZi5pbmNsdWRlcygnbGQtbXVzbC0nKVxuXG5jb25zdCBpc011c2xGcm9tRmlsZXN5c3RlbSA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVhZEZpbGVTeW5jKCcvdXNyL2Jpbi9sZGQnLCAndXRmLTgnKS5pbmNsdWRlcygnbXVzbCcpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY29uc3QgaXNNdXNsRnJvbVJlcG9ydCA9ICgpID0+IHtcbiAgbGV0IHJlcG9ydCA9IG51bGxcbiAgaWYgKHR5cGVvZiBwcm9jZXNzLnJlcG9ydD8uZ2V0UmVwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5yZXBvcnQuZXhjbHVkZU5ldHdvcmsgPSB0cnVlXG4gICAgcmVwb3J0ID0gcHJvY2Vzcy5yZXBvcnQuZ2V0UmVwb3J0KClcbiAgfVxuICBpZiAoIXJlcG9ydCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHJlcG9ydC5oZWFkZXIgJiYgcmVwb3J0LmhlYWRlci5nbGliY1ZlcnNpb25SdW50aW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocmVwb3J0LnNoYXJlZE9iamVjdHMpKSB7XG4gICAgaWYgKHJlcG9ydC5zaGFyZWRPYmplY3RzLnNvbWUoaXNGaWxlTXVzbCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5jb25zdCBpc011c2xGcm9tQ2hpbGRQcm9jZXNzID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMoJ2xkZCAtLXZlcnNpb24nLCB7IGVuY29kaW5nOiAndXRmOCcgfSkuaW5jbHVkZXMoJ211c2wnKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWYgd2UgcmVhY2ggdGhpcyBjYXNlLCB3ZSBkb24ndCBrbm93IGlmIHRoZSBzeXN0ZW0gaXMgbXVzbCBvciBub3QsIHNvIGlzIGJldHRlciB0byBqdXN0IGZhbGxiYWNrIHRvIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWlyZU5hdGl2ZSgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfTkFUSVZFX0xJQlJBUllfUEFUSCkge1xuICAgIHRyeSB7XG4gICAgICBuYXRpdmVCaW5kaW5nID0gcmVxdWlyZShwcm9jZXNzLmVudi5OQVBJX1JTX05BVElWRV9MSUJSQVJZX1BBVEgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2FuZHJvaWQtYXJtNjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdhbmRyb2lkLWFybS1lYWJpJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIEFuZHJvaWQgXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi14NjQtbXN2YycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi1pYTMyLW1zdmMnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLWFybTY0LW1zdmMnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gV2luZG93czogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4tdW5pdmVyc2FsJywgNil9XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4teDY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4tYXJtNjQnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gbWFjT1M6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdmcmVlYnNkLXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZnJlZWJzZC1hcm02NCcpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBGcmVlQlNEOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm0tbXVzbGVhYmloZicsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm0tZ251ZWFiaWhmJywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAncmlzY3Y2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcmlzY3Y2NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXJpc2N2NjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAncHBjNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcHBjNjQtZ251Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdzMzkweCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1zMzkweC1nbnUnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gTGludXg6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ29wZW5oYXJtb255Jykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1vaG9zJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LW9ob3MnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm0tb2hvcycpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBPcGVuSGFybW9ueTogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIE9TOiBcXCR7cHJvY2Vzcy5wbGF0Zm9ybX0sIGFyY2hpdGVjdHVyZTogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICB9XG59XG5cbm5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlTmF0aXZlKClcblxuaWYgKCFuYXRpdmVCaW5kaW5nIHx8IHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICB0cnkge1xuICAgIG5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlKCcuLyR7bG9jYWxOYW1lfS53YXNpLmNqcycpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgfVxuICB9XG4gIGlmICghbmF0aXZlQmluZGluZykge1xuICAgIHRyeSB7XG4gICAgICBuYXRpdmVCaW5kaW5nID0gcmVxdWlyZSgnJHtwa2dOYW1lfS13YXNtMzItd2FzaScpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gICAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICghbmF0aXZlQmluZGluZykge1xuICBpZiAobG9hZEVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXFxgQ2Fubm90IGZpbmQgbmF0aXZlIGJpbmRpbmcuIFxcYCArXG4gICAgICAgIFxcYG5wbSBoYXMgYSBidWcgcmVsYXRlZCB0byBvcHRpb25hbCBkZXBlbmRlbmNpZXMgKGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vY2xpL2lzc3Vlcy80ODI4KS4gXFxgICtcbiAgICAgICAgJ1BsZWFzZSB0cnkgXFxgbnBtIGlcXGAgYWdhaW4gYWZ0ZXIgcmVtb3ZpbmcgYm90aCBwYWNrYWdlLWxvY2suanNvbiBhbmQgbm9kZV9tb2R1bGVzIGRpcmVjdG9yeS4nLFxuICAgICAgeyBjYXVzZTogbG9hZEVycm9ycyB9XG4gICAgKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcXGBGYWlsZWQgdG8gbG9hZCBuYXRpdmUgYmluZGluZ1xcYClcbn1cbmBcbn1cbiIsImV4cG9ydCBjb25zdCBjcmVhdGVXYXNpQnJvd3NlckJpbmRpbmcgPSAoXG4gIHdhc2lGaWxlbmFtZTogc3RyaW5nLFxuICBpbml0aWFsTWVtb3J5ID0gNDAwMCxcbiAgbWF4aW11bU1lbW9yeSA9IDY1NTM2LFxuICBmcyA9IGZhbHNlLFxuICBhc3luY0luaXQgPSBmYWxzZSxcbiAgYnVmZmVyID0gZmFsc2UsXG4pID0+IHtcbiAgY29uc3QgZnNJbXBvcnQgPSBmcyA/IGBpbXBvcnQgeyBtZW1mcyB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgIDogJydcbiAgY29uc3QgYnVmZmVySW1wb3J0ID0gYnVmZmVyXG4gICAgPyBmc1xuICAgICAgPyBgYFxuICAgICAgOiBgaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJ2BcbiAgICA6ICcnXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgXG5leHBvcnQgY29uc3QgeyBmczogX19mcywgdm9sOiBfX3ZvbHVtZSB9ID0gbWVtZnMoKVxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19XQVNJKHtcbiAgdmVyc2lvbjogJ3ByZXZpZXcxJyxcbiAgZnM6IF9fZnMsXG4gIHByZW9wZW5zOiB7XG4gICAgJy8nOiAnLycsXG4gIH0sXG59KWBcbiAgICA6IGBcbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxufSlgXG5cbiAgY29uc3Qgd29ya2VyRnNIYW5kbGVyID0gZnNcbiAgICA/IGAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fZnMpKVxcbmBcbiAgICA6ICcnXG5cbiAgY29uc3QgZW1uYXBpSW5qZWN0QnVmZmVyID0gYnVmZmVyXG4gICAgPyAnX19lbW5hcGlDb250ZXh0LmZlYXR1cmUuQnVmZmVyID0gQnVmZmVyJ1xuICAgIDogJydcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVJbXBvcnQgPSBhc3luY0luaXRcbiAgICA/IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGUgYXMgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmNgXG4gIGNvbnN0IGVtbmFwaUluc3RhbnRpYXRlQ2FsbCA9IGFzeW5jSW5pdFxuICAgID8gYGF3YWl0IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlYFxuICAgIDogYF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcblxuICByZXR1cm4gYGltcG9ydCB7XG4gIGNyZWF0ZU9uTWVzc2FnZSBhcyBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dCBhcyBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0LFxuICAke2VtbmFwaUluc3RhbnRpYXRlSW1wb3J0fSxcbiAgV0FTSSBhcyBfX1dBU0ksXG59IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbiR7ZnNJbXBvcnR9XG4ke2J1ZmZlckltcG9ydH1cbiR7d2FzaUNyZWF0aW9ufVxuXG5jb25zdCBfX3dhc21VcmwgPSBuZXcgVVJMKCcuLyR7d2FzaUZpbGVuYW1lfS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmXG5jb25zdCBfX2VtbmFwaUNvbnRleHQgPSBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0KClcbiR7ZW1uYXBpSW5qZWN0QnVmZmVyfVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5jb25zdCBfX3dhc21GaWxlID0gYXdhaXQgZmV0Y2goX193YXNtVXJsKS50aGVuKChyZXMpID0+IHJlcy5hcnJheUJ1ZmZlcigpKVxuXG5jb25zdCB7XG4gIGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSxcbiAgbW9kdWxlOiBfX3dhc2lNb2R1bGUsXG4gIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSxcbn0gPSAke2VtbmFwaUluc3RhbnRpYXRlQ2FsbH0oX193YXNtRmlsZSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiA0LFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgnLi93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybCksIHtcbiAgICAgIHR5cGU6ICdtb2R1bGUnLFxuICAgIH0pXG4ke3dvcmtlckZzSGFuZGxlcn1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVXYXNpQmluZGluZyA9IChcbiAgd2FzbUZpbGVOYW1lOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4pID0+IGAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogcHJldHRpZXItaWdub3JlICovXG5cbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cblxuY29uc3QgX19ub2RlRnMgPSByZXF1aXJlKCdub2RlOmZzJylcbmNvbnN0IF9fbm9kZVBhdGggPSByZXF1aXJlKCdub2RlOnBhdGgnKVxuY29uc3QgeyBXQVNJOiBfX25vZGVXQVNJIH0gPSByZXF1aXJlKCdub2RlOndhc2knKVxuY29uc3QgeyBXb3JrZXIgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCB7XG4gIGNyZWF0ZU9uTWVzc2FnZTogX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eSxcbiAgZ2V0RGVmYXVsdENvbnRleHQ6IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmM6IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyxcbn0gPSByZXF1aXJlKCdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnKVxuXG5jb25zdCBfX3Jvb3REaXIgPSBfX25vZGVQYXRoLnBhcnNlKHByb2Nlc3MuY3dkKCkpLnJvb3RcblxuY29uc3QgX193YXNpID0gbmV3IF9fbm9kZVdBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBlbnY6IHByb2Nlc3MuZW52LFxuICBwcmVvcGVuczoge1xuICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gIH1cbn0pXG5cbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5sZXQgX193YXNtRmlsZVBhdGggPSBfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnJHt3YXNtRmlsZU5hbWV9Lndhc20nKVxuY29uc3QgX193YXNtRGVidWdGaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0uZGVidWcud2FzbScpXG5cbmlmIChfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbURlYnVnRmlsZVBhdGgpKSB7XG4gIF9fd2FzbUZpbGVQYXRoID0gX193YXNtRGVidWdGaWxlUGF0aFxufSBlbHNlIGlmICghX19ub2RlRnMuZXhpc3RzU3luYyhfX3dhc21GaWxlUGF0aCkpIHtcbiAgdHJ5IHtcbiAgICBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGgucmVzb2x2ZSgnJHtwYWNrYWdlTmFtZX0td2FzbTMyLXdhc2knKVxuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kICR7d2FzbUZpbGVOYW1lfS53YXNtIGZpbGUsIGFuZCAke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaSBwYWNrYWdlIGlzIG5vdCBpbnN0YWxsZWQuJylcbiAgfVxufVxuXG5jb25zdCB7IGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSwgbW9kdWxlOiBfX3dhc2lNb2R1bGUsIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSB9ID0gX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKF9fbm9kZUZzLnJlYWRGaWxlU3luYyhfX3dhc21GaWxlUGF0aCksIHtcbiAgY29udGV4dDogX19lbW5hcGlDb250ZXh0LFxuICBhc3luY1dvcmtQb29sU2l6ZTogKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRocmVhZHNTaXplRnJvbUVudiA9IE51bWJlcihwcm9jZXNzLmVudi5OQVBJX1JTX0FTWU5DX1dPUktfUE9PTF9TSVpFID8/IHByb2Nlc3MuZW52LlVWX1RIUkVBRFBPT0xfU0laRSlcbiAgICAvLyBOYU4gPiAwIGlzIGZhbHNlXG4gICAgaWYgKHRocmVhZHNTaXplRnJvbUVudiA+IDApIHtcbiAgICAgIHJldHVybiB0aHJlYWRzU2l6ZUZyb21FbnZcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDRcbiAgICB9XG4gIH0pKCksXG4gIHJldXNlV29ya2VyOiB0cnVlLFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJ3dhc2ktd29ya2VyLm1qcycpLCB7XG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgIH0pXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eShfX25vZGVGcykoZGF0YSlcbiAgICB9XG5cbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgb2YgTm9kZS5qcyB3YWl0cyBmb3IgYWxsIHRoZSBhY3RpdmUgaGFuZGxlcyBiZWZvcmUgZXhpdGluZy5cbiAgICAvLyBCdXQgUnVzdCB0aHJlYWRzIGFyZSBuZXZlciB3YWl0ZWQgd2l0aG91dCBcXGB0aHJlYWQ6OmpvaW5cXGAuXG4gICAgLy8gU28gaGVyZSB3ZSBoYWNrIHRoZSBjb2RlIG9mIE5vZGUuanMgdG8gcHJldmVudCB0aGUgd29ya2VycyBmcm9tIGJlaW5nIHJlZmVyZW5jZWQgKGFjdGl2ZSkuXG4gICAgLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzE5ZTBkNDcyNzI4Yzc5ZDQxOGI3NGJkZGZmNTg4YmVhNzBhNDAzZDAvbGliL2ludGVybmFsL3dvcmtlci5qcyNMNDE1LFxuICAgIC8vIGEgd29ya2VyIGlzIGNvbnNpc3Qgb2YgdHdvIGhhbmRsZXM6IGtQdWJsaWNQb3J0IGFuZCBrSGFuZGxlLlxuICAgIHtcbiAgICAgIGNvbnN0IGtQdWJsaWNQb3J0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrUHVibGljUG9ydFwiKVxuICAgICAgKTtcbiAgICAgIGlmIChrUHVibGljUG9ydCkge1xuICAgICAgICB3b3JrZXJba1B1YmxpY1BvcnRdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrSGFuZGxlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrSGFuZGxlXCIpXG4gICAgICApO1xuICAgICAgaWYgKGtIYW5kbGUpIHtcbiAgICAgICAgd29ya2VyW2tIYW5kbGVdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICB3b3JrZXIudW5yZWYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlclxuICB9LFxuICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgbWVtb3J5OiBfX3NoYXJlZE1lbW9yeSxcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE9iamVjdFxuICB9LFxuICBiZWZvcmVJbml0KHsgaW5zdGFuY2UgfSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpbnN0YW5jZS5leHBvcnRzKSkge1xuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnX19uYXBpX3JlZ2lzdGVyX18nKSkge1xuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW25hbWVdKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59KVxuYFxuIiwiZXhwb3J0IGNvbnN0IFdBU0lfV09SS0VSX1RFTVBMQVRFID0gYGltcG9ydCBmcyBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJub2RlOm1vZHVsZVwiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgeyBXQVNJIH0gZnJvbSBcIm5vZGU6d2FzaVwiO1xuaW1wb3J0IHsgcGFyZW50UG9ydCwgV29ya2VyIH0gZnJvbSBcIm5vZGU6d29ya2VyX3RocmVhZHNcIjtcblxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcblxuY29uc3QgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgZ2V0RGVmYXVsdENvbnRleHQgfSA9IHJlcXVpcmUoXCJAbmFwaS1ycy93YXNtLXJ1bnRpbWVcIik7XG5cbmlmIChwYXJlbnRQb3J0KSB7XG4gIHBhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsIChkYXRhKSA9PiB7XG4gICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UoeyBkYXRhIH0pO1xuICB9KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIHNlbGY6IGdsb2JhbFRoaXMsXG4gIHJlcXVpcmUsXG4gIFdvcmtlcixcbiAgaW1wb3J0U2NyaXB0czogZnVuY3Rpb24gKGYpIHtcbiAgICA7KDAsIGV2YWwpKGZzLnJlYWRGaWxlU3luYyhmLCBcInV0ZjhcIikgKyBcIi8vIyBzb3VyY2VVUkw9XCIgKyBmKTtcbiAgfSxcbiAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAocGFyZW50UG9ydCkge1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5jb25zdCBlbW5hcGlDb250ZXh0ID0gZ2V0RGVmYXVsdENvbnRleHQoKTtcblxuY29uc3QgX19yb290RGlyID0gcGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdDtcblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgIGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMod2FzbU1vZHVsZSwge1xuICAgICAgY2hpbGRUaHJlYWQ6IHRydWUsXG4gICAgICB3YXNpLFxuICAgICAgY29udGV4dDogZW1uYXBpQ29udGV4dCxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbn0pO1xuXG5nbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gIGhhbmRsZXIuaGFuZGxlKGUpO1xufTtcbmBcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyA9IChmczogYm9vbGVhbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzXG4gICAgPyBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0ksIGNyZWF0ZUZzUHJveHkgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnXG5pbXBvcnQgeyBtZW1mc0V4cG9ydGVkIGFzIF9fbWVtZnNFeHBvcnRlZCB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydcblxuY29uc3QgZnMgPSBjcmVhdGVGc1Byb3h5KF9fbWVtZnNFeHBvcnRlZClgXG4gICAgOiBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0kgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnYFxuICBjb25zdCB3YXNpQ3JlYXRpb24gPSBmc1xuICAgID8gYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBmcyxcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgICcvJzogJy8nLFxuICAgICAgfSxcbiAgICAgIHByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgICBwcmludEVycjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICB9KWBcbiAgICA6IGBjb25zdCB3YXNpID0gbmV3IFdBU0koe1xuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICByZXR1cm4gYCR7ZnNJbXBvcnR9XG5cbmNvbnN0IGhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoe1xuICBvbkxvYWQoeyB3YXNtTW9kdWxlLCB3YXNtTWVtb3J5IH0pIHtcbiAgICAke3dhc2lDcmVhdGlvbn1cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgICAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgICAgICBtZW1vcnk6IHdhc21NZW1vcnksXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcbiAgfSxcbn0pXG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSlcbn1cbmBcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ25vZGU6Y3J5cHRvJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgbWtkaXJTeW5jLCBybVN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ25vZGU6bW9kdWxlJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgeyBwYXJzZSwgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9yZXR0ZSdcbmltcG9ydCB7IGluY2x1ZGUgYXMgc2V0am1wSW5jbHVkZSwgbGliIGFzIHNldGptcExpYiB9IGZyb20gJ3dhc20tc2psaidcblxuaW1wb3J0IHsgQnVpbGRPcHRpb25zIGFzIFJhd0J1aWxkT3B0aW9ucyB9IGZyb20gJy4uL2RlZi9idWlsZC5qcydcbmltcG9ydCB7XG4gIENMSV9WRVJTSU9OLFxuICBjb3B5RmlsZUFzeW5jLFxuICBDcmF0ZSxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RZUEVfREVGX0hFQURFUixcbiAgZmlsZUV4aXN0cyxcbiAgZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCxcbiAgZ2V0VGFyZ2V0TGlua2VyLFxuICBta2RpckFzeW5jLFxuICBOYXBpQ29uZmlnLFxuICBwYXJzZU1ldGFkYXRhLFxuICBwYXJzZVRyaXBsZSxcbiAgcHJvY2Vzc1R5cGVEZWYsXG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICBUYXJnZXQsXG4gIHRhcmdldFRvRW52VmFyLFxuICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnksXG4gIHVubGlua0FzeW5jLFxuICB3cml0ZUZpbGVBc3luYyxcbiAgZGlyRXhpc3RzQXN5bmMsXG4gIHJlYWRkaXJBc3luYyxcbiAgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmltcG9ydCB7IGNyZWF0ZUNqc0JpbmRpbmcsIGNyZWF0ZUVzbUJpbmRpbmcgfSBmcm9tICcuL3RlbXBsYXRlcy9pbmRleC5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCaW5kaW5nLFxuICBjcmVhdGVXYXNpQnJvd3NlckJpbmRpbmcsXG59IGZyb20gJy4vdGVtcGxhdGVzL2xvYWQtd2FzaS10ZW1wbGF0ZS5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyxcbiAgV0FTSV9XT1JLRVJfVEVNUExBVEUsXG59IGZyb20gJy4vdGVtcGxhdGVzL3dhc2ktd29ya2VyLXRlbXBsYXRlLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYnVpbGQnKVxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKVxuXG50eXBlIE91dHB1dEtpbmQgPSAnanMnIHwgJ2R0cycgfCAnbm9kZScgfCAnZXhlJyB8ICd3YXNtJ1xudHlwZSBPdXRwdXQgPSB7IGtpbmQ6IE91dHB1dEtpbmQ7IHBhdGg6IHN0cmluZyB9XG5cbnR5cGUgQnVpbGRPcHRpb25zID0gUmF3QnVpbGRPcHRpb25zICYgeyBjYXJnb09wdGlvbnM/OiBzdHJpbmdbXSB9XG50eXBlIFBhcnNlZEJ1aWxkT3B0aW9ucyA9IE9taXQ8QnVpbGRPcHRpb25zLCAnY3dkJz4gJiB7IGN3ZDogc3RyaW5nIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUHJvamVjdChyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMpIHtcbiAgZGVidWcoJ25hcGkgYnVpbGQgY29tbWFuZCByZWNlaXZlIG9wdGlvbnM6ICVPJywgcmF3T3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMgPSB7XG4gICAgZHRzQ2FjaGU6IHRydWUsXG4gICAgLi4ucmF3T3B0aW9ucyxcbiAgICBjd2Q6IHJhd09wdGlvbnMuY3dkID8/IHByb2Nlc3MuY3dkKCksXG4gIH1cblxuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuXG4gIGNvbnN0IG1hbmlmZXN0UGF0aCA9IHJlc29sdmVQYXRoKG9wdGlvbnMubWFuaWZlc3RQYXRoID8/ICdDYXJnby50b21sJylcbiAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aClcblxuICBjb25zdCBjcmF0ZSA9IG1ldGFkYXRhLnBhY2thZ2VzLmZpbmQoKHApID0+IHtcbiAgICAvLyBwYWNrYWdlIHdpdGggZ2l2ZW4gbmFtZVxuICAgIGlmIChvcHRpb25zLnBhY2thZ2UpIHtcbiAgICAgIHJldHVybiBwLm5hbWUgPT09IG9wdGlvbnMucGFja2FnZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC5tYW5pZmVzdF9wYXRoID09PSBtYW5pZmVzdFBhdGhcbiAgICB9XG4gIH0pXG5cbiAgaWYgKCFjcmF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdVbmFibGUgdG8gZmluZCBjcmF0ZSB0byBidWlsZC4gSXQgc2VlbXMgeW91IGFyZSB0cnlpbmcgdG8gYnVpbGQgYSBjcmF0ZSBpbiBhIHdvcmtzcGFjZSwgdHJ5IHVzaW5nIGAtLXBhY2thZ2VgIG9wdGlvbiB0byBzcGVjaWZ5IHRoZSBwYWNrYWdlIHRvIGJ1aWxkLicsXG4gICAgKVxuICB9XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHJlc29sdmVQYXRoKFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8/IG9wdGlvbnMucGFja2FnZUpzb25QYXRoID8/ICdwYWNrYWdlLmpzb24nLFxuICAgICksXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZVBhdGgob3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVpbGRlcihtZXRhZGF0YSwgY3JhdGUsIGNvbmZpZywgb3B0aW9ucylcblxuICByZXR1cm4gYnVpbGRlci5idWlsZCgpXG59XG5cbmNsYXNzIEJ1aWxkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGFyZ3M6IHN0cmluZ1tdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBlbnZzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRzOiBPdXRwdXRbXSA9IFtdXG5cbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXQ6IFRhcmdldFxuICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlRGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXREaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5hYmxlVHlwZURlZjogYm9vbGVhbiA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlOiBDcmF0ZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogTmFwaUNvbmZpZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldFxuICAgICAgPyBwYXJzZVRyaXBsZShvcHRpb25zLnRhcmdldClcbiAgICAgIDogcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUXG4gICAgICAgID8gcGFyc2VUcmlwbGUocHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUKVxuICAgICAgICA6IGdldFN5c3RlbURlZmF1bHRUYXJnZXQoKVxuICAgIHRoaXMuY3JhdGVEaXIgPSBwYXJzZShjcmF0ZS5tYW5pZmVzdF9wYXRoKS5kaXJcbiAgICB0aGlzLm91dHB1dERpciA9IHJlc29sdmUoXG4gICAgICB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5vdXRwdXREaXIgPz8gdGhpcy5jcmF0ZURpcixcbiAgICApXG4gICAgdGhpcy50YXJnZXREaXIgPVxuICAgICAgb3B0aW9ucy50YXJnZXREaXIgPz9cbiAgICAgIHByb2Nlc3MuZW52LkNBUkdPX0JVSUxEX1RBUkdFVF9ESVIgPz9cbiAgICAgIG1ldGFkYXRhLnRhcmdldF9kaXJlY3RvcnlcbiAgICB0aGlzLmVuYWJsZVR5cGVEZWYgPSB0aGlzLmNyYXRlLmRlcGVuZGVuY2llcy5zb21lKFxuICAgICAgKGRlcCkgPT5cbiAgICAgICAgZGVwLm5hbWUgPT09ICduYXBpLWRlcml2ZScgJiZcbiAgICAgICAgKGRlcC51c2VzX2RlZmF1bHRfZmVhdHVyZXMgfHwgZGVwLmZlYXR1cmVzLmluY2x1ZGVzKCd0eXBlLWRlZicpKSxcbiAgICApXG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgY29uc3QgcmVxdWlyZW1lbnRXYXJuaW5nID1cbiAgICAgICAgJ2BuYXBpLWRlcml2ZWAgY3JhdGUgaXMgbm90IHVzZWQgb3IgYHR5cGUtZGVmYCBmZWF0dXJlIGlzIG5vdCBlbmFibGVkIGZvciBgbmFwaS1kZXJpdmVgIGNyYXRlJ1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gV2lsbCBza2lwIGJpbmRpbmcgZ2VuZXJhdGlvbiBmb3IgXFxgLm5vZGVcXGAsIFxcYC53YXNpXFxgIGFuZCBcXGAuZC50c1xcYCBmaWxlcy5gLFxuICAgICAgKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub3B0aW9ucy5kdHMgfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXIgfHxcbiAgICAgICAgdGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gXFxgZHRzXFxgIHJlbGF0ZWQgb3B0aW9ucyBhcmUgZW5hYmxlZCBidXQgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY2R5TGliTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2NkeWxpYicpKVxuICAgICAgPy5uYW1lXG4gIH1cblxuICBnZXQgYmluTmFtZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vcHRpb25zLmJpbiA/P1xuICAgICAgLy8gb25seSBhdmFpbGFibGUgaWYgbm90IGNkeWxpYiBvciBiaW4gbmFtZSBzcGVjaWZpZWRcbiAgICAgICh0aGlzLmNkeUxpYk5hbWVcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2JpbicpKT8ubmFtZSlcbiAgICApXG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3Qgd2FybmluZyA9XG4gICAgICAgICdNaXNzaW5nIGBjcmF0ZS10eXBlID0gW1wiY2R5bGliXCJdYCBpbiBbbGliXSBjb25maWcuIFRoZSBidWlsZCByZXN1bHQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFzIG5vZGUgYWRkb24uJ1xuXG4gICAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICAgIGRlYnVnLndhcm4od2FybmluZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3YXJuaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBpY2tCaW5hcnkoKVxuICAgICAgLnNldFBhY2thZ2UoKVxuICAgICAgLnNldEZlYXR1cmVzKClcbiAgICAgIC5zZXRUYXJnZXQoKVxuICAgICAgLnBpY2tDcm9zc1Rvb2xjaGFpbigpXG4gICAgICAuc2V0RW52cygpXG4gICAgICAuc2V0QnlwYXNzQXJncygpXG4gICAgICAuZXhlYygpXG4gIH1cblxuICBwcml2YXRlIHBpY2tDcm9zc1Rvb2xjaGFpbigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VOYXBpQ3Jvc3MpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zc2AgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS11c2UtY3Jvc3NgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gdXNlIGJvdGggYC0tY3Jvc3MtY29tcGlsZWAgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS1jcm9zcy1jb21waWxlYCB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBkb3dubG9hZCB9ID0gcmVxdWlyZSgnQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluJylcblxuICAgICAgY29uc3QgYWxpYXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudSc6ICdzMzkweC1pYm0tbGludXgtZ251JyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9vbGNoYWluUGF0aCA9IGpvaW4oXG4gICAgICAgIGhvbWVkaXIoKSxcbiAgICAgICAgJy5uYXBpLXJzJyxcbiAgICAgICAgJ2Nyb3NzLXRvb2xjaGFpbicsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICAgIClcbiAgICAgIG1rZGlyU3luYyh0b29sY2hhaW5QYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICAgICAgaWYgKGV4aXN0c1N5bmMoam9pbih0b29sY2hhaW5QYXRoLCAncGFja2FnZS5qc29uJykpKSB7XG4gICAgICAgIGRlYnVnKGBUb29sY2hhaW4gJHt0b29sY2hhaW5QYXRofSBleGlzdHMsIHNraXAgZXh0cmFjdGluZ2ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJBcmNoaXZlID0gZG93bmxvYWQocHJvY2Vzcy5hcmNoLCB0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICAgIHRhckFyY2hpdmUudW5wYWNrKHRvb2xjaGFpblBhdGgpXG4gICAgICB9XG4gICAgICBjb25zdCB1cHBlckNhc2VUYXJnZXQgPSB0YXJnZXRUb0VudlZhcih0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICBjb25zdCBjcm9zc1RhcmdldE5hbWUgPSBhbGlhc1t0aGlzLnRhcmdldC50cmlwbGVdID8/IHRoaXMudGFyZ2V0LnRyaXBsZVxuICAgICAgY29uc3QgbGlua2VyRW52ID0gYENBUkdPX1RBUkdFVF8ke3VwcGVyQ2FzZVRhcmdldH1fTElOS0VSYFxuICAgICAgdGhpcy5lbnZzW2xpbmtlckVudl0gPSBqb2luKFxuICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAnYmluJyxcbiAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nY2NgLFxuICAgICAgKVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfU1lTUk9PVCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9TWVNST09UYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgY3Jvc3NUYXJnZXROYW1lLFxuICAgICAgICAgICdzeXNyb290JyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQVIpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQVJgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWFyYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfUkFOTElCKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1JBTkxJQmBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgICdiaW4nLFxuICAgICAgICAgIGAke2Nyb3NzVGFyZ2V0TmFtZX0tcmFubGliYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfUkVBREVMRikge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9SRUFERUxGYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yZWFkZWxmYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQ19JTkNMVURFX1BBVEgpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ19JTkNMVURFX1BBVEhgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICBjcm9zc1RhcmdldE5hbWUsXG4gICAgICAgICAgJ3N5c3Jvb3QnLFxuICAgICAgICAgICd1c3InLFxuICAgICAgICAgICdpbmNsdWRlLycsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuVEFSR0VUX0NDKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX0NDYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nY2NgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9DWFgpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ1hYYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nKytgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52LlRBUkdFVF9DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSB8fFxuICAgICAgICAocHJvY2Vzcy5lbnYuQ0M/LnN0YXJ0c1dpdGgoJ2NsYW5nJykgJiYgIXByb2Nlc3MuZW52LlRBUkdFVF9DQylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ0ZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NGTEFHUyA/PyAnJ1xuICAgICAgICB0aGlzLmVudnMuVEFSR0VUX0NGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NGTEFHU31gXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChwcm9jZXNzLmVudi5DWFg/LnN0YXJ0c1dpdGgoJ2NsYW5nKysnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgVEFSR0VUX0NYWEZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWEZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ1hYRkxBR1MgPSBgLS1zeXNyb290PSR7dGhpcy5lbnZzLlRBUkdFVF9TWVNST09UfSAtLWdjYy10b29sY2hhaW49JHt0b29sY2hhaW5QYXRofSAke1RBUkdFVF9DWFhGTEFHU31gXG4gICAgICB9XG4gICAgICB0aGlzLmVudnMuUEFUSCA9IHRoaXMuZW52cy5QQVRIXG4gICAgICAgID8gYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7dGhpcy5lbnZzLlBBVEh9OiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgICAgIDogYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcud2FybignUGljayBjcm9zcyB0b29sY2hhaW4gZmFpbGVkJywgZSBhcyBFcnJvcilcbiAgICAgIC8vIGlnbm9yZSwgZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBleGVjKCkge1xuICAgIGRlYnVnKGBTdGFydCBidWlsZGluZyBjcmF0ZTogJHt0aGlzLmNyYXRlLm5hbWV9YClcbiAgICBkZWJ1ZygnICAlaScsIGBjYXJnbyAke3RoaXMuYXJncy5qb2luKCcgJyl9YClcblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgIGNvbnN0IHdhdGNoID0gdGhpcy5vcHRpb25zLndhdGNoXG4gICAgY29uc3QgYnVpbGRUYXNrID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcyAmJiB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnYC0tdXNlLWNyb3NzYCBhbmQgYC0tY3Jvc3MtY29tcGlsZWAgY2FuIG5vdCBiZSB1c2VkIHRvZ2V0aGVyJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3QgY29tbWFuZCA9XG4gICAgICAgIHByb2Nlc3MuZW52LkNBUkdPID8/ICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MgPyAnY3Jvc3MnIDogJ2NhcmdvJylcbiAgICAgIGNvbnN0IGJ1aWxkUHJvY2VzcyA9IHNwYXduKGNvbW1hbmQsIHRoaXMuYXJncywge1xuICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLnRoaXMuZW52cyB9LFxuICAgICAgICBzdGRpbzogd2F0Y2ggPyBbJ2luaGVyaXQnLCAnaW5oZXJpdCcsICdwaXBlJ10gOiAnaW5oZXJpdCcsXG4gICAgICAgIGN3ZDogdGhpcy5vcHRpb25zLmN3ZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICBkZWJ1ZygnJWknLCBgQnVpbGQgY3JhdGUgJHt0aGlzLmNyYXRlLm5hbWV9IHN1Y2Nlc3NmdWxseSFgKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGV4aXQgY29kZSAke2NvZGV9YCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGVycm9yOiAke2UubWVzc2FnZX1gLCB7IGNhdXNlOiBlIH0pKVxuICAgICAgfSlcblxuICAgICAgLy8gd2F0Y2ggbW9kZSBvbmx5LCB0aGV5IGFyZSBwaXBlZCB0aHJvdWdoIHN0ZGVyclxuICAgICAgYnVpbGRQcm9jZXNzLnN0ZGVycj8ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY29uc29sZS5lcnJvcihvdXRwdXQpXG4gICAgICAgIGlmICgvRmluaXNoZWRcXHMoYGRldmB8YHJlbGVhc2VgKS8udGVzdChvdXRwdXQpKSB7XG4gICAgICAgICAgdGhpcy5wb3N0QnVpbGQoKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhc2s6IGJ1aWxkVGFzay50aGVuKCgpID0+IHRoaXMucG9zdEJ1aWxkKCkpLFxuICAgICAgYWJvcnQ6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBpY2tCaW5hcnkoKSB7XG4gICAgbGV0IHNldCA9IGZhbHNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy53YXRjaCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkNJKSB7XG4gICAgICAgIGRlYnVnLndhcm4oJ1dhdGNoIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiBDSSBlbnZpcm9ubWVudCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXdhdGNoJylcbiAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby13YXRjaCcsICd3YXRjaCcpXG4gICAgICAgIC8vIHlhcm4gbmFwaSB3YXRjaCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnUgWy0tY3Jvc3MtY29tcGlsZV1cbiAgICAgICAgLy8gPT09PlxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSBidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgLy8gY2FyZ28gd2F0Y2ggWy4uLl0gLS0gemlnYnVpbGQgLS10YXJnZXQgeDg2XzY0LXVua25vd24tbGludXgtZ251XG4gICAgICAgIHRoaXMuYXJncy5wdXNoKFxuICAgICAgICAgICd3YXRjaCcsXG4gICAgICAgICAgJy0td2h5JyxcbiAgICAgICAgICAnLWknLFxuICAgICAgICAgICcqLntqcyx0cyxub2RlfScsXG4gICAgICAgICAgJy13JyxcbiAgICAgICAgICB0aGlzLmNyYXRlRGlyLFxuICAgICAgICAgICctLScsXG4gICAgICAgICAgJ2NhcmdvJyxcbiAgICAgICAgICAnYnVpbGQnLFxuICAgICAgICApXG4gICAgICAgIHNldCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIHdpbjMyIHBsYXRmb3JtIG9uIHdpbjMyIHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjYXJnby14d2luIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm1cbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXh3aW4nKVxuICAgICAgICAgIHRyeUluc3RhbGxDYXJnb0JpbmFyeSgnY2FyZ28teHdpbicsICd4d2luJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgneHdpbicsICdidWlsZCcpXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmFyY2ggPT09ICdpYTMyJykge1xuICAgICAgICAgICAgdGhpcy5lbnZzLlhXSU5fQVJDSCA9ICd4ODYnXG4gICAgICAgICAgfVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJlxuICAgICAgICAgIHRoaXMudGFyZ2V0LmFyY2ggPT09IHByb2Nlc3MuYXJjaCAmJlxuICAgICAgICAgIChmdW5jdGlvbiAoYWJpOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBnbGliY1ZlcnNpb25SdW50aW1lID1cbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBwcm9jZXNzLnJlcG9ydD8uZ2V0UmVwb3J0KCk/LmhlYWRlcj8uZ2xpYmNWZXJzaW9uUnVudGltZVxuICAgICAgICAgICAgY29uc3QgbGliYyA9IGdsaWJjVmVyc2lvblJ1bnRpbWUgPyAnZ251JyA6ICdtdXNsJ1xuICAgICAgICAgICAgcmV0dXJuIGFiaSA9PT0gbGliY1xuICAgICAgICAgIH0pKHRoaXMudGFyZ2V0LmFiaSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIGxpbnV4IHRhcmdldCBvbiBsaW51eCBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gZGFyd2luIHRhcmdldCBvbiBkYXJ3aW4gcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXppZ2J1aWxkIHRvIGNyb3NzIGNvbXBpbGUgdG8gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgZGVidWcoJ1VzZSAlaScsICdjYXJnby16aWdidWlsZCcpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby16aWdidWlsZCcsICd6aWdidWlsZCcpXG4gICAgICAgICAgdGhpcy5hcmdzLnB1c2goJ3ppZ2J1aWxkJylcbiAgICAgICAgICBzZXQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNldCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJ2J1aWxkJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0UGFja2FnZSgpIHtcbiAgICBjb25zdCBhcmdzID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2FnZSkge1xuICAgICAgYXJncy5wdXNoKCctLXBhY2thZ2UnLCB0aGlzLm9wdGlvbnMucGFja2FnZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYmluJywgdGhpcy5iaW5OYW1lKVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgZGVidWcoJ1NldCBwYWNrYWdlIGZsYWdzOiAnKVxuICAgICAgZGVidWcoJyAgJU8nLCBhcmdzKVxuICAgICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRUYXJnZXQoKSB7XG4gICAgZGVidWcoJ1NldCBjb21waWxpbmcgdGFyZ2V0IHRvOiAnKVxuICAgIGRlYnVnKCcgICVpJywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgdGhpcy5hcmdzLnB1c2goJy0tdGFyZ2V0JywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0RW52cygpIHtcbiAgICAvLyBUWVBFIERFRlxuICAgIGlmICh0aGlzLmVuYWJsZVR5cGVEZWYpIHtcbiAgICAgIHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIgPVxuICAgICAgICB0aGlzLmdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpXG4gICAgICB0aGlzLnNldEZvcmNlQnVpbGRFbnZzKHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIpXG4gICAgfVxuXG4gICAgLy8gUlVTVEZMQUdTXG4gICAgbGV0IHJ1c3RmbGFncyA9XG4gICAgICBwcm9jZXNzLmVudi5SVVNURkxBR1MgPz8gcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfUlVTVEZMQUdTID8/ICcnXG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRhcmdldC5hYmk/LmluY2x1ZGVzKCdtdXNsJykgJiZcbiAgICAgICFydXN0ZmxhZ3MuaW5jbHVkZXMoJ3RhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJylcbiAgICApIHtcbiAgICAgIHJ1c3RmbGFncyArPSAnIC1DIHRhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJ1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaXAgJiYgIXJ1c3RmbGFncy5pbmNsdWRlcygnbGluay1hcmc9LXMnKSkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgbGluay1hcmc9LXMnXG4gICAgfVxuXG4gICAgaWYgKHJ1c3RmbGFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZW52cy5SVVNURkxBR1MgPSBydXN0ZmxhZ3NcbiAgICB9XG4gICAgLy8gRU5EIFJVU1RGTEFHU1xuXG4gICAgLy8gTElOS0VSXG4gICAgY29uc3QgbGlua2VyID0gdGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZVxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogZ2V0VGFyZ2V0TGlua2VyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAvLyBUT0RPOlxuICAgIC8vICAgZGlyZWN0bHkgc2V0IENBUkdPX1RBUkdFVF88dGFyZ2V0Pl9MSU5LRVIgd2lsbCBjb3ZlciAuY2FyZ28vY29uZmlnLnRvbWxcbiAgICAvLyAgIHdpbGwgZGV0ZWN0IGJ5IGNhcmdvIGNvbmZpZyB3aGVuIGl0IGJlY29tZXMgc3RhYmxlXG4gICAgLy8gICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvY2FyZ28vaXNzdWVzLzkzMDFcbiAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dGFyZ2V0VG9FbnZWYXIoXG4gICAgICB0aGlzLnRhcmdldC50cmlwbGUsXG4gICAgKX1fTElOS0VSYFxuICAgIGlmIChsaW5rZXIgJiYgIXByb2Nlc3MuZW52W2xpbmtlckVudl0gJiYgIXRoaXMuZW52c1tsaW5rZXJFbnZdKSB7XG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGxpbmtlclxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICB0aGlzLnNldEFuZHJvaWRFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knKSB7XG4gICAgICB0aGlzLnNldFdhc2lFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgdGhpcy5zZXRPcGVuSGFybW9ueUVudigpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBlbnZzOiAnKVxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW52cykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICBkZWJ1ZygnICAlaScsIGAke2t9PSR7dn1gKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb3JjZUJ1aWxkRW52cyh0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmcpIHtcbiAgICAvLyBkeW5hbWljYWxseSBjaGVjayBhbGwgbmFwaS1ycyBkZXBzIGFuZCBzZXQgYE5BUElfRk9SQ0VfQlVJTERfe3VwcGVyY2FzZShzbmFrZV9jYXNlKG5hbWUpKX0gPSB0aW1lc3RhbXBgXG4gICAgdGhpcy5tZXRhZGF0YS5wYWNrYWdlcy5mb3JFYWNoKChjcmF0ZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBjcmF0ZS5kZXBlbmRlbmNpZXMuc29tZSgoZCkgPT4gZC5uYW1lID09PSAnbmFwaS1kZXJpdmUnKSAmJlxuICAgICAgICAhZXhpc3RzU3luYyhqb2luKHR5cGVEZWZUbXBGb2xkZXIsIGNyYXRlLm5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW52c1tcbiAgICAgICAgICBgTkFQSV9GT1JDRV9CVUlMRF8ke2NyYXRlLm5hbWUucmVwbGFjZSgvLS9nLCAnXycpLnRvVXBwZXJDYXNlKCl9YFxuICAgICAgICBdID0gRGF0ZS5ub3coKS50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kcm9pZEVudigpIHtcbiAgICBjb25zdCB7IEFORFJPSURfTkRLX0xBVEVTVF9IT01FIH0gPSBwcm9jZXNzLmVudlxuICAgIGlmICghQU5EUk9JRF9OREtfTEFURVNUX0hPTUUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoXG4gICAgICAgICAgJ0FORFJPSURfTkRLX0xBVEVTVF9IT01FJyxcbiAgICAgICAgKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gc2tpcCBjcm9zcyBjb21waWxlIHNldHVwIGlmIGhvc3QgaXMgYW5kcm9pZFxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldEFyY2ggPSB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhcm12N2EnIDogJ2FhcmNoNjQnXG4gICAgY29uc3QgdGFyZ2V0UGxhdGZvcm0gPVxuICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gJ2FybScgPyAnYW5kcm9pZGVhYmkyNCcgOiAnYW5kcm9pZDI0J1xuICAgIGNvbnN0IGhvc3RQbGF0Zm9ybSA9XG4gICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICA/ICdkYXJ3aW4nXG4gICAgICAgIDogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgICAgICAgID8gJ3dpbmRvd3MnXG4gICAgICAgICAgOiAnbGludXgnXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmVudnMsIHtcbiAgICAgIENBUkdPX1RBUkdFVF9BQVJDSDY0X0xJTlVYX0FORFJPSURfTElOS0VSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtYW5kcm9pZDI0LWNsYW5nYCxcbiAgICAgIENBUkdPX1RBUkdFVF9BUk1WN19MSU5VWF9BTkRST0lERUFCSV9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkZWFiaTI0LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DQzogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DWFg6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC0ke3RhcmdldFBsYXRmb3JtfS1jbGFuZysrYCxcbiAgICAgIFRBUkdFVF9BUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLWFyYCxcbiAgICAgIFRBUkdFVF9SQU5MSUI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vbGx2bS1yYW5saWJgLFxuICAgICAgQU5EUk9JRF9OREs6IEFORFJPSURfTkRLX0xBVEVTVF9IT01FLFxuICAgICAgUEFUSDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2JpbiR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YCxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRXYXNpRW52KCkge1xuICAgIGNvbnN0IGVtbmFwaSA9IGpvaW4oXG4gICAgICByZXF1aXJlLnJlc29sdmUoJ2VtbmFwaScpLFxuICAgICAgJy4uJyxcbiAgICAgICdsaWInLFxuICAgICAgJ3dhc20zMi13YXNpLXRocmVhZHMnLFxuICAgIClcbiAgICB0aGlzLmVudnMuRU1OQVBJX0xJTktfRElSID0gZW1uYXBpXG4gICAgdGhpcy5lbnZzLlNFVEpNUF9MSU5LX0RJUiA9IHNldGptcExpYlxuICAgIGNvbnN0IHsgV0FTSV9TREtfUEFUSCB9ID0gcHJvY2Vzcy5lbnZcblxuICAgIGlmIChXQVNJX1NES19QQVRIICYmIGV4aXN0c1N5bmMoV0FTSV9TREtfUEFUSCkpIHtcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lfUFJFVklFVzFfVEhSRUFEU19MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAxX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDFfVEhSRUFEU19MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAyX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnY2xhbmcnKSlcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYJyxcbiAgICAgICAgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2NsYW5nKysnKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUicsIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdhcicpKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9SQU5MSUInLFxuICAgICAgICBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAncmFubGliJyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NGTEFHUycsXG4gICAgICAgIGAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzIC0tc3lzcm9vdD0ke1dBU0lfU0RLX1BBVEh9L3NoYXJlL3dhc2ktc3lzcm9vdCAtcHRocmVhZCAtbWxsdm0gLXdhc20tZW5hYmxlLXNqbGogLUkke3NldGptcEluY2x1ZGV9YCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYRkxBR1MnLFxuICAgICAgICBgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkcyAtLXN5c3Jvb3Q9JHtXQVNJX1NES19QQVRIfS9zaGFyZS93YXNpLXN5c3Jvb3QgLXB0aHJlYWQgLW1sbHZtIC13YXNtLWVuYWJsZS1zamxqIC1JJHtzZXRqbXBJbmNsdWRlfWAsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICBgVEFSR0VUX0xERkxBR1NgLFxuICAgICAgICBgLWZ1c2UtbGQ9JHtXQVNJX1NES19QQVRIfS9iaW4vd2FzbS1sZCAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldE9wZW5IYXJtb255RW52KCkge1xuICAgIGNvbnN0IHsgT0hPU19TREtfUEFUSCwgT0hPU19TREtfTkFUSVZFIH0gPSBwcm9jZXNzLmVudlxuICAgIGNvbnN0IG5ka1BhdGggPSBPSE9TX1NES19QQVRIXG4gICAgICA/IGAke09IT1NfU0RLX05BVElWRX0vbmF0aXZlYFxuICAgICAgOiBPSE9TX1NES19OQVRJVkVcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKCFuZGtQYXRoICYmIHByb2Nlc3MucGxhdGZvcm0gIT09ICdvcGVuaGFybW9ueScpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX1BBVEgnKX0gb3IgJHtjb2xvcnMucmVkKCdPSE9TX1NES19OQVRJVkUnKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbGlua2VyTmFtZSA9IGBDQVJHT19UQVJHRVRfJHt0aGlzLnRhcmdldC50cmlwbGUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyl9X0xJTktFUmBcbiAgICBjb25zdCByYW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1yYW5saWJgXG4gICAgY29uc3QgYXJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hcmBcbiAgICBjb25zdCBjY1BhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi8ke3RoaXMudGFyZ2V0LnRyaXBsZX0tY2xhbmdgXG4gICAgY29uc3QgY3h4UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZysrYFxuICAgIGNvbnN0IGFzUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tYXNgXG4gICAgY29uc3QgbGRQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGQubGxkYFxuICAgIGNvbnN0IHN0cmlwUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tc3RyaXBgXG4gICAgY29uc3Qgb2JqRHVtcFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamR1bXBgXG4gICAgY29uc3Qgb2JqQ29weVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamNvcHlgXG4gICAgY29uc3Qgbm1QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1ubWBcbiAgICBjb25zdCBiaW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW5gXG4gICAgY29uc3QgbGliUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vbGliYFxuXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnTElCQ0xBTkdfUEFUSCcsIGxpYlBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnREVQX0FUT01JQycsICdjbGFuZ19ydC5idWlsdGlucycpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhsaW5rZXJOYW1lLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NDJywgY2NQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DWFgnLCBjeHhQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUicsIGFyUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfUkFOTElCJywgcmFuUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQVMnLCBhc1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0xEJywgbGRQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9TVFJJUCcsIHN0cmlwUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfT0JKRFVNUCcsIG9iakR1bXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpDT1BZJywgb2JqQ29weVBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX05NJywgbm1QYXRoKVxuICAgIHRoaXMuZW52cy5QQVRIID0gYCR7YmluUGF0aH0ke3Byb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnOycgOiAnOid9JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgfVxuXG4gIHByaXZhdGUgc2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxGZWF0dXJlcyAmJiB0aGlzLm9wdGlvbnMubm9EZWZhdWx0RmVhdHVyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IC0tYWxsLWZlYXR1cmVzIGFuZCAtLW5vLWRlZmF1bHQtZmVhdHVyZXMgdG9nZXRoZXInLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYWxsLWZlYXR1cmVzJylcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWRlZmF1bHQtZmVhdHVyZXMnKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tZmVhdHVyZXMnLCAuLi50aGlzLm9wdGlvbnMuZmVhdHVyZXMpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBmZWF0dXJlcyBmbGFnczogJylcbiAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEJ5cGFzc0FyZ3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWxlYXNlKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1yZWxlYXNlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXZlcmJvc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQtZGlyJywgdGhpcy5vcHRpb25zLnRhcmdldERpcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXByb2ZpbGUnLCB0aGlzLm9wdGlvbnMucHJvZmlsZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tbWFuaWZlc3QtcGF0aCcsIHRoaXMub3B0aW9ucy5tYW5pZmVzdFBhdGgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXJnb09wdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goLi4udGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUludGVybWVkaWF0ZVR5cGVEZWZGb2xkZXIoKSB7XG4gICAgbGV0IGZvbGRlciA9IGpvaW4oXG4gICAgICB0aGlzLnRhcmdldERpcixcbiAgICAgICduYXBpLXJzJyxcbiAgICAgIGAke3RoaXMuY3JhdGUubmFtZX0tJHtjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKHRoaXMuY3JhdGUubWFuaWZlc3RfcGF0aClcbiAgICAgICAgLnVwZGF0ZShDTElfVkVSU0lPTilcbiAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgLnN1YnN0cmluZygwLCA4KX1gLFxuICAgIClcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmR0c0NhY2hlKSB7XG4gICAgICBybVN5bmMoZm9sZGVyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbiAgICAgIGZvbGRlciArPSBgXyR7RGF0ZS5ub3coKX1gXG4gICAgfVxuXG4gICAgbWtkaXJBc3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG5cbiAgICByZXR1cm4gZm9sZGVyXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBvc3RCdWlsZCgpIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeTpgKVxuICAgICAgZGVidWcoJyAgJWknLCB0aGlzLm91dHB1dERpcilcbiAgICAgIGF3YWl0IG1rZGlyQXN5bmModGhpcy5vdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBkZWJ1ZyhgT3V0cHV0IGRpcmVjdG9yeSBjcmVhdGVkYClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeSAke3RoaXMub3V0cHV0RGlyfWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHdhc21CaW5hcnlOYW1lID0gYXdhaXQgdGhpcy5jb3B5QXJ0aWZhY3QoKVxuXG4gICAgLy8gb25seSBmb3IgY2R5bGliXG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgaWRlbnRzID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVEZWYoKVxuICAgICAgY29uc3QganNPdXRwdXQgPSBhd2FpdCB0aGlzLndyaXRlSnNCaW5kaW5nKGlkZW50cylcbiAgICAgIGNvbnN0IHdhc21CaW5kaW5nc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVXYXNpQmluZGluZyhcbiAgICAgICAgd2FzbUJpbmFyeU5hbWUsXG4gICAgICAgIGlkZW50cyxcbiAgICAgIClcbiAgICAgIGlmIChqc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChqc091dHB1dClcbiAgICAgIH1cbiAgICAgIGlmICh3YXNtQmluZGluZ3NPdXRwdXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goLi4ud2FzbUJpbmRpbmdzT3V0cHV0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm91dHB1dHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY29weUFydGlmYWN0KCkge1xuICAgIGNvbnN0IFtzcmNOYW1lLCBkZXN0TmFtZSwgd2FzbUJpbmFyeU5hbWVdID0gdGhpcy5nZXRBcnRpZmFjdE5hbWVzKClcbiAgICBpZiAoIXNyY05hbWUgfHwgIWRlc3ROYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcm9maWxlID1cbiAgICAgIHRoaXMub3B0aW9ucy5wcm9maWxlID8/ICh0aGlzLm9wdGlvbnMucmVsZWFzZSA/ICdyZWxlYXNlJyA6ICdkZWJ1ZycpXG4gICAgY29uc3Qgc3JjID0gam9pbih0aGlzLnRhcmdldERpciwgdGhpcy50YXJnZXQudHJpcGxlLCBwcm9maWxlLCBzcmNOYW1lKVxuICAgIGRlYnVnKGBDb3B5IGFydGlmYWN0IGZyb206IFske3NyY31dYClcbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgZGVzdE5hbWUpXG4gICAgY29uc3QgaXNXYXNtID0gZGVzdC5lbmRzV2l0aCgnLndhc20nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdPbGQgYXJ0aWZhY3QgZm91bmQsIHJlbW92ZSBpdCBmaXJzdCcpXG4gICAgICAgIGF3YWl0IHVubGlua0FzeW5jKGRlc3QpXG4gICAgICB9XG4gICAgICBkZWJ1ZygnQ29weSBhcnRpZmFjdCB0bzonKVxuICAgICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgICAgaWYgKGlzV2FzbSkge1xuICAgICAgICBjb25zdCB7IE1vZHVsZUNvbmZpZyB9ID0gYXdhaXQgaW1wb3J0KCdAbmFwaS1ycy93YXNtLXRvb2xzJylcbiAgICAgICAgZGVidWcoJ0dlbmVyYXRlIGRlYnVnIHdhc20gbW9kdWxlJylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVOYW1lU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybSh0cnVlKVxuICAgICAgICAgICAgLnN0cmljdFZhbGlkYXRlKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMoc3JjKSlcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21CaW5hcnkgPSBkZWJ1Z1dhc21Nb2R1bGUuZW1pdFdhc20odHJ1ZSlcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgICAgIGRlc3QucmVwbGFjZSgvXFwud2FzbSQvLCAnLmRlYnVnLndhc20nKSxcbiAgICAgICAgICAgIGRlYnVnV2FzbUJpbmFyeSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcoJ0dlbmVyYXRlIHJlbGVhc2Ugd2FzbSBtb2R1bGUnKVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtTW9kdWxlID0gbmV3IE1vZHVsZUNvbmZpZygpXG4gICAgICAgICAgICAuZ2VuZXJhdGVEd2FyZihmYWxzZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbihmYWxzZSlcbiAgICAgICAgICAgIC5wcmVzZXJ2ZUNvZGVUcmFuc2Zvcm0oZmFsc2UpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAub25seVN0YWJsZUZlYXR1cmVzKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGRlYnVnV2FzbUJpbmFyeSlcbiAgICAgICAgICBjb25zdCByZWxlYXNlV2FzbUJpbmFyeSA9IHJlbGVhc2VXYXNtTW9kdWxlLmVtaXRXYXNtKGZhbHNlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIHJlbGVhc2VXYXNtQmluYXJ5KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGU6ICR7KGUgYXMgYW55KS5tZXNzYWdlID8/IGV9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGNvcHlGaWxlQXN5bmMoc3JjLCBkZXN0KVxuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgICBraW5kOiBkZXN0LmVuZHNXaXRoKCcubm9kZScpID8gJ25vZGUnIDogaXNXYXNtID8gJ3dhc20nIDogJ2V4ZScsXG4gICAgICAgIHBhdGg6IGRlc3QsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHdhc21CaW5hcnlOYW1lID8gam9pbih0aGlzLm91dHB1dERpciwgd2FzbUJpbmFyeU5hbWUpIDogbnVsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvcHkgYXJ0aWZhY3QnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcnRpZmFjdE5hbWVzKCkge1xuICAgIGlmICh0aGlzLmNkeUxpYk5hbWUpIHtcbiAgICAgIGNvbnN0IGNkeUxpYiA9IHRoaXMuY2R5TGliTmFtZS5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIGNvbnN0IHdhc2lUYXJnZXQgPSB0aGlzLmNvbmZpZy50YXJnZXRzLmZpbmQoKHQpID0+IHQucGxhdGZvcm0gPT09ICd3YXNpJylcblxuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICAgID8gYGxpYiR7Y2R5TGlifS5keWxpYmBcbiAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgICA/IGAke2NkeUxpYn0uZGxsYFxuICAgICAgICAgICAgOiB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knIHx8IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbSdcbiAgICAgICAgICAgICAgPyBgJHtjZHlMaWJ9Lndhc21gXG4gICAgICAgICAgICAgIDogYGxpYiR7Y2R5TGlifS5zb2BcblxuICAgICAgbGV0IGRlc3ROYW1lID0gdGhpcy5jb25maWcuYmluYXJ5TmFtZVxuICAgICAgLy8gYWRkIHBsYXRmb3JtIHN1ZmZpeCB0byBiaW5hcnkgbmFtZVxuICAgICAgLy8gaW5kZXhbLmxpbnV4LXg2NC1nbnVdLm5vZGVcbiAgICAgIC8vICAgICAgIF5eXl5eXl5eXl5eXl5eXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICAgIGRlc3ROYW1lICs9IGAuJHt0aGlzLnRhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YFxuICAgICAgfVxuICAgICAgaWYgKHNyY05hbWUuZW5kc1dpdGgoJy53YXNtJykpIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy53YXNtJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy5ub2RlJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzcmNOYW1lLFxuICAgICAgICBkZXN0TmFtZSxcbiAgICAgICAgd2FzaVRhcmdldFxuICAgICAgICAgID8gYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0uJHt3YXNpVGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgICA6IG51bGwsXG4gICAgICBdXG4gICAgfSBlbHNlIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGNvbnN0IHNyY05hbWUgPVxuICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGAke3RoaXMuYmluTmFtZX0uZXhlYCA6IHRoaXMuYmluTmFtZVxuXG4gICAgICByZXR1cm4gW3NyY05hbWUsIHNyY05hbWVdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZURlZigpIHtcbiAgICBjb25zdCB0eXBlRGVmRGlyID0gdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUlxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmIHx8ICEoYXdhaXQgZGlyRXhpc3RzQXN5bmModHlwZURlZkRpcikpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgdGhpcy5vcHRpb25zLmR0cyA/PyAnaW5kZXguZC50cycpXG5cbiAgICBsZXQgaGVhZGVyID0gJydcbiAgICBsZXQgZHRzID0gJydcbiAgICBsZXQgZXhwb3J0czogc3RyaW5nW10gPSBbXVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubm9EdHNIZWFkZXIpIHtcbiAgICAgIGNvbnN0IGR0c0hlYWRlciA9IHRoaXMub3B0aW9ucy5kdHNIZWFkZXIgPz8gdGhpcy5jb25maWcuZHRzSGVhZGVyXG4gICAgICAvLyBgZHRzSGVhZGVyRmlsZWAgaW4gY29uZmlnID4gYGR0c0hlYWRlcmAgaW4gY2xpIGZsYWcgPiBgZHRzSGVhZGVyYCBpbiBjb25maWdcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVyID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICAgIGpvaW4odGhpcy5vcHRpb25zLmN3ZCwgdGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZSksXG4gICAgICAgICAgICAndXRmLTgnLFxuICAgICAgICAgIClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlYWQgZHRzIGhlYWRlciBmaWxlICR7dGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZX1gLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZHRzSGVhZGVyKSB7XG4gICAgICAgIGhlYWRlciA9IGR0c0hlYWRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyID0gREVGQVVMVF9UWVBFX0RFRl9IRUFERVJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHJlYWRkaXJBc3luYyh0eXBlRGVmRGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnTm8gdHlwZSBkZWYgZmlsZXMgZm91bmQuIFNraXAgZ2VuZXJhdGluZyBkdHMgZmlsZS4nKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoIWZpbGUuaXNGaWxlKCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkdHM6IGZpbGVEdHMsIGV4cG9ydHM6IGZpbGVFeHBvcnRzIH0gPSBhd2FpdCBwcm9jZXNzVHlwZURlZihcbiAgICAgICAgam9pbih0eXBlRGVmRGlyLCBmaWxlLm5hbWUpLFxuICAgICAgICB0aGlzLm9wdGlvbnMuY29uc3RFbnVtID8/IHRoaXMuY29uZmlnLmNvbnN0RW51bSA/PyB0cnVlLFxuICAgICAgKVxuXG4gICAgICBkdHMgKz0gZmlsZUR0c1xuICAgICAgZXhwb3J0cy5wdXNoKC4uLmZpbGVFeHBvcnRzKVxuICAgIH1cblxuICAgIGlmIChkdHMuaW5kZXhPZignRXh0ZXJuYWxPYmplY3Q8JykgPiAtMSkge1xuICAgICAgaGVhZGVyICs9IGBcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV4dGVybmFsT2JqZWN0PFQ+IHtcbiAgcmVhZG9ubHkgJyc6IHtcbiAgICByZWFkb25seSAnJzogdW5pcXVlIHN5bWJvbFxuICAgIFtLOiBzeW1ib2xdOiBUXG4gIH1cbn1cbmBcbiAgICB9XG5cbiAgICBpZiAoZHRzLmluZGV4T2YoJ1R5cGVkQXJyYXknKSA+IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9IEludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheSB8IEJpZ0ludDY0QXJyYXkgfCBCaWdVaW50NjRBcnJheVxuYFxuICAgIH1cblxuICAgIGR0cyA9IGhlYWRlciArIGR0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKCdXcml0aW5nIHR5cGUgZGVmIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBkdHMsICd1dGYtOCcpXG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7IGtpbmQ6ICdkdHMnLCBwYXRoOiBkZXN0IH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0eXBlIGRlZiBmaWxlJylcbiAgICAgIGRlYnVnLmVycm9yKGUgYXMgRXJyb3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVKc0JpbmRpbmcoaWRlbnRzOiBzdHJpbmdbXSkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLm9wdGlvbnMucGxhdGZvcm0gfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgdGhpcy5vcHRpb25zLm5vSnNCaW5kaW5nIHx8XG4gICAgICBpZGVudHMubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5vcHRpb25zLmpzQmluZGluZyA/PyAnaW5kZXguanMnXG5cbiAgICBjb25zdCBjcmVhdGVCaW5kaW5nID0gdGhpcy5vcHRpb25zLmVzbSA/IGNyZWF0ZUVzbUJpbmRpbmcgOiBjcmVhdGVDanNCaW5kaW5nXG4gICAgY29uc3QgYmluZGluZyA9IGNyZWF0ZUJpbmRpbmcoXG4gICAgICB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lLFxuICAgICAgdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICBpZGVudHMsXG4gICAgKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBuYW1lKVxuICAgICAgZGVidWcoJ1dyaXRpbmcganMgYmluZGluZyB0bzonKVxuICAgICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgYmluZGluZywgJ3V0Zi04JylcbiAgICAgIHJldHVybiB7IGtpbmQ6ICdqcycsIHBhdGg6IGRlc3QgfSBzYXRpc2ZpZXMgT3V0cHV0XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gd3JpdGUganMgYmluZGluZyBmaWxlJywgeyBjYXVzZTogZSB9KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVXYXNpQmluZGluZyhcbiAgICBkaXN0RmlsZU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgaWRlbnRzOiBzdHJpbmdbXSxcbiAgKSB7XG4gICAgaWYgKGRpc3RGaWxlTmFtZSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBkaXIgfSA9IHBhcnNlKGRpc3RGaWxlTmFtZSlcbiAgICAgIGNvbnN0IGJpbmRpbmdQYXRoID0gam9pbihkaXIsIGAke3RoaXMuY29uZmlnLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgIGNvbnN0IGJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICAgIGRpcixcbiAgICAgICAgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgIClcbiAgICAgIGNvbnN0IHdvcmtlclBhdGggPSBqb2luKGRpciwgJ3dhc2ktd29ya2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyV29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXItYnJvd3Nlci5tanMnKVxuICAgICAgY29uc3QgYnJvd3NlckVudHJ5UGF0aCA9IGpvaW4oZGlyLCAnYnJvd3Nlci5qcycpXG4gICAgICBjb25zdCBleHBvcnRzQ29kZSA9XG4gICAgICAgIGBtb2R1bGUuZXhwb3J0cyA9IF9fbmFwaU1vZHVsZS5leHBvcnRzXFxuYCArXG4gICAgICAgIGlkZW50c1xuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAoaWRlbnQpID0+XG4gICAgICAgICAgICAgIGBtb2R1bGUuZXhwb3J0cy4ke2lkZW50fSA9IF9fbmFwaU1vZHVsZS5leHBvcnRzLiR7aWRlbnR9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICApICtcbiAgICAgICAgICBleHBvcnRzQ29kZSArXG4gICAgICAgICAgJ1xcbicsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyhcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmluaXRpYWxNZW1vcnksXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8ubWF4aW11bU1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5mcyxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5hc3luY0luaXQsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uYnVmZmVyLFxuICAgICAgICApICtcbiAgICAgICAgICBgZXhwb3J0IGRlZmF1bHQgX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgICBpZGVudHNcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgICBgZXhwb3J0IGNvbnN0ICR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMod29ya2VyUGF0aCwgV0FTSV9XT1JLRVJfVEVNUExBVEUsICd1dGY4JylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyV29ya2VyUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nKHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzID8/IGZhbHNlKSxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJFbnRyeVBhdGgsXG4gICAgICAgIGBleHBvcnQgKiBmcm9tICcke3RoaXMuY29uZmlnLnBhY2thZ2VOYW1lfS13YXNtMzItd2FzaSdcXG5gLFxuICAgICAgKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBiaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJCaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IHdvcmtlclBhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBicm93c2VyV29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJFbnRyeVBhdGggfSxcbiAgICAgIF0gc2F0aXNmaWVzIE91dHB1dFtdXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZJZk5vdEV4aXN0cyhlbnY6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGlmICghcHJvY2Vzcy5lbnZbZW52XSkge1xuICAgICAgdGhpcy5lbnZzW2Vudl0gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydjcmVhdGUtbnBtLWRpcnMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbnBtIHBhY2thZ2UgZGlycyBmb3IgZGlmZmVyZW50IHBsYXRmb3Jtc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5wbURpcnNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnMoXG4gIG9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zLFxuKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnc2VtdmVyJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbiAgQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQge1xuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWROYXBpQ29uZmlnLFxuICBta2RpckFzeW5jIGFzIHJhd01rZGlyQXN5bmMsXG4gIHBpY2ssXG4gIHdyaXRlRmlsZUFzeW5jIGFzIHJhd1dyaXRlRmlsZUFzeW5jLFxuICBUYXJnZXQsXG4gIHR5cGUgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnY3JlYXRlLW5wbS1kaXJzJylcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlTWV0YSB7XG4gICdkaXN0LXRhZ3MnOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5wbURpcnModXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBhc3luYyBmdW5jdGlvbiBta2RpckFzeW5jKGRpcjogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1RyeSB0byBjcmVhdGUgZGlyOiAlaScsIGRpcilcbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd01rZGlyQXN5bmMoZGlyLCB7XG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUFzeW5jKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1dyaXRpbmcgZmlsZSAlaScsIGZpbGUpXG5cbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGRlYnVnKGNvbnRlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdXcml0ZUZpbGVBc3luYyhmaWxlLCBjb250ZW50KVxuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IG5wbVBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpcilcblxuICBkZWJ1ZyhgUmVhZCBjb250ZW50IGZyb20gWyR7b3B0aW9ucy5jb25maWdQYXRoID8/IHBhY2thZ2VKc29uUGF0aH1dYClcblxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbiB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBqb2luKG5wbVBhdGgsIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YClcbiAgICBhd2FpdCBta2RpckFzeW5jKHRhcmdldERpcilcblxuICAgIGNvbnN0IGJpbmFyeUZpbGVOYW1lID1cbiAgICAgIHRhcmdldC5hcmNoID09PSAnd2FzbTMyJ1xuICAgICAgICA/IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgOiBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lm5vZGVgXG4gICAgY29uc3Qgc2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzID0ge1xuICAgICAgbmFtZTogYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIGNwdTogdGFyZ2V0LmFyY2ggIT09ICd1bml2ZXJzYWwnID8gW3RhcmdldC5hcmNoXSA6IHVuZGVmaW5lZCxcbiAgICAgIG1haW46IGJpbmFyeUZpbGVOYW1lLFxuICAgICAgZmlsZXM6IFtiaW5hcnlGaWxlTmFtZV0sXG4gICAgICAuLi5waWNrKFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2tleXdvcmRzJyxcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdhdXRob3JzJyxcbiAgICAgICAgJ2hvbWVwYWdlJyxcbiAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAnZW5naW5lcycsXG4gICAgICAgICdyZXBvc2l0b3J5JyxcbiAgICAgICAgJ2J1Z3MnLFxuICAgICAgKSxcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcgPSBwaWNrKFxuICAgICAgICBwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnLFxuICAgICAgICAncmVnaXN0cnknLFxuICAgICAgICAnYWNjZXNzJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhcmdldC5hcmNoICE9PSAnd2FzbTMyJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ub3MgPSBbdGFyZ2V0LnBsYXRmb3JtXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubWFpbiA9IGVudHJ5XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyID0gYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZmlsZXM/LnB1c2goXG4gICAgICAgIGVudHJ5LFxuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyLFxuICAgICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICAgIClcbiAgICAgIGxldCBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IHRydWVcbiAgICAgIGlmIChzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzPy5ub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBtYWpvciB9ID0gcGFyc2Uoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcy5ub2RlKSA/PyB7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ham9yID49IDE0KSB7XG4gICAgICAgICAgICBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMgPSB7XG4gICAgICAgICAgbm9kZTogJz49MTQuMC4wJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzbVJ1bnRpbWUgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL0BuYXBpLXJzL3dhc20tcnVudGltZWAsXG4gICAgICApLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSBhcyBQcm9taXNlPFBhY2thZ2VNZXRhPilcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgJ0BuYXBpLXJzL3dhc20tcnVudGltZSc6IGBeJHt3YXNtUnVudGltZVsnZGlzdC10YWdzJ10ubGF0ZXN0fWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hYmkgPT09ICdnbnUnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydnbGliYyddXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWJpID09PSAnbXVzbCcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ211c2wnXVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBhY2thZ2VKc29uID0gam9pbih0YXJnZXREaXIsICdwYWNrYWdlLmpzb24nKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgdGFyZ2V0UGFja2FnZUpzb24sXG4gICAgICBKU09OLnN0cmluZ2lmeShzY29wZWRQYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJyxcbiAgICApXG4gICAgY29uc3QgdGFyZ2V0UmVhZG1lID0gam9pbih0YXJnZXREaXIsICdSRUFETUUubWQnKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHRhcmdldFJlYWRtZSwgcmVhZG1lKHBhY2thZ2VOYW1lLCB0YXJnZXQpKVxuXG4gICAgZGVidWcuaW5mbyhgJHtwYWNrYWdlTmFtZX0gLSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0gY3JlYXRlZGApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHRhcmdldDogVGFyZ2V0KSB7XG4gIHJldHVybiBgIyBcXGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9XFxgXG5cblRoaXMgaXMgdGhlICoqJHt0YXJnZXQudHJpcGxlfSoqIGJpbmFyeSBmb3IgXFxgJHtwYWNrYWdlTmFtZX1cXGBcbmBcbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5pbXBvcnQgKiBhcyB0eXBhbmlvbiBmcm9tICd0eXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VOZXdDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ25ldyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIGEgbmV3IHByb2plY3Qgd2l0aCBwcmUtY29uZmlndXJlZCBib2lsZXJwbGF0ZScsXG4gIH0pXG5cbiAgJCRwYXRoID0gT3B0aW9uLlN0cmluZyh7IHJlcXVpcmVkOiBmYWxzZSB9KVxuXG4gICQkbmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbmFtZSwtbicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IGlmIG5vdCBwcm92aWRlZCcsXG4gIH0pXG5cbiAgbWluTm9kZUFwaVZlcnNpb24gPSBPcHRpb24uU3RyaW5nKCctLW1pbi1ub2RlLWFwaSwtdicsICc0Jywge1xuICAgIHZhbGlkYXRvcjogdHlwYW5pb24uaXNOdW1iZXIoKSxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydCcsXG4gIH0pXG5cbiAgcGFja2FnZU1hbmFnZXIgPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtbWFuYWdlcicsICd5YXJuJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LicsXG4gIH0pXG5cbiAgbGljZW5zZSA9IE9wdGlvbi5TdHJpbmcoJy0tbGljZW5zZSwtbCcsICdNSVQnLCB7XG4gICAgZGVzY3JpcHRpb246ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0cyA9IE9wdGlvbi5BcnJheSgnLS10YXJnZXRzLC10JywgW10sIHtcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci4nLFxuICB9KVxuXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWRlZmF1bHQtdGFyZ2V0cycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlQWxsVGFyZ2V0cyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1hbGwtdGFyZ2V0cycsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlVHlwZURlZiA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS10eXBlLWRlZicsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvbicsXG4gIH0pXG5cbiAgZW5hYmxlR2l0aHViQWN0aW9ucyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1naXRodWItYWN0aW9ucycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZ2VuZXJhdGUgcHJlY29uZmlndXJlZCBHaXRIdWIgQWN0aW9ucyB3b3JrZmxvdycsXG4gIH0pXG5cbiAgdGVzdEZyYW1ld29yayA9IE9wdGlvbi5TdHJpbmcoJy0tdGVzdC1mcmFtZXdvcmsnLCAnYXZhJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3cnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciB0byBydW4gdGhlIGNvbW1hbmQgaW4gZHJ5LXJ1biBtb2RlJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB0aGlzLiQkcGF0aCxcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgbWluTm9kZUFwaVZlcnNpb246IHRoaXMubWluTm9kZUFwaVZlcnNpb24sXG4gICAgICBwYWNrYWdlTWFuYWdlcjogdGhpcy5wYWNrYWdlTWFuYWdlcixcbiAgICAgIGxpY2Vuc2U6IHRoaXMubGljZW5zZSxcbiAgICAgIHRhcmdldHM6IHRoaXMudGFyZ2V0cyxcbiAgICAgIGVuYWJsZURlZmF1bHRUYXJnZXRzOiB0aGlzLmVuYWJsZURlZmF1bHRUYXJnZXRzLFxuICAgICAgZW5hYmxlQWxsVGFyZ2V0czogdGhpcy5lbmFibGVBbGxUYXJnZXRzLFxuICAgICAgZW5hYmxlVHlwZURlZjogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogdGhpcy5lbmFibGVHaXRodWJBY3Rpb25zLFxuICAgICAgdGVzdEZyYW1ld29yazogdGhpcy50ZXN0RnJhbWV3b3JrLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB3aGVyZSB0aGUgTkFQSS1SUyBwcm9qZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBOb2RlLUFQSSB2ZXJzaW9uIHRvIHN1cHBvcnRcbiAgICpcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgbWluTm9kZUFwaVZlcnNpb24/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlIG1hbmFnZXIgdG8gdXNlLiBPbmx5IHN1cHBvcnQgeWFybiA0LnggZm9yIG5vdy5cbiAgICpcbiAgICogQGRlZmF1bHQgJ3lhcm4nXG4gICAqL1xuICBwYWNrYWdlTWFuYWdlcj86IHN0cmluZ1xuICAvKipcbiAgICogTGljZW5zZSBmb3Igb3Blbi1zb3VyY2VkIHByb2plY3RcbiAgICpcbiAgICogQGRlZmF1bHQgJ01JVCdcbiAgICovXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgYWxsIHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVuYWJsZUFsbFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGVUeXBlRGVmPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZUdpdGh1YkFjdGlvbnM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgSmF2YVNjcmlwdCB0ZXN0IGZyYW1ld29yayB0byB1c2UsIG9ubHkgc3VwcG9ydCBgYXZhYCBmb3Igbm93XG4gICAqXG4gICAqIEBkZWZhdWx0ICdhdmEnXG4gICAqL1xuICB0ZXN0RnJhbWV3b3JrPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGVcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyeVJ1bj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9uczogTmV3T3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIG1pbk5vZGVBcGlWZXJzaW9uOiA0LFxuICAgIHBhY2thZ2VNYW5hZ2VyOiAneWFybicsXG4gICAgbGljZW5zZTogJ01JVCcsXG4gICAgdGFyZ2V0czogW10sXG4gICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRydWUsXG4gICAgZW5hYmxlQWxsVGFyZ2V0czogZmFsc2UsXG4gICAgZW5hYmxlVHlwZURlZjogdHJ1ZSxcbiAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0cnVlLFxuICAgIHRlc3RGcmFtZXdvcms6ICdhdmEnLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCkge1xuICBpZiAodC5oYXMoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiA9IHJlcXVpcmUoXCIuL2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24uanNcIik7XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMoZSwgYSkge1xuICBjaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIGEpLCBhLmFkZChlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGNoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24gPSByZXF1aXJlKFwiLi9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uLmpzXCIpO1xuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoZSwgdCwgYSkge1xuICBjaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpLCB0LnNldChlLCBhKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfYXNzZXJ0Q2xhc3NCcmFuZChlLCB0LCBuKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlID09PSB0IDogZS5oYXModCkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHQgOiBuO1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IG9uIHRoaXMgb2JqZWN0XCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0Q2xhc3NCcmFuZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBhc3NlcnRDbGFzc0JyYW5kID0gcmVxdWlyZShcIi4vYXNzZXJ0Q2xhc3NCcmFuZC5qc1wiKTtcbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIocywgYSkge1xuICByZXR1cm4gcy5nZXQoYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc1ByaXZhdGVGaWVsZEdldDIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLy8gQmFyZSBrZXlzIG1heSBvbmx5IGNvbnRhaW4gQVNDSUkgbGV0dGVycyxcbi8vIEFTQ0lJIGRpZ2l0cywgdW5kZXJzY29yZXMsIGFuZCBkYXNoZXMgKEEtWmEtejAtOV8tKS5cbmZ1bmN0aW9uIGpvaW5LZXlzKGtleXMpIHtcbiAgLy8gRG90dGVkIGtleXMgYXJlIGEgc2VxdWVuY2Ugb2YgYmFyZSBvciBxdW90ZWQga2V5cyBqb2luZWQgd2l0aCBhIGRvdC5cbiAgLy8gVGhpcyBhbGxvd3MgZm9yIGdyb3VwaW5nIHNpbWlsYXIgcHJvcGVydGllcyB0b2dldGhlcjpcbiAgcmV0dXJuIGtleXMubWFwKChzdHIpPT57XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDAgfHwgc3RyLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID8gSlNPTi5zdHJpbmdpZnkoc3RyKSA6IHN0cjtcbiAgfSkuam9pbihcIi5cIik7XG59XG5jbGFzcyBEdW1wZXIge1xuICBtYXhQYWQgPSAwO1xuICBzcmNPYmplY3Q7XG4gIG91dHB1dCA9IFtdO1xuICAjYXJyYXlUeXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHNyY09iamMpe1xuICAgIHRoaXMuc3JjT2JqZWN0ID0gc3JjT2JqYztcbiAgfVxuICBkdW1wKGZtdE9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNwcmludE9iamVjdCh0aGlzLnNyY09iamVjdCk7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLiNmb3JtYXQoZm10T3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICB9XG4gICNwcmludE9iamVjdChvYmosIGtleXMgPSBbXSkge1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBjb25zdCBpbmxpbmVQcm9wcyA9IFtdO1xuICAgIGNvbnN0IG11bHRpbGluZVByb3BzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKXtcbiAgICAgIGlmICh0aGlzLiNpc1NpbXBseVNlcmlhbGl6YWJsZShvYmpbcHJvcF0pKSB7XG4gICAgICAgIGlubGluZVByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aWxpbmVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRQcm9wcyA9IGlubGluZVByb3BzLmNvbmNhdChtdWx0aWxpbmVQcm9wcyk7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHNvcnRlZFByb3BzKXtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNkYXRlRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI3N0ckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI251bWJlckRlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jYm9vbERlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXlUeXBlID0gdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoYXJyYXlUeXBlID09PSBcIk9OTFlfUFJJTUlUSVZFXCIpIHtcbiAgICAgICAgICBvdXQucHVzaCh0aGlzLiNhcnJheURlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5VHlwZSA9PT0gXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIikge1xuICAgICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgICAgICAgICBvdXQucHVzaCh0aGlzLiNoZWFkZXJHcm91cChbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuI3ByaW50T2JqZWN0KHZhbHVlW2ldLCBbXG4gICAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICAgIHByb3BcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbXBsZXggYXJyYXksIHVzZSB0aGUgaW5saW5lIGZvcm1hdC5cbiAgICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIG91dC5wdXNoKGAke3RoaXMuI2RlY2xhcmF0aW9uKFtcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKX1bJHtzdHJ9XWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvdXQucHVzaChcIlwiKTtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jaGVhZGVyKFtcbiAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgIHByb3BcbiAgICAgICAgXSkpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB0b1BhcnNlID0gdmFsdWU7XG4gICAgICAgICAgb3V0LnB1c2goLi4udGhpcy4jcHJpbnRPYmplY3QodG9QYXJzZSwgW1xuICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICBdKSk7XG4gICAgICAgIH1cbiAgICAgIC8vIG91dC5wdXNoKC4uLnRoaXMuX3BhcnNlKHZhbHVlLCBgJHtwYXRofSR7cHJvcH0uYCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQucHVzaChcIlwiKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gICNpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgW1xuICAgICAgXCJzdHJpbmdcIixcbiAgICAgIFwibnVtYmVyXCIsXG4gICAgICBcImJvb2xlYW5cIlxuICAgIF0uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbiAgfVxuICAjZ2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKHRoaXMuI2FycmF5VHlwZUNhY2hlLmhhcyhhcnIpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jYXJyYXlUeXBlQ2FjaGUuZ2V0KGFycik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLiNkb0dldFR5cGVPZkFycmF5KGFycik7XG4gICAgdGhpcy4jYXJyYXlUeXBlQ2FjaGUuc2V0KGFyciwgdHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgI2RvR2V0VHlwZU9mQXJyYXkoYXJyKSB7XG4gICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAvLyBhbnkgdHlwZSBzaG91bGQgYmUgZmluZVxuICAgICAgcmV0dXJuIFwiT05MWV9QUklNSVRJVkVcIjtcbiAgICB9XG4gICAgY29uc3Qgb25seVByaW1pdGl2ZSA9IHRoaXMuI2lzUHJpbWl0aXZlKGFyclswXSk7XG4gICAgaWYgKGFyclswXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gXCJNSVhFRFwiO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChvbmx5UHJpbWl0aXZlICE9PSB0aGlzLiNpc1ByaW1pdGl2ZShhcnJbaV0pIHx8IGFycltpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcIk1JWEVEXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbmx5UHJpbWl0aXZlID8gXCJPTkxZX1BSSU1JVElWRVwiIDogXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIjtcbiAgfVxuICAjcHJpbnRBc0lubGluZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGBcIiR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1cImA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb25zdCBzdHIgPSB2YWx1ZS5tYXAoKHgpPT50aGlzLiNwcmludEFzSW5saW5lVmFsdWUoeCkpLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGBbJHtzdHJ9XWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RyID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2V5KT0+e1xuICAgICAgICByZXR1cm4gYCR7am9pbktleXMoW1xuICAgICAgICAgIGtleVxuICAgICAgICBdKX0gPSAkey8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh2YWx1ZVtrZXldKX1gO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYHske3N0cn19YDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoXCIpO1xuICB9XG4gICNpc1NpbXBseVNlcmlhbGl6YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpcy4jZ2V0VHlwZU9mQXJyYXkodmFsdWUpICE9PSBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiO1xuICB9XG4gICNoZWFkZXIoa2V5cykge1xuICAgIHJldHVybiBgWyR7am9pbktleXMoa2V5cyl9XWA7XG4gIH1cbiAgI2hlYWRlckdyb3VwKGtleXMpIHtcbiAgICByZXR1cm4gYFtbJHtqb2luS2V5cyhrZXlzKX1dXWA7XG4gIH1cbiAgI2RlY2xhcmF0aW9uKGtleXMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGpvaW5LZXlzKGtleXMpO1xuICAgIGlmICh0aXRsZS5sZW5ndGggPiB0aGlzLm1heFBhZCkge1xuICAgICAgdGhpcy5tYXhQYWQgPSB0aXRsZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aXRsZX0gPSBgO1xuICB9XG4gICNhcnJheURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI3N0ckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gIH1cbiAgI251bWJlckRlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX1uYW5gO1xuICAgIH1cbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBJbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfWluZmA7XG4gICAgICBjYXNlIC1JbmZpbml0eTpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfS1pbmZgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dmFsdWV9YDtcbiAgICB9XG4gIH1cbiAgI2Jvb2xEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3ZhbHVlfWA7XG4gIH1cbiAgI3ByaW50RGF0ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIGR0UGFkKHYsIGxQYWQgPSAyKSB7XG4gICAgICByZXR1cm4gdi5wYWRTdGFydChsUGFkLCBcIjBcIik7XG4gICAgfVxuICAgIGNvbnN0IG0gPSBkdFBhZCgodmFsdWUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGQgPSBkdFBhZCh2YWx1ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgaCA9IGR0UGFkKHZhbHVlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbWluID0gZHRQYWQodmFsdWUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IHMgPSBkdFBhZCh2YWx1ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgbXMgPSBkdFBhZCh2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKS50b1N0cmluZygpLCAzKTtcbiAgICAvLyBmb3JtYXR0ZWQgZGF0ZVxuICAgIGNvbnN0IGZEYXRhID0gYCR7dmFsdWUuZ2V0VVRDRnVsbFllYXIoKX0tJHttfS0ke2R9VCR7aH06JHttaW59OiR7c30uJHttc31gO1xuICAgIHJldHVybiBmRGF0YTtcbiAgfVxuICAjZGF0ZURlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dGhpcy4jcHJpbnREYXRlKHZhbHVlKX1gO1xuICB9XG4gICNmb3JtYXQob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBrZXlBbGlnbm1lbnQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByRGVjbGFyYXRpb24gPSAvXihcXFwiLipcXFwifFtePV0qKVxccz0vO1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCBsID0gdGhpcy5vdXRwdXRbaV07XG4gICAgICAvLyB3ZSBrZWVwIGVtcHR5IGVudHJ5IGZvciBhcnJheSBvZiBvYmplY3RzXG4gICAgICBpZiAobFswXSA9PT0gXCJbXCIgJiYgbFsxXSAhPT0gXCJbXCIpIHtcbiAgICAgICAgLy8gbm9uLWVtcHR5IG9iamVjdCB3aXRoIG9ubHkgc3Vib2JqZWN0cyBhcyBwcm9wZXJ0aWVzXG4gICAgICAgIGlmICh0aGlzLm91dHB1dFtpICsgMV0gPT09IFwiXCIgJiYgdGhpcy5vdXRwdXRbaSArIDJdPy5zbGljZSgwLCBsLmxlbmd0aCkgPT09IGwuc2xpY2UoMCwgLTEpICsgXCIuXCIpIHtcbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5QWxpZ25tZW50KSB7XG4gICAgICAgICAgY29uc3QgbSA9IHJEZWNsYXJhdGlvbi5leGVjKGwpO1xuICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGwucmVwbGFjZShtWzFdLCBtWzFdLnBhZEVuZCh0aGlzLm1heFBhZCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuaW5nIG11bHRpcGxlIHNwYWNlc1xuICAgIGNvbnN0IGNsZWFuZWRPdXRwdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGwgPSBvdXRbaV07XG4gICAgICBpZiAoIShsID09PSBcIlwiICYmIG91dFtpICsgMV0gPT09IFwiXCIpKSB7XG4gICAgICAgIGNsZWFuZWRPdXRwdXQucHVzaChsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsZWFuZWRPdXRwdXQ7XG4gIH1cbn1cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IHRvIGEge0BsaW5rIGh0dHBzOi8vdG9tbC5pbyB8IFRPTUx9IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZSBVc2FnZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCJAc3RkL3RvbWwvc3RyaW5naWZ5XCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCBvYmogPSB7XG4gKiAgIHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLFxuICogICBvd25lcjoge1xuICogICAgIG5hbWU6IFwiQm9iXCIsXG4gKiAgICAgYmlvOiBcIkJvYiBpcyBhIGNvb2wgZ3V5XCIsXG4gKiAgfVxuICogfTtcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBzdHJpbmdpZnkob2JqKTtcbiAqIGFzc2VydEVxdWFscyh0b21sU3RyaW5nLCBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXFxuXFxuW293bmVyXVxcbm5hbWUgPSBcIkJvYlwiXFxuYmlvID0gXCJCb2IgaXMgYSBjb29sIGd1eVwiXFxuYCk7XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogU291cmNlIG9iamVjdFxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3Igc3RyaW5naWZ5aW5nLlxuICogQHJldHVybnMgVE9NTCBzdHJpbmdcbiAqLyBleHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IER1bXBlcihvYmopLmR1bXAob3B0aW9ucykuam9pbihcIlxcblwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ2lmeS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBnaXZlbiBhcnJheSwgcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAqICoqaW4gcGxhY2UuIFRoaXMgbWVhbnMgYGFycmF5YCB3aWxsIGJlIG1vZGlmaWVkISoqLlxuICovIGV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJJblBsYWNlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgbGV0IG91dHB1dEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBjdXIgb2YgYXJyYXkpe1xuICAgIGlmICghcHJlZGljYXRlKGN1cikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhcnJheVtvdXRwdXRJbmRleF0gPSBjdXI7XG4gICAgb3V0cHV0SW5kZXggKz0gMTtcbiAgfVxuICBhcnJheS5zcGxpY2Uob3V0cHV0SW5kZXgpO1xuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdXRpbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGZpbHRlckluUGxhY2UgfSBmcm9tIFwiLi9fdXRpbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UocmVjb3JkLCBvdGhlciwgb3B0aW9ucykge1xuICByZXR1cm4gZGVlcE1lcmdlSW50ZXJuYWwocmVjb3JkLCBvdGhlciwgbmV3IFNldCgpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZUludGVybmFsKHJlY29yZCwgb3RoZXIsIHNlZW4sIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGtleXMgPSBuZXcgU2V0KFtcbiAgICAuLi5nZXRLZXlzKHJlY29yZCksXG4gICAgLi4uZ2V0S2V5cyhvdGhlcilcbiAgXSk7XG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGtleSBvZiBvdGhlciBvYmplY3QgYW5kIHVzZSBjb3JyZWN0IG1lcmdpbmcgc3RyYXRlZ3lcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgLy8gU2tpcCB0byBwcmV2ZW50IE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fIGFjY2Vzc29yIHByb3BlcnR5IGNhbGxzIG9uIG5vbi1EZW5vIHBsYXRmb3Jtc1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBhID0gcmVjb3JkW2tleV07XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKG90aGVyLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYiA9IG90aGVyW2tleV07XG4gICAgaWYgKGlzTm9uTnVsbE9iamVjdChhKSAmJiBpc05vbk51bGxPYmplY3QoYikgJiYgIXNlZW4uaGFzKGEpICYmICFzZWVuLmhhcyhiKSkge1xuICAgICAgc2Vlbi5hZGQoYSk7XG4gICAgICBzZWVuLmFkZChiKTtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPYmplY3RzKGEsIGIsIHNlZW4sIG9wdGlvbnMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHZhbHVlXG4gICAgcmVzdWx0W2tleV0gPSBiO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdHMobGVmdCwgcmlnaHQsIHNlZW4sIG9wdGlvbnMgPSB7XG4gIGFycmF5czogXCJtZXJnZVwiLFxuICBzZXRzOiBcIm1lcmdlXCIsXG4gIG1hcHM6IFwibWVyZ2VcIlxufSkge1xuICAvLyBSZWN1cnNpdmVseSBtZXJnZSBtZXJnZWFibGUgb2JqZWN0c1xuICBpZiAoaXNNZXJnZWFibGUobGVmdCkgJiYgaXNNZXJnZWFibGUocmlnaHQpKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZUludGVybmFsKGxlZnQsIHJpZ2h0LCBzZWVuLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShsZWZ0KSAmJiBpc0l0ZXJhYmxlKHJpZ2h0KSkge1xuICAgIC8vIEhhbmRsZSBhcnJheXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsZWZ0KSAmJiBBcnJheS5pc0FycmF5KHJpZ2h0KSkge1xuICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIG1hcHNcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIE1hcCAmJiByaWdodCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgaWYgKG9wdGlvbnMubWFwcyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKFtcbiAgICAgICAgICAuLi5sZWZ0LFxuICAgICAgICAgIC4uLnJpZ2h0XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgc2V0c1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU2V0ICYmIHJpZ2h0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBpZiAob3B0aW9ucy5zZXRzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoW1xuICAgICAgICAgIC4uLmxlZnQsXG4gICAgICAgICAgLi4ucmlnaHRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByaWdodDtcbn1cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaXMgbWVyZ2VhYmxlIG9yIG5vdFxuICogQnVpbHRpbnMgdGhhdCBsb29rIGxpa2Ugb2JqZWN0cywgbnVsbCBhbmQgdXNlciBkZWZpbmVkIGNsYXNzZXNcbiAqIGFyZSBub3QgY29uc2lkZXJlZCBtZXJnZWFibGUgKGl0IG1lYW5zIHRoYXQgcmVmZXJlbmNlIHdpbGwgYmUgY29waWVkKVxuICovIGZ1bmN0aW9uIGlzTWVyZ2VhYmxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gaXNJdGVyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gZ2V0S2V5cyhyZWNvcmQpIHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhyZWNvcmQpO1xuICBmaWx0ZXJJblBsYWNlKHJlc3VsdCwgKGtleSk9Pk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChyZWNvcmQsIGtleSkpO1xuICByZXN1bHQucHVzaCguLi5PYmplY3Qua2V5cyhyZWNvcmQpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXBfbWVyZ2UuanMubWFwIiwidmFyIGFzc2VydENsYXNzQnJhbmQgPSByZXF1aXJlKFwiLi9hc3NlcnRDbGFzc0JyYW5kLmpzXCIpO1xuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihzLCBhLCByKSB7XG4gIHJldHVybiBzLnNldChhc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBkZWVwTWVyZ2UgfSBmcm9tIFwiQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXAtbWVyZ2VcIjtcbi8qKlxuICogQ29weSBvZiBgaW1wb3J0IHsgaXNMZWFwIH0gZnJvbSBcIkBzdGQvZGF0ZXRpbWVcIjtgIGJlY2F1c2UgaXQgY2Fubm90IGJlIGltcG90ZWQgYXMgbG9uZyBhcyBpdCBpcyB1bnN0YWJsZS5cbiAqLyBmdW5jdGlvbiBpc0xlYXAoeWVhck51bWJlcikge1xuICByZXR1cm4geWVhck51bWJlciAlIDQgPT09IDAgJiYgeWVhck51bWJlciAlIDEwMCAhPT0gMCB8fCB5ZWFyTnVtYmVyICUgNDAwID09PSAwO1xufVxuZXhwb3J0IGNsYXNzIFNjYW5uZXIge1xuICAjd2hpdGVzcGFjZSA9IC9bIFxcdF0vO1xuICAjcG9zaXRpb24gPSAwO1xuICAjc291cmNlO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2Upe1xuICAgIHRoaXMuI3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uO1xuICB9XG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBpbmRleCAtIHJlbGF0aXZlIGluZGV4IGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gY2hhcihpbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlW3RoaXMuI3Bvc2l0aW9uICsgaW5kZXhdID8/IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzbGljZWQgc3RyaW5nXG4gICAqIEBwYXJhbSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZW5kIC0gZW5kIHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2Uuc2xpY2UodGhpcy4jcG9zaXRpb24gKyBzdGFydCwgdGhpcy4jcG9zaXRpb24gKyBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIHBvc2l0aW9uIHRvIG5leHRcbiAgICovIG5leHQoY291bnQgPSAxKSB7XG4gICAgdGhpcy4jcG9zaXRpb24gKz0gY291bnQ7XG4gIH1cbiAgc2tpcFdoaXRlc3BhY2VzKCkge1xuICAgIHdoaWxlKHRoaXMuI3doaXRlc3BhY2UudGVzdCh0aGlzLmNoYXIoKSkgJiYgIXRoaXMuZW9mKCkpe1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIC8vIEludmFsaWQgaWYgY3VycmVudCBjaGFyIGlzIG90aGVyIGtpbmRzIG9mIHdoaXRlc3BhY2VcbiAgICBpZiAoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmIC9cXHMvLnRlc3QodGhpcy5jaGFyKCkpKSB7XG4gICAgICBjb25zdCBlc2NhcGVkID0gXCJcXFxcdVwiICsgdGhpcy5jaGFyKCkuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IEl0IGNvbnRhaW5zIGludmFsaWQgd2hpdGVzcGFjZSBhdCBwb3NpdGlvbiAnJHtwb3NpdGlvbn0nOiBcXGAke2VzY2FwZWR9XFxgYCk7XG4gICAgfVxuICB9XG4gIG5leHRVbnRpbENoYXIob3B0aW9ucyA9IHtcbiAgICBza2lwQ29tbWVudHM6IHRydWVcbiAgfSkge1xuICAgIHdoaWxlKCF0aGlzLmVvZigpKXtcbiAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLmNoYXIoKTtcbiAgICAgIGlmICh0aGlzLiN3aGl0ZXNwYWNlLnRlc3QoY2hhcikgfHwgdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2tpcENvbW1lbnRzICYmIHRoaXMuY2hhcigpID09PSBcIiNcIikge1xuICAgICAgICAvLyBlbnRlcmluZyBjb21tZW50XG4gICAgICAgIHdoaWxlKCF0aGlzLmlzQ3VycmVudENoYXJFT0woKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUG9zaXRpb24gcmVhY2hlZCBFT0Ygb3Igbm90XG4gICAqLyBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uID49IHRoaXMuI3NvdXJjZS5sZW5ndGg7XG4gIH1cbiAgaXNDdXJyZW50Q2hhckVPTCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyKCkgPT09IFwiXFxuXCIgfHwgdGhpcy5zdGFydHNXaXRoKFwiXFxyXFxuXCIpO1xuICB9XG4gIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZywgdGhpcy4jcG9zaXRpb24pO1xuICB9XG4gIG1hdGNoKHJlZ0V4cCkge1xuICAgIGlmICghcmVnRXhwLnN0aWNreSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdFeHAgJHtyZWdFeHB9IGRvZXMgbm90IGhhdmUgYSBzdGlja3kgJ3knIGZsYWdgKTtcbiAgICB9XG4gICAgcmVnRXhwLmxhc3RJbmRleCA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2UubWF0Y2gocmVnRXhwKTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN1Y2Nlc3MoYm9keSkge1xuICByZXR1cm4ge1xuICAgIG9rOiB0cnVlLFxuICAgIGJvZHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGZhaWx1cmUoKSB7XG4gIHJldHVybiB7XG4gICAgb2s6IGZhbHNlXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhlIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBlLmcuIGB1bmZsYXQoW1wiYVwiLCBcImJcIiwgXCJjXCJdLCAxKWAgcmV0dXJucyBgeyBhOiB7IGI6IHsgYzogMSB9IH0gfWBcbiAqLyBleHBvcnQgZnVuY3Rpb24gdW5mbGF0KGtleXMsIHZhbHVlcyA9IHt9KSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZVJpZ2h0KChhY2MsIGtleSk9Pih7XG4gICAgICBba2V5XTogYWNjXG4gICAgfSksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKSB7XG4gIGNvbnN0IGtleSA9IGtleXNbMF07XG4gIGlmICgha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHRoZSBUT01MOiBrZXkgbGVuZ3RoIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5mdW5jdGlvbiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IGtleXMsIHR5cGUsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgdmFsdWUpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgY29uc3QgbGFzdCA9IGN1cnJlbnRWYWx1ZS5hdCgtMSk7XG4gICAgZGVlcEFzc2lnbihsYXN0LCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgdGFibGUpIHtcbiAgY29uc3QgeyB0eXBlLCBrZXlzLCB2YWx1ZSB9ID0gdGFibGU7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldFRhcmdldFZhbHVlKHRhcmdldCwga2V5cyk7XG4gIGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgdW5mbGF0KGtleXMsIFtcbiAgICAgIHZhbHVlXG4gICAgXSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgYm9keSkge1xuICBzd2l0Y2goYm9keS50eXBlKXtcbiAgICBjYXNlIFwiQmxvY2tcIjpcbiAgICAgIHJldHVybiBkZWVwTWVyZ2UodGFyZ2V0LCBib2R5LnZhbHVlKTtcbiAgICBjYXNlIFwiVGFibGVcIjpcbiAgICAgIHJldHVybiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCBib2R5KTtcbiAgICBjYXNlIFwiVGFibGVBcnJheVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgYm9keSk7XG4gIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbWJpbmF0b3JzIGFuZCBnZW5lcmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBvcihwYXJzZXJzKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBmb3IgKGNvbnN0IHBhcnNlIG9mIHBhcnNlcnMpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2Uoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZmFpbHVyZSgpO1xuICB9O1xufVxuLyoqIEpvaW4gdGhlIHBhcnNlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHBhcnNlciBpbnRvIGFuIGFycmF5LlxuICpcbiAqIElmIHRoZSBwYXJzZXIgZmFpbHMgYXQgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICovIGZ1bmN0aW9uIGpvaW4ocGFyc2VyLCBzZXBhcmF0b3IpIHtcbiAgY29uc3QgU2VwYXJhdG9yID0gY2hhcmFjdGVyKHNlcGFyYXRvcik7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBmaXJzdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWZpcnN0Lm9rKSByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICAgIG91dC5wdXNoKGZpcnN0LmJvZHkpO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGlmICghU2VwYXJhdG9yKHNjYW5uZXIpLm9rKSBicmVhaztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChyZXN1bHQuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG91dCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogVGhpcyByZXF1aXJlcyB0aGUgcGFyc2VyIHRvIHN1Y2NlZWQgYXQgbGVhc3Qgb25jZS5cbiAqLyBmdW5jdGlvbiBqb2luMShwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgb3V0ID0gW1xuICAgICAgZmlyc3QuYm9keVxuICAgIF07XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGt2KGtleVBhcnNlciwgc2VwYXJhdG9yLCB2YWx1ZVBhcnNlcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHBvc2l0aW9uID0gc2Nhbm5lci5wb3NpdGlvbjtcbiAgICBjb25zdCBrZXkgPSBrZXlQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFrZXkub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgc2VwID0gU2VwYXJhdG9yKHNjYW5uZXIpO1xuICAgIGlmICghc2VwLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYGtleS92YWx1ZSBwYWlyIGRvZXNuJ3QgaGF2ZSBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCF2YWx1ZS5vaykge1xuICAgICAgY29uc3QgbGluZUVuZEluZGV4ID0gc2Nhbm5lci5zb3VyY2UuaW5kZXhPZihcIlxcblwiLCBzY2FubmVyLnBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gbGluZUVuZEluZGV4ID4gMCA/IGxpbmVFbmRJbmRleCA6IHNjYW5uZXIuc291cmNlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxpbmUgPSBzY2FubmVyLnNvdXJjZS5zbGljZShwb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdmFsdWUgb24gbGluZSAnJHtsaW5lfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3ModW5mbGF0KGtleS5ib2R5LCB2YWx1ZS5ib2R5KSk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZShwYXJzZXIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBsZXQgYm9keSA9IHt9O1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlc3VsdC5ib2R5KXtcbiAgICAgIGlmICh0eXBlb2YgcmVjb3JkID09PSBcIm9iamVjdFwiICYmIHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gZGVlcE1lcmdlKGJvZHksIHJlY29yZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVwZWF0KHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICAgIGJvZHkucHVzaChyZXN1bHQuYm9keSk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgICB9XG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gc3Vycm91bmQobGVmdCwgcGFyc2VyLCByaWdodCkge1xuICBjb25zdCBMZWZ0ID0gY2hhcmFjdGVyKGxlZnQpO1xuICBjb25zdCBSaWdodCA9IGNoYXJhY3RlcihyaWdodCk7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBpZiAoIUxlZnQoc2Nhbm5lcikub2spIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIGlmICghUmlnaHQoc2Nhbm5lcikub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm90IGNsb3NlZCBieSBcIiR7cmlnaHR9XCIgYWZ0ZXIgc3RhcnRlZCB3aXRoIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKHJlc3VsdC5ib2R5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlcihzdHIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoc3RyKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBzY2FubmVyLm5leHQoc3RyLmxlbmd0aCk7XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICByZXR1cm4gc3VjY2Vzcyh1bmRlZmluZWQpO1xuICB9O1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlciBjb21wb25lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQkFSRV9LRVlfUkVHRVhQID0gL1tBLVphLXowLTlfLV0rL3k7XG5leHBvcnQgZnVuY3Rpb24gYmFyZUtleShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IGtleSA9IHNjYW5uZXIubWF0Y2goQkFSRV9LRVlfUkVHRVhQKT8uWzBdO1xuICBpZiAoIWtleSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KGtleS5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhrZXkpO1xufVxuZnVuY3Rpb24gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcikge1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXFxcXFwiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgLy8gU2VlIGh0dHBzOi8vdG9tbC5pby9lbi92MS4wLjAtcmMuMyNzdHJpbmdcbiAgc3dpdGNoKHNjYW5uZXIuY2hhcigpKXtcbiAgICBjYXNlIFwiYlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcYlwiKTtcbiAgICBjYXNlIFwidFwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcdFwiKTtcbiAgICBjYXNlIFwiblwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcblwiKTtcbiAgICBjYXNlIFwiZlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcZlwiKTtcbiAgICBjYXNlIFwiclwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcclwiKTtcbiAgICBjYXNlIFwidVwiOlxuICAgIGNhc2UgXCJVXCI6XG4gICAgICB7XG4gICAgICAgIC8vIFVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGNvZGVQb2ludExlbiA9IHNjYW5uZXIuY2hhcigpID09PSBcInVcIiA/IDQgOiA2O1xuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBwYXJzZUludChcIjB4XCIgKyBzY2FubmVyLnNsaWNlKDEsIDEgKyBjb2RlUG9pbnRMZW4pLCAxNik7XG4gICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgIHNjYW5uZXIubmV4dChjb2RlUG9pbnRMZW4gKyAxKTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moc3RyKTtcbiAgICAgIH1cbiAgICBjYXNlICdcIic6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKCdcIicpO1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxcXFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXCR7c2Nhbm5lci5jaGFyKCl9YCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBiYXNpY1N0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJyAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgU2luZ2xlLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICBzY2FubmVyLm5leHQoKTsgLy8gc2tpcCBsYXN0ICdcIlwiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIikgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gXCInXCIgJiYgIXNjYW5uZXIuZW9mKCkpe1xuICAgIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiU2luZ2xlLWxpbmUgc3RyaW5nIGNhbm5vdCBjb250YWluIEVPTFwiKTtcbiAgICB9XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgXCInXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKCdcIlwiXCInKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgLy8gbGluZSBlbmRpbmcgYmFja3NsYXNoXG4gICAgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXHJcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKTtcbiAgICBpZiAoZXNjYXBlZENoYXIub2spIHtcbiAgICAgIGFjYy5wdXNoKGVzY2FwZWRDaGFyLmJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgXCJgLCBwdXNoIHRoZSBmaXN0IGBcImAgdG8gc3RyaW5nXG4gIGlmIChzY2FubmVyLmNoYXIoMykgPT09ICdcIicpIHtcbiAgICBhY2MucHVzaCgnXCInKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCAnXCJcIlwiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KDMpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfSBlbHNlIGlmIChzY2FubmVyLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoQ1JMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgyKTtcbiAgfVxuICBjb25zdCBhY2MgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBNdWx0aS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgLy8gaWYgZW5kcyB3aXRoIDQgYCdgLCBwdXNoIHRoZSBmaXN0IGAnYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gXCInXCIpIHtcbiAgICBhY2MucHVzaChcIidcIik7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KDMpOyAvLyBza2lwIGxhc3QgXCInJydcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5jb25zdCBCT09MRUFOX1JFR0VYUCA9IC8oPzp0cnVlfGZhbHNlKVxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goQk9PTEVBTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IHN0cmluZyA9PT0gXCJ0cnVlXCI7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IElORklOSVRZX01BUCA9IG5ldyBNYXAoW1xuICBbXG4gICAgXCJpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCIraW5mXCIsXG4gICAgSW5maW5pdHlcbiAgXSxcbiAgW1xuICAgIFwiLWluZlwiLFxuICAgIC1JbmZpbml0eVxuICBdXG5dKTtcbmNvbnN0IElORklOSVRZX1JFR0VYUCA9IC9bKy1dP2luZlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXR5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElORklOSVRZX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gSU5GSU5JVFlfTUFQLmdldChzdHJpbmcpO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5jb25zdCBOQU5fUkVHRVhQID0gL1srLV0/bmFuXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbmFuKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE5BTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IE5hTjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0IGRvdHRlZEtleSA9IGpvaW4xKG9yKFtcbiAgYmFyZUtleSxcbiAgYmFzaWNTdHJpbmcsXG4gIGxpdGVyYWxTdHJpbmdcbl0pLCBcIi5cIik7XG5jb25zdCBCSU5BUllfUkVHRVhQID0gLzBiWzAxXSsoPzpfWzAxXSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCSU5BUllfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDIpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IE9DVEFMX1JFR0VYUCA9IC8wb1swLTddKyg/Ol9bMC03XSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIG9jdGFsKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE9DVEFMX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2guc2xpY2UoMikucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBIRVhfUkVHRVhQID0gLzB4WzAtOWEtZl0rKD86X1swLTlhLWZdKykqXFxiL3lpO1xuZXhwb3J0IGZ1bmN0aW9uIGhleChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChIRVhfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlcihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChJTlRFR0VSX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2gucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IGludCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiBzdWNjZXNzKGludCk7XG59XG5jb25zdCBGTE9BVF9SRUdFWFAgPSAvWystXT8oPzowfFsxLTldWzAtOV0qKD86X1swLTldKykqKSg/OlxcLlswLTldKyg/Ol9bMC05XSspKik/KD86ZVsrLV0/WzAtOV0rKD86X1swLTldKykqKT9cXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goRkxPQVRfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgZmxvYXQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKGlzTmFOKGZsb2F0KSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoZmxvYXQpO1xufVxuY29uc3QgREFURV9USU1FX1JFR0VYUCA9IC8oPzx5ZWFyPlxcZHs0fSktKD88bW9udGg+XFxkezJ9KS0oPzxkYXk+XFxkezJ9KSg/OlsgMC05VFouOistXSspP1xcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKERBVEVfVElNRV9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gIC8vIHNwZWNpYWwgY2FzZSBpZiBtb250aCBpcyBGZWJydWFyeVxuICBpZiAoZ3JvdXBzLm1vbnRoID09IFwiMDJcIikge1xuICAgIGNvbnN0IGRheXMgPSBwYXJzZUludChncm91cHMuZGF5KTtcbiAgICBpZiAoZGF5cyA+IDI5KSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChncm91cHMueWVhcik7XG4gICAgaWYgKGRheXMgPiAyOCAmJiAhaXNMZWFwKHllYXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcudHJpbSgpKTtcbiAgLy8gaW52YWxpZCBkYXRlXG4gIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gIH1cbiAgcmV0dXJuIHN1Y2Nlc3MoZGF0ZSk7XG59XG5jb25zdCBMT0NBTF9USU1FX1JFR0VYUCA9IC8oXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KSg/OlxcLlswLTldKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKExPQ0FMX1RJTUVfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MobWF0Y2gpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VmFsdWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiW1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICBhcnJheS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIC8vIG1heSBoYXZlIGEgbmV4dCBpdGVtLCBidXQgdHJhaWxpbmcgY29tbWEgaXMgYWxsb3dlZCBhdCBhcnJheVxuICAgIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXVwiKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBcnJheSBpcyBub3QgY2xvc2VkXCIpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYXJyYXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVRhYmxlKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoMSkgPT09IFwifVwiKSB7XG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICAgIHJldHVybiBzdWNjZXNzKHt9KTtcbiAgfVxuICBjb25zdCBwYWlycyA9IHN1cnJvdW5kKFwie1wiLCBqb2luKHBhaXIsIFwiLFwiKSwgXCJ9XCIpKHNjYW5uZXIpO1xuICBpZiAoIXBhaXJzLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBsZXQgdGFibGUgPSB7fTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzLmJvZHkpe1xuICAgIHRhYmxlID0gZGVlcE1lcmdlKHRhYmxlLCBwYWlyKTtcbiAgfVxuICByZXR1cm4gc3VjY2Vzcyh0YWJsZSk7XG59XG5leHBvcnQgY29uc3QgdmFsdWUgPSBvcihbXG4gIG11bHRpbGluZUJhc2ljU3RyaW5nLFxuICBtdWx0aWxpbmVMaXRlcmFsU3RyaW5nLFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZyxcbiAgYm9vbGVhbixcbiAgaW5maW5pdHksXG4gIG5hbixcbiAgZGF0ZVRpbWUsXG4gIGxvY2FsVGltZSxcbiAgYmluYXJ5LFxuICBvY3RhbCxcbiAgaGV4LFxuICBmbG9hdCxcbiAgaW50ZWdlcixcbiAgYXJyYXlWYWx1ZSxcbiAgaW5saW5lVGFibGVcbl0pO1xuZXhwb3J0IGNvbnN0IHBhaXIgPSBrdihkb3R0ZWRLZXksIFwiPVwiLCB2YWx1ZSk7XG5leHBvcnQgZnVuY3Rpb24gYmxvY2soc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2UocmVwZWF0KHBhaXIpKShzY2FubmVyKTtcbiAgaWYgKHJlc3VsdC5vaykgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiQmxvY2tcIixcbiAgICB2YWx1ZTogcmVzdWx0LmJvZHlcbiAgfSk7XG4gIHJldHVybiBmYWlsdXJlKCk7XG59XG5leHBvcnQgY29uc3QgdGFibGVIZWFkZXIgPSBzdXJyb3VuZChcIltcIiwgZG90dGVkS2V5LCBcIl1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgaGVhZGVyID0gdGFibGVIZWFkZXIoc2Nhbm5lcik7XG4gIGlmICghaGVhZGVyLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgYiA9IGJsb2NrKHNjYW5uZXIpO1xuICByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJUYWJsZVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge31cbiAgfSk7XG59XG5leHBvcnQgY29uc3QgdGFibGVBcnJheUhlYWRlciA9IHN1cnJvdW5kKFwiW1tcIiwgZG90dGVkS2V5LCBcIl1dXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIHRhYmxlQXJyYXkoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgaGVhZGVyID0gdGFibGVBcnJheUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlQXJyYXlcIixcbiAgICBrZXlzOiBoZWFkZXIuYm9keSxcbiAgICB2YWx1ZTogYi5vayA/IGIuYm9keS52YWx1ZSA6IHt9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvbWwoc2Nhbm5lcikge1xuICBjb25zdCBibG9ja3MgPSByZXBlYXQob3IoW1xuICAgIGJsb2NrLFxuICAgIHRhYmxlQXJyYXksXG4gICAgdGFibGVcbiAgXSkpKHNjYW5uZXIpO1xuICBpZiAoIWJsb2Nrcy5vaykgcmV0dXJuIHN1Y2Nlc3Moe30pO1xuICBjb25zdCBib2R5ID0gYmxvY2tzLmJvZHkucmVkdWNlKGRlZXBBc3NpZ24sIHt9KTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHN0cmluZyA9IHNjYW5uZXIuc291cmNlLnNsaWNlKDAsIHNjYW5uZXIucG9zaXRpb24pO1xuICBjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3Qgcm93ID0gbGluZXMubGVuZ3RoO1xuICBjb25zdCBjb2x1bW4gPSBsaW5lcy5hdCgtMSk/Lmxlbmd0aCA/PyAwO1xuICByZXR1cm4gYFBhcnNlIGVycm9yIG9uIGxpbmUgJHtyb3d9LCBjb2x1bW4gJHtjb2x1bW59OiAke21lc3NhZ2V9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGYWN0b3J5KHBhcnNlcikge1xuICByZXR1cm4gKHRvbWxTdHJpbmcpPT57XG4gICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRvbWxTdHJpbmcpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rICYmIHNjYW5uZXIuZW9mKCkpIHJldHVybiByZXN1bHQuYm9keTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJHtzY2FubmVyLmNoYXIoKX1cImA7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBlcnJvciB0eXBlIGNhdWdodFwiO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpKTtcbiAgICB9XG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcGFyc2VyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBwYXJzZXJGYWN0b3J5LCB0b21sIH0gZnJvbSBcIi4vX3BhcnNlci5qc1wiO1xuLyoqXG4gKiBQYXJzZXMgYSB7QGxpbmsgaHR0cHM6Ly90b21sLmlvIHwgVE9NTH0gc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQHN0ZC90b21sL3BhcnNlXCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCB0b21sU3RyaW5nID0gYHRpdGxlID0gXCJUT01MIEV4YW1wbGVcIlxuICogW293bmVyXVxuICogbmFtZSA9IFwiQWxpY2VcIlxuICogYmlvID0gXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCJgO1xuICpcbiAqIGNvbnN0IG9iaiA9IHBhcnNlKHRvbWxTdHJpbmcpO1xuICogYXNzZXJ0RXF1YWxzKG9iaiwgeyB0aXRsZTogXCJUT01MIEV4YW1wbGVcIiwgb3duZXI6IHsgbmFtZTogXCJBbGljZVwiLCBiaW86IFwiQWxpY2UgaXMgYSBwcm9ncmFtbWVyLlwiIH0gfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB0b21sU3RyaW5nIFRPTUwgc3RyaW5nIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgSlMgb2JqZWN0LlxuICovIGV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0b21sU3RyaW5nKSB7XG4gIHJldHVybiBwYXJzZXJGYWN0b3J5KHRvbWwpKHRvbWxTdHJpbmcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VSZW5hbWVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3JlbmFtZSddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3QnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gICQkbmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbmFtZSwtbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdCcsXG4gIH0pXG5cbiAgYmluYXJ5TmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYmluYXJ5LW5hbWUsLWInLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IGJpbmFyeSBuYW1lICoubm9kZSBmaWxlcycsXG4gIH0pXG5cbiAgcGFja2FnZU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtbmFtZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBtYW5pZmVzdFBhdGggPSBPcHRpb24uU3RyaW5nKCctLW1hbmlmZXN0LXBhdGgnLCAnQ2FyZ28udG9tbCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYENhcmdvLnRvbWxgJyxcbiAgfSlcblxuICByZXBvc2l0b3J5Pzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1yZXBvc2l0b3J5Jywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyByZXBvc2l0b3J5IG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBkZXNjcmlwdGlvbj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZGVzY3JpcHRpb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICBuYW1lOiB0aGlzLiQkbmFtZSxcbiAgICAgIGJpbmFyeU5hbWU6IHRoaXMuYmluYXJ5TmFtZSxcbiAgICAgIHBhY2thZ2VOYW1lOiB0aGlzLnBhY2thZ2VOYW1lLFxuICAgICAgbWFuaWZlc3RQYXRoOiB0aGlzLm1hbmlmZXN0UGF0aCxcbiAgICAgIHJlcG9zaXRvcnk6IHRoaXMucmVwb3NpdG9yeSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbmFtZSB0aGUgTkFQSS1SUyBwcm9qZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVuYW1lT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IG5hbWUgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzXG4gICAqL1xuICBiaW5hcnlOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IHBhY2thZ2UgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcGFja2FnZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYENhcmdvLnRvbWxgXG4gICAqXG4gICAqIEBkZWZhdWx0ICdDYXJnby50b21sJ1xuICAgKi9cbiAgbWFuaWZlc3RQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3RcbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zKG9wdGlvbnM6IFJlbmFtZU9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIG1hbmlmZXN0UGF0aDogJ0NhcmdvLnRvbWwnLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgcmVuYW1lIH0gZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCB7IHJlc29sdmUsIGpvaW4gfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlVG9tbCwgc3RyaW5naWZ5IGFzIHN0cmluZ2lmeVRvbWwgfSBmcm9tICdAc3RkL3RvbWwnXG5pbXBvcnQgeyBsb2FkIGFzIHlhbWxQYXJzZSwgZHVtcCBhcyB5YW1sU3RyaW5naWZ5IH0gZnJvbSAnanMteWFtbCdcbmltcG9ydCB7IGlzTmlsLCBtZXJnZSwgb21pdEJ5LCBwaWNrIH0gZnJvbSAnbG9kYXNoLWVzJ1xuaW1wb3J0IHsgZmluZFVwIH0gZnJvbSAnZmluZC11cCdcblxuaW1wb3J0IHsgYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucywgUmVuYW1lT3B0aW9ucyB9IGZyb20gJy4uL2RlZi9yZW5hbWUuanMnXG5pbXBvcnQgeyByZWFkQ29uZmlnLCByZWFkRmlsZUFzeW5jLCB3cml0ZUZpbGVBc3luYyB9IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lUHJvamVjdCh1c2VyT3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgbmFwaUNvbmZpZyA9IGF3YWl0IHJlYWRDb25maWcob3B0aW9ucylcbiAgY29uc3Qgb2xkTmFtZSA9IG5hcGlDb25maWcuYmluYXJ5TmFtZVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCBjYXJnb1RvbWxQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5tYW5pZmVzdFBhdGgpXG5cbiAgY29uc3QgcGFja2FnZUpzb25Db250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYWNrYWdlSnNvblBhdGgsICd1dGY4JylcbiAgY29uc3QgcGFja2FnZUpzb25EYXRhID0gSlNPTi5wYXJzZShwYWNrYWdlSnNvbkNvbnRlbnQpXG5cbiAgbWVyZ2UoXG4gICAgcGFja2FnZUpzb25EYXRhLFxuICAgIG9taXRCeShwaWNrKG9wdGlvbnMsIFsnbmFtZScsICdkZXNjcmlwdGlvbicsICdhdXRob3InLCAnbGljZW5zZSddKSwgaXNOaWwpLFxuICAgIHtcbiAgICAgIG5hcGk6IG9taXRCeShcbiAgICAgICAge1xuICAgICAgICAgIGJpbmFyeU5hbWU6IG9wdGlvbnMuYmluYXJ5TmFtZSxcbiAgICAgICAgICBwYWNrYWdlTmFtZTogb3B0aW9ucy5wYWNrYWdlTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNOaWwsXG4gICAgICApLFxuICAgIH0sXG4gIClcblxuICBpZiAob3B0aW9ucy5jb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aClcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgY29uc3QgY29uZmlnRGF0YSA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudClcbiAgICBjb25maWdEYXRhLmJpbmFyeU5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICBjb25maWdEYXRhLnBhY2thZ2VOYW1lID0gb3B0aW9ucy5wYWNrYWdlTmFtZVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGNvbmZpZ0RhdGEsIG51bGwsIDIpKVxuICB9XG5cbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uRGF0YSwgbnVsbCwgMiksXG4gIClcblxuICBjb25zdCB0b21sQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY2FyZ29Ub21sUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBjYXJnb1RvbWwgPSBwYXJzZVRvbWwodG9tbENvbnRlbnQpIGFzIGFueVxuXG4gIC8vIFVwZGF0ZSB0aGUgcGFja2FnZSBuYW1lXG4gIGlmIChjYXJnb1RvbWwucGFja2FnZSAmJiBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICAvLyBTYW5pdGl6ZSB0aGUgYmluYXJ5IG5hbWUgZm9yIFJ1c3QgcGFja2FnZSBuYW1pbmcgY29udmVudGlvbnNcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAucmVwbGFjZSgnQCcsICcnKVxuICAgICAgLnJlcGxhY2UoJy8nLCAnXycpXG4gICAgICAucmVwbGFjZSgvLS9nLCAnXycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgIGNhcmdvVG9tbC5wYWNrYWdlLm5hbWUgPSBzYW5pdGl6ZWROYW1lXG4gIH1cblxuICAvLyBTdHJpbmdpZnkgdGhlIHVwZGF0ZWQgVE9NTFxuICBjb25zdCB1cGRhdGVkVG9tbENvbnRlbnQgPSBzdHJpbmdpZnlUb21sKGNhcmdvVG9tbClcblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCB1cGRhdGVkVG9tbENvbnRlbnQpXG4gIGlmIChvbGROYW1lICE9PSBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICBjb25zdCBnaXRodWJBY3Rpb25zUGF0aCA9IGF3YWl0IGZpbmRVcCgnLmdpdGh1YicsIHtcbiAgICAgIGN3ZDogb3B0aW9ucy5jd2QsXG4gICAgICB0eXBlOiAnZGlyZWN0b3J5JyxcbiAgICB9KVxuICAgIGlmIChnaXRodWJBY3Rpb25zUGF0aCkge1xuICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCA9IGpvaW4oXG4gICAgICAgIGdpdGh1YkFjdGlvbnNQYXRoLFxuICAgICAgICAnd29ya2Zsb3dzJyxcbiAgICAgICAgJ0NJLnltbCcsXG4gICAgICApXG4gICAgICBpZiAoZXhpc3RzU3luYyhnaXRodWJBY3Rpb25zQ0lZbWxQYXRoKSkge1xuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAndXRmOCcsXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0RhdGEgPSB5YW1sUGFyc2UoZ2l0aHViQWN0aW9uc0NvbnRlbnQpIGFzIGFueVxuICAgICAgICBpZiAoZ2l0aHViQWN0aW9uc0RhdGEuZW52Py5BUFBfTkFNRSkge1xuICAgICAgICAgIGdpdGh1YkFjdGlvbnNEYXRhLmVudi5BUFBfTkFNRSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAgIHlhbWxTdHJpbmdpZnkoZ2l0aHViQWN0aW9uc0RhdGEsIHtcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiAtMSxcbiAgICAgICAgICAgICAgbm9SZWZzOiB0cnVlLFxuICAgICAgICAgICAgICBzb3J0S2V5czogZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIGAke29sZE5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGpvaW4ob3B0aW9ucy5jd2QsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IG9sZFdhc2lCaW5kaW5nUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIGAke29sZE5hbWV9Lndhc2kuY2pzYClcbiAgICBpZiAoZXhpc3RzU3luYyhvbGRXYXNpQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBnaXRBdHRyaWJ1dGVzUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsICcuZ2l0YXR0cmlidXRlcycpXG4gICAgaWYgKGV4aXN0c1N5bmMoZ2l0QXR0cmlidXRlc1BhdGgpKSB7XG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgIGdpdEF0dHJpYnV0ZXNQYXRoLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzRGF0YSA9IGdpdEF0dHJpYnV0ZXNDb250ZW50XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBsaW5lXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgICAgICAgICAgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnJlcGxhY2UoYCR7b2xkTmFtZX0ud2FzaS5janNgLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhnaXRBdHRyaWJ1dGVzUGF0aCwgZ2l0QXR0cmlidXRlc0RhdGEpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBleGVjLCBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ25vZGU6ZnMnXG5cbmltcG9ydCB7IGxvYWQgYXMgeWFtbExvYWQsIGR1bXAgYXMgeWFtbER1bXAgfSBmcm9tICdqcy15YW1sJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHROZXdPcHRpb25zLFxuICBOZXdPcHRpb25zIGFzIFJhd05ld09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9uZXcuanMnXG5pbXBvcnQge1xuICBBVkFJTEFCTEVfVEFSR0VUUyxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RBUkdFVFMsXG4gIG1rZGlyQXN5bmMsXG4gIHJlYWRkaXJBc3luYyxcbiAgc3RhdEFzeW5jLFxuICBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5pbXBvcnQgeyBuYXBpRW5naW5lUmVxdWlyZW1lbnQgfSBmcm9tICcuLi91dGlscy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vcmVuYW1lLmpzJ1xuXG4vLyBUZW1wbGF0ZSBpbXBvcnRzIHJlbW92ZWQgYXMgd2UncmUgbm93IHVzaW5nIGV4dGVybmFsIHRlbXBsYXRlc1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnbmV3JylcblxudHlwZSBOZXdPcHRpb25zID0gUmVxdWlyZWQ8UmF3TmV3T3B0aW9ucz5cblxuY29uc3QgVEVNUExBVEVfUkVQT1MgPSB7XG4gIHlhcm46ICdodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9wYWNrYWdlLXRlbXBsYXRlJyxcbiAgcG5wbTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUtcG5wbScsXG59IGFzIGNvbnN0XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0Q29tbWFuZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgLS12ZXJzaW9uJylcbiAgICAgIGNwLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgIH0pXG4gICAgICBjcC5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYWNoZURpcihcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY2FjaGVEaXIgPSBwYXRoLmpvaW4oaG9tZWRpcigpLCAnLm5hcGktcnMnLCAndGVtcGxhdGUnLCBwYWNrYWdlTWFuYWdlcilcbiAgYXdhaXQgbWtkaXJBc3luYyhjYWNoZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgcmV0dXJuIGNhY2hlRGlyXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVGVtcGxhdGUoXG4gIHBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbiAgY2FjaGVEaXI6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXBvVXJsID0gVEVNUExBVEVfUkVQT1NbcGFja2FnZU1hbmFnZXJdXG4gIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuXG4gIGlmIChleGlzdHNTeW5jKHRlbXBsYXRlUGF0aCkpIHtcbiAgICBkZWJ1ZyhgVGVtcGxhdGUgY2FjaGUgZm91bmQgYXQgJHt0ZW1wbGF0ZVBhdGh9LCB1cGRhdGluZy4uLmApXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGxhdGVzdCBjaGFuZ2VzIGFuZCByZXNldCB0byByZW1vdGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgZmV0Y2ggb3JpZ2luJywgeyBjd2Q6IHRlbXBsYXRlUGF0aCB9KVxuICAgICAgICBjcC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggbGF0ZXN0IGNoYW5nZXMsIGdpdCBwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGV4ZWNTeW5jKCdnaXQgcmVzZXQgLS1oYXJkIG9yaWdpbi9tYWluJywge1xuICAgICAgICBjd2Q6IHRlbXBsYXRlUGF0aCxcbiAgICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgICAgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKGBGYWlsZWQgdG8gdXBkYXRlIHRlbXBsYXRlOiAke2Vycm9yfWApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKGBDbG9uaW5nIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfS4uLmApXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGBnaXQgY2xvbmUgJHtyZXBvVXJsfSByZXBvYCwgeyBjd2Q6IGNhY2hlRGlyLCBzdGRpbzogJ2luaGVyaXQnIH0pXG4gICAgICBkZWJ1ZygnVGVtcGxhdGUgY2xvbmVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNsb25lIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfTogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5RGlyZWN0b3J5KFxuICBzcmM6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBpbmNsdWRlV2FzaUJpbmRpbmdzOiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IG1rZGlyQXN5bmMoZGVzdCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIoc3JjLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBzcmNQYXRoID0gcGF0aC5qb2luKHNyYywgZW50cnkubmFtZSlcbiAgICBjb25zdCBkZXN0UGF0aCA9IHBhdGguam9pbihkZXN0LCBlbnRyeS5uYW1lKVxuXG4gICAgLy8gU2tpcCAuZ2l0IGRpcmVjdG9yeVxuICAgIGlmIChlbnRyeS5uYW1lID09PSAnLmdpdCcpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGF3YWl0IGNvcHlEaXJlY3Rvcnkoc3JjUGF0aCwgZGVzdFBhdGgsIGluY2x1ZGVXYXNpQmluZGluZ3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWluY2x1ZGVXYXNpQmluZGluZ3MgJiZcbiAgICAgICAgKGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLWJyb3dzZXIuanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLmNqcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnd2FzaS13b3JrZXIuYnJvd3Nlci5tanMgJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5tanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ2Jyb3dzZXIuanMnKSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgYXdhaXQgZnMuY29weUZpbGUoc3JjUGF0aCwgZGVzdFBhdGgpXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJblBhY2thZ2VKc29uKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudClcblxuICAvLyBGaWx0ZXIgbmFwaS50YXJnZXRzXG4gIGlmIChwYWNrYWdlSnNvbi5uYXBpPy50YXJnZXRzKSB7XG4gICAgcGFja2FnZUpzb24ubmFwaS50YXJnZXRzID0gcGFja2FnZUpzb24ubmFwaS50YXJnZXRzLmZpbHRlcihcbiAgICAgICh0YXJnZXQ6IHN0cmluZykgPT4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSxcbiAgICApXG4gIH1cblxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSArICdcXG4nKVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXJUYXJnZXRzSW5HaXRodWJBY3Rpb25zKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCB5YW1sID0geWFtbExvYWQoY29udGVudCkgYXMgYW55XG5cbiAgY29uc3QgbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgICAnYWFyY2g2NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgXSlcblxuICBjb25zdCBsaW51eFRhcmdldHMgPSBuZXcgU2V0KFtcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtZ251JyxcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FybXY3LXVua25vd24tbGludXgtZ251ZWFiaWhmJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtbGludXgtYW5kcm9pZCcsXG4gICAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgXSlcblxuICAvLyBDaGVjayBpZiBhbnkgTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZFxuICBjb25zdCBoYXNMaW51eFRhcmdldHMgPSBlbmFibGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+XG4gICAgbGludXhUYXJnZXRzLmhhcyh0YXJnZXQpLFxuICApXG5cbiAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIGJ1aWxkIGpvYlxuICBpZiAoeWFtbD8uam9icz8uYnVpbGQ/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzKSB7XG4gICAgeWFtbC5qb2JzLmJ1aWxkLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncyA9XG4gICAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcigoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZXR0aW5nLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgfVxuXG4gIGNvbnN0IGpvYnNUb1JlbW92ZTogc3RyaW5nW10gPSBbXVxuXG4gIGlmIChlbmFibGVkVGFyZ2V0cy5ldmVyeSgodGFyZ2V0KSA9PiAhbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cy5oYXModGFyZ2V0KSkpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyBqb2JcbiAgICBpZiAoXG4gICAgICB5YW1sPy5qb2JzPy5bJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzXG4gICAgKSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgICAgeWFtbC5qb2JzWyd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncy5maWx0ZXIoXG4gICAgICAgICAgKHNldHRpbmc6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIExpbnV4IHRhcmdldHMgYXJlIGVuYWJsZWQsIHJlbW92ZSBMaW51eC1zcGVjaWZpYyBqb2JzXG4gIGlmICghaGFzTGludXhUYXJnZXRzKSB7XG4gICAgLy8gUmVtb3ZlIHRlc3QtbGludXgtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXSkge1xuICAgICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3QtbGludXgtYmluZGluZycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8udGFyZ2V0KSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbGludXgtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQgPSB5YW1sLmpvYnNbXG4gICAgICAgICd0ZXN0LWxpbnV4LWJpbmRpbmcnXG4gICAgICBdLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQuZmlsdGVyKCh0YXJnZXQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LXdhc2knKVxuICB9XG5cbiAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcygneDg2XzY0LXVua25vd24tZnJlZWJzZCcpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ2J1aWxkLWZyZWVic2QnKVxuICB9XG5cbiAgLy8gRmlsdGVyIG90aGVyIHRlc3Qgam9icyBiYXNlZCBvbiB0YXJnZXRcbiAgZm9yIChjb25zdCBbam9iTmFtZSwgam9iQ29uZmlnXSBvZiBPYmplY3QuZW50cmllcyh5YW1sLmpvYnMgfHwge30pKSB7XG4gICAgaWYgKFxuICAgICAgam9iTmFtZS5zdGFydHNXaXRoKCd0ZXN0LScpICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1saW51eC14NjQtZ251LWJpbmRpbmcnXG4gICAgKSB7XG4gICAgICAvLyBFeHRyYWN0IHRhcmdldCBmcm9tIGpvYiBuYW1lIG9yIGNvbmZpZ1xuICAgICAgY29uc3Qgam9iID0gam9iQ29uZmlnIGFzIGFueVxuICAgICAgaWYgKGpvYi5zdHJhdGVneT8ubWF0cml4Py5zZXR0aW5ncz8uWzBdPy50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gam9iLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5nc1swXS50YXJnZXRcbiAgICAgICAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgam9ic1RvUmVtb3ZlLnB1c2goam9iTmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBqb2JzIGZvciBkaXNhYmxlZCB0YXJnZXRzXG4gIGZvciAoY29uc3Qgam9iTmFtZSBvZiBqb2JzVG9SZW1vdmUpIHtcbiAgICBkZWxldGUgeWFtbC5qb2JzW2pvYk5hbWVdXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh5YW1sLmpvYnM/LnB1Ymxpc2g/Lm5lZWRzKSkge1xuICAgIHlhbWwuam9icy5wdWJsaXNoLm5lZWRzID0geWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMuZmlsdGVyKFxuICAgICAgKG5lZWQ6IHN0cmluZykgPT4gIWpvYnNUb1JlbW92ZS5pbmNsdWRlcyhuZWVkKSxcbiAgICApXG4gIH1cblxuICAvLyBXcml0ZSBiYWNrIHRoZSBmaWx0ZXJlZCBZQU1MXG4gIGNvbnN0IHVwZGF0ZWRZYW1sID0geWFtbER1bXAoeWFtbCwge1xuICAgIGxpbmVXaWR0aDogLTEsXG4gICAgbm9SZWZzOiB0cnVlLFxuICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgfSlcbiAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCB1cGRhdGVkWWFtbClcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnUHJvY2Vzc2luZyBvcHRpb25zLi4uJylcbiAgaWYgKCFvcHRpb25zLnBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRoZSBwYXRoIGFzIHRoZSBhcmd1bWVudCcpXG4gIH1cbiAgb3B0aW9ucy5wYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIG9wdGlvbnMucGF0aClcbiAgZGVidWcoYFJlc29sdmVkIHRhcmdldCBwYXRoIHRvOiAke29wdGlvbnMucGF0aH1gKVxuXG4gIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gcGF0aC5wYXJzZShvcHRpb25zLnBhdGgpLmJhc2VcbiAgICBkZWJ1ZyhgTm8gcHJvamVjdCBuYW1lIHByb3ZpZGVkLCBmaXggaXQgdG8gZGlyIG5hbWU6ICR7b3B0aW9ucy5uYW1lfWApXG4gIH1cblxuICBpZiAoIW9wdGlvbnMudGFyZ2V0cz8ubGVuZ3RoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gQVZBSUxBQkxFX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgYWxsIHRhcmdldHMnKVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbmFibGVEZWZhdWx0VGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gREVGQVVMVF9UQVJHRVRTLmNvbmNhdCgpXG4gICAgICBkZWJ1ZygnRW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHRhcmdldCBtdXN0IGJlIGVuYWJsZWQnKVxuICAgIH1cbiAgfVxuICBpZiAoXG4gICAgb3B0aW9ucy50YXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycpXG4gICkge1xuICAgIGNvbnN0IG91dCA9IGV4ZWNTeW5jKGBydXN0dXAgdGFyZ2V0IGxpc3RgLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIH0pXG4gICAgaWYgKG91dC5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJykpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0cyA9IG9wdGlvbnMudGFyZ2V0cy5tYXAoKHRhcmdldCkgPT5cbiAgICAgICAgdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcydcbiAgICAgICAgICA/ICd3YXNtMzItd2FzaXAxLXRocmVhZHMnXG4gICAgICAgICAgOiB0YXJnZXQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9ucykgYXMgTmV3T3B0aW9uc1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3UHJvamVjdCh1c2VyT3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnV2lsbCBjcmVhdGUgbmFwaS1ycyBwcm9qZWN0IHdpdGggZ2l2ZW4gb3B0aW9uczonKVxuICBkZWJ1Zyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zID0gcHJvY2Vzc09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgZGVidWcoJ1RhcmdldHMgdG8gYmUgZW5hYmxlZDonKVxuICBkZWJ1ZyhvcHRpb25zLnRhcmdldHMpXG5cbiAgLy8gQ2hlY2sgaWYgZ2l0IGlzIGF2YWlsYWJsZVxuICBpZiAoIShhd2FpdCBjaGVja0dpdENvbW1hbmQoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR2l0IGlzIG5vdCBpbnN0YWxsZWQgb3Igbm90IGF2YWlsYWJsZSBpbiBQQVRILiBQbGVhc2UgaW5zdGFsbCBHaXQgdG8gY29udGludWUuJyxcbiAgICApXG4gIH1cblxuICBjb25zdCBwYWNrYWdlTWFuYWdlciA9IG9wdGlvbnMucGFja2FnZU1hbmFnZXIgYXMgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJcblxuICAvLyBFbnN1cmUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGVtcHR5XG4gIGF3YWl0IGVuc3VyZVBhdGgob3B0aW9ucy5wYXRoLCBvcHRpb25zLmRyeVJ1bilcblxuICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERvd25sb2FkIG9yIHVwZGF0ZSB0ZW1wbGF0ZVxuICAgICAgY29uc3QgY2FjaGVEaXIgPSBhd2FpdCBlbnN1cmVDYWNoZURpcihwYWNrYWdlTWFuYWdlcilcbiAgICAgIGF3YWl0IGRvd25sb2FkVGVtcGxhdGUocGFja2FnZU1hbmFnZXIsIGNhY2hlRGlyKVxuXG4gICAgICAvLyBDb3B5IHRlbXBsYXRlIGZpbGVzIHRvIHRhcmdldCBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShcbiAgICAgICAgdGVtcGxhdGVQYXRoLFxuICAgICAgICBvcHRpb25zLnBhdGgsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0cy5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyksXG4gICAgICApXG5cbiAgICAgIC8vIFJlbmFtZSBwcm9qZWN0IHVzaW5nIHRoZSByZW5hbWUgQVBJXG4gICAgICBhd2FpdCByZW5hbWVQcm9qZWN0KHtcbiAgICAgICAgY3dkOiBvcHRpb25zLnBhdGgsXG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgYmluYXJ5TmFtZTogZ2V0QmluYXJ5TmFtZShvcHRpb25zLm5hbWUpLFxuICAgICAgfSlcblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gcGFja2FnZS5qc29uXG4gICAgICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAncGFja2FnZS5qc29uJylcbiAgICAgIGlmIChleGlzdHNTeW5jKHBhY2thZ2VKc29uUGF0aCkpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciB0YXJnZXRzIGluIEdpdEh1YiBBY3Rpb25zIENJXG4gICAgICBjb25zdCBjaVBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicsICd3b3JrZmxvd3MnLCAnQ0kueW1sJylcbiAgICAgIGlmIChleGlzdHNTeW5jKGNpUGF0aCkgJiYgb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zKSB7XG4gICAgICAgIGF3YWl0IGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoY2lQYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zICYmXG4gICAgICAgIGV4aXN0c1N5bmMocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSlcbiAgICAgICkge1xuICAgICAgICAvLyBSZW1vdmUgLmdpdGh1YiBkaXJlY3RvcnkgaWYgR2l0SHViIEFjdGlvbnMgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgYXdhaXQgZnMucm0ocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSwge1xuICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHBhY2thZ2UuanNvbiB3aXRoIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbnNcbiAgICAgIGNvbnN0IHBrZ0pzb25Db250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUocGFja2FnZUpzb25QYXRoLCAndXRmLTgnKVxuICAgICAgY29uc3QgcGtnSnNvbiA9IEpTT04ucGFyc2UocGtnSnNvbkNvbnRlbnQpXG5cbiAgICAgIC8vIFVwZGF0ZSBlbmdpbmUgcmVxdWlyZW1lbnRcbiAgICAgIGlmICghcGtnSnNvbi5lbmdpbmVzKSB7XG4gICAgICAgIHBrZ0pzb24uZW5naW5lcyA9IHt9XG4gICAgICB9XG4gICAgICBwa2dKc29uLmVuZ2luZXMubm9kZSA9IG5hcGlFbmdpbmVSZXF1aXJlbWVudChvcHRpb25zLm1pbk5vZGVBcGlWZXJzaW9uKVxuXG4gICAgICAvLyBVcGRhdGUgbGljZW5zZSBpZiBkaWZmZXJlbnQgZnJvbSB0ZW1wbGF0ZVxuICAgICAgaWYgKG9wdGlvbnMubGljZW5zZSAmJiBwa2dKc29uLmxpY2Vuc2UgIT09IG9wdGlvbnMubGljZW5zZSkge1xuICAgICAgICBwa2dKc29uLmxpY2Vuc2UgPSBvcHRpb25zLmxpY2Vuc2VcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRlc3QgZnJhbWV3b3JrIGlmIG5lZWRlZFxuICAgICAgaWYgKG9wdGlvbnMudGVzdEZyYW1ld29yayAhPT0gJ2F2YScpIHtcbiAgICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBsb2dpYyB0byB1cGRhdGUgdGVzdCBzY3JpcHRzIGFuZCBkZXBlbmRlbmNpZXNcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYFRlc3QgZnJhbWV3b3JrICR7b3B0aW9ucy50ZXN0RnJhbWV3b3JrfSByZXF1ZXN0ZWQgYnV0IG5vdCB5ZXQgaW1wbGVtZW50ZWRgLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShwa2dKc29uLCBudWxsLCAyKSArICdcXG4nLFxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcHJvamVjdDogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGBQcm9qZWN0IGNyZWF0ZWQgYXQ6ICR7b3B0aW9ucy5wYXRofWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZVBhdGgocGF0aDogc3RyaW5nLCBkcnlSdW4gPSBmYWxzZSkge1xuICBjb25zdCBzdGF0ID0gYXdhaXQgc3RhdEFzeW5jKHBhdGgsIHt9KS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpXG5cbiAgLy8gZmlsZSBkZXNjcmlwdG9yIGV4aXN0c1xuICBpZiAoc3RhdCkge1xuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LmAsXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHBhdGgpXG4gICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGF0aCAke3BhdGh9IGZvciBjcmVhdGluZyBuZXcgbmFwaS1ycyBwcm9qZWN0IGFscmVhZHkgZXhpc3RzIGFuZCBpdCdzIG5vdCBlbXB0eS5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWApXG4gICAgICBpZiAoIWRyeVJ1bikge1xuICAgICAgICBhd2FpdCBta2RpckFzeW5jKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRhcmdldCBkaXJlY3Rvcnk6ICR7cGF0aH1gLCB7XG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbmFtZS5zcGxpdCgnLycpLnBvcCgpIVxufVxuXG5leHBvcnQgeyBOZXdPcHRpb25zIH1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlUHJlUHVibGlzaENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncHJlLXB1Ymxpc2gnXSwgWydwcmVwdWJsaXNoJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVXBkYXRlIHBhY2thZ2UuanNvbiBhbmQgY29weSBhZGRvbnMgaW50byBwZXIgcGxhdGZvcm0gcGFja2FnZXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpciwtcCcsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIHRhZ1N0eWxlID0gT3B0aW9uLlN0cmluZygnLS10YWctc3R5bGUsLS10YWdzdHlsZSwtdCcsICdsZXJuYScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ2dpdCB0YWcgc3R5bGUsIGBucG1gIG9yIGBsZXJuYWAnLFxuICB9KVxuXG4gIGdoUmVsZWFzZSA9IE9wdGlvbi5Cb29sZWFuKCctLWdoLXJlbGVhc2UnLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGNyZWF0ZSBHaXRIdWIgcmVsZWFzZScsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZ2gtcmVsZWFzZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnR2l0SHViIHJlbGVhc2UgbmFtZScsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlSWQ/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWdoLXJlbGVhc2UtaWQnLCB7XG4gICAgZGVzY3JpcHRpb246ICdFeGlzdGluZyBHaXRIdWIgcmVsZWFzZSBpZCcsXG4gIH0pXG5cbiAgc2tpcE9wdGlvbmFsUHVibGlzaCA9IE9wdGlvbi5Cb29sZWFuKCctLXNraXAtb3B0aW9uYWwtcHVibGlzaCcsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHNraXAgb3B0aW9uYWxEZXBlbmRlbmNpZXMgcGFja2FnZXMgcHVibGlzaCcsXG4gIH0pXG5cbiAgZHJ5UnVuID0gT3B0aW9uLkJvb2xlYW4oJy0tZHJ5LXJ1bicsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdEcnkgcnVuIHdpdGhvdXQgdG91Y2hpbmcgZmlsZSBzeXN0ZW0nLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIHRhZ1N0eWxlOiB0aGlzLnRhZ1N0eWxlLFxuICAgICAgZ2hSZWxlYXNlOiB0aGlzLmdoUmVsZWFzZSxcbiAgICAgIGdoUmVsZWFzZU5hbWU6IHRoaXMuZ2hSZWxlYXNlTmFtZSxcbiAgICAgIGdoUmVsZWFzZUlkOiB0aGlzLmdoUmVsZWFzZUlkLFxuICAgICAgc2tpcE9wdGlvbmFsUHVibGlzaDogdGhpcy5za2lwT3B0aW9uYWxQdWJsaXNoLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgcGFja2FnZS5qc29uIGFuZCBjb3B5IGFkZG9ucyBpbnRvIHBlciBwbGF0Zm9ybSBwYWNrYWdlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByZVB1Ymxpc2hPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGdpdCB0YWcgc3R5bGUsIGBucG1gIG9yIGBsZXJuYWBcbiAgICpcbiAgICogQGRlZmF1bHQgJ2xlcm5hJ1xuICAgKi9cbiAgdGFnU3R5bGU/OiAnbnBtJyB8ICdsZXJuYSdcbiAgLyoqXG4gICAqIFdoZXRoZXIgY3JlYXRlIEdpdEh1YiByZWxlYXNlXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdoUmVsZWFzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEdpdEh1YiByZWxlYXNlIG5hbWVcbiAgICovXG4gIGdoUmVsZWFzZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEV4aXN0aW5nIEdpdEh1YiByZWxlYXNlIGlkXG4gICAqL1xuICBnaFJlbGVhc2VJZD86IHN0cmluZ1xuICAvKipcbiAgICogV2hldGhlciBza2lwIG9wdGlvbmFsRGVwZW5kZW5jaWVzIHBhY2thZ2VzIHB1Ymxpc2hcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNraXBPcHRpb25hbFB1Ymxpc2g/OiBib29sZWFuXG4gIC8qKlxuICAgKiBEcnkgcnVuIHdpdGhvdXQgdG91Y2hpbmcgZmlsZSBzeXN0ZW1cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyeVJ1bj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zKG9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICB0YWdTdHlsZTogJ2xlcm5hJyxcbiAgICBnaFJlbGVhc2U6IHRydWUsXG4gICAgc2tpcE9wdGlvbmFsUHVibGlzaDogZmFsc2UsXG4gICAgZHJ5UnVuOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVZlcnNpb25Db21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3ZlcnNpb24nXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ1VwZGF0ZSB2ZXJzaW9uIGluIGNyZWF0ZWQgbnBtIHBhY2thZ2VzJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHZlcnNpb24gaW4gY3JlYXRlZCBucG0gcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZXJzaW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyhvcHRpb25zOiBWZXJzaW9uT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnMsIFZlcnNpb25PcHRpb25zIH0gZnJvbSAnLi4vZGVmL3ZlcnNpb24uanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICB1cGRhdGVQYWNrYWdlSnNvbixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCd2ZXJzaW9uJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcnNpb24odXNlck9wdGlvbnM6IFZlcnNpb25PcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiBjb25maWcudGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyLCB0YXJnZXQucGxhdGZvcm1BcmNoQUJJKVxuXG4gICAgZGVidWcoYFVwZGF0ZSB2ZXJzaW9uIHRvICVpIGluIFslaV1gLCBjb25maWcucGFja2FnZUpzb24udmVyc2lvbiwgcGtnRGlyKVxuICAgIGF3YWl0IHVwZGF0ZVBhY2thZ2VKc29uKGpvaW4ocGtnRGlyLCAncGFja2FnZS5qc29uJyksIHtcbiAgICAgIHZlcnNpb246IGNvbmZpZy5wYWNrYWdlSnNvbi52ZXJzaW9uLFxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgc3RhdFN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gJ0BvY3Rva2l0L3Jlc3QnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zLFxuICBQcmVQdWJsaXNoT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgdXBkYXRlUGFja2FnZUpzb24sXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgncHJlLXB1Ymxpc2gnKVxuXG5pbnRlcmZhY2UgUGFja2FnZUluZm8ge1xuICBuYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIHRhZzogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVQdWJsaXNoKHVzZXJPcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucykge1xuICBkZWJ1ZygnUmVjZWl2ZSBwcmUtcHVibGlzaCBvcHRpb25zOicpXG4gIGRlYnVnKCcgICVPJywgdXNlck9wdGlvbnMpXG5cbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IHsgcGFja2FnZUpzb24sIHRhcmdldHMsIHBhY2thZ2VOYW1lLCBiaW5hcnlOYW1lLCBucG1DbGllbnQgfSA9XG4gICAgYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICAgIClcblxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVHaFJlbGVhc2UocGFja2FnZU5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gICAgaWYgKCFvcHRpb25zLmdoUmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgcmVwbywgb3duZXIsIHBrZ0luZm8sIG9jdG9raXQgfSA9IGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lLCB2ZXJzaW9uKVxuXG4gICAgaWYgKCFyZXBvIHx8ICFvd25lcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb2N0b2tpdC5yZXBvcy5jcmVhdGVSZWxlYXNlKHtcbiAgICAgICAgICBvd25lcixcbiAgICAgICAgICByZXBvLFxuICAgICAgICAgIHRhZ19uYW1lOiBwa2dJbmZvLnRhZyxcbiAgICAgICAgICBuYW1lOiBvcHRpb25zLmdoUmVsZWFzZU5hbWUsXG4gICAgICAgICAgcHJlcmVsZWFzZTpcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ2FscGhhJykgfHxcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ2JldGEnKSB8fFxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygncmMnKSxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYFBhcmFtczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHsgb3duZXIsIHJlcG8sIHRhZ19uYW1lOiBwa2dJbmZvLnRhZyB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIDIsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWU6IHN0cmluZywgdmVyc2lvbjogc3RyaW5nKSB7XG4gICAgY29uc3QgaGVhZENvbW1pdCA9IGV4ZWNTeW5jKCdnaXQgbG9nIC0xIC0tcHJldHR5PSVCJywge1xuICAgICAgZW5jb2Rpbmc6ICd1dGYtOCcsXG4gICAgfSkudHJpbSgpXG5cbiAgICBjb25zdCB7IEdJVEhVQl9SRVBPU0lUT1JZIH0gPSBwcm9jZXNzLmVudlxuICAgIGlmICghR0lUSFVCX1JFUE9TSVRPUlkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cbiAgICBkZWJ1ZyhgR2l0aHViIHJlcG9zaXRvcnk6ICR7R0lUSFVCX1JFUE9TSVRPUll9YClcbiAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gR0lUSFVCX1JFUE9TSVRPUlkuc3BsaXQoJy8nKVxuICAgIGNvbnN0IG9jdG9raXQgPSBuZXcgT2N0b2tpdCh7XG4gICAgICBhdXRoOiBwcm9jZXNzLmVudi5HSVRIVUJfVE9LRU4sXG4gICAgfSlcbiAgICBsZXQgcGtnSW5mbzogUGFja2FnZUluZm8gfCB1bmRlZmluZWRcbiAgICBpZiAob3B0aW9ucy50YWdTdHlsZSA9PT0gJ2xlcm5hJykge1xuICAgICAgY29uc3QgcGFja2FnZXNUb1B1Ymxpc2ggPSBoZWFkQ29tbWl0XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkpXG4gICAgICAgIC5maWx0ZXIoKGxpbmUsIGluZGV4KSA9PiBsaW5lLmxlbmd0aCAmJiBpbmRleClcbiAgICAgICAgLm1hcCgobGluZSkgPT4gbGluZS5zdWJzdHJpbmcoMikpXG4gICAgICAgIC5tYXAocGFyc2VUYWcpXG5cbiAgICAgIHBrZ0luZm8gPSBwYWNrYWdlc1RvUHVibGlzaC5maW5kKFxuICAgICAgICAocGtnSW5mbykgPT4gcGtnSW5mby5uYW1lID09PSBwYWNrYWdlTmFtZSxcbiAgICAgIClcblxuICAgICAgaWYgKCFwa2dJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYE5vIHJlbGVhc2UgY29tbWl0IGZvdW5kIHdpdGggJHtwYWNrYWdlTmFtZX0sIG9yaWdpbmFsIGNvbW1pdCBpbmZvOiAke2hlYWRDb21taXR9YCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwa2dJbmZvID0ge1xuICAgICAgICB0YWc6IGB2JHt2ZXJzaW9ufWAsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIG5hbWU6IHBhY2thZ2VOYW1lLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgYXdhaXQgdmVyc2lvbih1c2VyT3B0aW9ucylcbiAgICBhd2FpdCB1cGRhdGVQYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIHtcbiAgICAgIG9wdGlvbmFsRGVwZW5kZW5jaWVzOiB0YXJnZXRzLnJlZHVjZShcbiAgICAgICAgKGRlcHMsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIGRlcHNbYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXSA9IHBhY2thZ2VKc29uLnZlcnNpb25cblxuICAgICAgICAgIHJldHVybiBkZXBzXG4gICAgICAgIH0sXG4gICAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gICAgICApLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH0gPSBvcHRpb25zLmdoUmVsZWFzZUlkXG4gICAgPyBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24udmVyc2lvbilcbiAgICA6IGF3YWl0IGNyZWF0ZUdoUmVsZWFzZShwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24udmVyc2lvbilcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgY29uc3QgcGtnRGlyID0gcmVzb2x2ZShcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5ucG1EaXIsXG4gICAgICBgJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWAsXG4gICAgKVxuICAgIGNvbnN0IGV4dCA9XG4gICAgICB0YXJnZXQucGxhdGZvcm0gPT09ICd3YXNpJyB8fCB0YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJyA/ICd3YXNtJyA6ICdub2RlJ1xuICAgIGNvbnN0IGZpbGVuYW1lID0gYCR7YmluYXJ5TmFtZX0uJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfS4ke2V4dH1gXG4gICAgY29uc3QgZHN0UGF0aCA9IGpvaW4ocGtnRGlyLCBmaWxlbmFtZSlcblxuICAgIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGlmICghZXhpc3RzU3luYyhkc3RQYXRoKSkge1xuICAgICAgICBkZWJ1Zy53YXJuKGAlcyBkb2Vzbid0IGV4aXN0YCwgZHN0UGF0aClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNraXBPcHRpb25hbFB1Ymxpc2gpIHtcbiAgICAgICAgZXhlY1N5bmMoYCR7bnBtQ2xpZW50fSBwdWJsaXNoYCwge1xuICAgICAgICAgIGN3ZDogcGtnRGlyLFxuICAgICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmdoUmVsZWFzZSAmJiByZXBvICYmIG93bmVyKSB7XG4gICAgICAgIGRlYnVnLmluZm8oYENyZWF0aW5nIEdpdEh1YiByZWxlYXNlICR7cGtnSW5mby50YWd9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWxlYXNlSWQgPSBvcHRpb25zLmdoUmVsZWFzZUlkXG4gICAgICAgICAgICA/IE51bWJlcihvcHRpb25zLmdoUmVsZWFzZUlkKVxuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgYXdhaXQgb2N0b2tpdCEucmVwb3MuZ2V0UmVsZWFzZUJ5VGFnKHtcbiAgICAgICAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBrZ0luZm8udGFnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICkuZGF0YS5pZFxuICAgICAgICAgIGNvbnN0IGRzdEZpbGVTdGF0cyA9IHN0YXRTeW5jKGRzdFBhdGgpXG4gICAgICAgICAgY29uc3QgYXNzZXRJbmZvID0gYXdhaXQgb2N0b2tpdCEucmVwb3MudXBsb2FkUmVsZWFzZUFzc2V0KHtcbiAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIHJlbGVhc2VfaWQ6IHJlbGVhc2VJZCxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogeyBmb3JtYXQ6ICdyYXcnIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IGRzdEZpbGVTdGF0cy5zaXplLFxuICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBvY3Rva2l0IHR5cGVzIGFyZSB3cm9uZ1xuICAgICAgICAgICAgZGF0YTogYXdhaXQgcmVhZEZpbGVBc3luYyhkc3RQYXRoKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGRlYnVnLmluZm8oYEdpdEh1YiByZWxlYXNlIGNyZWF0ZWRgKVxuICAgICAgICAgIGRlYnVnLmluZm8oYERvd25sb2FkIFVSTDogJXNgLCBhc3NldEluZm8uZGF0YS5icm93c2VyX2Rvd25sb2FkX3VybClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLmVycm9yKFxuICAgICAgICAgICAgYFBhcmFtOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWc6IHBrZ0luZm8udGFnLCBmaWxlbmFtZTogZHN0UGF0aCB9LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFnKHRhZzogc3RyaW5nKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gdGFnLnNwbGl0KCdAJylcbiAgY29uc3QgdmVyc2lvbiA9IHNlZ21lbnRzLnBvcCgpIVxuICBjb25zdCBuYW1lID0gc2VnbWVudHMuam9pbignQCcpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHZlcnNpb24sXG4gICAgdGFnLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sndW5pdmVyc2FsaXplJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnknLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG91dHB1dERpciA9IE9wdGlvbi5TdHJpbmcoJy0tb3V0cHV0LWRpciwtbycsICcuLycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmQnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbml2ZXJzYWxpemVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuLydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyhvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgb3V0cHV0RGlyOiAnLi8nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnMsXG4gIFVuaXZlcnNhbGl6ZU9wdGlvbnMsXG59IGZyb20gJy4uL2RlZi91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyByZWFkTmFwaUNvbmZpZyB9IGZyb20gJy4uL3V0aWxzL2NvbmZpZy5qcydcbmltcG9ydCB7IGRlYnVnRmFjdG9yeSB9IGZyb20gJy4uL3V0aWxzL2xvZy5qcydcbmltcG9ydCB7IGZpbGVFeGlzdHMgfSBmcm9tICcuLi91dGlscy9taXNjLmpzJ1xuaW1wb3J0IHsgVW5pQXJjaHNCeVBsYXRmb3JtIH0gZnJvbSAnLi4vdXRpbHMvdGFyZ2V0LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndW5pdmVyc2FsaXplJylcblxuY29uc3QgdW5pdmVyc2FsaXplcnM6IFBhcnRpYWw8XG4gIFJlY29yZDxOb2RlSlMuUGxhdGZvcm0sIChpbnB1dHM6IHN0cmluZ1tdLCBvdXRwdXQ6IHN0cmluZykgPT4gdm9pZD5cbj4gPSB7XG4gIGRhcndpbjogKGlucHV0cywgb3V0cHV0KSA9PiB7XG4gICAgc3Bhd25TeW5jKCdsaXBvJywgWyctY3JlYXRlJywgJy1vdXRwdXQnLCBvdXRwdXQsIC4uLmlucHV0c10sIHtcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuaXZlcnNhbGl6ZUJpbmFyaWVzKHVzZXJPcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgdGFyZ2V0ID0gY29uZmlnLnRhcmdldHMuZmluZChcbiAgICAodCkgPT4gdC5wbGF0Zm9ybSA9PT0gcHJvY2Vzcy5wbGF0Zm9ybSAmJiB0LmFyY2ggPT09ICd1bml2ZXJzYWwnLFxuICApXG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJ3VuaXZlcnNhbCcgYXJjaCBmb3IgcGxhdGZvcm0gJyR7cHJvY2Vzcy5wbGF0Zm9ybX0nIG5vdCBmb3VuZCBpbiBjb25maWchYCxcbiAgICApXG4gIH1cblxuICBjb25zdCBzcmNGaWxlcyA9IFVuaUFyY2hzQnlQbGF0Zm9ybVtwcm9jZXNzLnBsYXRmb3JtXT8ubWFwKChhcmNoKSA9PlxuICAgIHJlc29sdmUoXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMub3V0cHV0RGlyLFxuICAgICAgYCR7Y29uZmlnLmJpbmFyeU5hbWV9LiR7cHJvY2Vzcy5wbGF0Zm9ybX0tJHthcmNofS5ub2RlYCxcbiAgICApLFxuICApXG5cbiAgaWYgKCFzcmNGaWxlcyB8fCAhdW5pdmVyc2FsaXplcnNbcHJvY2Vzcy5wbGF0Zm9ybV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJ3VuaXZlcnNhbCcgYXJjaCBmb3IgcGxhdGZvcm0gJyR7cHJvY2Vzcy5wbGF0Zm9ybX0nIG5vdCBzdXBwb3J0ZWQuYCxcbiAgICApXG4gIH1cblxuICBkZWJ1ZyhgTG9va2luZyB1cCBzb3VyY2UgYmluYXJpZXMgdG8gY29tYmluZTogYClcbiAgZGVidWcoJyAgJU8nLCBzcmNGaWxlcylcblxuICBjb25zdCBzcmNGaWxlTG9va3VwID0gYXdhaXQgUHJvbWlzZS5hbGwoc3JjRmlsZXMubWFwKChmKSA9PiBmaWxlRXhpc3RzKGYpKSlcblxuICBjb25zdCBub3RGb3VuZEZpbGVzID0gc3JjRmlsZXMuZmlsdGVyKChfLCBpKSA9PiAhc3JjRmlsZUxvb2t1cFtpXSlcblxuICBpZiAobm90Rm91bmRGaWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU29tZSBiaW5hcnkgZmlsZXMgd2VyZSBub3QgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkobm90Rm91bmRGaWxlcyl9YCxcbiAgICApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSByZXNvbHZlKFxuICAgIG9wdGlvbnMuY3dkLFxuICAgIG9wdGlvbnMub3V0cHV0RGlyLFxuICAgIGAke2NvbmZpZy5iaW5hcnlOYW1lfS4ke3Byb2Nlc3MucGxhdGZvcm19LXVuaXZlcnNhbC5ub2RlYCxcbiAgKVxuXG4gIHVuaXZlcnNhbGl6ZXJzW3Byb2Nlc3MucGxhdGZvcm1dPy4oc3JjRmlsZXMsIG91dHB1dClcblxuICBkZWJ1ZyhgUHJvZHVjZWQgdW5pdmVyc2FsIGJpbmFyeTogJHtvdXRwdXR9YClcbn1cbiIsImltcG9ydCB7IGNvbGxlY3RBcnRpZmFjdHMgfSBmcm9tICcuL2FwaS9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBidWlsZFByb2plY3QgfSBmcm9tICcuL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IGNyZWF0ZU5wbURpcnMgfSBmcm9tICcuL2FwaS9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBuZXdQcm9qZWN0IH0gZnJvbSAnLi9hcGkvbmV3LmpzJ1xuaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4vYXBpL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IHVuaXZlcnNhbGl6ZUJpbmFyaWVzIH0gZnJvbSAnLi9hcGkvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vYXBpL3ZlcnNpb24uanMnXG5cbi8qKlxuICpcbiAqIEB1c2FnZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBjbGkgPSBuZXcgTmFwaUNsaSgpXG4gKlxuICogY2xpLmJ1aWxkKHtcbiAqICAgY3dkOiAnL3BhdGgvdG8veW91ci9wcm9qZWN0JyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5hcGlDbGkge1xuICBhcnRpZmFjdHMgPSBjb2xsZWN0QXJ0aWZhY3RzXG4gIG5ldyA9IG5ld1Byb2plY3RcbiAgYnVpbGQgPSBidWlsZFByb2plY3RcbiAgY3JlYXRlTnBtRGlycyA9IGNyZWF0ZU5wbURpcnNcbiAgcHJlUHVibGlzaCA9IHByZVB1Ymxpc2hcbiAgcmVuYW1lID0gcmVuYW1lUHJvamVjdFxuICB1bml2ZXJzYWxpemUgPSB1bml2ZXJzYWxpemVCaW5hcmllc1xuICB2ZXJzaW9uID0gdmVyc2lvblxufVxuXG5leHBvcnQgeyBwYXJzZVRyaXBsZSB9IGZyb20gJy4vdXRpbHMvdGFyZ2V0LmpzJ1xuIl0sInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBQUEsU0FBU0EsVUFBUSxHQUFHO0FBQ2xCO0FBRUEsU0FBTyxPQUFPLFVBQVVBLFlBQVUscUJBQXFCLFVBQVUsbUJBQW1CLE9BQU8sV0FBVyxTQUFVQyxLQUFHO0FBQ2pILGlCQUFjQTtFQUNmLElBQUcsU0FBVUEsS0FBRztBQUNmLFVBQU9BLE9BQUsscUJBQXFCLFVBQVVBLElBQUUsZ0JBQWdCLFVBQVVBLFFBQU0sT0FBTyxZQUFZLGtCQUFrQkE7RUFDbkgsR0FBRSxPQUFPLFFBQVEsYUFBYSxNQUFNLE9BQU8sUUFBUSxhQUFhLE9BQU8sU0FBUyxVQUFRLEVBQUU7Q0FDNUY7QUFDRCxRQUFPLFVBQVVELFdBQVMsT0FBTyxRQUFRLGFBQWEsTUFBTSxPQUFPLFFBQVEsYUFBYSxPQUFPOzs7Ozs7Q0NUL0YsSUFBSUUsNkJBQWlDO0NBQ3JDLFNBQVNDLGNBQVksR0FBRyxHQUFHO0FBQ3pCLE1BQUksWUFBWSxVQUFRLEVBQUUsS0FBSyxFQUFHLFFBQU87RUFDekMsSUFBSSxJQUFJLEVBQUUsT0FBTztBQUNqQixXQUFTLE1BQU0sR0FBRztHQUNoQixJQUFJLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxVQUFVO0FBQ2pDLE9BQUksWUFBWSxVQUFRLEVBQUUsQ0FBRSxRQUFPO0FBQ25DLFNBQU0sSUFBSSxVQUFVO0VBQ3JCO0FBQ0QsU0FBTyxD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