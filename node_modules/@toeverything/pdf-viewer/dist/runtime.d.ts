import type { FPDF_Config, PDFiumModule } from '@toeverything/pdfium';
import type { ErrorCode, BitmapFormat, FileIdentifier, PageMode, Rotation } from '@toeverything/pdf-viewer-types';
export declare const DefaultConfig: FPDF_Config;
/**
 * PDFium runtime.
 */
export declare class Runtime {
    engine: PDFiumModule;
    constructor(engine: PDFiumModule);
    get wasm(): import("@toeverything/pdfium").WasmExports;
    get HEAPU8(): Uint8Array;
    malloc(size: number): number;
    free(ptr: number): void;
    stringToUTF8(str: string, strPtr: number, maxBytesToRead?: number): void;
    stringToNewUTF8(str: string): number;
    UTF8ToString(ptr: number, maxBytesToRead?: number): string;
    UTF16ToString(ptr: number, maxBytesToRead?: number): string;
    getValue(ptr: number, type: Emscripten.CType): number;
    setValue(ptr: number, value: any, type: Emscripten.CType, noSafe?: boolean): void;
    /**
     * Copys bytes to WASM.
     */
    copyBytesTo(bytes: Uint8Array): number;
    /**
     * Initialize the PDFium library and allocate global resources for it.
     */
    init: (config: FPDF_Config) => void;
    deinit: () => void;
    /**
     * Gets last error code when a function fails.
     */
    lastErrorCode: () => ErrorCode;
    version: (docPtr: number, versionPtr: number) => number;
    fileIdentifier: (docPtr: number, idType: FileIdentifier, bytesPtr?: number, size?: number) => number;
    metaText: (docPtr: number, tagPtr: number, bytesPtr?: number, size?: number) => number;
    openDocument: (bytesPtr: number, size: number, passwordPtr: number) => number;
    pageMode: (docPtr: number) => PageMode;
    closeDocument(ptr: number): void;
    pageCount: (docPtr: number) => number;
    loadPage: (docPtr: number, pageIdx: number) => number;
    closePage: (pagePtr: number) => void;
    pageLabel: (docPtr: number, pageIdx: number, bytesPtr?: number, size?: number) => number;
    pageWidth: (pagePtr: number) => number;
    pageHeight: (pagePtr: number) => number;
    pageSize: (docPtr: number, pageIdx: number, rectPtr: number) => boolean;
    pageRotation: (pagePtr: number) => Rotation;
    pageTransparency: (pagePtr: number) => number;
    renderPageBitmap: (bitmapPtr: number, pagePtr: number, startX: number, startY: number, sizeX: number, sizeY: number, rotate: number, flags: number) => void;
    pointFromDeviceToPage: (pagePtr: number, startX: number, startY: number, sizeX: number, sizeY: number, rotate: number, deviceX: number, deviceY: number, pageXPtr: number, pageYPtr: number) => any;
    pointFromPageToDevice: (pagePtr: number, startX: number, startY: number, sizeX: number, sizeY: number, rotate: number, pageX: number, pageY: number, deviceXPtr: number, deviceYPtr: number) => any;
    createBitmap: (width: number, height: number, alpha: number) => number;
    createBitmapWith: (width: number, height: number, format: BitmapFormat, firstScan?: number, stride?: number) => number;
    fillBitmap: (bitmapPtr: number, left: number, top: number, width: number, height: number, color: number) => number;
    closeBitmap: (bitmapPtr: number) => void;
    bitmapWidth: (bitmapPtr: number) => number;
    bitmapHeight: (bitmapPtr: number) => number;
    bitmapStride: (bitmapPtr: number) => number;
    bitmapBuffer: (bitmapPtr: number) => number;
}
//# sourceMappingURL=runtime.d.ts.map