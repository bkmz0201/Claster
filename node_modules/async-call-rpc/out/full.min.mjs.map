{"version":3,"file":"full.min.mjs","sources":["../src/utils/encoder.ts","../src/utils/constants.ts","../src/utils/serialization.ts","../src/utils/internalSymbol.ts","../src/core/notify.ts","../src/core/batch.ts","../src/utils/error.ts","../src/utils/jsonrpc.ts","../src/utils/generateRandomID.ts","../src/utils/normalizeOptions.ts","../src/Async-Call.ts","../src/Async-Call-Generator.ts"],"sourcesContent":["import type { IsomorphicEncoder, Request, Requests, Response, Responses, SuccessResponse } from '../types.ts'\nimport { isArray, undefined } from './constants.ts'\n\n/**\n * @public\n * Options of {@link (JSONEncoder:function)}\n */\nexport interface JSONEncoderOptions {\n    /** Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read. */\n    space?: string | number | undefined\n    /**\n     * How to handle `\"undefined\"` in the result of {@link SuccessResponse}.\n     *\n     * @remarks\n     * If you need a full support of encoding `undefined`, for example, when the result is `{ field: undefined }` and you want to keep it,\n     * you need to find another library to do this.\n     *\n     * If this is not handled properly, `JSON.stringify` will emit an invalid JSON-RPC object (fields with `undefined` value will be omitted).\n     *\n     * Options:\n     * - `\"null\"`(**default**): convert it to `null`.\n     * - `false`: do not do anything, let it break.\n     */\n    keepUndefined?: false | 'null' | undefined\n    /** A function that transforms the results. */\n    replacer?: ((this: any, key: string, value: any) => any) | undefined\n    /** A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is. */\n    reviver?: ((this: any, key: string, value: any) => any) | undefined\n}\n/**\n * Create a encoder by JSON.parse/stringify\n *\n * @public\n * @param options - Options for this encoder.\n * @remarks {@link IsomorphicEncoder}\n */\nexport function JSONEncoder({\n    keepUndefined = 'null',\n    replacer,\n    reviver,\n    space,\n}: JSONEncoderOptions = {}): IsomorphicEncoder {\n    return {\n        encode(data) {\n            if (keepUndefined) {\n                isArray(data) ? data.forEach(undefinedEncode) : undefinedEncode(data)\n            }\n            return JSON.stringify(data, replacer, space)\n        },\n        decode(encoded) {\n            const data: Requests | Responses = JSON.parse(encoded as string, reviver)\n            return data\n        },\n    }\n}\n\nconst undefinedEncode = (i: Response | Request) => {\n    if ('result' in i && i.result === undefined) {\n        i.result = null\n    }\n}\n\n/** @public */\nexport namespace JSONEncoder {\n    export const Default: IsomorphicEncoder<unknown, unknown> = JSONEncoder()\n}\n","export const isString = (x: unknown): x is string => typeof x === 'string'\nexport const isBoolean = (x: unknown): x is boolean => typeof x === 'boolean'\nexport const isFunction = (x: unknown): x is Function => typeof x === 'function'\nexport const isObject = (params: any): params is object => typeof params === 'object' && params !== null\nexport const ERROR = 'Error'\nexport const undefined = void 0\nexport const { setPrototypeOf } = Object\nexport const Promise_resolve = <T>(x: T) => Promise.resolve(x)\nexport const { isArray } = Array as { isArray(arg: any): arg is readonly any[] }\nexport const { apply } = Reflect\n","import { isObject, undefined } from './constants.ts'\nimport type { Serialization } from '../types.ts'\n\n/**\n * Serialization implementation that do nothing\n * @remarks {@link Serialization}\n * @public\n * @deprecated Will be removed in next major version\n */\nexport const NoSerialization: Serialization = {\n    serialization(from) {\n        return from\n    },\n    deserialization(serialized) {\n        return serialized\n    },\n}\n\n/**\n * Create a serialization by JSON.parse/stringify\n *\n * @param replacerAndReceiver - Replacer and receiver of JSON.parse/stringify\n * @param space - Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n * @param undefinedKeepingBehavior - How to keep \"undefined\" in result of SuccessResponse?\n *\n * If it is not handled properly, JSON.stringify will emit an invalid JSON RPC object.\n *\n * Options:\n * - `\"null\"`(**default**): convert it to null.\n * - `\"keep\"`: try to keep it by additional property \"undef\".\n * - `false`: Don't keep it, let it break.\n * @remarks {@link Serialization}\n * @public\n */\nexport const JSONSerialization = (\n    replacerAndReceiver: [((key: string, value: any) => any)?, ((key: string, value: any) => any)?] = [\n        undefined,\n        undefined,\n    ],\n    space?: string | number | undefined,\n    undefinedKeepingBehavior: 'keep' | 'null' | false = 'null',\n): Serialization => ({\n    serialization(from) {\n        if (undefinedKeepingBehavior && isObject(from) && 'result' in from && from.result === undefined) {\n            const alt = { ...from }\n            alt.result = null\n            if (undefinedKeepingBehavior === 'keep') (alt as any).undef = true\n            from = alt\n        }\n        return JSON.stringify(from, replacerAndReceiver[0], space)\n    },\n    deserialization(serialized) {\n        const result = JSON.parse(serialized as string, replacerAndReceiver[1])\n        if (\n            isObject(result) &&\n            'result' in result &&\n            result.result === null &&\n            'undef' in result &&\n            result.undef === true\n        ) {\n            result.result = undefined\n            delete result.undef\n        }\n        return result\n    },\n})\n","const i = 'AsyncCall/'\n// ! side effect\nexport const AsyncCallIgnoreResponse = Symbol.for(i + 'ignored')\nexport const AsyncCallNotify = Symbol.for(i + 'notify')\nexport const AsyncCallBatch = Symbol.for(i + 'batch')\n","import { AsyncCallNotify } from '../utils/internalSymbol.ts'\nimport { isFunction } from '../utils/constants.ts'\n\n/**\n * Make the returning type to `Promise<void>`\n * @internal\n * @remarks\n * Due to the limitation of TypeScript, generic signatures cannot be preserved\n * if the function is the top level parameter of this utility type,\n * or the function is not returning `Promise<void>`.\n */\nexport type _IgnoreResponse<T> = T extends (...args: infer Args) => unknown\n    ? (...args: Args) => Promise<void>\n    : {\n          [key in keyof T as T[key] extends Function ? key : never]: T[key] extends (\n              ...args: infer Args\n          ) => infer Return\n              ? Return extends Promise<void>\n                  ? T[key]\n                  : (...args: Args) => Promise<void>\n              : never\n      }\n/**\n * Wrap the AsyncCall instance to send notification.\n * @param instanceOrFnOnInstance - The AsyncCall instance or function on the AsyncCall instance\n * @example\n * const notifyOnly = notify(AsyncCall(...))\n * @public\n */\n\nexport function notify<T extends object>(instanceOrFnOnInstance: T): _IgnoreResponse<T> {\n    if (isFunction(instanceOrFnOnInstance)) return (instanceOrFnOnInstance as any)[AsyncCallNotify]\n    return new Proxy(instanceOrFnOnInstance, { get: notifyTrap }) as any\n}\nconst notifyTrap = (target: any, p: string | number | symbol) => {\n    return target[p][AsyncCallNotify]\n}\n","import { isString } from '../utils/constants.ts'\nimport { AsyncCallBatch, AsyncCallNotify } from '../utils/internalSymbol.ts'\nimport type { Request } from '../types.ts'\n/**\n * Wrap the AsyncCall instance to use batch call.\n * @param asyncCallInstance - The AsyncCall instance\n * @example\n * const [batched, send, drop] = batch(AsyncCall(...))\n * batched.call1() // pending\n * batched.call2() // pending\n * send() // send all pending requests\n * drop() // drop all pending requests\n * @returns It will return a tuple.\n *\n * The first item is the batched version of AsyncCall instance passed in.\n *\n * The second item is a function to send all pending requests.\n *\n * The third item is a function to drop and reject all pending requests.\n * @public\n */\n// TODO: use private field in the future.\nexport function batch<T extends object>(asyncCallInstance: T): [T, () => void, (error?: unknown) => void] {\n    const queue: BatchQueue = []\n    const getTrap = new Proxy(\n        {},\n        {\n            get(_, p) {\n                // @ts-expect-error\n                const f = (...args: any) => asyncCallInstance[AsyncCallBatch](queue, p, ...args)\n                // @ts-expect-error\n                f[AsyncCallNotify] = (...args: any) =>\n                    // @ts-expect-error\n                    asyncCallInstance[AsyncCallBatch][AsyncCallNotify](queue, p, ...args)\n                f[AsyncCallNotify][AsyncCallNotify] = f[AsyncCallNotify]\n                isString(p) && Object.defineProperty(methodContainer, p, { value: f, configurable: true })\n                return f\n            },\n        },\n    )\n    const methodContainer = { __proto__: getTrap } as any\n    return [\n        new Proxy(methodContainer, {\n            getPrototypeOf: () => null,\n            setPrototypeOf: (_, value) => value === null,\n        }),\n        () => {\n            queue.length && queue.r![0]()\n            queue.length = 0\n        },\n        (error = new Error('Aborted')) => {\n            queue.length && queue.r![1](error)\n            queue.length = 0\n        },\n    ]\n}\nexport type BatchQueue = Request[] & {\n    /** Request handler */\n    r?: [emit: () => void, reject: (error?: unknown) => void]\n}\n","import type { AbortSignalLike } from '../types.ts'\n\nclass CustomError extends Error {\n    // TODO: support cause\n    constructor(\n        public name: string,\n        message: string,\n        public code: number,\n        public stack: string,\n    ) {\n        super(message)\n    }\n}\nexport const Err_Cannot_find_a_running_iterator_with_given_ID: unique symbol = {} as any\nexport const Err_Only_string_can_be_the_RPC_method_name: unique symbol = {} as any\nexport const Err_Cannot_call_method_starts_with_rpc_dot_directly: unique symbol = {} as any\nexport const Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options: unique symbol =\n    {} as any\nconst Messages = [\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n] as const\n// https://github.com/Jack-Works/async-call-rpc/wiki/Error-messages\nexport const makeHostedMessage = (id: (typeof Messages)[number], error: Error) => {\n    const n = Messages.indexOf(id)\n    error.message += `Error ${n}: https://github.com/Jack-Works/async-call-rpc/wiki/Errors#` + n\n    return error\n}\n// ! side effect\n/** These Error is defined in ECMAScript spec */\nconst errors: Record<string, typeof EvalError> = {\n    // @ts-expect-error\n    __proto__: null,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n}\nexport const DOMExceptionHeader = 'DOMException:'\n/**\n * AsyncCall support somehow transfer ECMAScript Error\n */\nexport const RecoverError = (type: string, message: string, code: number, stack: string): Error => {\n    try {\n        let E\n        if (type.startsWith(DOMExceptionHeader) && (E = globalDOMException())) {\n            const name = type.slice(DOMExceptionHeader.length)\n            return new E(message, name)\n        } else if (type in errors) {\n            const e = new errors[type]!(message)\n            e.stack = stack\n            // @ts-expect-error\n            e.code = code\n            return e\n        } else {\n            return new CustomError(type, message, code, stack)\n        }\n    } catch {\n        return new Error(`E${code} ${type}: ${message}\\n${stack}`)\n    }\n}\nexport const removeStackHeader = (stack: unknown) => String(stack).replace(/^.+\\n.+\\n/, '')\n// ! side effect\nexport const globalDOMException = (() => {\n    try {\n        // @ts-expect-error\n        return DOMException\n    } catch {}\n}) as () => DOMException | undefined\ntype DOMException = { new (message: string, name: string): any }\nexport function onAbort(signal: AbortSignalLike | undefined, callback: () => void) {\n    signal && signal.addEventListener('abort', callback, { once: true })\n}\n","import { globalDOMException as DOMException, DOMExceptionHeader } from './error.ts'\nimport type { ErrorMapFunction } from '../Async-Call.ts'\nimport { ERROR, isArray, isFunction, isObject, undefined } from './constants.ts'\nimport type { Request, SuccessResponse, ErrorResponse, ID, Response } from '../types.ts'\n\nexport const jsonrpc = '2.0'\nexport const makeRequest = (\n    id: ID,\n    method: string,\n    params: readonly unknown[] | object,\n    remoteStack?: string,\n): Request => {\n    const x: Request = { jsonrpc, id, method, params, remoteStack }\n    deleteUndefined(x, 'id')\n    deleteFalsy(x, 'remoteStack')\n    return x\n}\nexport const makeSuccessResponse = (id: ID, result: unknown): SuccessResponse => {\n    const x: SuccessResponse = { jsonrpc, id, result }\n    deleteUndefined(x, 'id')\n    return x\n}\nexport const makeErrorResponse = <T>(id: ID, code: number, message: string, data?: T): ErrorResponse<T> => {\n    if (id === undefined) id = null\n    code = Math.floor(code)\n    if (Number.isNaN(code)) code = -1\n    const x: ErrorResponse<T> = { jsonrpc, id, error: { code, message, data } }\n    deleteUndefined(x.error, 'data')\n    return x\n}\n// Pre defined error in section 5.1\n// ! side effect\nexport const ErrorResponseParseError = <T>(e: unknown, mapper: ErrorMapFunction<T>): ErrorResponse<T> => {\n    const obj = ErrorResponseMapped({} as any, e, mapper)\n    const o = obj.error as Mutable<ErrorResponse['error']>\n    o.code = -32700\n    o.message = 'Parse error'\n    return obj\n}\n\n// Not using.\n// InvalidParams -32602 'Invalid params'\n// InternalError -32603 'Internal error'\nexport const ErrorResponseInvalidRequest = (id: ID) => makeErrorResponse(id, -32600, 'Invalid Request')\nexport const ErrorResponseMethodNotFound = (id: ID) => makeErrorResponse(id, -32601, 'Method not found')\n\ntype AsyncCallErrorDetail = {\n    stack?: string\n    type?: string\n}\nexport const ErrorResponseMapped = <T>(request: Request, e: unknown, mapper: ErrorMapFunction<T>): ErrorResponse<T> => {\n    const { id } = request\n    const { code, message, data } = mapper(e, request)\n    return makeErrorResponse(id, code, message, data)\n}\n\nexport const defaultErrorMapper =\n    (stack = '', code = -1): ErrorMapFunction<AsyncCallErrorDetail> =>\n    (e) => {\n        let message = toString('', () => (e as any).message)\n        let type = toString(ERROR, (ctor = (e as any).constructor) => isFunction(ctor) && ctor.name)\n        const E = DOMException()\n        if (E && e instanceof E) type = DOMExceptionHeader + e.name\n        const eType = typeof e\n        if (eType == 'string' || eType === 'number' || eType == 'boolean' || eType == 'bigint') {\n            type = ERROR\n            message = String(e)\n        }\n        const data: AsyncCallErrorDetail = stack ? { stack, type } : { type }\n        return { code, message, data }\n    }\n\nexport const isJSONRPCObject = (data: any): data is Response | Request => {\n    if (!isObject(data)) return false\n    if (!('jsonrpc' in data)) return false\n    if (data.jsonrpc !== jsonrpc) return false\n    if ('params' in data) {\n        const params = data.params\n        if (!isArray(params) && !isObject(params)) return false\n    }\n    return true\n}\n\nconst toString = (_default: string, val: () => any) => {\n    try {\n        const v = val()\n        if (v === undefined) return _default\n        return String(v)\n    } catch {\n        return _default\n    }\n}\nconst deleteUndefined = <O>(x: O, key: keyof O) => {\n    if (x[key] === undefined) delete x[key]\n}\nconst deleteFalsy = <T>(x: T, key: keyof T) => {\n    if (!x[key]) delete x[key]\n}\ntype Mutable<T> = { -readonly [key in keyof T]: T[key] }\n","export const generateRandomID = () => Math.random().toString(36).slice(2)\n","import type { AsyncCallOptions } from '../Async-Call.ts'\nimport { isBoolean } from './constants.ts'\nconst undefinedToTrue = (x: undefined | boolean) => (x === void 0 ? true : x)\ntype NormalizedLogOptions = readonly [\n    beCalled: boolean,\n    localError: boolean,\n    remoteError: boolean,\n    isPretty?: boolean,\n    requestReplay?: boolean,\n    sendLocalStack?: boolean,\n]\n\nexport const normalizeLogOptions = (log: NonNullable<AsyncCallOptions['log']>): NormalizedLogOptions | [] => {\n    if (log === 'all') return [true, true, true, true, true, true]\n    if (!isBoolean(log)) {\n        const { beCalled, localError, remoteError, type, requestReplay, sendLocalStack } = log\n        return [\n            undefinedToTrue(beCalled),\n            undefinedToTrue(localError),\n            undefinedToTrue(remoteError),\n            type !== 'basic',\n            requestReplay,\n            sendLocalStack,\n        ]\n    }\n    if (log) return [true, true, true, true] as const\n    return []\n}\n\nexport const normalizeStrictOptions = (strict: NonNullable<AsyncCallOptions['strict']>) => {\n    if (!isBoolean(strict)) {\n        const { methodNotFound, unknownMessage } = strict\n        return [methodNotFound, unknownMessage] as const\n    }\n    return [strict, strict] as const\n}\n","export type * from './types.ts'\nexport type { _IgnoreResponse } from './core/notify.ts'\nexport { JSONSerialization, NoSerialization } from './utils/serialization.ts'\nexport { JSONEncoder, type JSONEncoderOptions } from './utils/encoder.ts'\nexport { notify } from './core/notify.ts'\nexport { batch } from './core/batch.ts'\n\nimport {\n    makeRequest,\n    ErrorResponseMapped,\n    makeSuccessResponse,\n    isJSONRPCObject,\n    defaultErrorMapper,\n    ErrorResponseMethodNotFound,\n    ErrorResponseInvalidRequest,\n    ErrorResponseParseError,\n} from './utils/jsonrpc.ts'\nimport {\n    removeStackHeader,\n    RecoverError,\n    makeHostedMessage,\n    Err_Cannot_call_method_starts_with_rpc_dot_directly,\n    Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n    onAbort,\n} from './utils/error.ts'\nimport { generateRandomID } from './utils/generateRandomID.ts'\nimport { normalizeStrictOptions, normalizeLogOptions } from './utils/normalizeOptions.ts'\nimport { AsyncCallIgnoreResponse, AsyncCallNotify, AsyncCallBatch } from './utils/internalSymbol.ts'\nimport type { BatchQueue } from './core/batch.ts'\nimport type {\n    CallbackBasedChannel,\n    EventBasedChannel,\n    AsyncCallOptions,\n    ConsoleInterface,\n    AsyncVersionOf,\n    Request,\n    Response,\n    SuccessResponse,\n    ErrorResponse,\n    IsomorphicEncoderFull,\n    IsomorphicEncoder,\n    Requests,\n    Responses,\n} from './types.ts'\nimport { apply, ERROR, isArray, isFunction, isObject, isString, Promise_resolve, undefined } from './utils/constants.ts'\n\n/**\n * Create a RPC server & client.\n *\n * @remarks\n * See {@link AsyncCallOptions}\n *\n * thisSideImplementation can be a Promise so you can write:\n *\n * ```ts\n * export const service = AsyncCall(typeof window === 'object' ? {} : import('./backend/service.js'), {})\n * ```\n *\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server. Can be a Promise.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, it will be converted to the async version.\n * @returns Same as the `OtherSideImplementedFunctions` type parameter, but every function in that interface becomes async and non-function value is removed. Method called \"then\" are also removed.\n * @public\n */\nexport function AsyncCall<OtherSideImplementedFunctions = {}>(\n    thisSideImplementation: null | undefined | object | Promise<object>,\n    options: AsyncCallOptions,\n): AsyncVersionOf<OtherSideImplementedFunctions> {\n    type Hint = 'request' | 'response' | undefined\n\n    let isThisSideImplementationPending = true\n    let resolvedThisSideImplementationValue: unknown\n    let rejectedThisSideImplementation: unknown\n\n    let resolvedChannel: EventBasedChannel | CallbackBasedChannel | undefined\n    let channelPromise: Promise<EventBasedChannel | CallbackBasedChannel> | undefined\n    // This promise should never fail\n    const awaitThisSideImplementation = async () => {\n        try {\n            resolvedThisSideImplementationValue = await thisSideImplementation\n        } catch (e) {\n            rejectedThisSideImplementation = e\n            console_error('AsyncCall failed to start', e)\n        } finally {\n            isThisSideImplementationPending = false\n        }\n    }\n    const onChannelResolved = (channel: EventBasedChannel | CallbackBasedChannel) => {\n        resolvedChannel = channel\n        if (isCallbackBasedChannel(channel)) {\n            channel.setup(\n                (data, hint) => rawMessageReceiver(data, hint).then(rawMessageSender),\n                (data, hint) => {\n                    let _ = hintedDecode(data, hint)\n\n                    if (isJSONRPCObject(_)) return true\n                    return Promise_resolve(_).then(isJSONRPCObject)\n                },\n            )\n        }\n        if (isEventBasedChannel(channel)) {\n            const m = channel\n            m.on &&\n                m.on((_, hint) =>\n                    rawMessageReceiver(_, hint)\n                        .then(rawMessageSender)\n                        .then((x) => x && m.send!(x)),\n                )\n        }\n        return channel\n    }\n\n    const {\n        serializer,\n        encoder,\n        key: deprecatedName,\n        name,\n        strict = true,\n        log = true,\n        parameterStructures: deprecatedParameterStructures,\n        parameterStructure,\n        preferLocalImplementation = false,\n        idGenerator = generateRandomID,\n        mapError,\n        logger,\n        channel,\n        thenable,\n        signal,\n        forceSignal,\n    } = options\n\n    // Note: we're not shorten this error message because it will be removed in the next major version.\n    if (serializer && encoder) throw new TypeError('Please remove serializer.')\n    if (name && deprecatedName) throw new TypeError('Please remove key.')\n    if (deprecatedParameterStructures && parameterStructure) throw new TypeError('Please remove parameterStructure.')\n    const paramStyle = deprecatedParameterStructures || parameterStructure || 'by-position'\n    const logKey = name || deprecatedName || 'rpc'\n\n    const throwIfAborted = () => {\n        signal && signal.throwIfAborted()\n        forceSignal && forceSignal.throwIfAborted()\n    }\n\n    const {\n        encode: encodeFromOption,\n        encodeRequest: encodeRequestFromOption,\n        encodeResponse: encodeResponseFromOption,\n        decode,\n        decodeRequest,\n        decodeResponse,\n    } = (encoder || {}) as IsomorphicEncoder & IsomorphicEncoderFull\n\n    const encodeRequest: (data: Requests | Responses) => any = encoder\n        ? (data) => apply(encodeRequestFromOption || encodeFromOption, encoder, [data])\n        : serializer\n          ? (data) => serializer.serialization(data)\n          : Object\n\n    const encodeResponse: (data: Requests | Responses) => any = encoder\n        ? (data) => apply(encodeResponseFromOption || encodeFromOption, encoder, [data])\n        : serializer\n          ? (data) => serializer.serialization(data)\n          : Object\n\n    const hintedDecode: (data: unknown, hint: Hint) => unknown = encoder\n        ? (data, hint) =>\n              hint == 'request'\n                  ? apply(decodeRequest || decode, encoder, [data])\n                  : hint == 'response'\n                    ? apply(decodeResponse || decode, encoder, [data])\n                    : apply(decode, encoder, [data])\n        : serializer\n          ? (data) => serializer.deserialization(data)\n          : Object\n\n    if (thisSideImplementation instanceof Promise) awaitThisSideImplementation()\n    else {\n        resolvedThisSideImplementationValue = thisSideImplementation\n        isThisSideImplementationPending = false\n    }\n\n    const [banMethodNotFound, banUnknownMessage] = normalizeStrictOptions(strict)\n    const [log_beCalled, log_localError, log_remoteError, log_pretty, log_requestReplay, log_sendLocalStack] =\n        normalizeLogOptions(log)\n    const {\n        log: console_log,\n        error: console_error = console_log,\n        debug: console_debug = console_log,\n        groupCollapsed: console_groupCollapsed = console_log,\n        groupEnd: console_groupEnd = console_log,\n        warn: console_warn = console_log,\n    } = (logger || console) as ConsoleInterface\n    type PromiseParam = [resolve: (value?: any) => void, reject: (reason?: any) => void, stack?: string]\n    const requestContext = new Map<string | number, PromiseParam>()\n\n    onAbort(forceSignal, () => {\n        requestContext.forEach((x) => x[1](forceSignal!.reason))\n        requestContext.clear()\n    })\n\n    const onRequest = async (data: Request): Promise<Response | undefined> => {\n        if ((signal && signal.aborted) || (forceSignal && forceSignal.aborted))\n            return makeErrorObject((signal && signal.reason) || (forceSignal && forceSignal.reason), '', data)\n        if (isThisSideImplementationPending) await awaitThisSideImplementation()\n        // TODO: in next major version we should not send this message since it might contain sensitive info.\n        else if (rejectedThisSideImplementation) return makeErrorObject(rejectedThisSideImplementation, '', data)\n        let frameworkStack: string = ''\n        try {\n            const { params, method, id: req_id, remoteStack } = data\n            // ? We're mapping any method starts with 'rpc.' to a Symbol.for\n            const key = (method.startsWith('rpc.') ? Symbol.for(method) : method) as keyof object\n            const executor: unknown = resolvedThisSideImplementationValue && resolvedThisSideImplementationValue[key]\n            if (!isFunction(executor)) {\n                if (!banMethodNotFound) {\n                    if (log_localError) console_debug('Missing method', key, data)\n                    return\n                } else return ErrorResponseMethodNotFound(req_id)\n            }\n            const args = isArray(params) ? params : [params]\n            frameworkStack = removeStackHeader(new Error().stack)\n            const promise = new Promise((resolve) =>\n                resolve(apply(executor, resolvedThisSideImplementationValue, args)),\n            )\n            if (log_beCalled) {\n                if (log_pretty) {\n                    const logArgs: unknown[] = [\n                        `${logKey}.%c${method}%c(${args.map(() => '%o').join(', ')}%c)\\n%o %c@${req_id}`,\n                        'color:#d2c057',\n                        '',\n                        ...args,\n                        '',\n                        promise,\n                        'color:gray;font-style:italic;',\n                    ]\n                    if (log_requestReplay) {\n                        const replay = () => {\n                            debugger\n                            return apply(executor, resolvedThisSideImplementationValue, args)\n                        }\n                        // this function will be logged, keep it short.\n                        // Do not inline it, it's hard to keep it in a single line after build step.\n                        logArgs.push(() => replay())\n                    }\n                    if (remoteStack) {\n                        console_groupCollapsed(...logArgs)\n                        console_log(remoteStack)\n                        console_groupEnd()\n                    } else console_log(...logArgs)\n                } else console_log(`${logKey}.${method}(${[...args].toString()}) @${req_id}`)\n            }\n            const result = await promise\n            if (result === AsyncCallIgnoreResponse) return\n            return makeSuccessResponse(req_id, result)\n        } catch (e) {\n            return makeErrorObject(e, frameworkStack, data)\n        }\n    }\n    const onResponse = async (data: Response): Promise<void> => {\n        let errorMessage = '',\n            remoteErrorStack = '',\n            errorCode = 0,\n            errorType = ERROR\n        if ('error' in data) {\n            const e = data.error\n            errorMessage = e.message\n            errorCode = e.code\n            const detail = e.data\n\n            if (isObject(detail) && 'stack' in detail && isString(detail.stack)) remoteErrorStack = detail.stack\n            else remoteErrorStack = '<remote stack not available>'\n\n            if (isObject(detail) && 'type' in detail && isString(detail.type)) errorType = detail.type\n            else errorType = ERROR\n\n            if (log_remoteError)\n                log_pretty\n                    ? console_error(\n                          `${errorType}: ${errorMessage}(${errorCode}) %c@${data.id}\\n%c${remoteErrorStack}`,\n                          'color: gray',\n                          '',\n                      )\n                    : console_error(`${errorType}: ${errorMessage}(${errorCode}) @${data.id}\\n${remoteErrorStack}`)\n        }\n        const { id } = data\n        if (id === null || id === undefined || !requestContext.has(id)) return\n        const [resolve, reject, localErrorStack = ''] = requestContext.get(id)!\n        requestContext.delete(id)\n        if ('error' in data) {\n            reject(\n                // TODO: add a hook to customize this\n                RecoverError(\n                    errorType,\n                    errorMessage,\n                    errorCode,\n                    // ? We use \\u0430 which looks like \"a\" to prevent browser think \"at AsyncCall\" is a real stack\n                    remoteErrorStack + '\\n    \\u0430t AsyncCall (rpc) \\n' + localErrorStack,\n                ),\n            )\n        } else {\n            resolve(data.result)\n        }\n        return\n    }\n    const rawMessageReceiver = async (\n        _: unknown,\n        hint: Hint,\n    ): Promise<undefined | Response | (Response | undefined)[]> => {\n        let data: unknown\n        let result: Response | undefined = undefined\n        try {\n            data = await hintedDecode(_, hint)\n            if (isJSONRPCObject(data)) {\n                return (result = await handleSingleMessage(data))\n            } else if (isArray(data) && data.every(isJSONRPCObject) && data.length !== 0) {\n                return Promise.all(data.map(handleSingleMessage))\n            } else {\n                if (banUnknownMessage) {\n                    let id = (data as any).id\n                    if (id === undefined) id = null\n                    return ErrorResponseInvalidRequest(id)\n                } else {\n                    // ? Ignore this message. The message channel maybe also used to transfer other message too.\n                    return undefined\n                }\n            }\n        } catch (e) {\n            if (log_localError) console_error(e, data, result)\n            let stack: string | undefined\n            try {\n                stack = '' + (e as any).stack\n            } catch {}\n            return ErrorResponseParseError(e, mapError || defaultErrorMapper(stack))\n        }\n    }\n    const rawMessageSender = async (res: undefined | Response | (Response | undefined)[]) => {\n        if (!res) return\n        if (isArray(res)) {\n            const reply = res.filter((x): x is Response => (x && 'id' in x) as boolean)\n            if (reply.length === 0) return\n            return encodeResponse(reply)\n        } else {\n            return encodeResponse(res)\n        }\n    }\n\n    if (channel instanceof Promise) channelPromise = channel.then(onChannelResolved)\n    else onChannelResolved(channel)\n\n    const makeErrorObject = (e: any, frameworkStack: string, data: Request) => {\n        if (isObject(e) && 'stack' in e)\n            e.stack = frameworkStack\n                .split('\\n')\n                .reduce((stack, fstack) => stack.replace(fstack + '\\n', ''), '' + e.stack)\n        if (log_localError) console_error(e)\n        return ErrorResponseMapped(data, e, mapError || defaultErrorMapper(log_sendLocalStack ? e.stack : undefined))\n    }\n\n    const sendPayload = async (payload: Requests | BatchQueue, removeQueueR?: true) => {\n        if (removeQueueR) payload = [...(payload as BatchQueue)]\n        const data = await encodeRequest(payload)\n        return (resolvedChannel || (await channelPromise))!.send!(data)\n    }\n    const rejectsQueue = (queue: BatchQueue, error: unknown) => {\n        for (const x of queue) {\n            if ('id' in x) {\n                const ctx = requestContext.get(x.id!)\n                ctx && ctx[1](error)\n            }\n        }\n    }\n    const handleSingleMessage = async (\n        data: SuccessResponse | ErrorResponse | Request,\n    ): Promise<SuccessResponse | ErrorResponse | undefined> => {\n        if ('method' in data) {\n            if ('id' in data) {\n                if (!forceSignal) return onRequest(data)\n                return new Promise((resolve, reject) => {\n                    const handleForceAbort = () => resolve(makeErrorObject(forceSignal.reason, '', data))\n                    onRequest(data)\n                        .then(resolve, reject)\n                        .finally(() => forceSignal.removeEventListener('abort', handleForceAbort))\n                    onAbort(forceSignal, handleForceAbort)\n                })\n            }\n            onRequest(data).catch(() => {})\n            return // Skip response for notifications\n        }\n        return onResponse(data) as Promise<undefined>\n    }\n    const call = (method: string | symbol, args: unknown[], stack: string | undefined, notify = false) => {\n        return new Promise<void>((resolve, reject) => {\n            throwIfAborted()\n            let queue: BatchQueue | undefined = undefined\n            if (method === AsyncCallBatch) {\n                queue = args.shift() as any\n                method = args.shift() as any\n            }\n            if (typeof method === 'symbol') {\n                const RPCInternalMethod: string = Symbol.keyFor(method) || (method as any).description\n                if (RPCInternalMethod) {\n                    if (RPCInternalMethod.startsWith('rpc.')) method = RPCInternalMethod\n                    else throw new TypeError('Not start with rpc.')\n                }\n            } else if (method.startsWith('rpc.')) {\n                throw makeHostedMessage(Err_Cannot_call_method_starts_with_rpc_dot_directly, new TypeError())\n            }\n\n            if (preferLocalImplementation && !isThisSideImplementationPending && isString(method)) {\n                const localImpl: unknown =\n                    resolvedThisSideImplementationValue && (resolvedThisSideImplementationValue as any)[method]\n                if (isFunction(localImpl)) return resolve(localImpl(...args))\n            }\n            const id = idGenerator()\n            stack = removeStackHeader(stack)\n            const param = paramStyle === 'by-name' && args.length === 1 && isObject(args[0]) ? args[0] : args\n            const request = makeRequest(\n                notify ? undefined : id,\n                method as string,\n                param,\n                log_sendLocalStack ? stack : undefined,\n            )\n            if (queue) {\n                queue.push(request)\n                if (!queue.r) queue.r = [() => sendPayload(queue!, true), (e) => rejectsQueue(queue!, e)]\n            } else sendPayload(request).catch(reject)\n            if (notify) return resolve()\n            requestContext.set(id, [resolve, reject, stack])\n        })\n    }\n    const getTrap = (_: any, method: string | symbol) => {\n        const f = {\n            // This function will be logged to the console so it must be 1 line\n            [method]: (..._: unknown[]) => call(method, _, new Error().stack),\n        }[method as any]!\n        const f2 = {\n            [method]: (..._: unknown[]) => call(method, _, new Error().stack, true),\n        }[method as any]!\n        // @ts-expect-error\n        f[AsyncCallNotify] = f2[AsyncCallNotify] = f2\n        isString(method) && Object.defineProperty(methodContainer, method, { value: f, configurable: true })\n        return f\n    }\n    const methodContainer: any = { __proto__: new Proxy({}, { get: getTrap }) }\n    if (thenable === false) methodContainer.then = undefined\n    else if (thenable === undefined) {\n        Object.defineProperty(methodContainer, 'then', {\n            configurable: true,\n            get() {\n                console_warn(\n                    makeHostedMessage(\n                        Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options,\n                        new TypeError('RPC used as Promise: '),\n                    ),\n                )\n            },\n        })\n    }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: () => null,\n        setPrototypeOf: (_, value) => value === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor(_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            return Object.getOwnPropertyDescriptor(methodContainer, method)\n        },\n    }) as AsyncVersionOf<OtherSideImplementedFunctions>\n}\n// Assume a console object in global if there is no custom logger provided\ndeclare const console: ConsoleInterface\n\nconst isEventBasedChannel = (x: EventBasedChannel | CallbackBasedChannel): x is EventBasedChannel =>\n    'send' in x && isFunction(x.send)\nconst isCallbackBasedChannel = (x: EventBasedChannel | CallbackBasedChannel): x is CallbackBasedChannel =>\n    'setup' in x && isFunction(x.setup)\n","/**\n * See the document at https://github.com/Jack-Works/async-call/\n */\nimport type { AsyncCallOptions } from './types.ts'\nimport { AsyncCall } from './Async-Call.ts'\nimport { AsyncCallIgnoreResponse } from './utils/internalSymbol.ts'\nimport { normalizeStrictOptions } from './utils/normalizeOptions.ts'\nimport { generateRandomID } from './utils/generateRandomID.ts'\nimport { isFunction, isString, setPrototypeOf } from './utils/constants.ts'\nimport {\n    Err_Cannot_find_a_running_iterator_with_given_ID,\n    Err_Only_string_can_be_the_RPC_method_name,\n    makeHostedMessage,\n} from './utils/error.ts'\n\nconst i = 'rpc.async-iterator.'\n// ! side effect\nconst AsyncIteratorStart = Symbol.for(i + 'start')\nconst AsyncIteratorNext = Symbol.for(i + 'next')\nconst AsyncIteratorReturn = Symbol.for(i + 'return')\nconst AsyncIteratorThrow = Symbol.for(i + 'throw')\n\ninterface AsyncGeneratorInternalMethods {\n    [AsyncIteratorStart](method: string, params: unknown[]): Promise<string>\n    [AsyncIteratorNext](id: string, value: unknown): Promise<IteratorResult<unknown>>\n    [AsyncIteratorReturn](id: string, value: unknown): Promise<IteratorResult<unknown>>\n    [AsyncIteratorThrow](id: string, value: unknown): Promise<IteratorResult<unknown>>\n}\n\n/** @internal */\nexport type _IteratorOrIterableFunction = (\n    ...args: any\n) => Iterator<any, any, any> | Iterable<any> | AsyncIterator<any, any, any> | AsyncIterable<any>\n/** @internal */\nexport type _IteratorLikeToAsyncGenerator<T extends _IteratorOrIterableFunction> = T extends (\n    ...args: any\n) => AsyncGenerator<any>\n    ? T // return async generator as-is so generics can be preserved\n    : T extends (\n          ...args: infer Args\n      ) =>\n          | Iterator<infer Yield, infer Return, infer Next>\n          | Iterable<infer Yield>\n          | AsyncIterator<infer Yield, infer Return, infer Next>\n          | AsyncIterable<infer Yield>\n    ? (...args: Args) => AsyncGenerator<Yield, Return, Next>\n    : never\n\n/**\n * Make all generator in the type T becomes AsyncGenerator\n *\n * @remarks\n * Only generics signatures on function that returning an AsyncGenerator<T> will be preserved due to the limitation of TypeScript.\n *\n * Method called `then` are intentionally removed because it is very likely to be a foot gun in promise auto-unwrap.\n * @public\n */\nexport type AsyncGeneratorVersionOf<T> = T extends Record<keyof T, _IteratorOrIterableFunction>\n    ? 'then' extends keyof T\n        ? Omit<Readonly<T>, 'then'>\n        : // in this case we don't want to use Readonly<T>, so it will provide a better experience\n          T\n    : _AsyncGeneratorVersionOf<T>\n/** @internal */\nexport type _AsyncGeneratorVersionOf<T> = {\n    // Omit 'then'\n    [key in keyof T as key extends 'then'\n        ? never\n        : // Omit non-iterator/iterable\n        T[key] extends _IteratorOrIterableFunction\n        ? key\n        : never]: T[key] extends _IteratorOrIterableFunction ? _IteratorLikeToAsyncGenerator<T[key]> : never\n}\n\ntype Iter = Iterator<unknown, unknown, unknown> | AsyncIterator<unknown>\ntype IterResult = IteratorResult<unknown> | Promise<IteratorResult<unknown>>\n/**\n * The async generator version of the AsyncCall\n * @param thisSideImplementation - The implementation when this AsyncCall acts as a JSON RPC server.\n * @param options - {@link AsyncCallOptions}\n * @typeParam OtherSideImplementedFunctions - The type of the API that server expose. For any function on this interface, AsyncCall will convert it to the Promised type.\n * @remarks\n * Warning: Due to technical limitation, AsyncGeneratorCall will leak memory. Use it at your own risk.\n *\n * To use AsyncGeneratorCall, the server and the client MUST support the following JSON RPC internal methods which is pre ECMAScript async generator semantics:\n *\n * - `rpc.async-iterator.start`\n *\n * - `rpc.async-iterator.next`\n *\n * - `rpc.async-iterator.return`\n *\n * - `rpc.async-iterator.throw`\n *\n * @example\n * ```ts\n * const server = {\n *      async *generator() {\n *          let last = 0\n *          while (true) yield last++\n *      },\n * }\n * type Server = typeof server\n * const serverRPC = AsyncGeneratorCall<Server>({}, { channel })\n * async function main() {\n *      for await (const x of serverRPC.generator()) {\n *          console.log('Server yielded number', x)\n *      }\n * }\n * ```\n * @public\n */\nexport function AsyncGeneratorCall<OtherSideImplementedFunctions = {}>(\n    thisSideImplementation: null | undefined | object | Promise<object>,\n    options: AsyncCallOptions,\n): AsyncGeneratorVersionOf<OtherSideImplementedFunctions> {\n    if (!AsyncGeneratorPrototypeSet) {\n        const EmptyAsyncGenerator = async function* () {}\n        const AsyncGeneratorConstructor = (AsyncGeneratorPrototypeSet = EmptyAsyncGenerator.constructor)\n        const AsyncGeneratorConstructorPrototype = AsyncGeneratorConstructor.prototype\n        setPrototypeOf(_AsyncGenerator, AsyncGeneratorConstructorPrototype)\n        const AsyncGeneratorPrototype = Object.getPrototypeOf(EmptyAsyncGenerator())\n        setPrototypeOf(_AsyncGenerator.prototype, AsyncGeneratorPrototype)\n    }\n    const iterators = new Map<string | number, Iter>()\n    const [methodNotFound] = normalizeStrictOptions(options.strict ?? true)\n    const { idGenerator = generateRandomID } = options\n    const findIterator = (\n        id: string,\n        next: (iterator: Iter) => IterResult | undefined | false,\n    ): false | undefined | IterResult | typeof AsyncCallIgnoreResponse => {\n        const it = iterators.get(id)\n        if (!it) {\n            if (methodNotFound)\n                throw makeHostedMessage(Err_Cannot_find_a_running_iterator_with_given_ID, new Error(`Iterator ${id}, `))\n            else return AsyncCallIgnoreResponse\n        }\n        const result = next(it)\n        isFinished(result, () => iterators.delete(id))\n        return result\n    }\n    const server = {\n        async [AsyncIteratorStart](method, args) {\n            const iteratorGenerator: unknown = ((await thisSideImplementation) as any)[method]\n            if (!isFunction(iteratorGenerator)) {\n                if (methodNotFound) throw new TypeError(method + ' is not a function')\n                else return AsyncCallIgnoreResponse\n            }\n            const iterator = iteratorGenerator(...args)\n            const id = idGenerator()\n            iterators.set(id, iterator)\n            return id\n        },\n        [AsyncIteratorNext](id, val) {\n            return findIterator(id, (it) => it.next(val as any))\n        },\n        [AsyncIteratorReturn](id, val) {\n            return findIterator(id, (it) => isFunction(it.return) && it.return(val))\n        },\n        [AsyncIteratorThrow](id, val) {\n            return findIterator(id, (it) => isFunction(it.throw) && it.throw(val))\n        },\n    } as AsyncGeneratorInternalMethods\n    const remote = AsyncCall<AsyncGeneratorInternalMethods>(server, options)\n\n    const getTrap = (_: any, method: PropertyKey) => {\n        if (!isString(method)) throw makeHostedMessage(Err_Only_string_can_be_the_RPC_method_name, new TypeError(''))\n        const f = {\n            [method]: (..._: unknown[]) => {\n                const id = remote[AsyncIteratorStart](method, _)\n                return new _AsyncGenerator(remote, id)\n            },\n        }[method]!\n        Object.defineProperty(methodContainer, method, { value: f, configurable: true })\n        return f\n    }\n    const methodContainer: any = { __proto__: new Proxy({}, { get: getTrap }) }\n    return new Proxy(methodContainer, {\n        getPrototypeOf: () => null,\n        setPrototypeOf: (_, val) => val === null,\n        // some library will treat this object as a normal object and run algorithm steps in https://tc39.es/ecma262/#sec-ordinaryget\n        getOwnPropertyDescriptor(_, method) {\n            if (!(method in methodContainer)) getTrap(_, method) // trigger [[Get]]\n            return Object.getOwnPropertyDescriptor(methodContainer, method)\n        },\n    }) as AsyncGeneratorVersionOf<OtherSideImplementedFunctions>\n}\nclass _AsyncGenerator implements AsyncIterableIterator<unknown>, AsyncIterator<unknown, unknown, unknown> {\n    /** done? */\n    private d: boolean = false\n    /** check */\n    private c = async (val: IterResult) => {\n        await isFinished(val, () => (this.d = true))\n        return val\n    }\n    /**\n     * @param r Remote Implementation\n     * @param i id\n     */\n    constructor(\n        private r: AsyncGeneratorInternalMethods,\n        private i: Promise<string>,\n    ) {}\n    async return(val: unknown) {\n        if (this.d) return makeIteratorResult(true, val)\n        return this.c(this.r[AsyncIteratorReturn](await this.i, val))\n    }\n    async next(val?: unknown) {\n        if (this.d) return makeIteratorResult(true)\n        return this.c(this.r[AsyncIteratorNext](await this.i, val))\n    }\n    async throw(val?: unknown) {\n        if (!this.d) return this.c(this.r[AsyncIteratorThrow](await this.i, val))\n        throw val\n    }\n    // Inherited from AsyncGeneratorPrototype\n    declare [Symbol.asyncIterator]: () => this\n}\nlet AsyncGeneratorPrototypeSet: unknown = false\n\nconst isFinished = async (result: IterResult | undefined | false, cb: () => void) => {\n    try {\n        const x = await result\n        x && x.done && cb()\n    } catch {}\n}\n\nconst makeIteratorResult = (done: boolean, value: unknown = undefined): IteratorResult<unknown, unknown> => ({\n    done,\n    value,\n})\n"],"names":["JSONEncoder","isString","x","isBoolean","isFunction","isObject","params","ERROR","undefined","setPrototypeOf","Object","Promise_resolve","Promise","resolve","isArray","Array","apply","Reflect","NoSerialization","serialization","from","deserialization","serialized","JSONSerialization","replacerAndReceiver","space","undefinedKeepingBehavior","result","alt","undef","JSON","stringify","parse","keepUndefined","replacer","reviver","encode","data","forEach","undefinedEncode","decode","encoded","i","Default","AsyncCallIgnoreResponse","Symbol","for","AsyncCallNotify","AsyncCallBatch","notify","instanceOrFnOnInstance","Proxy","get","notifyTrap","target","p","batch","asyncCallInstance","queue","methodContainer","__proto__","_","f","args","defineProperty","value","configurable","getPrototypeOf","length","r","error","Error","CustomError","constructor","name","message","code","stack","Err_Cannot_find_a_running_iterator_with_given_ID","Err_Only_string_can_be_the_RPC_method_name","Err_Cannot_call_method_starts_with_rpc_dot_directly","Err_Then_is_accessed_on_local_implementation_Please_explicitly_mark_if_it_is_thenable_in_the_options","Messages","makeHostedMessage","id","n","indexOf","errors","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","DOMExceptionHeader","RecoverError","type","E","startsWith","globalDOMException","slice","e","removeStackHeader","String","replace","DOMException","onAbort","signal","callback","addEventListener","once","makeRequest","method","remoteStack","jsonrpc","deleteUndefined","deleteFalsy","makeSuccessResponse","makeErrorResponse","Number","isNaN","Math","floor","ErrorResponseParseError","mapper","obj","ErrorResponseMapped","o","ErrorResponseInvalidRequest","ErrorResponseMethodNotFound","request","defaultErrorMapper","toString","ctor","eType","isJSONRPCObject","_default","val","v","key","generateRandomID","random","undefinedToTrue","normalizeLogOptions","log","beCalled","localError","remoteError","requestReplay","sendLocalStack","normalizeStrictOptions","strict","methodNotFound","unknownMessage","AsyncCall","thisSideImplementation","options","resolvedThisSideImplementationValue","rejectedThisSideImplementation","resolvedChannel","channelPromise","isThisSideImplementationPending","awaitThisSideImplementation","console_error","onChannelResolved","channel","isCallbackBasedChannel","setup","hint","rawMessageReceiver","then","rawMessageSender","hintedDecode","isEventBasedChannel","m","on","send","serializer","encoder","deprecatedName","parameterStructures","deprecatedParameterStructures","parameterStructure","preferLocalImplementation","idGenerator","mapError","logger","thenable","forceSignal","paramStyle","logKey","throwIfAborted","encodeFromOption","encodeRequest","encodeRequestFromOption","encodeResponse","encodeResponseFromOption","decodeRequest","decodeResponse","banMethodNotFound","banUnknownMessage","log_beCalled","log_localError","log_remoteError","log_pretty","log_requestReplay","log_sendLocalStack","console_log","debug","console_debug","groupCollapsed","console_groupCollapsed","groupEnd","console_groupEnd","warn","console_warn","console","requestContext","Map","reason","clear","onRequest","aborted","makeErrorObject","frameworkStack","req_id","executor","promise","logArgs","map","join","replay","push","onResponse","errorMessage","remoteErrorStack","errorCode","errorType","detail","has","reject","localErrorStack","delete","handleSingleMessage","every","all","res","reply","filter","split","reduce","fstack","sendPayload","payload","removeQueueR","rejectsQueue","ctx","handleForceAbort","finally","removeEventListener","catch","call","shift","RPCInternalMethod","keyFor","description","localImpl","param","set","getTrap","f2","getOwnPropertyDescriptor","_define_property","AsyncIteratorStart","AsyncIteratorNext","AsyncIteratorReturn","AsyncIteratorThrow","AsyncGeneratorCall","AsyncGeneratorPrototypeSet","EmptyAsyncGenerator","_AsyncGenerator","AsyncGeneratorConstructor","prototype","AsyncGeneratorPrototype","iterators","findIterator","next","it","isFinished","remote","iteratorGenerator","iterator","return","throw","d","makeIteratorResult","c","cb","done"],"mappings":"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"}