"use strict";
/*
Copyright 2022 ByteDance and/or its affiliates.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.readStatsFile = exports.extractBundleFromStream = exports.resolveStatsPath = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const stream_1 = require("stream");
const zlib_1 = require("zlib");
const msgpack_stream_1 = require("@eyhn/msgpack-stream");
const tar_1 = require("tar");
const jsonr_1 = tslib_1.__importDefault(require("@perfsee/jsonr"));
const utils_1 = require("./utils");
function resolveStatsPath(dir, regexp) {
    const isValidDir = (0, fs_1.existsSync)(dir) && (0, fs_1.statSync)(dir).isDirectory();
    if (!isValidDir) {
        return null;
    }
    for (const child of (0, fs_1.readdirSync)(dir)) {
        const path = (0, path_1.join)(dir, child);
        const stats = (0, fs_1.statSync)(path);
        if (stats.isFile() && regexp.test(child)) {
            return path;
        }
        else if (stats.isDirectory()) {
            const filePath = resolveStatsPath(path, regexp);
            if (filePath) {
                return filePath;
            }
        }
    }
    return null;
}
exports.resolveStatsPath = resolveStatsPath;
async function extractBundleFromStream(stream, path) {
    await new Promise((resolve, reject) => {
        (0, fs_1.rmSync)(path, { recursive: true, force: true });
        (0, fs_1.mkdirSync)(path, { recursive: true });
        stream
            .pipe((0, tar_1.extract)({
            cwd: path,
        }))
            .on('finish', () => {
            resolve(path);
        })
            .on('error', (e) => {
            reject(e);
        });
    });
    const statsFilePath = resolveStatsPath(path, new RegExp(`^webpack-stats-(.*)\\.(mp|jsonr)\\.gz$`));
    if (!statsFilePath) {
        throw new Error("Can't find stats file inside artifacts file list.");
    }
    return decompressStatsFile(statsFilePath);
}
exports.extractBundleFromStream = extractBundleFromStream;
async function decompressStatsFile(path) {
    const { dir, name } = (0, path_1.parse)(path);
    const target = (0, path_1.join)(dir, name);
    // brotli compressed stats file is deprecated
    // exists only for compatibility
    if (path.endsWith('.br')) {
        await new Promise((resolve, reject) => {
            const stream = (0, stream_1.pipeline)((0, fs_1.createReadStream)(path), (0, zlib_1.createBrotliDecompress)(), (0, fs_1.createWriteStream)(target), (e) => {
                if (e) {
                    reject(e);
                }
            });
            stream.on('error', reject);
            stream.on('end', resolve);
            stream.on('close', resolve);
        });
        return target;
    }
    // gzipped file sometimes meet invalid header error with createGunzip()
    if (path.endsWith('.gz')) {
        try {
            (0, child_process_1.execFileSync)('gzip', ['-d', path]);
            return target;
            // eslint-disable-next-line no-empty
        }
        catch { }
        try {
            await new Promise((resolve, reject) => {
                const stream = (0, stream_1.pipeline)((0, fs_1.createReadStream)(path), (0, zlib_1.createGunzip)(), (0, fs_1.createWriteStream)(target), (e) => {
                    if (e) {
                        reject(e);
                    }
                });
                stream.on('error', reject);
                stream.on('end', resolve);
                stream.on('close', resolve);
            });
            return target;
        }
        catch (e) {
            throw new Error(`Failed to decompress stats file. Internal Error: ${e.message}`);
        }
    }
    return path;
}
async function readStatsFile(path) {
    if (path.endsWith('.json')) {
        return (0, utils_1.readJSONFile)(path);
    }
    else if (path.endsWith('.jsonr')) {
        const stats = (0, fs_1.statSync)(path);
        if (stats.size < 2 * 1024 * 1024 * 1024 /* 2GB */) {
            const buf = (0, fs_1.readFileSync)(path, 'utf-8');
            return jsonr_1.default.parse(buf);
        }
        else {
            const data = [];
            const readStream = (0, fs_1.createReadStream)(path, { encoding: 'utf-8' });
            for await (const chunk of readStream) {
                data.push(chunk);
            }
            return jsonr_1.default.parseStream(data);
        }
    }
    else if (path.endsWith('.mp')) {
        const stats = (0, fs_1.statSync)(path);
        if (stats.size < 2 * 1024 * 1024 * 1024 /* 2GB */) {
            const buf = (0, fs_1.readFileSync)(path);
            return (0, msgpack_stream_1.decode)(buf);
        }
        else {
            return (await (0, msgpack_stream_1.decodeStream)((0, fs_1.createReadStream)(path)));
        }
    }
    else {
        throw new Error('unsupported stats file encoding.');
    }
}
exports.readStatsFile = readStatsFile;
//# sourceMappingURL=bundle-extractor.js.map