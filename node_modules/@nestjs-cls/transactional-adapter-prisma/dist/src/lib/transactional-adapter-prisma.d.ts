import { TransactionalAdapter } from '@nestjs-cls/transactional';
import { PrismaClient } from '@prisma/client';
import { SQLFlavor } from './savepoint-syntax';
interface AnyTransactionClient {
    $transaction: (fn: (client: any) => Promise<any>, options?: any) => any;
}
export type PrismaTransactionalClient<TClient extends AnyTransactionClient = PrismaClient> = Parameters<Parameters<TClient['$transaction']>[0]>[0];
export type PrismaTransactionOptions<TClient extends AnyTransactionClient = PrismaClient> = Parameters<TClient['$transaction']>[1];
export interface PrismaTransactionalAdapterOptions<TClient extends AnyTransactionClient = PrismaClient> {
    /**
     * The injection token for the PrismaClient instance.
     */
    prismaInjectionToken: any;
    /**
     * Default options for the transaction. These will be merged with any transaction-specific options
     * passed to the `@Transactional` decorator or the `TransactionHost#withTransaction` method.
     */
    defaultTxOptions?: Partial<PrismaTransactionOptions<TClient>>;
    /**
     * Specify the SQL flavor used by the database (does not apply to NoSQL databases).
     *
     * This is used to determine the syntax for savepoints in nested transactions, because
     * the PrismaClient does not provide a way to determine the SQL flavor automatically.
     *
     * If not provided, the adapter will not support nested transactions.
     */
    sqlFlavor?: SQLFlavor;
}
export declare class TransactionalAdapterPrisma<TClient extends AnyTransactionClient = PrismaClient> implements TransactionalAdapter<TClient, PrismaTransactionalClient<TClient>, PrismaTransactionOptions<TClient>> {
    connectionToken: any;
    defaultTxOptions?: Partial<PrismaTransactionOptions<TClient>>;
    sqlFlavor?: SQLFlavor;
    constructor(options: PrismaTransactionalAdapterOptions<TClient>);
    optionsFactory: (prisma: TClient) => {
        wrapWithTransaction: (options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<any>, setClient: (client?: PrismaTransactionalClient<TClient>) => void) => Promise<any>;
        wrapWithNestedTransaction: ((_options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<any>, setClient: (client?: PrismaTransactionalClient<TClient>) => void, tx: any) => Promise<any>) | undefined;
        getFallbackInstance: () => TClient;
    };
    private readonly wrapWithNestedTransaction;
}
export {};
//# sourceMappingURL=transactional-adapter-prisma.d.ts.map