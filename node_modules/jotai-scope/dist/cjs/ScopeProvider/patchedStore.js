"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPatchedStore = createPatchedStore;
exports.isTopLevelScope = isTopLevelScope;
function PatchedStore() { }
/**
 * @returns a patched store that intercepts get and set calls to apply the scope
 */
function createPatchedStore(baseStore, scope) {
    const store = Object.assign(Object.assign({}, baseStore), { get(anAtom, ...args) {
            const [scopedAtom] = scope.getAtom(anAtom);
            return baseStore.get(scopedAtom, ...args);
        },
        set(anAtom, ...args) {
            const [scopedAtom, implicitScope] = scope.getAtom(anAtom);
            const restore = scope.prepareWriteAtom(scopedAtom, anAtom, implicitScope);
            try {
                return baseStore.set(scopedAtom, ...args);
            }
            finally {
                restore === null || restore === void 0 ? void 0 : restore();
            }
        },
        sub(anAtom, ...args) {
            const [scopedAtom] = scope.getAtom(anAtom);
            return baseStore.sub(scopedAtom, ...args);
        } });
    return Object.assign(Object.create(PatchedStore.prototype), store);
}
/**
 * @returns true if the current scope is the first descendant scope under Provider
 */
function isTopLevelScope(parentStore) {
    return !(parentStore instanceof PatchedStore);
}
//# sourceMappingURL=patchedStore.js.map