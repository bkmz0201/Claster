"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionProxyUnsupportedError = exports.ClsPluginTransactional = void 0;
const nestjs_cls_1 = require("nestjs-cls");
const inject_transaction_decorator_1 = require("./inject-transaction.decorator");
const symbols_1 = require("./symbols");
const transaction_host_1 = require("./transaction-host");
class ClsPluginTransactional {
    constructor(options) {
        this.imports = [];
        this.exports = [];
        this.name = options.connectionName
            ? `cls-plugin-transactional-${options.connectionName}`
            : 'cls-plugin-transactional';
        this.imports.push(...(options.imports ?? []));
        const transactionHostToken = (0, transaction_host_1.getTransactionHostToken)(options.connectionName);
        this.providers = [
            {
                provide: symbols_1.TRANSACTION_CONNECTION,
                ...(options.adapter.connectionToken
                    ? { useExisting: options.adapter.connectionToken }
                    : { useValue: options.adapter.connection }),
            },
            {
                provide: symbols_1.TRANSACTIONAL_ADAPTER_OPTIONS,
                inject: [symbols_1.TRANSACTION_CONNECTION],
                useFactory: (connection) => {
                    const adapterOptions = options.adapter.optionsFactory.call(options.adapter, connection);
                    return {
                        ...adapterOptions,
                        ...this.bindLifecycleHooks(options),
                        connectionName: options.connectionName,
                        enableTransactionProxy: options.enableTransactionProxy ?? false,
                        defaultTxOptions: options.adapter.defaultTxOptions ?? {},
                    };
                },
            },
            {
                provide: transactionHostToken,
                useClass: transaction_host_1.TransactionHost,
            },
        ];
        this.exports.push(transactionHostToken);
        if (options.enableTransactionProxy) {
            if (options.adapter.supportsTransactionProxy === false) {
                throw new TransactionProxyUnsupportedError(options.adapter);
            }
            const transactionProxyToken = (0, inject_transaction_decorator_1.getTransactionToken)(options.connectionName);
            this.imports.push(nestjs_cls_1.ClsModule.forFeatureAsync({
                provide: transactionProxyToken,
                inject: [transactionHostToken],
                useFactory: (txHost) => txHost.tx,
                type: 'function',
                global: true,
            }));
        }
    }
    bindLifecycleHooks(options) {
        const { onModuleInit, onModuleDestroy, onApplicationBootstrap, beforeApplicationShutdown, onApplicationShutdown, } = options.adapter;
        return {
            onModuleInit: onModuleInit?.bind(options.adapter),
            onModuleDestroy: onModuleDestroy?.bind(options.adapter),
            onApplicationBootstrap: onApplicationBootstrap?.bind(options.adapter),
            beforeApplicationShutdown: beforeApplicationShutdown?.bind(options.adapter),
            onApplicationShutdown: onApplicationShutdown?.bind(options.adapter),
        };
    }
}
exports.ClsPluginTransactional = ClsPluginTransactional;
class TransactionProxyUnsupportedError extends Error {
    constructor(adapter) {
        super(`The adapter ${adapter.constructor.name} does not support the "Transaction Proxy" feature, please disable the "enableTransactionProxy" option.`);
    }
}
exports.TransactionProxyUnsupportedError = TransactionProxyUnsupportedError;
//# sourceMappingURL=plugin-transactional.js.map