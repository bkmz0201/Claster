#!/usr/bin/env node
import { createRequire } from "node:module";
import { Cli, Command, Option } from "clipanion";
import path, { join, parse, resolve } from "node:path";
import * as colors$2 from "colorette";
import * as colors$1 from "colorette";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import rawDebug from "debug";
import fs, { copyFile, existsSync, mkdir, mkdirSync, promises, readFile, readdir, rmSync, stat, statSync, unlink, writeFile } from "node:fs";
import { promisify } from "node:util";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import { isNil, merge, omit, omitBy, pick, sortBy } from "lodash-es";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { include, lib } from "wasm-sjlj";
import { parse as parse$1 } from "semver";
import { checkbox, confirm, input, select } from "@inquirer/prompts";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { rename } from "node:fs/promises";
import { findUp } from "find-up";
import { Octokit } from "@octokit/rest";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/typeof.js
var require_typeof = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/typeof.js"(exports, module) {
	function _typeof$2(o) {
		"@babel/helpers - typeof";
		return module.exports = _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
			return typeof o$1;
		} : function(o$1) {
			return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
		}, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof$2(o);
	}
	module.exports = _typeof$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js"(exports, module) {
	var _typeof$1 = require_typeof()["default"];
	function toPrimitive$1(t, r) {
		if ("object" != _typeof$1(t) || !t) return t;
		var e = t[Symbol.toPrimitive];
		if (void 0 !== e) {
			var i = e.call(t, r || "default");
			if ("object" != _typeof$1(i)) return i;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return ("string" === r ? String : Number)(t);
	}
	module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js"(exports, module) {
	var _typeof = require_typeof()["default"];
	var toPrimitive = require_toPrimitive();
	function toPropertyKey$1(t) {
		var i = toPrimitive(t, "string");
		return "symbol" == _typeof(i) ? i : i + "";
	}
	module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/defineProperty.js
var require_defineProperty = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/defineProperty.js"(exports, module) {
	var toPropertyKey = require_toPropertyKey();
	function _defineProperty$14(e, r, t) {
		return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
			value: t,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[r] = t, e;
	}
	module.exports = _defineProperty$14, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region src/def/artifacts.ts
var import_defineProperty$13 = __toESM(require_defineProperty(), 1);
var BaseArtifactsCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$13.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$13.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$13.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$13.default)(this, "outputDir", Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" }));
		(0, import_defineProperty$13.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$13.default)(this, "buildOutputDir", Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
(0, import_defineProperty$13.default)(BaseArtifactsCommand, "paths", [["artifacts"]]);
(0, import_defineProperty$13.default)(BaseArtifactsCommand, "usage", Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" }));
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
rawDebug.formatters.i = (v) => {
	return colors$2.green(v);
};
const debugFactory = (namespace) => {
	const debug$10 = rawDebug(`napi:${namespace}`);
	debug$10.info = (...args) => console.error(colors$2.black(colors$2.bgGreen(" INFO ")), ...args);
	debug$10.warn = (...args) => console.error(colors$2.black(colors$2.bgYellow(" WARNING ")), ...args);
	debug$10.error = (...args) => console.error(colors$2.white(colors$2.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$10;
};
const debug$9 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.0.0";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module$1 = "./dist/index.js";
var exports = {
	".": {
		"import": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.js"
		},
		"require": {
			"types": "./dist/index.d.ts",
			"default": "./dist/index.cjs"
		}
	},
	"./package.json": {
		"import": "./package.json",
		"require": "./package.json"
	}
};
var files = ["dist", "src"];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.4.0",
	"@napi-rs/cross-toolchain": "^0.0.19",
	"@napi-rs/wasm-tools": "^0.0.3",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.0",
	"emnapi": "^1.4.0",
	"find-up": "^7.0.0",
	"js-yaml": "^4.1.0",
	"lodash-es": "^4.17.21",
	"semver": "^7.7.1",
	"typanion": "^3.14.0",
	"wasm-sjlj": "^1.0.6"
};
var devDependencies = {
	"@emnapi/core": "^1.4.0",
	"@emnapi/runtime": "^1.4.0",
	"@oxc-node/core": "^0.0.29",
	"@std/toml": "npm:@jsr/std__toml@^1.0.8",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.7",
	"@types/js-yaml": "^4.0.9",
	"@types/lodash-es": "^4.17.12",
	"@types/node": "^22.13.16",
	"@types/semver": "^7.7.0",
	"ava": "^6.2.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.5.3",
	"rolldown": "^1.0.0-beta.23",
	"tslib": "^2.8.1",
	"typescript": "^5.8.2"
};
var peerDependencies = {
	"@emnapi/runtime": "^1.1.0",
	"emnapi": "^1.1.0"
};
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"clean": "node --import @oxc-node/core/register ./clean.ts",
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsc && yarn clean && rolldown -c rolldown.config.js",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "1m",
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var gitHead = "cdbf2bc43945175eabe56b19a6bb0f8584dbc34c";
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module: module$1,
	exports,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava,
	gitHead
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = promisify(readFile);
const writeFileAsync = promisify(writeFile);
const unlinkAsync = promisify(unlink);
const copyFileAsync = promisify(copyFile);
const mkdirAsync = promisify(mkdir);
const statAsync = promisify(stat);
const readdirAsync = promisify(readdir);
async function fileExists(path$1) {
	const exists = await statAsync(path$1).then(() => true).catch(() => false);
	return exists;
}
async function dirExistsAsync(path$1) {
	try {
		const stats = await statAsync(path$1);
		return stats.isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	const exists = await fileExists(path$1);
	if (!exists) {
		debug$9(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triple = rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple;
	const triples = triple.split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	if (rawTriple.includes("ohos")) return {
		triple: rawTriple,
		platformArchABI: `linux-${arch}-ohos`,
		platform: "openharmony",
		arch,
		abi: null
	};
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host?.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	let error = null;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (error) throw new Error("cargo metadata failed to run", { cause: error });
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, "targets"));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig?.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if (userNapiConfig.triples?.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if (userNapiConfig.triples?.additional?.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	const uniqueTargets = new Set(targets);
	if (uniqueTargets.size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$9("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$9("Installing cargo binary: %s", name$1);
		execSync(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$9("Detecting cargo binary: %s", bin$1);
	try {
		execSync(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$9("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$9("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			s += `${exportDeclare(ambient)} class ${line.name} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$1 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	const dts = sortBy(Array.from(groupedDefs), ([namespace]) => namespace).map(([namespace, defs$1]) => {
		if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
			switch (def.kind) {
				case TypeDefKind.Const:
				case TypeDefKind.Enum:
				case TypeDefKind.StringEnum:
				case TypeDefKind.Fn:
				case TypeDefKind.Struct: {
					exports$1.push(def.name);
					if (def.original_name && def.original_name !== def.name) exports$1.push(def.original_name);
					break;
				}
				default: break;
			}
			return prettyPrint(def, constEnum, 0);
		}).join("\n\n");
		else {
			exports$1.push(namespace);
			let declaration = "";
			declaration += `export declare namespace ${namespace} {\n`;
			for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
			declaration += "}";
			return declaration;
		}
	}).join("\n\n") + "\n";
	return {
		dts,
		exports: exports$1
	};
}
async function readIntermediateTypeFile(file) {
	const content = await readFileAsync(file, "utf8");
	const defs = content.split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	});
	return defs.sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = new Map();
	const classDefs = new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	const result = src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		const s = `${" ".repeat(rightIndent)}${line}`;
		return s;
	}).join("\n");
	return result;
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return config;
}

//#endregion
//#region src/api/artifacts.ts
const debug$8 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => UniArchsByPlatform[p.platform]?.map((a) => `${p.platform}-${a}`)).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$8.info(`Read [${colors$1.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$8.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir = distDirs.find((dir$1) => dir$1.includes(platformArchABI));
		if (!dir && universalSourceBins.has(platformArchABI)) {
			debug$8.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir, parsedName.base);
		debug$8.info(`Write file content to [${colors$1.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$8.info(`Write file content to [${colors$1.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$8.info(`Move wasi binding file [${colors$1.yellowBright(cjsFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$8.info(`Move wasi worker file [${colors$1.yellowBright(workerFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$8.info(`Move wasi browser entry file [${colors$1.yellowBright(browserEntry)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$8.info(`Move wasi browser worker file [${colors$1.yellowBright(browserWorkerFile)}] to [${colors$1.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files$1 = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir of dirs) if (dir.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir.name)));
	return nodeBinaries;
}

//#endregion
//#region src/commands/artifacts.ts
var import_defineProperty$12 = __toESM(require_defineProperty(), 1);
var ArtifactsCommand = class extends BaseArtifactsCommand {
	async execute() {
		await collectArtifacts(this.getOptions());
	}
};
(0, import_defineProperty$12.default)(ArtifactsCommand, "usage", Command.Usage({
	description: "Copy artifacts from Github Actions into specified dir",
	examples: [["$0 artifacts --output-dir ./artifacts --dist ./npm", `Copy [binaryName].[platform].node under current dir(.) into packages under npm dir.
e.g: index.linux-x64-gnu.node --> ./npm/linux-x64-gnu/index.linux-x64-gnu.node`]]
}));
(0, import_defineProperty$12.default)(ArtifactsCommand, "paths", [["artifacts"]]);

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents) {
	return `${bindingHeader}
const { createRequire } = require('node:module')
require = createRequire(__filename)

${createCommonBinding(localName, pkgName)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      ${requireTuple("win32-x64-msvc")}
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("linux-arm64-ohos")}
    } else if (process.arch === 'x64') {
      ${requireTuple("linux-x64-ohos")}
    } else if (process.arch === 'arm') {
      ${requireTuple("linux-arm-ohos")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./${localName}.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('${pkgName}-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	const fsImport = fs$1 ? `import { memfs } from '@napi-rs/wasm-runtime/fs'` : "";
	const bufferImport = buffer ? fs$1 ? `` : `import { Buffer } from 'buffer'` : "";
	const wasiCreation = fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`;
	const workerFsHandler = fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : "";
	const emnapiInjectBuffer = buffer ? "__emnapiContext.feature.Buffer = Buffer" : "";
	const emnapiInstantiateImport = asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`;
	const emnapiInstantiateCall = asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`;
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${emnapiInstantiateImport},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fsImport}
${bufferImport}
${wasiCreation}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${emnapiInjectBuffer}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${emnapiInstantiateCall}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${workerFsHandler}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	const fsImport = fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`;
	const wasiCreation = fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`;
	return `${fsImport}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${wasiCreation}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
var import_defineProperty$11 = __toESM(require_defineProperty(), 1);
const debug$7 = debugFactory("build");
const require$1 = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$7("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.configPath ?? options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	const builder = new Builder(metadata, crate, config, options);
	return builder.build();
}
var Builder = class {
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		(0, import_defineProperty$11.default)(this, "args", []);
		(0, import_defineProperty$11.default)(this, "envs", {});
		(0, import_defineProperty$11.default)(this, "outputs", []);
		(0, import_defineProperty$11.default)(this, "target", void 0);
		(0, import_defineProperty$11.default)(this, "crateDir", void 0);
		(0, import_defineProperty$11.default)(this, "outputDir", void 0);
		(0, import_defineProperty$11.default)(this, "targetDir", void 0);
		(0, import_defineProperty$11.default)(this, "enableTypeDef", false);
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$7.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$7.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		return this.crate.targets.find((t) => t.crate_types.includes("cdylib"))?.name;
	}
	get binName() {
		return this.options.bin ?? (this.cdyLibName ? null : this.crate.targets.find((t) => t.crate_types.includes("bin"))?.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$7.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$7.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$7.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			const { version: version$2, download } = require$1("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$7(`Toolchain ${toolchainPath} exists, skip extracting`);
			else {
				const tarArchive = download(process.arch, this.target.triple);
				tarArchive.unpack(toolchainPath);
			}
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.envs[linkerEnv] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_SYSROOT) this.envs[`TARGET_SYSROOT`] = join(toolchainPath, crossTargetName, "sysroot");
			if (!process.env.TARGET_AR) this.envs[`TARGET_AR`] = join(toolchainPath, "bin", `${crossTargetName}-ar`);
			if (!process.env.TARGET_RANLIB) this.envs[`TARGET_RANLIB`] = join(toolchainPath, "bin", `${crossTargetName}-ranlib`);
			if (!process.env.TARGET_READELF) this.envs[`TARGET_READELF`] = join(toolchainPath, "bin", `${crossTargetName}-readelf`);
			if (!process.env.TARGET_C_INCLUDE_PATH) this.envs[`TARGET_C_INCLUDE_PATH`] = join(toolchainPath, crossTargetName, "sysroot", "usr", "include/");
			if (!process.env.TARGET_CC) this.envs[`TARGET_CC`] = join(toolchainPath, "bin", `${crossTargetName}-gcc`);
			if (!process.env.TARGET_CXX) this.envs[`TARGET_CXX`] = join(toolchainPath, "bin", `${crossTargetName}-g++`);
			if (process.env.TARGET_CC?.startsWith("clang") || process.env.CC?.startsWith("clang") && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (process.env.CXX?.startsWith("clang++") && !process.env.TARGET_CXX || process.env.TARGET_CXX?.startsWith("clang++")) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$7.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$7(`Start building crate: ${this.crate.name}`);
		debug$7("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		const buildTask = new Promise((resolve$1, reject) => {
			if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
			const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
			const buildProcess = spawn(command, this.args, {
				env: {
					...process.env,
					...this.envs
				},
				stdio: watch ? [
					"inherit",
					"inherit",
					"pipe"
				] : "inherit",
				cwd: this.options.cwd,
				signal: controller.signal
			});
			buildProcess.once("exit", (code) => {
				if (code === 0) {
					debug$7("%i", `Build crate ${this.crate.name} successfully!`);
					resolve$1();
				} else reject(new Error(`Build failed with exit code ${code}`));
			});
			buildProcess.once("error", (e) => {
				reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
			});
			buildProcess.stderr?.on("data", (data) => {
				const output = data.toString();
				console.error(output);
				if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
			});
		});
		return {
			task: buildTask.then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$7.warn("Watch mode is not supported in CI environment");
		else {
			debug$7("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$7.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && function(abi) {
			const glibcVersionRuntime = process.report?.getReport()?.header?.glibcVersionRuntime;
			const libc = glibcVersionRuntime ? "gnu" : "musl";
			return abi === libc;
		}(this.target.abi)) debug$7.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$7.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$7("Set package flags: ");
			debug$7("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$7("Set compiling target to: ");
		debug$7("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (this.target.abi?.includes("musl") && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$7("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$7("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$7.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require$1.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		this.envs.SETJMP_LINK_DIR = lib;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj -I${include}`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj -I${include}`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_NATIVE}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$7.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$7("Set features flags: ");
		debug$7("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if (this.options.cargoOptions?.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$7(`Try to create output directory:`);
			debug$7("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$7(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$7(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$7("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$7("Copy artifact to:");
			debug$7("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$7("Generate debug wasm module");
				try {
					const debugWasmModule = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src));
					const debugWasmBinary = debugWasmModule.emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$7("Generate release wasm module");
					const releaseWasmModule = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary);
					const releaseWasmBinary = releaseWasmModule.emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$7.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef || !await dirExistsAsync(typeDefDir)) return [];
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		let header = "";
		let dts = "";
		let exports$1 = [];
		if (!this.options.noDtsHeader) {
			const dtsHeader = this.options.dtsHeader ?? this.config.dtsHeader;
			if (this.config.dtsHeaderFile) try {
				header = await readFileAsync(join(this.options.cwd, this.config.dtsHeaderFile), "utf-8");
			} catch (e) {
				debug$7.warn(`Failed to read dts header file ${this.config.dtsHeaderFile}`, e);
			}
			else if (dtsHeader) header = dtsHeader;
			else header = DEFAULT_TYPE_DEF_HEADER;
		}
		const files$1 = await readdirAsync(typeDefDir, { withFileTypes: true });
		if (!files$1.length) {
			debug$7("No type def files found. Skip generating dts file.");
			return [];
		}
		for (const file of files$1) {
			if (!file.isFile()) continue;
			const { dts: fileDts, exports: fileExports } = await processTypeDef(join(typeDefDir, file.name), this.options.constEnum ?? this.config.constEnum ?? true);
			dts += fileDts;
			exports$1.push(...fileExports);
		}
		if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
		if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
		dts = header + dts;
		try {
			debug$7("Writing type def to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
			this.outputs.push({
				kind: "dts",
				path: dest
			});
		} catch (e) {
			debug$7.error("Failed to write type def file");
			debug$7.error(e);
		}
		return exports$1;
	}
	async writeJsBinding(idents) {
		if (!this.options.platform || this.options.noJsBinding || idents.length === 0) return;
		const name$1 = this.options.jsBinding ?? "index.js";
		const createBinding = this.options.esm ? createEsmBinding : createCjsBinding;
		const binding = createBinding(this.config.binaryName, this.config.packageName, idents);
		try {
			const dest = join(this.outputDir, name$1);
			debug$7("Writing js binding to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, binding, "utf-8");
			return {
				kind: "js",
				path: dest
			};
		} catch (e) {
			throw new Error("Failed to write js binding file", { cause: e });
		}
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			const { name: name$1, dir } = parse(distFileName);
			const bindingPath = join(dir, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir, "wasi-worker.mjs");
			const browserWorkerPath = join(dir, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, this.config.wasm?.initialMemory, this.config.wasm?.maximumMemory, this.config.wasm?.browser?.fs, this.config.wasm?.browser?.asyncInit, this.config.wasm?.browser?.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(this.config.wasm?.browser?.fs ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};

//#endregion
//#region src/def/build.ts
var import_defineProperty$10 = __toESM(require_defineProperty(), 1);
var BaseBuildCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$10.default)(this, "target", Option.String("--target,-t", { description: "Build for the target triple, bypassed to `cargo build --target`" }));
		(0, import_defineProperty$10.default)(this, "cwd", Option.String("--cwd", { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$10.default)(this, "manifestPath", Option.String("--manifest-path", { description: "Path to `Cargo.toml`" }));
		(0, import_defineProperty$10.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$10.default)(this, "packageJsonPath", Option.String("--package-json-path", { description: "Path to `package.json`" }));
		(0, import_defineProperty$10.default)(this, "targetDir", Option.String("--target-dir", { description: "Directory for all crate generated artifacts, see `cargo build --target-dir`" }));
		(0, import_defineProperty$10.default)(this, "outputDir", Option.String("--output-dir,-o", { description: "Path to where all the built files would be put. Default to the crate folder" }));
		(0, import_defineProperty$10.default)(this, "platform", Option.Boolean("--platform", { description: "Add platform triple to the generated nodejs binding file, eg: `[name].linux-x64-gnu.node`" }));
		(0, import_defineProperty$10.default)(this, "jsPackageName", Option.String("--js-package-name", { description: "Package name in generated js binding file. Only works with `--platform` flag" }));
		(0, import_defineProperty$10.default)(this, "constEnum", Option.Boolean("--const-enum", { description: "Whether generate const enum for typescript bindings" }));
		(0, import_defineProperty$10.default)(this, "jsBinding", Option.String("--js", { description: "Path and filename of generated JS binding file. Only works with `--platform` flag. Relative to `--output-dir`." }));
		(0, import_defineProperty$10.default)(this, "noJsBinding", Option.Boolean("--no-js", { description: "Whether to disable the generation JS binding file. Only works with `--platform` flag." }));
		(0, import_defineProperty$10.default)(this, "dts", Option.String("--dts", { description: "Path and filename of generated type def file. Relative to `--output-dir`" }));
		(0, import_defineProperty$10.default)(this, "dtsHeader", Option.String("--dts-header", { description: "Custom file header for generated type def file. Only works when `typedef` feature enabled." }));
		(0, import_defineProperty$10.default)(this, "noDtsHeader", Option.Boolean("--no-dts-header", { description: "Whether to disable the default file header for generated type def file. Only works when `typedef` feature enabled." }));
		(0, import_defineProperty$10.default)(this, "dtsCache", Option.Boolean("--dts-cache", true, { description: "Whether to enable the dts cache, default to true" }));
		(0, import_defineProperty$10.default)(this, "esm", Option.Boolean("--esm", { description: "Whether to emit an ESM JS binding file instead of CJS format. Only works with `--platform` flag." }));
		(0, import_defineProperty$10.default)(this, "strip", Option.Boolean("--strip,-s", { description: "Whether strip the library to achieve the minimum file size" }));
		(0, import_defineProperty$10.default)(this, "release", Option.Boolean("--release,-r", { description: "Build in release mode" }));
		(0, import_defineProperty$10.default)(this, "verbose", Option.Boolean("--verbose,-v", { description: "Verbosely log build command trace" }));
		(0, import_defineProperty$10.default)(this, "bin", Option.String("--bin", { description: "Build only the specified binary" }));
		(0, import_defineProperty$10.default)(this, "package", Option.String("--package,-p", { description: "Build the specified library or the one at cwd" }));
		(0, import_defineProperty$10.default)(this, "profile", Option.String("--profile", { description: "Build artifacts with the specified profile" }));
		(0, import_defineProperty$10.default)(this, "crossCompile", Option.Boolean("--cross-compile,-x", { description: "[experimental] cross-compile for the specified target with `cargo-xwin` on windows and `cargo-zigbuild` on other platform" }));
		(0, import_defineProperty$10.default)(this, "useCross", Option.Boolean("--use-cross", { description: "[experimental] use [cross](https://github.com/cross-rs/cross) instead of `cargo`" }));
		(0, import_defineProperty$10.default)(this, "useNapiCross", Option.Boolean("--use-napi-cross", { description: "[experimental] use @napi-rs/cross-toolchain to cross-compile Linux arm/arm64/x64 gnu targets." }));
		(0, import_defineProperty$10.default)(this, "watch", Option.Boolean("--watch,-w", { description: "watch the crate changes and build continuously with `cargo-watch` crates" }));
		(0, import_defineProperty$10.default)(this, "features", Option.Array("--features,-F", { description: "Space-separated list of features to activate" }));
		(0, import_defineProperty$10.default)(this, "allFeatures", Option.Boolean("--all-features", { description: "Activate all available features" }));
		(0, import_defineProperty$10.default)(this, "noDefaultFeatures", Option.Boolean("--no-default-features", { description: "Do not activate the `default` feature" }));
	}
	getOptions() {
		return {
			target: this.target,
			cwd: this.cwd,
			manifestPath: this.manifestPath,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			targetDir: this.targetDir,
			outputDir: this.outputDir,
			platform: this.platform,
			jsPackageName: this.jsPackageName,
			constEnum: this.constEnum,
			jsBinding: this.jsBinding,
			noJsBinding: this.noJsBinding,
			dts: this.dts,
			dtsHeader: this.dtsHeader,
			noDtsHeader: this.noDtsHeader,
			dtsCache: this.dtsCache,
			esm: this.esm,
			strip: this.strip,
			release: this.release,
			verbose: this.verbose,
			bin: this.bin,
			package: this.package,
			profile: this.profile,
			crossCompile: this.crossCompile,
			useCross: this.useCross,
			useNapiCross: this.useNapiCross,
			watch: this.watch,
			features: this.features,
			allFeatures: this.allFeatures,
			noDefaultFeatures: this.noDefaultFeatures
		};
	}
};
(0, import_defineProperty$10.default)(BaseBuildCommand, "paths", [["build"]]);
(0, import_defineProperty$10.default)(BaseBuildCommand, "usage", Command.Usage({ description: "Build the NAPI-RS project" }));

//#endregion
//#region src/commands/build.ts
var import_defineProperty$9 = __toESM(require_defineProperty(), 1);
const debug$6 = debugFactory("build");
var BuildCommand = class extends BaseBuildCommand {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$9.default)(this, "pipe", Option.String("--pipe", { description: "Pipe all outputs file to given command. e.g. `napi build --pipe \"npx prettier --write\"`" }));
		(0, import_defineProperty$9.default)(this, "cargoOptions", Option.Rest());
	}
	async execute() {
		const { task } = await buildProject({
			...this.getOptions(),
			cargoOptions: this.cargoOptions
		});
		const outputs = await task;
		if (this.pipe) for (const output of outputs) {
			debug$6("Piping output file to command: %s", this.pipe);
			try {
				execSync(`${this.pipe} ${output.path}`, {
					stdio: "inherit",
					cwd: this.cwd
				});
			} catch (e) {
				debug$6.error(`Failed to pipe output file ${output.path} to command`);
				debug$6.error(e);
			}
		}
	}
};

//#endregion
//#region src/def/create-npm-dirs.ts
var import_defineProperty$8 = __toESM(require_defineProperty(), 1);
var BaseCreateNpmDirsCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$8.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$8.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$8.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$8.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$8.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$8.default)(BaseCreateNpmDirsCommand, "paths", [["create-npm-dirs"]]);
(0, import_defineProperty$8.default)(BaseCreateNpmDirsCommand, "usage", Command.Usage({ description: "Create npm package dirs for different platforms" }));
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$5 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir) {
		debug$5("Try to create dir: %i", dir);
		if (options.dryRun) return;
		await mkdirAsync(dir, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$5("Writing file %i", file);
		if (options.dryRun) {
			debug$5(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$5(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			scopedPackageJson.files?.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if (scopedPackageJson.engines?.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = join(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = join(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$5.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/commands/create-npm-dirs.ts
var CreateNpmDirsCommand = class extends BaseCreateNpmDirsCommand {
	async execute() {
		await createNpmDirs(this.getOptions());
	}
};

//#endregion
//#region src/commands/help.ts
var import_defineProperty$7 = __toESM(require_defineProperty(), 1);
/**
* A command that prints the usage of all commands.
*
* Paths: `-h`, `--help`
*/
var HelpCommand = class extends Command {
	async execute() {
		await this.context.stdout.write(this.cli.usage());
	}
};
(0, import_defineProperty$7.default)(HelpCommand, "paths", [[`-h`], [`--help`]]);

//#endregion
//#region src/def/new.ts
var import_defineProperty$6 = __toESM(require_defineProperty(), 1);
var BaseNewCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$6.default)(this, "$$path", Option.String({ required: false }));
		(0, import_defineProperty$6.default)(this, "$$name", Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" }));
		(0, import_defineProperty$6.default)(this, "minNodeApiVersion", Option.String("--min-node-api,-v", "4", {
			validator: typanion.isNumber(),
			description: "The minimum Node-API version to support"
		}));
		(0, import_defineProperty$6.default)(this, "packageManager", Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." }));
		(0, import_defineProperty$6.default)(this, "license", Option.String("--license,-l", "MIT", { description: "License for open-sourced project" }));
		(0, import_defineProperty$6.default)(this, "targets", Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." }));
		(0, import_defineProperty$6.default)(this, "enableDefaultTargets", Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" }));
		(0, import_defineProperty$6.default)(this, "enableAllTargets", Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" }));
		(0, import_defineProperty$6.default)(this, "enableTypeDef", Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" }));
		(0, import_defineProperty$6.default)(this, "enableGithubActions", Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" }));
		(0, import_defineProperty$6.default)(this, "testFramework", Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" }));
		(0, import_defineProperty$6.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" }));
	}
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$6.default)(BaseNewCommand, "paths", [["new"]]);
(0, import_defineProperty$6.default)(BaseNewCommand, "usage", Command.Usage({ description: "Create a new project with pre-configured boilerplate" }));
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/checkPrivateRedeclaration.js
var require_checkPrivateRedeclaration = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/checkPrivateRedeclaration.js"(exports, module) {
	function _checkPrivateRedeclaration(e, t) {
		if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	module.exports = _checkPrivateRedeclaration, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateMethodInitSpec.js
var require_classPrivateMethodInitSpec = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateMethodInitSpec.js"(exports, module) {
	var checkPrivateRedeclaration$1 = require_checkPrivateRedeclaration();
	function _classPrivateMethodInitSpec$1(e, a) {
		checkPrivateRedeclaration$1(e, a), a.add(e);
	}
	module.exports = _classPrivateMethodInitSpec$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldInitSpec.js
var require_classPrivateFieldInitSpec = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldInitSpec.js"(exports, module) {
	var checkPrivateRedeclaration = require_checkPrivateRedeclaration();
	function _classPrivateFieldInitSpec$2(e, t, a) {
		checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	module.exports = _classPrivateFieldInitSpec$2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/assertClassBrand.js
var require_assertClassBrand = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/assertClassBrand.js"(exports, module) {
	function _assertClassBrand$1(e, t, n) {
		if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
		throw new TypeError("Private element is not present on this object");
	}
	module.exports = _assertClassBrand$1, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldGet2.js
var require_classPrivateFieldGet2 = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldGet2.js"(exports, module) {
	var assertClassBrand$1 = require_assertClassBrand();
	function _classPrivateFieldGet2(s, a) {
		return s.get(assertClassBrand$1(s, a));
	}
	module.exports = _classPrivateFieldGet2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@std/toml/stringify.js
var import_classPrivateMethodInitSpec = __toESM(require_classPrivateMethodInitSpec(), 1);
var import_defineProperty$5 = __toESM(require_defineProperty(), 1);
var import_classPrivateFieldInitSpec$1 = __toESM(require_classPrivateFieldInitSpec(), 1);
var import_assertClassBrand = __toESM(require_assertClassBrand(), 1);
var import_classPrivateFieldGet2$1 = __toESM(require_classPrivateFieldGet2(), 1);
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var _arrayTypeCache = /* @__PURE__ */ new WeakMap();
var _Dumper_brand = /* @__PURE__ */ new WeakSet();
var Dumper = class {
	constructor(srcObjc) {
		(0, import_classPrivateMethodInitSpec.default)(this, _Dumper_brand);
		(0, import_defineProperty$5.default)(this, "maxPad", 0);
		(0, import_defineProperty$5.default)(this, "srcObject", void 0);
		(0, import_defineProperty$5.default)(this, "output", []);
		(0, import_classPrivateFieldInitSpec$1.default)(this, _arrayTypeCache, new Map());
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = (0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, this.srcObject);
		this.output = (0, import_assertClassBrand.default)(_Dumper_brand, this, _format).call(this, fmtOptions);
		return this.output;
	}
};
function _printObject(obj, keys = []) {
	const out = [];
	const props = Object.keys(obj);
	const inlineProps = [];
	const multilineProps = [];
	for (const prop of props) if ((0, import_assertClassBrand.default)(_Dumper_brand, this, _isSimplySerializable).call(this, obj[prop])) inlineProps.push(prop);
	else multilineProps.push(prop);
	const sortedProps = inlineProps.concat(multilineProps);
	for (const prop of sortedProps) {
		const value$1 = obj[prop];
		if (value$1 instanceof Date) out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _dateDeclaration).call(this, [prop], value$1));
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _strDeclaration).call(this, [prop], value$1.toString()));
		else if (typeof value$1 === "number") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _numberDeclaration).call(this, [prop], value$1));
		else if (typeof value$1 === "boolean") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _boolDeclaration).call(this, [prop], value$1));
		else if (value$1 instanceof Array) {
			const arrayType = (0, import_assertClassBrand.default)(_Dumper_brand, this, _getTypeOfArray).call(this, value$1);
			if (arrayType === "ONLY_PRIMITIVE") out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _arrayDeclaration).call(this, [prop], value$1));
			else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
				out.push("");
				out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _headerGroup).call(this, [...keys, prop]));
				out.push(...(0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, value$1[i], [...keys, prop]));
			}
			else {
				const str = value$1.map((x) => (0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, x)).join(",");
				out.push(`${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, [prop])}[${str}]`);
			}
		} else if (typeof value$1 === "object") {
			out.push("");
			out.push((0, import_assertClassBrand.default)(_Dumper_brand, this, _header).call(this, [...keys, prop]));
			if (value$1) {
				const toParse = value$1;
				out.push(...(0, import_assertClassBrand.default)(_Dumper_brand, this, _printObject).call(this, toParse, [...keys, prop]));
			}
		}
	}
	out.push("");
	return out;
}
function _isPrimitive(value$1) {
	return value$1 instanceof Date || value$1 instanceof RegExp || [
		"string",
		"number",
		"boolean"
	].includes(typeof value$1);
}
function _getTypeOfArray(arr) {
	if ((0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).has(arr)) return (0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).get(arr);
	const type$1 = (0, import_assertClassBrand.default)(_Dumper_brand, this, _doGetTypeOfArray).call(this, arr);
	(0, import_classPrivateFieldGet2$1.default)(_arrayTypeCache, this).set(arr, type$1);
	return type$1;
}
function _doGetTypeOfArray(arr) {
	if (!arr.length) return "ONLY_PRIMITIVE";
	const onlyPrimitive = (0, import_assertClassBrand.default)(_Dumper_brand, this, _isPrimitive).call(this, arr[0]);
	if (arr[0] instanceof Array) return "MIXED";
	for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== (0, import_assertClassBrand.default)(_Dumper_brand, this, _isPrimitive).call(this, arr[i]) || arr[i] instanceof Array) return "MIXED";
	return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
}
function _printAsInlineValue(value$1) {
	if (value$1 instanceof Date) return `"${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printDate).call(this, value$1)}"`;
	else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
	else if (typeof value$1 === "number") return value$1;
	else if (typeof value$1 === "boolean") return value$1.toString();
	else if (value$1 instanceof Array) {
		const str = value$1.map((x) => (0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, x)).join(",");
		return `[${str}]`;
	} else if (typeof value$1 === "object") {
		if (!value$1) throw new Error("Should never reach");
		const str = Object.keys(value$1).map((key) => {
			return `${joinKeys([key])} = ${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printAsInlineValue).call(this, value$1[key])}`;
		}).join(",");
		return `{${str}}`;
	}
	throw new Error("Should never reach");
}
function _isSimplySerializable(value$1) {
	return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && (0, import_assertClassBrand.default)(_Dumper_brand, this, _getTypeOfArray).call(this, value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
}
function _header(keys) {
	return `[${joinKeys(keys)}]`;
}
function _headerGroup(keys) {
	return `[[${joinKeys(keys)}]]`;
}
function _declaration(keys) {
	const title = joinKeys(keys);
	if (title.length > this.maxPad) this.maxPad = title.length;
	return `${title} = `;
}
function _arrayDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${JSON.stringify(value$1)}`;
}
function _strDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${JSON.stringify(value$1)}`;
}
function _numberDeclaration(keys, value$1) {
	if (Number.isNaN(value$1)) return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}nan`;
	switch (value$1) {
		case Infinity: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}inf`;
		case -Infinity: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}-inf`;
		default: return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${value$1}`;
	}
}
function _boolDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${value$1}`;
}
function _printDate(value$1) {
	function dtPad(v, lPad = 2) {
		return v.padStart(lPad, "0");
	}
	const m = dtPad((value$1.getUTCMonth() + 1).toString());
	const d = dtPad(value$1.getUTCDate().toString());
	const h = dtPad(value$1.getUTCHours().toString());
	const min = dtPad(value$1.getUTCMinutes().toString());
	const s = dtPad(value$1.getUTCSeconds().toString());
	const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
	const fData = `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
	return fData;
}
function _dateDeclaration(keys, value$1) {
	return `${(0, import_assertClassBrand.default)(_Dumper_brand, this, _declaration).call(this, keys)}${(0, import_assertClassBrand.default)(_Dumper_brand, this, _printDate).call(this, value$1)}`;
}
function _format(options = {}) {
	const { keyAlignment = false } = options;
	const rDeclaration = /^(\".*\"|[^=]*)\s=/;
	const out = [];
	for (let i = 0; i < this.output.length; i++) {
		const l = this.output[i];
		if (l[0] === "[" && l[1] !== "[") {
			if (this.output[i + 1] === "" && this.output[i + 2]?.slice(0, l.length) === l.slice(0, -1) + ".") {
				i += 1;
				continue;
			}
			out.push(l);
		} else if (keyAlignment) {
			const m = rDeclaration.exec(l);
			if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
			else out.push(l);
		} else out.push(l);
	}
	const cleanedOutput = [];
	for (let i = 0; i < out.length; i++) {
		const l = out[i];
		if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
	}
	return cleanedOutput;
}
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldSet2.js
var require_classPrivateFieldSet2 = __commonJS({ "../node_modules/@oxc-project/runtime/src/helpers/classPrivateFieldSet2.js"(exports, module) {
	var assertClassBrand = require_assertClassBrand();
	function _classPrivateFieldSet2(s, a, r) {
		return s.set(assertClassBrand(s, a), r), r;
	}
	module.exports = _classPrivateFieldSet2, module.exports.__esModule = true, module.exports["default"] = module.exports;
} });

//#endregion
//#region ../node_modules/@std/toml/_parser.js
var import_classPrivateFieldInitSpec = __toESM(require_classPrivateFieldInitSpec(), 1);
var import_classPrivateFieldSet2 = __toESM(require_classPrivateFieldSet2(), 1);
var import_classPrivateFieldGet2 = __toESM(require_classPrivateFieldGet2(), 1);
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var _whitespace = /* @__PURE__ */ new WeakMap();
var _position = /* @__PURE__ */ new WeakMap();
var _source = /* @__PURE__ */ new WeakMap();
var Scanner = class {
	constructor(source) {
		(0, import_classPrivateFieldInitSpec.default)(this, _whitespace, /[ \t]/);
		(0, import_classPrivateFieldInitSpec.default)(this, _position, 0);
		(0, import_classPrivateFieldInitSpec.default)(this, _source, void 0);
		(0, import_classPrivateFieldSet2.default)(_source, this, source);
	}
	get position() {
		return (0, import_classPrivateFieldGet2.default)(_position, this);
	}
	get source() {
		return (0, import_classPrivateFieldGet2.default)(_source, this);
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return (0, import_classPrivateFieldGet2.default)(_source, this)[(0, import_classPrivateFieldGet2.default)(_position, this) + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return (0, import_classPrivateFieldGet2.default)(_source, this).slice((0, import_classPrivateFieldGet2.default)(_position, this) + start, (0, import_classPrivateFieldGet2.default)(_position, this) + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		(0, import_classPrivateFieldSet2.default)(_position, this, (0, import_classPrivateFieldGet2.default)(_position, this) + count);
	}
	skipWhitespaces() {
		while ((0, import_classPrivateFieldGet2.default)(_whitespace, this).test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = (0, import_classPrivateFieldGet2.default)(_position, this);
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if ((0, import_classPrivateFieldGet2.default)(_whitespace, this).test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return (0, import_classPrivateFieldGet2.default)(_position, this) >= (0, import_classPrivateFieldGet2.default)(_source, this).length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return (0, import_classPrivateFieldGet2.default)(_source, this).startsWith(searchString, (0, import_classPrivateFieldGet2.default)(_position, this));
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = (0, import_classPrivateFieldGet2.default)(_position, this);
		return (0, import_classPrivateFieldGet2.default)(_source, this).match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = {}) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		const last = currentValue.at(-1);
		deepAssign(last, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		currentValue.push(value$1);
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		const sep = Separator(scanner);
		if (!sep.ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = {};
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	scanner.skipWhitespaces();
	const key = scanner.match(BARE_KEY_REGEXP)?.[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = string === "true";
	return success(value$1);
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = NaN;
	return success(value$1);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BINARY_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(OCTAL_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(HEX_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INTEGER_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const int = parseInt(value$1, 10);
	return success(int);
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(FLOAT_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(LOCAL_TIME_REGEXP)?.[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({});
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = {};
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : {}
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({});
	const body = blocks.body.reduce(deepAssign, {});
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	const string = scanner.source.slice(0, scanner.position);
	const lines = string.split("\n");
	const row = lines.length;
	const column = lines.at(-1)?.length ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			const message = "Invalid error type caught";
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region src/def/rename.ts
var import_defineProperty$4 = __toESM(require_defineProperty(), 1);
var BaseRenameCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$4.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$4.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$4.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$4.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$4.default)(this, "$$name", Option.String("--name,-n", { description: "The new name of the project" }));
		(0, import_defineProperty$4.default)(this, "binaryName", Option.String("--binary-name,-b", { description: "The new binary name *.node files" }));
		(0, import_defineProperty$4.default)(this, "packageName", Option.String("--package-name", { description: "The new package name of the project" }));
		(0, import_defineProperty$4.default)(this, "manifestPath", Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" }));
		(0, import_defineProperty$4.default)(this, "repository", Option.String("--repository", { description: "The new repository of the project" }));
		(0, import_defineProperty$4.default)(this, "description", Option.String("--description", { description: "The new description of the project" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
(0, import_defineProperty$4.default)(BaseRenameCommand, "paths", [["rename"]]);
(0, import_defineProperty$4.default)(BaseRenameCommand, "usage", Command.Usage({ description: "Rename the NAPI-RS project" }));
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const napiConfig = await readConfig(options);
	const oldName = napiConfig.binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = await findUp(".github", {
			cwd: options.cwd,
			type: "directory"
		});
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = load(githubActionsContent);
				if (githubActionsData.env?.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) {
			const gitAttributesContent = await readFileAsync(gitAttributesPath, "utf8");
			const gitAttributesData = gitAttributesContent.split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$4 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$4(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$4("Template updated successfully");
		} catch (error) {
			debug$4(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$4(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$4("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if (packageJson.napi?.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	const content = await promises.readFile(filePath, "utf-8");
	const yaml = load(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml?.jobs?.build?.strategy?.matrix?.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else if (yaml?.jobs?.["test-macOS-windows-binding"]?.strategy?.matrix?.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	if (!hasLinuxTargets) {
		if (yaml?.jobs?.["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else if (yaml?.jobs?.["test-linux-binding"]?.strategy?.matrix?.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
		if (target) return enabledTargets.includes(target);
		return true;
	});
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		const job = jobConfig;
		if (job.strategy?.matrix?.settings?.[0]?.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray(yaml.jobs?.publish?.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	debug$4("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$4(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$4(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!options.targets?.length) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$4("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$4("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		const out = execSync(`rustup target list`, { encoding: "utf8" });
		if (out.includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$4("Will create napi-rs project with given options:");
	debug$4(userOptions);
	const options = processOptions(userOptions);
	debug$4("Targets to be enabled:");
	debug$4(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = path.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$4(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$4(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			const files$1 = await readdirAsync(path$1);
			if (files$1.length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$4(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region src/commands/new.ts
var import_defineProperty$3 = __toESM(require_defineProperty(), 1);
const debug$3 = debugFactory("new");
var NewCommand = class extends BaseNewCommand {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$3.default)(this, "interactive", Option.Boolean("--interactive,-i", true, { description: "Ask project basic information interactively without just using the default." }));
	}
	async execute() {
		try {
			const options = await this.fetchOptions();
			await newProject(options);
			return 0;
		} catch (e) {
			debug$3("Failed to create new project");
			debug$3.error(e);
			return 1;
		}
	}
	async fetchOptions() {
		const cmdOptions = super.getOptions();
		if (this.interactive) {
			const targetPath = cmdOptions.path ? cmdOptions.path : await inquirerProjectPath();
			cmdOptions.path = targetPath;
			return {
				...cmdOptions,
				name: await this.fetchName(path.parse(targetPath).base),
				minNodeApiVersion: await this.fetchNapiVersion(),
				targets: await this.fetchTargets(),
				license: await this.fetchLicense(),
				enableTypeDef: await this.fetchTypeDef(),
				enableGithubActions: await this.fetchGithubActions()
			};
		}
		return cmdOptions;
	}
	async fetchName(defaultName) {
		return this.$$name ?? input({
			message: "Package name (the name field in your package.json file)",
			default: defaultName
		});
	}
	async fetchLicense() {
		return input({
			message: "License for open-sourced project",
			default: this.license
		});
	}
	async fetchNapiVersion() {
		return select({
			message: "Minimum node-api version (with node version requirement)",
			loop: false,
			choices: Array.from({ length: 8 }, (_, i) => ({
				name: `napi${i + 1} (${napiEngineRequirement(i + 1)})`,
				value: i + 1
			})),
			default: this.minNodeApiVersion - 1
		});
	}
	async fetchTargets() {
		if (this.enableAllTargets) return AVAILABLE_TARGETS.concat();
		const targets = await checkbox({
			loop: false,
			message: "Choose target(s) your crate will be compiled to",
			choices: AVAILABLE_TARGETS.map((target) => ({
				name: target,
				value: target,
				checked: DEFAULT_TARGETS.includes(target)
			}))
		});
		return targets;
	}
	async fetchTypeDef() {
		const enableTypeDef = await confirm({
			message: "Enable type definition auto-generation",
			default: this.enableTypeDef
		});
		return enableTypeDef;
	}
	async fetchGithubActions() {
		const enableGithubActions = await confirm({
			message: "Enable Github Actions CI",
			default: this.enableGithubActions
		});
		return enableGithubActions;
	}
};
async function inquirerProjectPath() {
	return input({ message: "Target path to create the project, relative to cwd." }).then((path$1) => {
		if (!path$1) return inquirerProjectPath();
		return path$1;
	});
}

//#endregion
//#region src/def/pre-publish.ts
var import_defineProperty$2 = __toESM(require_defineProperty(), 1);
var BasePrePublishCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$2.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$2.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$2.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$2.default)(this, "npmDir", Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" }));
		(0, import_defineProperty$2.default)(this, "tagStyle", Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" }));
		(0, import_defineProperty$2.default)(this, "ghRelease", Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" }));
		(0, import_defineProperty$2.default)(this, "ghReleaseName", Option.String("--gh-release-name", { description: "GitHub release name" }));
		(0, import_defineProperty$2.default)(this, "ghReleaseId", Option.String("--gh-release-id", { description: "Existing GitHub release id" }));
		(0, import_defineProperty$2.default)(this, "skipOptionalPublish", Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" }));
		(0, import_defineProperty$2.default)(this, "dryRun", Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
(0, import_defineProperty$2.default)(BasePrePublishCommand, "paths", [["pre-publish"], ["prepublish"]]);
(0, import_defineProperty$2.default)(BasePrePublishCommand, "usage", Command.Usage({ description: "Update package.json and copy addons into per platform packages" }));
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var import_defineProperty$1 = __toESM(require_defineProperty(), 1);
var BaseVersionCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty$1.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty$1.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty$1.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty$1.default)(this, "npmDir", Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
(0, import_defineProperty$1.default)(BaseVersionCommand, "paths", [["version"]]);
(0, import_defineProperty$1.default)(BaseVersionCommand, "usage", Command.Usage({ description: "Update version in created npm packages" }));
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$2 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$2(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$1 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$1("Receive pre-publish options:");
	debug$1("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$1(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$1(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			const packagesToPublish = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag);
			pkgInfo$1 = packagesToPublish.find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$1.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) execSync(`${npmClient} publish`, {
				cwd: pkgDir,
				env: process.env
			});
			if (options.ghRelease && repo && owner) {
				debug$1.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$1.info(`GitHub release created`);
					debug$1.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$1.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$1.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	const name$1 = segments.join("@");
	return {
		name: name$1,
		version: version$2,
		tag
	};
}

//#endregion
//#region src/commands/pre-publish.ts
var PrePublishCommand = class extends BasePrePublishCommand {
	async execute() {
		await prePublish(this.getOptions());
	}
};

//#endregion
//#region src/commands/rename.ts
var RenameCommand = class extends BaseRenameCommand {
	async execute() {
		await renameProject(this.getOptions());
	}
};

//#endregion
//#region src/def/universalize.ts
var import_defineProperty = __toESM(require_defineProperty(), 1);
var BaseUniversalizeCommand = class extends Command {
	constructor(..._args) {
		super(..._args);
		(0, import_defineProperty.default)(this, "cwd", Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" }));
		(0, import_defineProperty.default)(this, "configPath", Option.String("--config-path,-c", { description: "Path to `napi` config json file" }));
		(0, import_defineProperty.default)(this, "packageJsonPath", Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" }));
		(0, import_defineProperty.default)(this, "outputDir", Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" }));
	}
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
(0, import_defineProperty.default)(BaseUniversalizeCommand, "paths", [["universalize"]]);
(0, import_defineProperty.default)(BaseUniversalizeCommand, "usage", Command.Usage({ description: "Combile built binaries into one universal binary" }));
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	const target = config.targets.find((t) => t.platform === process.platform && t.arch === "universal");
	if (!target) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = UniArchsByPlatform[process.platform]?.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug(`Looking up source binaries to combine: `);
	debug("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	universalizers[process.platform]?.(srcFiles, output);
	debug(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/commands/universalize.ts
var UniversalizeCommand = class extends BaseUniversalizeCommand {
	async execute() {
		await universalizeBinaries(this.getOptions());
	}
};

//#endregion
//#region src/commands/version.ts
var VersionCommand = class extends BaseVersionCommand {
	async execute() {
		await version(this.getOptions());
	}
};

//#endregion
//#region src/cli.ts
const cli = new Cli({
	binaryName: "napi",
	binaryVersion: CLI_VERSION
});
cli.register(NewCommand);
cli.register(BuildCommand);
cli.register(CreateNpmDirsCommand);
cli.register(ArtifactsCommand);
cli.register(UniversalizeCommand);
cli.register(RenameCommand);
cli.register(PrePublishCommand);
cli.register(VersionCommand);
cli.register(HelpCommand);
cli.runExit(process.argv.slice(2));

//#endregion
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJfdHlwZW9mIiwidG9QcmltaXRpdmUiLCJ0b1Byb3BlcnR5S2V5IiwiX2RlZmluZVByb3BlcnR5Iiwib3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucyIsIm5hbWVzcGFjZTogc3RyaW5nIiwiZGVidWciLCJwYXRoOiBzdHJpbmciLCJwYXRoIiwicGljayIsIm86IE8iLCJwYXJ0aWFsOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IiwicGtnSnNvbiIsIlRBUkdFVF9MSU5LRVI6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4iLCJDcHVUb05vZGVBcmNoOiBSZWNvcmQ8c3RyaW5nLCBOb2RlSlNBcmNoPiIsIlN5c1RvTm9kZVBsYXRmb3JtOiBSZWNvcmQ8c3RyaW5nLCBQbGF0Zm9ybT4iLCJVbmlBcmNoc0J5UGxhdGZvcm06IFBhcnRpYWw8UmVjb3JkPFBsYXRmb3JtLCBOb2RlSlNBcmNoW10+PiIsInJhd1RyaXBsZTogc3RyaW5nIiwiY3B1OiBzdHJpbmciLCJzeXM6IHN0cmluZyIsImFiaTogc3RyaW5nIHwgbnVsbCIsInRhcmdldDogc3RyaW5nIiwidjogc3RyaW5nIiwibmFwaVZlcnNpb246IE5hcGlWZXJzaW9uIiwidmVyc2lvbnM6IE5vZGVWZXJzaW9uW10iLCJyZXF1aXJlbWVudHM6IHN0cmluZ1tdIiwibWFuaWZlc3RQYXRoOiBzdHJpbmciLCJyZXNvbHZlIiwicGF0aDogc3RyaW5nIiwiY29uZmlnUGF0aD86IHN0cmluZyIsInBhdGgiLCJzZXBhcmF0ZWRDb25maWc6IFVzZXJOYXBpQ29uZmlnIHwgdW5kZWZpbmVkIiwibmFwaUNvbmZpZzogTmFwaUNvbmZpZyIsInRhcmdldHM6IHN0cmluZ1tdIiwibmFtZTogc3RyaW5nIiwiYmluOiBzdHJpbmciLCJiaW4iLCJuYW1lIiwibGluZTogVHlwZURlZkxpbmUiLCJjb25zdEVudW06IGJvb2xlYW4iLCJpZGVudDogbnVtYmVyIiwiYW1iaWVudDogYm9vbGVhbiIsImludGVybWVkaWF0ZVR5cGVGaWxlOiBzdHJpbmciLCJleHBvcnRzOiBzdHJpbmdbXSIsImRlZnMiLCJmaWxlOiBzdHJpbmciLCJkZWZzOiBUeXBlRGVmTGluZVtdIiwic3JjOiBzdHJpbmciLCJvcHRpb25zOiBNaW5pbWFsTmFwaU9wdGlvbnMiLCJkZWJ1ZyIsInVzZXJPcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zIiwiZGlyIiwicm9vdDogc3RyaW5nIiwiZmlsZXMiLCJsb2NhbE5hbWU6IHN0cmluZyIsInBrZ05hbWU6IHN0cmluZyIsImlkZW50czogc3RyaW5nW10iLCJ0dXBsZTogc3RyaW5nIiwid2FzaUZpbGVuYW1lOiBzdHJpbmciLCJmcyIsIndhc21GaWxlTmFtZTogc3RyaW5nIiwicGFja2FnZU5hbWU6IHN0cmluZyIsImZzOiBib29sZWFuIiwiZnMiLCJkZWJ1ZyIsInJlcXVpcmUiLCJyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMiLCJvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMiLCJtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSIsImNyYXRlOiBDcmF0ZSIsImNvbmZpZzogTmFwaUNvbmZpZyIsImFsaWFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwidmVyc2lvbiIsInJlc29sdmUiLCJhYmk6IHN0cmluZyB8IG51bGwiLCJ0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmciLCJzZXRqbXBMaWIiLCJzZXRqbXBJbmNsdWRlIiwiZXhwb3J0czogc3RyaW5nW10iLCJmaWxlcyIsImV4cG9ydHMiLCJpZGVudHM6IHN0cmluZ1tdIiwibmFtZSIsImRpc3RGaWxlTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCIsImVudjogc3RyaW5nIiwidmFsdWU6IHN0cmluZyIsInZhbHVlIiwiZGVidWciLCJvcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucyIsImRlYnVnIiwidXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zIiwibWtkaXJBc3luYyIsImRpcjogc3RyaW5nIiwid3JpdGVGaWxlQXN5bmMiLCJmaWxlOiBzdHJpbmciLCJjb250ZW50OiBzdHJpbmciLCJzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMiLCJwYWNrYWdlTmFtZTogc3RyaW5nIiwidGFyZ2V0OiBUYXJnZXQiLCJvcHRpb25zOiBOZXdPcHRpb25zIiwiY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwiX2Fzc2VydENsYXNzQnJhbmQiLCJhc3NlcnRDbGFzc0JyYW5kIiwidmFsdWUiLCJ0eXBlIiwidmFsdWUiLCJ2YWx1ZSIsInRhYmxlIiwicGFyc2UiLCJqb2luIiwibWVyZ2UiLCJmbG9hdCIsInBhaXIiLCJwYXJzZSIsIm9wdGlvbnM6IFJlbmFtZU9wdGlvbnMiLCJ1c2VyT3B0aW9uczogUmVuYW1lT3B0aW9ucyIsImRlYnVnIiwicmVzb2x2ZSIsInBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciIsImNhY2hlRGlyOiBzdHJpbmciLCJzcmM6IHN0cmluZyIsImRlc3Q6IHN0cmluZyIsImluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4iLCJmaWxlUGF0aDogc3RyaW5nIiwiZW5hYmxlZFRhcmdldHM6IHN0cmluZ1tdIiwidGFyZ2V0OiBzdHJpbmciLCJzZXR0aW5nOiBhbnkiLCJqb2JzVG9SZW1vdmU6IHN0cmluZ1tdIiwibmVlZDogc3RyaW5nIiwib3B0aW9uczogUmF3TmV3T3B0aW9ucyIsInVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zIiwicGF0aDogc3RyaW5nIiwic3RhdCIsInBhdGgiLCJmaWxlcyIsIm5hbWU6IHN0cmluZyIsImRlYnVnIiwidGFyZ2V0UGF0aDogc3RyaW5nIiwiZGVmYXVsdE5hbWU6IHN0cmluZyIsInBhdGgiLCJvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucyIsIm9wdGlvbnM6IFZlcnNpb25PcHRpb25zIiwiZGVidWciLCJ1c2VyT3B0aW9uczogVmVyc2lvbk9wdGlvbnMiLCJkZWJ1ZyIsInVzZXJPcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucyIsInBhY2thZ2VOYW1lOiBzdHJpbmciLCJ2ZXJzaW9uOiBzdHJpbmciLCJwYWNrYWdlTmFtZSIsInZlcnNpb24iLCJyZXBvIiwib3duZXIiLCJwa2dJbmZvIiwib2N0b2tpdCIsInBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkIiwidGFnOiBzdHJpbmciLCJuYW1lIiwib3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucyIsInVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+IiwidXNlck9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMiXSwic291cmNlcyI6WyIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdHlwZW9mLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCIuLi9zcmMvZGVmL2FydGlmYWN0cy50cyIsIi4uL3NyYy91dGlscy9sb2cudHMiLCIuLi9wYWNrYWdlLmpzb24iLCIuLi9zcmMvdXRpbHMvbWlzYy50cyIsIi4uL3NyYy91dGlscy90YXJnZXQudHMiLCIuLi9zcmMvdXRpbHMvdmVyc2lvbi50cyIsIi4uL3NyYy91dGlscy9tZXRhZGF0YS50cyIsIi4uL3NyYy91dGlscy9jb25maWcudHMiLCIuLi9zcmMvdXRpbHMvY2FyZ28udHMiLCIuLi9zcmMvdXRpbHMvdHlwZWdlbi50cyIsIi4uL3NyYy91dGlscy9yZWFkLWNvbmZpZy50cyIsIi4uL3NyYy9hcGkvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL2NvbW1hbmRzL2FydGlmYWN0cy50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL2pzLWJpbmRpbmcudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy9sb2FkLXdhc2ktdGVtcGxhdGUudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy93YXNpLXdvcmtlci10ZW1wbGF0ZS50cyIsIi4uL3NyYy9hcGkvYnVpbGQudHMiLCIuLi9zcmMvZGVmL2J1aWxkLnRzIiwiLi4vc3JjL2NvbW1hbmRzL2J1aWxkLnRzIiwiLi4vc3JjL2RlZi9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvYXBpL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9jb21tYW5kcy9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvY29tbWFuZHMvaGVscC50cyIsIi4uL3NyYy9kZWYvbmV3LnRzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3NlcnRDbGFzc0JyYW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2NsYXNzUHJpdmF0ZUZpZWxkR2V0Mi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvc3RyaW5naWZ5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqc3Ivc3RkX19jb2xsZWN0aW9ucy9fdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXBfbWVyZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvY2xhc3NQcml2YXRlRmllbGRTZXQyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9fcGFyc2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9wYXJzZS5qcyIsIi4uL3NyYy9kZWYvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9yZW5hbWUudHMiLCIuLi9zcmMvYXBpL25ldy50cyIsIi4uL3NyYy9jb21tYW5kcy9uZXcudHMiLCIuLi9zcmMvZGVmL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9jb21tYW5kcy9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9jb21tYW5kcy9yZW5hbWUudHMiLCIuLi9zcmMvZGVmL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9hcGkvdW5pdmVyc2FsaXplLnRzIiwiLi4vc3JjL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9jb21tYW5kcy92ZXJzaW9uLnRzIiwiLi4vc3JjL2NsaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgX3R5cGVvZihvKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vdG9QcmltaXRpdmUuanNcIik7XG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9Qcm9wZXJ0eUtleSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydhcnRpZmFjdHMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDb3B5IGFydGlmYWN0cyBmcm9tIEdpdGh1YiBBY3Rpb25zIGludG8gbnBtIHBhY2thZ2VzIGFuZCByZWFkeSB0byBwdWJsaXNoJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBvdXRwdXREaXIgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8sLWQnLCAnLi9hcnRpZmFjdHMnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBidWlsZE91dHB1dERpcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYnVpbGQtb3V0cHV0LWRpcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBidWlsZCBvdXRwdXQgZGlyLCBvbmx5IG5lZWRlZCB3aGVuIHRhcmdldHMgY29udGFpbnMgYHdhc20zMi13YXNpLSpgJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgYnVpbGRPdXRwdXREaXI6IHRoaXMuYnVpbGRPdXRwdXREaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0c09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmRcbiAgICpcbiAgICogQGRlZmF1bHQgJy4vYXJ0aWZhY3RzJ1xuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYFxuICAgKi9cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMob3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG91dHB1dERpcjogJy4vYXJ0aWZhY3RzJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgcmF3RGVidWcgZnJvbSAnZGVidWcnXG5cbi8vIGRlYnVnKCclaScsICdUaGlzIGlzIGFuIGluZm8nKVxucmF3RGVidWcuZm9ybWF0dGVycy5pID0gKHYpID0+IHtcbiAgcmV0dXJuIGNvbG9ycy5ncmVlbih2KVxufVxuXG5kZWNsYXJlIG1vZHVsZSAnZGVidWcnIHtcbiAgaW50ZXJmYWNlIERlYnVnZ2VyIHtcbiAgICBpbmZvOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIHdhcm46IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gICAgZXJyb3I6IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnRmFjdG9yeSA9IChuYW1lc3BhY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBkZWJ1ZyA9IHJhd0RlYnVnKGBuYXBpOiR7bmFtZXNwYWNlfWApXG5cbiAgZGVidWcuaW5mbyA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdHcmVlbignIElORk8gJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy53YXJuID0gKC4uLmFyZ3M6IGFueVtdKSA9PlxuICAgIGNvbnNvbGUuZXJyb3IoY29sb3JzLmJsYWNrKGNvbG9ycy5iZ1llbGxvdygnIFdBUk5JTkcgJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy5lcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY29sb3JzLndoaXRlKGNvbG9ycy5iZ1JlZCgnIEVSUk9SICcpKSxcbiAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gKGFyZy5zdGFjayA/PyBhcmcubWVzc2FnZSkgOiBhcmcsXG4gICAgICApLFxuICAgIClcblxuICByZXR1cm4gZGVidWdcbn1cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndXRpbHMnKVxuIiwie1xuICBcIm5hbWVcIjogXCJAbmFwaS1ycy9jbGlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMy4wLjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNsaSB0b29scyBmb3IgbmFwaS1yc1wiLFxuICBcImF1dGhvclwiOiBcIkxvbmdZaW5hbiA8bHlud2VrbG1AZ21haWwuY29tPlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1yc1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJ0eXBlXCI6IFwibW9kdWxlXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0gMTZcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJuYXBpXCI6IFwiLi9kaXN0L2NsaS5qc1wiLFxuICAgIFwibmFwaS1yYXdcIjogXCIuL2NsaS5tanNcIlxuICB9LFxuICBcIm1haW5cIjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIFwibW9kdWxlXCI6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gIFwiZXhwb3J0c1wiOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIFwiaW1wb3J0XCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5qc1wiXG4gICAgICB9LFxuICAgICAgXCJyZXF1aXJlXCI6IHtcbiAgICAgICAgXCJ0eXBlc1wiOiBcIi4vZGlzdC9pbmRleC5kLnRzXCIsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiB7XG4gICAgICBcImltcG9ydFwiOiBcIi4vcGFja2FnZS5qc29uXCIsXG4gICAgICBcInJlcXVpcmVcIjogXCIuL3BhY2thZ2UuanNvblwiXG4gICAgfVxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcInNyY1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2xpXCIsXG4gICAgXCJydXN0XCIsXG4gICAgXCJuYXBpXCIsXG4gICAgXCJuLWFwaVwiLFxuICAgIFwibm9kZS1hcGlcIixcbiAgICBcIm5vZGUtYWRkb25cIixcbiAgICBcIm5lb25cIlxuICBdLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJMb25nWWluYW5cIixcbiAgICAgIFwiZW1haWxcIjogXCJseW53ZWtsbUBnbWFpbC5jb21cIixcbiAgICAgIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vQnJvb29vb29rbHluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImZvcmVoYWxvXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ZvcmVoYWxvXCJcbiAgICB9XG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy5naXRcIlxuICB9LFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwicmVnaXN0cnlcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cIixcbiAgICBcImFjY2Vzc1wiOiBcInB1YmxpY1wiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9uYXBpLXJzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBpbnF1aXJlci9wcm9tcHRzXCI6IFwiXjcuNC4wXCIsXG4gICAgXCJAbmFwaS1ycy9jcm9zcy10b29sY2hhaW5cIjogXCJeMC4wLjE5XCIsXG4gICAgXCJAbmFwaS1ycy93YXNtLXRvb2xzXCI6IFwiXjAuMC4zXCIsXG4gICAgXCJAb2N0b2tpdC9yZXN0XCI6IFwiXjIyLjAuMFwiLFxuICAgIFwiY2xpcGFuaW9uXCI6IFwiXjQuMC4wLXJjLjRcIixcbiAgICBcImNvbG9yZXR0ZVwiOiBcIl4yLjAuMjBcIixcbiAgICBcImRlYnVnXCI6IFwiXjQuNC4wXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS40LjBcIixcbiAgICBcImZpbmQtdXBcIjogXCJeNy4wLjBcIixcbiAgICBcImpzLXlhbWxcIjogXCJeNC4xLjBcIixcbiAgICBcImxvZGFzaC1lc1wiOiBcIl40LjE3LjIxXCIsXG4gICAgXCJzZW12ZXJcIjogXCJeNy43LjFcIixcbiAgICBcInR5cGFuaW9uXCI6IFwiXjMuMTQuMFwiLFxuICAgIFwid2FzbS1zamxqXCI6IFwiXjEuMC42XCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGVtbmFwaS9jb3JlXCI6IFwiXjEuNC4wXCIsXG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS40LjBcIixcbiAgICBcIkBveGMtbm9kZS9jb3JlXCI6IFwiXjAuMC4yOVwiLFxuICAgIFwiQHN0ZC90b21sXCI6IFwibnBtOkBqc3Ivc3RkX190b21sQF4xLjAuOFwiLFxuICAgIFwiQHR5cGVzL2RlYnVnXCI6IFwiXjQuMS4xMlwiLFxuICAgIFwiQHR5cGVzL2lucXVpcmVyXCI6IFwiXjkuMC43XCIsXG4gICAgXCJAdHlwZXMvanMteWFtbFwiOiBcIl40LjAuOVwiLFxuICAgIFwiQHR5cGVzL2xvZGFzaC1lc1wiOiBcIl40LjE3LjEyXCIsXG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIl4yMi4xMy4xNlwiLFxuICAgIFwiQHR5cGVzL3NlbXZlclwiOiBcIl43LjcuMFwiLFxuICAgIFwiYXZhXCI6IFwiXjYuMi4wXCIsXG4gICAgXCJlbnYtcGF0aHNcIjogXCJeMy4wLjBcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjMuNS4zXCIsXG4gICAgXCJyb2xsZG93blwiOiBcIl4xLjAuMC1iZXRhLjIzXCIsXG4gICAgXCJ0c2xpYlwiOiBcIl4yLjguMVwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl41LjguMlwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS4xLjBcIixcbiAgICBcImVtbmFwaVwiOiBcIl4xLjEuMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc01ldGFcIjoge1xuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJlbW5hcGlcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfVxuICB9LFxuICBcImZ1bmRpbmdcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdGh1YlwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3Nwb25zb3JzL0Jyb29vb29va2x5blwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJjbGVhblwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi9jbGVhbi50c1wiLFxuICAgIFwiY29kZWdlblwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi9jb2RlZ2VuL2luZGV4LnRzXCIsXG4gICAgXCJidWlsZFwiOiBcInRzYyAmJiB5YXJuIGNsZWFuICYmIHJvbGxkb3duIC1jIHJvbGxkb3duLmNvbmZpZy5qc1wiLFxuICAgIFwidGVzdFwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi4vbm9kZV9tb2R1bGVzL2F2YS9lbnRyeXBvaW50cy9jbGkubWpzXCJcbiAgfSxcbiAgXCJhdmFcIjoge1xuICAgIFwiZXh0ZW5zaW9uc1wiOiB7XG4gICAgICBcInRzXCI6IFwibW9kdWxlXCJcbiAgICB9LFxuICAgIFwidGltZW91dFwiOiBcIjFtXCIsXG4gICAgXCJmaWxlc1wiOiBbXG4gICAgICBcIioqL19fdGVzdHNfXy8qKi8qLnNwZWMudHNcIixcbiAgICAgIFwiZTJlLyoqLyouc3BlYy50c1wiXG4gICAgXVxuICB9LFxuICBcImdpdEhlYWRcIjogXCJjZGJmMmJjNDM5NDUxNzVlYWJlNTZiMTlhNmJiMGY4NTg0ZGJjMzRjXCJcbn1cbiIsImltcG9ydCB7XG4gIHJlYWRGaWxlLFxuICB3cml0ZUZpbGUsXG4gIGNvcHlGaWxlLFxuICBta2RpcixcbiAgdW5saW5rLFxuICBzdGF0LFxuICByZWFkZGlyLFxufSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAnbm9kZTp1dGlsJ1xuXG5pbXBvcnQgcGtnSnNvbiBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nIHdpdGggeyB0eXBlOiAnanNvbicgfVxuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuL2xvZy5qcydcblxuZXhwb3J0IGNvbnN0IHJlYWRGaWxlQXN5bmMgPSBwcm9taXNpZnkocmVhZEZpbGUpXG5leHBvcnQgY29uc3Qgd3JpdGVGaWxlQXN5bmMgPSBwcm9taXNpZnkod3JpdGVGaWxlKVxuZXhwb3J0IGNvbnN0IHVubGlua0FzeW5jID0gcHJvbWlzaWZ5KHVubGluaylcbmV4cG9ydCBjb25zdCBjb3B5RmlsZUFzeW5jID0gcHJvbWlzaWZ5KGNvcHlGaWxlKVxuZXhwb3J0IGNvbnN0IG1rZGlyQXN5bmMgPSBwcm9taXNpZnkobWtkaXIpXG5leHBvcnQgY29uc3Qgc3RhdEFzeW5jID0gcHJvbWlzaWZ5KHN0YXQpXG5leHBvcnQgY29uc3QgcmVhZGRpckFzeW5jID0gcHJvbWlzaWZ5KHJlYWRkaXIpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzKHBhdGg6IHN0cmluZykge1xuICBjb25zdCBleGlzdHMgPSBhd2FpdCBzdGF0QXN5bmMocGF0aClcbiAgICAudGhlbigoKSA9PiB0cnVlKVxuICAgIC5jYXRjaCgoKSA9PiBmYWxzZSlcbiAgcmV0dXJuIGV4aXN0c1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlyRXhpc3RzQXN5bmMocGF0aDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0QXN5bmMocGF0aClcbiAgICByZXR1cm4gc3RhdHMuaXNEaXJlY3RvcnkoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljazxPLCBLIGV4dGVuZHMga2V5b2YgTz4obzogTywgLi4ua2V5czogS1tdKTogUGljazxPLCBLPiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IG9ba2V5XVxuICAgIHJldHVybiBhY2NcbiAgfSwge30gYXMgTylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhY2thZ2VKc29uKFxuICBwYXRoOiBzdHJpbmcsXG4gIHBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pIHtcbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgZmlsZUV4aXN0cyhwYXRoKVxuICBpZiAoIWV4aXN0cykge1xuICAgIGRlYnVnKGBGaWxlIG5vdCBleGlzdHMgJHtwYXRofWApXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb2xkID0gSlNPTi5wYXJzZShhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JykpXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHBhdGgsIEpTT04uc3RyaW5naWZ5KHsgLi4ub2xkLCAuLi5wYXJ0aWFsIH0sIG51bGwsIDIpKVxufVxuXG5leHBvcnQgY29uc3QgQ0xJX1ZFUlNJT04gPSBwa2dKc29uLnZlcnNpb25cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5leHBvcnQgdHlwZSBQbGF0Zm9ybSA9IE5vZGVKUy5QbGF0Zm9ybSB8ICd3YXNtJyB8ICd3YXNpJyB8ICdvcGVuaGFybW9ueSdcblxuZXhwb3J0IGNvbnN0IFVOSVZFUlNBTF9UQVJHRVRTID0ge1xuICAndW5pdmVyc2FsLWFwcGxlLWRhcndpbic6IFsnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLCAneDg2XzY0LWFwcGxlLWRhcndpbiddLFxufSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgQVZBSUxBQkxFX1RBUkdFVFMgPSBbXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWxpbnV4LWFuZHJvaWQnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtb2hvcycsXG4gICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtZ251JyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtb2hvcycsXG4gICd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJyxcbiAgJ2k2ODYtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ2FybXY3LXVua25vd24tbGludXgtZ251ZWFiaWhmJyxcbiAgJ2FybXY3LXVua25vd24tbGludXgtbXVzbGVhYmloZicsXG4gICdhcm12Ny1saW51eC1hbmRyb2lkZWFiaScsXG4gICd1bml2ZXJzYWwtYXBwbGUtZGFyd2luJyxcbiAgJ3Jpc2N2NjRnYy11bmtub3duLWxpbnV4LWdudScsXG4gICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICdzMzkweC11bmtub3duLWxpbnV4LWdudScsXG4gICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJyxcbiAgJ3dhc20zMi13YXNpcDEtdGhyZWFkcycsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFRhcmdldFRyaXBsZSA9ICh0eXBlb2YgQVZBSUxBQkxFX1RBUkdFVFMpW251bWJlcl1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEFSR0VUUyA9IFtcbiAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICAnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLFxuICAneDg2XzY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgY29uc3QgVEFSR0VUX0xJTktFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJzogJ2FhcmNoNjQtbGludXgtbXVzbC1nY2MnLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JzogJ3Jpc2N2NjQtbGludXgtZ251LWdjYycsXG4gICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudSc6ICdwb3dlcnBjNjRsZS1saW51eC1nbnUtZ2NjJyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWxpbnV4LWdudS1nY2MnLFxufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfYXJjaFxudHlwZSBOb2RlSlNBcmNoID1cbiAgfCAnYXJtJ1xuICB8ICdhcm02NCdcbiAgfCAnaWEzMidcbiAgfCAnbWlwcydcbiAgfCAnbWlwc2VsJ1xuICB8ICdwcGMnXG4gIHwgJ3BwYzY0J1xuICB8ICdyaXNjdjY0J1xuICB8ICdzMzkwJ1xuICB8ICdzMzkweCdcbiAgfCAneDMyJ1xuICB8ICd4NjQnXG4gIHwgJ3VuaXZlcnNhbCdcbiAgfCAnd2FzbTMyJ1xuXG5jb25zdCBDcHVUb05vZGVBcmNoOiBSZWNvcmQ8c3RyaW5nLCBOb2RlSlNBcmNoPiA9IHtcbiAgeDg2XzY0OiAneDY0JyxcbiAgYWFyY2g2NDogJ2FybTY0JyxcbiAgaTY4NjogJ2lhMzInLFxuICBhcm12NzogJ2FybScsXG4gIHJpc2N2NjRnYzogJ3Jpc2N2NjQnLFxuICBwb3dlcnBjNjRsZTogJ3BwYzY0Jyxcbn1cblxuZXhwb3J0IGNvbnN0IE5vZGVBcmNoVG9DcHU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIHg2NDogJ3g4Nl82NCcsXG4gIGFybTY0OiAnYWFyY2g2NCcsXG4gIGlhMzI6ICdpNjg2JyxcbiAgYXJtOiAnYXJtdjcnLFxuICByaXNjdjY0OiAncmlzY3Y2NGdjJyxcbiAgcHBjNjQ6ICdwb3dlcnBjNjRsZScsXG59XG5cbmNvbnN0IFN5c1RvTm9kZVBsYXRmb3JtOiBSZWNvcmQ8c3RyaW5nLCBQbGF0Zm9ybT4gPSB7XG4gIGxpbnV4OiAnbGludXgnLFxuICBmcmVlYnNkOiAnZnJlZWJzZCcsXG4gIGRhcndpbjogJ2RhcndpbicsXG4gIHdpbmRvd3M6ICd3aW4zMicsXG4gIG9ob3M6ICdvcGVuaGFybW9ueScsXG59XG5cbmV4cG9ydCBjb25zdCBVbmlBcmNoc0J5UGxhdGZvcm06IFBhcnRpYWw8UmVjb3JkPFBsYXRmb3JtLCBOb2RlSlNBcmNoW10+PiA9IHtcbiAgZGFyd2luOiBbJ3g2NCcsICdhcm02NCddLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldCB7XG4gIHRyaXBsZTogc3RyaW5nXG4gIHBsYXRmb3JtQXJjaEFCSTogc3RyaW5nXG4gIHBsYXRmb3JtOiBQbGF0Zm9ybVxuICBhcmNoOiBOb2RlSlNBcmNoXG4gIGFiaTogc3RyaW5nIHwgbnVsbFxufVxuXG4vKipcbiAqIEEgdHJpcGxlIGlzIGEgc3BlY2lmaWMgZm9ybWF0IGZvciBzcGVjaWZ5aW5nIGEgdGFyZ2V0IGFyY2hpdGVjdHVyZS5cbiAqIFRyaXBsZXMgbWF5IGJlIHJlZmVycmVkIHRvIGFzIGEgdGFyZ2V0IHRyaXBsZSB3aGljaCBpcyB0aGUgYXJjaGl0ZWN0dXJlIGZvciB0aGUgYXJ0aWZhY3QgcHJvZHVjZWQsIGFuZCB0aGUgaG9zdCB0cmlwbGUgd2hpY2ggaXMgdGhlIGFyY2hpdGVjdHVyZSB0aGF0IHRoZSBjb21waWxlciBpcyBydW5uaW5nIG9uLlxuICogVGhlIGdlbmVyYWwgZm9ybWF0IG9mIHRoZSB0cmlwbGUgaXMgYDxhcmNoPjxzdWI+LTx2ZW5kb3I+LTxzeXM+LTxhYmk+YCB3aGVyZTpcbiAqICAgLSBgYXJjaGAgPSBUaGUgYmFzZSBDUFUgYXJjaGl0ZWN0dXJlLCBmb3IgZXhhbXBsZSBgeDg2XzY0YCwgYGk2ODZgLCBgYXJtYCwgYHRodW1iYCwgYG1pcHNgLCBldGMuXG4gKiAgIC0gYHN1YmAgPSBUaGUgQ1BVIHN1Yi1hcmNoaXRlY3R1cmUsIGZvciBleGFtcGxlIGBhcm1gIGhhcyBgdjdgLCBgdjdzYCwgYHY1dGVgLCBldGMuXG4gKiAgIC0gYHZlbmRvcmAgPSBUaGUgdmVuZG9yLCBmb3IgZXhhbXBsZSBgdW5rbm93bmAsIGBhcHBsZWAsIGBwY2AsIGBudmlkaWFgLCBldGMuXG4gKiAgIC0gYHN5c2AgPSBUaGUgc3lzdGVtIG5hbWUsIGZvciBleGFtcGxlIGBsaW51eGAsIGB3aW5kb3dzYCwgYGRhcndpbmAsIGV0Yy4gbm9uZSBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgYmFyZS1tZXRhbCB3aXRob3V0IGFuIE9TLlxuICogICAtIGBhYmlgID0gVGhlIEFCSSwgZm9yIGV4YW1wbGUgYGdudWAsIGBhbmRyb2lkYCwgYGVhYmlgLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyaXBsZShyYXdUcmlwbGU6IHN0cmluZyk6IFRhcmdldCB7XG4gIGlmIChcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaScgfHxcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJyB8fFxuICAgIHJhd1RyaXBsZS5zdGFydHNXaXRoKCd3YXNtMzItd2FzaXAnKVxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgICBwbGF0Zm9ybUFyY2hBQkk6ICd3YXNtMzItd2FzaScsXG4gICAgICBwbGF0Zm9ybTogJ3dhc2knLFxuICAgICAgYXJjaDogJ3dhc20zMicsXG4gICAgICBhYmk6ICd3YXNpJyxcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJpcGxlID0gcmF3VHJpcGxlLmVuZHNXaXRoKCdlYWJpJylcbiAgICA/IGAke3Jhd1RyaXBsZS5zbGljZSgwLCAtNCl9LWVhYmlgXG4gICAgOiByYXdUcmlwbGVcbiAgY29uc3QgdHJpcGxlcyA9IHRyaXBsZS5zcGxpdCgnLScpXG4gIGxldCBjcHU6IHN0cmluZ1xuICBsZXQgc3lzOiBzdHJpbmdcbiAgbGV0IGFiaTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgaWYgKHRyaXBsZXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gYWFyY2g2NC1mdWNoc2lhXG4gICAgLy8gXiBjcHUgICBeIHN5c1xuICAgIDtbY3B1LCBzeXNdID0gdHJpcGxlc1xuICB9IGVsc2Uge1xuICAgIC8vIGFhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsXG4gICAgLy8gXiBjcHUgICAgICAgICAgIF4gc3lzIF4gYWJpXG4gICAgLy8gYWFyY2g2NC1hcHBsZS1kYXJ3aW5cbiAgICAvLyBeIGNwdSAgICAgICAgIF4gc3lzICAoYWJpIGlzIE5vbmUpXG4gICAgO1tjcHUsICwgc3lzLCBhYmkgPSBudWxsXSA9IHRyaXBsZXNcbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtID0gU3lzVG9Ob2RlUGxhdGZvcm1bc3lzXSA/PyAoc3lzIGFzIFBsYXRmb3JtKVxuICBjb25zdCBhcmNoID0gQ3B1VG9Ob2RlQXJjaFtjcHVdID8/IChjcHUgYXMgTm9kZUpTQXJjaClcblxuICBpZiAocmF3VHJpcGxlLmluY2x1ZGVzKCdvaG9zJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgICBwbGF0Zm9ybUFyY2hBQkk6IGBsaW51eC0ke2FyY2h9LW9ob3NgLFxuICAgICAgcGxhdGZvcm06ICdvcGVuaGFybW9ueScsXG4gICAgICBhcmNoLFxuICAgICAgYWJpOiBudWxsLFxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgIHBsYXRmb3JtQXJjaEFCSTogYWJpID8gYCR7cGxhdGZvcm19LSR7YXJjaH0tJHthYml9YCA6IGAke3BsYXRmb3JtfS0ke2FyY2h9YCxcbiAgICBwbGF0Zm9ybSxcbiAgICBhcmNoLFxuICAgIGFiaSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpOiBUYXJnZXQge1xuICBjb25zdCBob3N0ID0gZXhlY1N5bmMoYHJ1c3RjIC12VmAsIHtcbiAgICBlbnY6IHByb2Nlc3MuZW52LFxuICB9KVxuICAgIC50b1N0cmluZygndXRmOCcpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2hvc3Q6ICcpKVxuICBjb25zdCB0cmlwbGUgPSBob3N0Py5zbGljZSgnaG9zdDogJy5sZW5ndGgpXG4gIGlmICghdHJpcGxlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBwYXJzZSB0YXJnZXQgdHJpcGxlIGZyb20gaG9zdGApXG4gIH1cbiAgcmV0dXJuIHBhcnNlVHJpcGxlKHRyaXBsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldExpbmtlcih0YXJnZXQ6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBUQVJHRVRfTElOS0VSW3RhcmdldF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvRW52VmFyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRhcmdldC5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKVxufVxuIiwiZXhwb3J0IGVudW0gTmFwaVZlcnNpb24ge1xuICBOYXBpMSA9IDEsXG4gIE5hcGkyLFxuICBOYXBpMyxcbiAgTmFwaTQsXG4gIE5hcGk1LFxuICBOYXBpNixcbiAgTmFwaTcsXG4gIE5hcGk4LFxuICBOYXBpOSxcbn1cblxuLy8vIGJlY2F1c2Ugbm9kZSBzdXBwb3J0IG5ldyBuYXBpIHZlcnNpb24gaW4gc29tZSBtaW5vciB2ZXJzaW9uIHVwZGF0ZXMsIHNvIHdlIG1pZ2h0IG1lZXQgc3VjaCBzaXR1YXRpb246XG4vLy8gYG5vZGUgdjEwLjIwLjBgIHN1cHBvcnRzIGBuYXBpNWAgYW5kIGBuYXBpNmAsIGJ1dCBgbm9kZSB2MTIuMC4wYCBvbmx5IHN1cHBvcnQgYG5hcGk0YCxcbi8vLyBieSB3aGljaCwgd2UgY2FuIG5vdCB0ZWxsIGRpcmVjdGx5IG5hcGkgdmVyc2lvbiBzdXBwb3J0bGVzcyBmcm9tIG5vZGUgdmVyc2lvbiBkaXJlY3RseS5cbmNvbnN0IE5BUElfVkVSU0lPTl9NQVRSSVggPSBuZXcgTWFwPE5hcGlWZXJzaW9uLCBzdHJpbmc+KFtcbiAgW05hcGlWZXJzaW9uLk5hcGkxLCAnOC42LjAgfCA5LjAuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTIsICc4LjEwLjAgfCA5LjMuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTMsICc2LjE0LjIgfCA4LjExLjIgfCA5LjExLjAgfCAxMC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk0LCAnMTAuMTYuMCB8IDExLjguMCB8IDEyLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTUsICcxMC4xNy4wIHwgMTIuMTEuMCB8IDEzLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTYsICcxMC4yMC4wIHwgMTIuMTcuMCB8IDE0LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTcsICcxMC4yMy4wIHwgMTIuMTkuMCB8IDE0LjEyLjAgfCAxNS4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk4LCAnMTIuMjIuMCB8IDE0LjE3LjAgfCAxNS4xMi4wIHwgMTYuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpOSwgJzE4LjE3LjAgfCAyMC4zLjAgfCAyMS4xLjAnXSxcbl0pXG5cbmludGVyZmFjZSBOb2RlVmVyc2lvbiB7XG4gIG1ham9yOiBudW1iZXJcbiAgbWlub3I6IG51bWJlclxuICBwYXRjaDogbnVtYmVyXG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZVZlcnNpb24odjogc3RyaW5nKTogTm9kZVZlcnNpb24ge1xuICBjb25zdCBtYXRjaGVzID0gdi5tYXRjaCgvdj8oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykvaSlcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB2ZXJzaW9uIG51bWJlcjogJyArIHYpXG4gIH1cblxuICBjb25zdCBbLCBtYWpvciwgbWlub3IsIHBhdGNoXSA9IG1hdGNoZXNcblxuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJzZUludChtYWpvciksXG4gICAgbWlub3I6IHBhcnNlSW50KG1pbm9yKSxcbiAgICBwYXRjaDogcGFyc2VJbnQocGF0Y2gpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IE5vZGVWZXJzaW9uW10ge1xuICBjb25zdCByZXF1aXJlbWVudCA9IE5BUElfVkVSU0lPTl9NQVRSSVguZ2V0KG5hcGlWZXJzaW9uKVxuXG4gIGlmICghcmVxdWlyZW1lbnQpIHtcbiAgICByZXR1cm4gW3BhcnNlTm9kZVZlcnNpb24oJzEwLjAuMCcpXVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVtZW50LnNwbGl0KCd8JykubWFwKHBhcnNlTm9kZVZlcnNpb24pXG59XG5cbmZ1bmN0aW9uIHRvRW5naW5lUmVxdWlyZW1lbnQodmVyc2lvbnM6IE5vZGVWZXJzaW9uW10pOiBzdHJpbmcge1xuICBjb25zdCByZXF1aXJlbWVudHM6IHN0cmluZ1tdID0gW11cbiAgdmVyc2lvbnMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgIGxldCByZXEgPSAnJ1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBsYXN0VmVyc2lvbiA9IHZlcnNpb25zW2kgLSAxXVxuICAgICAgcmVxICs9IGA8ICR7bGFzdFZlcnNpb24ubWFqb3IgKyAxfWBcbiAgICB9XG5cbiAgICByZXEgKz0gYCR7aSA9PT0gMCA/ICcnIDogJyB8fCAnfT49ICR7di5tYWpvcn0uJHt2Lm1pbm9yfS4ke3YucGF0Y2h9YFxuICAgIHJlcXVpcmVtZW50cy5wdXNoKHJlcSlcbiAgfSlcblxuICByZXR1cm4gcmVxdWlyZW1lbnRzLmpvaW4oJyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IHN0cmluZyB7XG4gIHJldHVybiB0b0VuZ2luZVJlcXVpcmVtZW50KHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uKSlcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMnXG5cbmV4cG9ydCB0eXBlIENyYXRlVGFyZ2V0S2luZCA9XG4gIHwgJ2JpbidcbiAgfCAnZXhhbXBsZSdcbiAgfCAndGVzdCdcbiAgfCAnYmVuY2gnXG4gIHwgJ2xpYidcbiAgfCAncmxpYidcbiAgfCAnY2R5bGliJ1xuICB8ICdjdXN0b20tYnVpbGQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGVUYXJnZXQge1xuICBuYW1lOiBzdHJpbmdcbiAga2luZDogQ3JhdGVUYXJnZXRLaW5kW11cbiAgY3JhdGVfdHlwZXM6IENyYXRlVGFyZ2V0S2luZFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGUge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzcmNfcGF0aDogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICBlZGl0aW9uOiBzdHJpbmdcbiAgdGFyZ2V0czogQ3JhdGVUYXJnZXRbXVxuICBmZWF0dXJlczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4gIG1hbmlmZXN0X3BhdGg6IHN0cmluZ1xuICBkZXBlbmRlbmNpZXM6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBzb3VyY2U6IHN0cmluZ1xuICAgIHJlcTogc3RyaW5nXG4gICAga2luZDogc3RyaW5nIHwgbnVsbFxuICAgIHJlbmFtZTogc3RyaW5nIHwgbnVsbFxuICAgIG9wdGlvbmFsOiBib29sZWFuXG4gICAgdXNlc19kZWZhdWx0X2ZlYXR1cmVzOiBib29sZWFuXG4gICAgZmVhdHVyZXM6IHN0cmluZ1tdXG4gICAgdGFyZ2V0OiBzdHJpbmcgfCBudWxsXG4gICAgcmVnaXN0cnk6IHN0cmluZyB8IG51bGxcbiAgfT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhIHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIHBhY2thZ2VzOiBDcmF0ZVtdXG4gIHdvcmtzcGFjZV9tZW1iZXJzOiBzdHJpbmdbXVxuICB0YXJnZXRfZGlyZWN0b3J5OiBzdHJpbmdcbiAgd29ya3NwYWNlX3Jvb3Q6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YShtYW5pZmVzdFBhdGg6IHN0cmluZykge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMobWFuaWZlc3RQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gY3JhdGUgZm91bmQgaW4gbWFuaWZlc3Q6ICR7bWFuaWZlc3RQYXRofWApXG4gIH1cblxuICBjb25zdCBjaGlsZFByb2Nlc3MgPSBzcGF3bihcbiAgICAnY2FyZ28nLFxuICAgIFsnbWV0YWRhdGEnLCAnLS1tYW5pZmVzdC1wYXRoJywgbWFuaWZlc3RQYXRoLCAnLS1mb3JtYXQtdmVyc2lvbicsICcxJ10sXG4gICAgeyBzdGRpbzogJ3BpcGUnIH0sXG4gIClcblxuICBsZXQgc3Rkb3V0ID0gJydcbiAgbGV0IHN0ZGVyciA9ICcnXG4gIGxldCBzdGF0dXMgPSAwXG4gIGxldCBlcnJvciA9IG51bGxcblxuICBjaGlsZFByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICBzdGRvdXQgKz0gZGF0YVxuICB9KVxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZGVyciArPSBkYXRhXG4gIH0pXG5cbiAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjaGlsZFByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgIHN0YXR1cyA9IGNvZGUgPz8gMFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhcmdvIG1ldGFkYXRhIGZhaWxlZCB0byBydW4nLCB7IGNhdXNlOiBlcnJvciB9KVxuICB9XG4gIGlmIChzdGF0dXMgIT09IDApIHtcbiAgICBjb25zdCBzaW1wbGVNZXNzYWdlID0gYGNhcmdvIG1ldGFkYXRhIGV4aXRlZCB3aXRoIGNvZGUgJHtzdGF0dXN9YFxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaW1wbGVNZXNzYWdlfSBhbmQgZXJyb3IgbWVzc2FnZTpcXG5cXG4ke3N0ZGVycn1gLCB7XG4gICAgICBjYXVzZTogbmV3IEVycm9yKHNpbXBsZU1lc3NhZ2UpLFxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dCkgYXMgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgY2FyZ28gbWV0YWRhdGEgSlNPTicsIHsgY2F1c2U6IGUgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgdW5kZXJsaW5lLCB5ZWxsb3cgfSBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgeyBtZXJnZSwgb21pdCB9IGZyb20gJ2xvZGFzaC1lcydcblxuaW1wb3J0IHsgZmlsZUV4aXN0cywgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4vbWlzYy5qcydcbmltcG9ydCB7IERFRkFVTFRfVEFSR0VUUywgcGFyc2VUcmlwbGUsIFRhcmdldCB9IGZyb20gJy4vdGFyZ2V0LmpzJ1xuXG5leHBvcnQgdHlwZSBWYWx1ZU9mQ29uc3RBcnJheTxUPiA9IFRbRXhjbHVkZTxrZXlvZiBULCBrZXlvZiBBcnJheTxhbnk+Pl1cblxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VycyA9IFsneWFybicsICdwbnBtJ10gYXMgY29uc3RcbmV4cG9ydCBjb25zdCBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrcyA9IFsnYXZhJ10gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIgPSBWYWx1ZU9mQ29uc3RBcnJheTxcbiAgdHlwZW9mIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2Vyc1xuPlxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVGVzdEZyYW1ld29yayA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkVGVzdEZyYW1ld29ya3Ncbj5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyTmFwaUNvbmZpZyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBiaW5hcnkgdG8gYmUgZ2VuZXJhdGVkLCBkZWZhdWx0IHRvIGBpbmRleGBcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG5wbSBwYWNrYWdlLCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHJvb3QgcGFja2FnZS5qc29uIG5hbWVcbiAgICpcbiAgICogQWx3YXlzIGdpdmVuIGBAc2NvcGUvcGtnYCBhbmQgYXJjaCBzdWZmaXggd2lsbCBiZSBhcHBlbmRlZCBsaWtlIGBAc2NvcGUvcGtnLWxpbnV4LWdudS14NjRgXG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yXG4gICAqL1xuICB0YXJnZXRzPzogc3RyaW5nW11cblxuICAvKipcbiAgICogVGhlIG5wbSBjbGllbnQgcHJvamVjdCB1c2VzLlxuICAgKi9cbiAgbnBtQ2xpZW50Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZ2VuZXJhdGUgY29uc3QgZW51bSBmb3IgdHlwZXNjcmlwdCBiaW5kaW5nc1xuICAgKi9cbiAgY29uc3RFbnVtPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBkdHMgaGVhZGVyIHByZXBlbmQgdG8gdGhlIGdlbmVyYXRlZCBkdHMgZmlsZVxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgZmlsZSBwYXRoIHRvIGJlIHByZXBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqIGlmIGJvdGggZHRzSGVhZGVyIGFuZCBkdHNIZWFkZXJGaWxlIGFyZSBwcm92aWRlZCwgZHRzSGVhZGVyRmlsZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIGR0c0hlYWRlckZpbGU/OiBzdHJpbmdcblxuICAvKipcbiAgICogd2FzbSBjb21waWxhdGlvbiBvcHRpb25zXG4gICAqL1xuICB3YXNtPzoge1xuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViQXNzZW1ibHkvSmF2YVNjcmlwdF9pbnRlcmZhY2UvTWVtb3J5XG4gICAgICogQGRlZmF1bHQgNDAwMCBwYWdlcyAoMjU2TWlCKVxuICAgICAqL1xuICAgIGluaXRpYWxNZW1vcnk/OiBudW1iZXJcbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCA2NTUzNiBwYWdlcyAoNEdpQilcbiAgICAgKi9cbiAgICBtYXhpbXVtTWVtb3J5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBCcm93c2VyIHdhc20gYmluZGluZyBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYnJvd3Nlcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIHVzZSBmcyBtb2R1bGUgaW4gYnJvd3NlclxuICAgICAgICovXG4gICAgICBmcz86IGJvb2xlYW5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBpbml0aWFsaXplIHdhc20gYXN5bmNocm9ub3VzbHlcbiAgICAgICAqL1xuICAgICAgYXN5bmNJbml0PzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluamVjdCBgYnVmZmVyYCB0byBlbW5hcGkgY29udGV4dFxuICAgICAgICovXG4gICAgICBidWZmZXI/OiBib29sZWFuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGJpbmFyeU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHBhY2thZ2VOYW1lIGluc3RlYWRcbiAgICovXG4gIHBhY2thZ2U/OiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGFyZ2V0cyBpbnN0ZWFkXG4gICAqL1xuICB0cmlwbGVzPzoge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0c1xuICAgICAqL1xuICAgIGRlZmF1bHRzOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCB0YXJnZXRzIHRvIGJlIGNvbXBpbGVkIGZvclxuICAgICAqL1xuICAgIGFkZGl0aW9uYWw/OiBzdHJpbmdbXVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMge1xuICBuYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIGtleXdvcmRzPzogc3RyaW5nW11cbiAgYXV0aG9yPzogc3RyaW5nXG4gIGF1dGhvcnM/OiBzdHJpbmdbXVxuICBsaWNlbnNlPzogc3RyaW5nXG4gIGNwdT86IHN0cmluZ1tdXG4gIG9zPzogc3RyaW5nW11cbiAgbGliYz86IHN0cmluZ1tdXG4gIGZpbGVzPzogc3RyaW5nW11cbiAgcmVwb3NpdG9yeT86IGFueVxuICBob21lcGFnZT86IGFueVxuICBlbmdpbmVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwdWJsaXNoQ29uZmlnPzogYW55XG4gIGJ1Z3M/OiBhbnlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIG5hcGk/OiBVc2VyTmFwaUNvbmZpZ1xuICB0eXBlPzogJ21vZHVsZScgfCAnY29tbW9uanMnXG4gIHNjcmlwdHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLy8gbW9kdWxlc1xuICBtYWluPzogc3RyaW5nXG4gIG1vZHVsZT86IHN0cmluZ1xuICB0eXBlcz86IHN0cmluZ1xuICBicm93c2VyPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBhbnlcblxuICBkZXBlbmRlbmNpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGRldkRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICBhdmE/OiB7XG4gICAgdGltZW91dD86IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE5hcGlDb25maWcgPSBSZXF1aXJlZDxcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ2JpbmFyeU5hbWUnIHwgJ3BhY2thZ2VOYW1lJyB8ICducG1DbGllbnQnPlxuPiAmXG4gIFBpY2s8VXNlck5hcGlDb25maWcsICd3YXNtJyB8ICdkdHNIZWFkZXInIHwgJ2R0c0hlYWRlckZpbGUnIHwgJ2NvbnN0RW51bSc+ICYge1xuICAgIHRhcmdldHM6IFRhcmdldFtdXG4gICAgcGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzXG4gIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWROYXBpQ29uZmlnKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcsXG4pOiBQcm9taXNlPE5hcGlDb25maWc+IHtcbiAgaWYgKGNvbmZpZ1BhdGggJiYgIShhd2FpdCBmaWxlRXhpc3RzKGNvbmZpZ1BhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTkFQSS1SUyBjb25maWcgbm90IGZvdW5kIGF0ICR7Y29uZmlnUGF0aH1gKVxuICB9XG4gIGlmICghKGF3YWl0IGZpbGVFeGlzdHMocGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrYWdlLmpzb24gbm90IGZvdW5kIGF0ICR7cGF0aH1gKVxuICB9XG4gIC8vIE1heSBzdXBwb3J0IG11bHRpcGxlIGNvbmZpZyBzb3VyY2VzIGxhdGVyIG9uLlxuICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRoLCAndXRmOCcpXG4gIGxldCBwa2dKc29uXG4gIHRyeSB7XG4gICAgcGtnSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbiBhdCAke3BhdGh9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxuXG4gIGxldCBzZXBhcmF0ZWRDb25maWc6IFVzZXJOYXBpQ29uZmlnIHwgdW5kZWZpbmVkXG4gIGlmIChjb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY29uZmlnUGF0aCwgJ3V0ZjgnKVxuICAgIHRyeSB7XG4gICAgICBzZXBhcmF0ZWRDb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0NvbnRlbnQpIGFzIFVzZXJOYXBpQ29uZmlnXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgTkFQSS1SUyBjb25maWcgYXQgJHtjb25maWdQYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVzZXJOYXBpQ29uZmlnID0gcGtnSnNvbi5uYXBpID8/IHt9XG4gIGlmIChwa2dKc29uLm5hcGkgJiYgc2VwYXJhdGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcGtnSnNvblBhdGggPSB1bmRlcmxpbmUocGF0aClcbiAgICBjb25zdCBjb25maWdQYXRoVW5kZXJsaW5lID0gdW5kZXJsaW5lKGNvbmZpZ1BhdGghKVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYEJvdGggbmFwaSBmaWVsZCBpbiAke3BrZ0pzb25QYXRofSBhbmQgW05BUEktUlMgY29uZmlnXSgke2NvbmZpZ1BhdGhVbmRlcmxpbmV9KSBmaWxlIGFyZSBmb3VuZCwgdGhlIE5BUEktUlMgY29uZmlnIGZpbGUgd2lsbCBiZSB1c2VkLmAsXG4gICAgICApLFxuICAgIClcbiAgICBPYmplY3QuYXNzaWduKHVzZXJOYXBpQ29uZmlnLCBzZXBhcmF0ZWRDb25maWcpXG4gIH1cbiAgY29uc3QgbmFwaUNvbmZpZzogTmFwaUNvbmZpZyA9IG1lcmdlKFxuICAgIHtcbiAgICAgIGJpbmFyeU5hbWU6ICdpbmRleCcsXG4gICAgICBwYWNrYWdlTmFtZTogcGtnSnNvbi5uYW1lLFxuICAgICAgdGFyZ2V0czogW10sXG4gICAgICBwYWNrYWdlSnNvbjogcGtnSnNvbixcbiAgICAgIG5wbUNsaWVudDogJ25wbScsXG4gICAgfSxcbiAgICBvbWl0KHVzZXJOYXBpQ29uZmlnLCAndGFyZ2V0cycpLFxuICApXG5cbiAgbGV0IHRhcmdldHM6IHN0cmluZ1tdID0gdXNlck5hcGlDb25maWcudGFyZ2V0cyA/PyBbXVxuXG4gIC8vIGNvbXBhdGlibGUgd2l0aCBvbGQgY29uZmlnXG4gIGlmICh1c2VyTmFwaUNvbmZpZz8ubmFtZSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYFtERVBSRUNBVEVEXSBuYXBpLm5hbWUgaXMgZGVwcmVjYXRlZCwgdXNlIG5hcGkuYmluYXJ5TmFtZSBpbnN0ZWFkLmAsXG4gICAgICApLFxuICAgIClcbiAgICBuYXBpQ29uZmlnLmJpbmFyeU5hbWUgPSB1c2VyTmFwaUNvbmZpZy5uYW1lXG4gIH1cblxuICBpZiAoIXRhcmdldHMubGVuZ3RoKSB7XG4gICAgbGV0IGRlcHJlY2F0ZWRXYXJuZWQgPSBmYWxzZVxuICAgIGNvbnN0IHdhcm5pbmcgPSB5ZWxsb3coXG4gICAgICBgW0RFUFJFQ0FURURdIG5hcGkudHJpcGxlcyBpcyBkZXByZWNhdGVkLCB1c2UgbmFwaS50YXJnZXRzIGluc3RlYWQuYCxcbiAgICApXG4gICAgaWYgKHVzZXJOYXBpQ29uZmlnLnRyaXBsZXM/LmRlZmF1bHRzKSB7XG4gICAgICBkZXByZWNhdGVkV2FybmVkID0gdHJ1ZVxuICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG4gICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoREVGQVVMVF9UQVJHRVRTKVxuICAgIH1cblxuICAgIGlmICh1c2VyTmFwaUNvbmZpZy50cmlwbGVzPy5hZGRpdGlvbmFsPy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdCh1c2VyTmFwaUNvbmZpZy50cmlwbGVzLmFkZGl0aW9uYWwpXG4gICAgICBpZiAoIWRlcHJlY2F0ZWRXYXJuZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZmluZCBkdXBsaWNhdGUgdGFyZ2V0c1xuICBjb25zdCB1bmlxdWVUYXJnZXRzID0gbmV3IFNldCh0YXJnZXRzKVxuICBpZiAodW5pcXVlVGFyZ2V0cy5zaXplICE9PSB0YXJnZXRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGR1cGxpY2F0ZVRhcmdldCA9IHRhcmdldHMuZmluZChcbiAgICAgICh0YXJnZXQsIGluZGV4KSA9PiB0YXJnZXRzLmluZGV4T2YodGFyZ2V0KSAhPT0gaW5kZXgsXG4gICAgKVxuICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHRhcmdldHMgYXJlIG5vdCBhbGxvd2VkOiAke2R1cGxpY2F0ZVRhcmdldH1gKVxuICB9XG5cbiAgbmFwaUNvbmZpZy50YXJnZXRzID0gdGFyZ2V0cy5tYXAocGFyc2VUcmlwbGUpXG5cbiAgcmV0dXJuIG5hcGlDb25maWdcbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdHJ5SW5zdGFsbENhcmdvQmluYXJ5KG5hbWU6IHN0cmluZywgYmluOiBzdHJpbmcpIHtcbiAgaWYgKGRldGVjdENhcmdvQmluYXJ5KGJpbikpIHtcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IGFscmVhZHkgaW5zdGFsbGVkOiAlcycsIG5hbWUpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGRlYnVnKCdJbnN0YWxsaW5nIGNhcmdvIGJpbmFyeTogJXMnLCBuYW1lKVxuICAgIGV4ZWNTeW5jKGBjYXJnbyBpbnN0YWxsICR7bmFtZX1gLCB7XG4gICAgICBzdGRpbzogJ2luaGVyaXQnLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbnN0YWxsIGNhcmdvIGJpbmFyeTogJHtuYW1lfWAsIHtcbiAgICAgIGNhdXNlOiBlLFxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZWN0Q2FyZ29CaW5hcnkoYmluOiBzdHJpbmcpIHtcbiAgZGVidWcoJ0RldGVjdGluZyBjYXJnbyBiaW5hcnk6ICVzJywgYmluKVxuICB0cnkge1xuICAgIGV4ZWNTeW5jKGBjYXJnbyBoZWxwICR7YmlufWAsIHtcbiAgICAgIHN0ZGlvOiAnaWdub3JlJyxcbiAgICB9KVxuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgZGV0ZWN0ZWQ6ICVzJywgYmluKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgbm90IGRldGVjdGVkOiAlcycsIGJpbilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwiaW1wb3J0IHsgc29ydEJ5IH0gZnJvbSAnbG9kYXNoLWVzJ1xuXG5pbXBvcnQgeyByZWFkRmlsZUFzeW5jIH0gZnJvbSAnLi9taXNjLmpzJ1xuXG5jb25zdCBUT1BfTEVWRUxfTkFNRVNQQUNFID0gJ19fVE9QX0xFVkVMX01PRFVMRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVFlQRV9ERUZfSEVBREVSID0gYC8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5gXG5cbmVudW0gVHlwZURlZktpbmQge1xuICBDb25zdCA9ICdjb25zdCcsXG4gIEVudW0gPSAnZW51bScsXG4gIFN0cmluZ0VudW0gPSAnc3RyaW5nX2VudW0nLFxuICBJbnRlcmZhY2UgPSAnaW50ZXJmYWNlJyxcbiAgVHlwZSA9ICd0eXBlJyxcbiAgRm4gPSAnZm4nLFxuICBTdHJ1Y3QgPSAnc3RydWN0JyxcbiAgSW1wbCA9ICdpbXBsJyxcbn1cblxuaW50ZXJmYWNlIFR5cGVEZWZMaW5lIHtcbiAga2luZDogVHlwZURlZktpbmRcbiAgbmFtZTogc3RyaW5nXG4gIG9yaWdpbmFsX25hbWU/OiBzdHJpbmdcbiAgZGVmOiBzdHJpbmdcbiAganNfZG9jPzogc3RyaW5nXG4gIGpzX21vZD86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBwcmV0dHlQcmludChcbiAgbGluZTogVHlwZURlZkxpbmUsXG4gIGNvbnN0RW51bTogYm9vbGVhbixcbiAgaWRlbnQ6IG51bWJlcixcbiAgYW1iaWVudCA9IGZhbHNlLFxuKTogc3RyaW5nIHtcbiAgbGV0IHMgPSBsaW5lLmpzX2RvYyA/PyAnJ1xuICBzd2l0Y2ggKGxpbmUua2luZCkge1xuICAgIGNhc2UgVHlwZURlZktpbmQuSW50ZXJmYWNlOlxuICAgICAgcyArPSBgZXhwb3J0IGludGVyZmFjZSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlR5cGU6XG4gICAgICBzICs9IGBleHBvcnQgdHlwZSAke2xpbmUubmFtZX0gPSBcXG4ke2xpbmUuZGVmfWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLkVudW06XG4gICAgICBjb25zdCBlbnVtTmFtZSA9IGNvbnN0RW51bSA/ICdjb25zdCBlbnVtJyA6ICdlbnVtJ1xuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSAke2VudW1OYW1lfSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cmluZ0VudW06XG4gICAgICBpZiAoY29uc3RFbnVtKSB7XG4gICAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gY29uc3QgZW51bSAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgKz0gYGV4cG9ydCB0eXBlICR7bGluZS5uYW1lfSA9ICR7bGluZS5kZWYucmVwbGFjZUFsbCgvLio9L2csICcnKS5yZXBsYWNlQWxsKCcsJywgJ3wnKX07YFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuU3RydWN0OlxuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjbGFzcyAke2xpbmUubmFtZX0ge1xcbiR7bGluZS5kZWZ9XFxufWBcbiAgICAgIGlmIChsaW5lLm9yaWdpbmFsX25hbWUgJiYgbGluZS5vcmlnaW5hbF9uYW1lICE9PSBsaW5lLm5hbWUpIHtcbiAgICAgICAgcyArPSBgXFxuZXhwb3J0IHR5cGUgJHtsaW5lLm9yaWdpbmFsX25hbWV9ID0gJHtsaW5lLm5hbWV9YFxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuRm46XG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9ICR7bGluZS5kZWZ9YFxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzICs9IGxpbmUuZGVmXG4gIH1cblxuICByZXR1cm4gY29ycmVjdFN0cmluZ0lkZW50KHMsIGlkZW50KVxufVxuXG5mdW5jdGlvbiBleHBvcnREZWNsYXJlKGFtYmllbnQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBpZiAoYW1iaWVudCkge1xuICAgIHJldHVybiAnZXhwb3J0J1xuICB9XG5cbiAgcmV0dXJuICdleHBvcnQgZGVjbGFyZSdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUeXBlRGVmKFxuICBpbnRlcm1lZGlhdGVUeXBlRmlsZTogc3RyaW5nLFxuICBjb25zdEVudW06IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgZXhwb3J0czogc3RyaW5nW10gPSBbXVxuICBjb25zdCBkZWZzID0gYXdhaXQgcmVhZEludGVybWVkaWF0ZVR5cGVGaWxlKGludGVybWVkaWF0ZVR5cGVGaWxlKVxuICBjb25zdCBncm91cGVkRGVmcyA9IHByZXByb2Nlc3NUeXBlRGVmKGRlZnMpXG5cbiAgY29uc3QgZHRzID1cbiAgICBzb3J0QnkoQXJyYXkuZnJvbShncm91cGVkRGVmcyksIChbbmFtZXNwYWNlXSkgPT4gbmFtZXNwYWNlKVxuICAgICAgLm1hcCgoW25hbWVzcGFjZSwgZGVmc10pID0+IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gVE9QX0xFVkVMX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBkZWZzXG4gICAgICAgICAgICAubWFwKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkZWYua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuQ29uc3Q6XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5FbnVtOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkZuOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RydWN0OiB7XG4gICAgICAgICAgICAgICAgICBleHBvcnRzLnB1c2goZGVmLm5hbWUpXG4gICAgICAgICAgICAgICAgICBpZiAoZGVmLm9yaWdpbmFsX25hbWUgJiYgZGVmLm9yaWdpbmFsX25hbWUgIT09IGRlZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucHVzaChkZWYub3JpZ2luYWxfbmFtZSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuXFxuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnB1c2gobmFtZXNwYWNlKVxuICAgICAgICAgIGxldCBkZWNsYXJhdGlvbiA9ICcnXG4gICAgICAgICAgZGVjbGFyYXRpb24gKz0gYGV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSAke25hbWVzcGFjZX0ge1xcbmBcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiArPSBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMiwgdHJ1ZSkgKyAnXFxuJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWNsYXJhdGlvbiArPSAnfSdcbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG5cXG4nKSArICdcXG4nXG5cbiAgcmV0dXJuIHtcbiAgICBkdHMsXG4gICAgZXhwb3J0cyxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoZmlsZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGUsICd1dGY4JylcblxuICBjb25zdCBkZWZzID0gY29udGVudFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGxpbmUpIGFzIFR5cGVEZWZMaW5lXG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgYmFjayB0byBhY3R1YWwgbmV3bGluZXMgaW4ganNfZG9jIGZpZWxkc1xuICAgICAgaWYgKHBhcnNlZC5qc19kb2MpIHtcbiAgICAgICAgcGFyc2VkLmpzX2RvYyA9IHBhcnNlZC5qc19kb2MucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgdG8gYWN0dWFsIG5ld2xpbmVzIGluIGRlZiBmaWVsZHMgZm9yIHN0cnVjdC9jbGFzcy9pbnRlcmZhY2UvdHlwZSB0eXBlc1xuICAgICAgLy8gd2hlcmUgXFxuIHJlcHJlc2VudHMgbWV0aG9kL2ZpZWxkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgYWN0dWFsIG5ld2xpbmVzXG4gICAgICBpZiAocGFyc2VkLmRlZikge1xuICAgICAgICBwYXJzZWQuZGVmID0gcGFyc2VkLmRlZi5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRcbiAgICB9KVxuXG4gIC8vIG1vdmUgYWxsIGBzdHJ1Y3RgIGRlZiB0byB0aGUgdmVyeSB0b3BcbiAgLy8gYW5kIG9yZGVyIHRoZSByZXN0IGFscGhhYmV0aWNhbGx5LlxuICByZXR1cm4gZGVmcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzVHlwZURlZihkZWZzOiBUeXBlRGVmTGluZVtdKTogTWFwPHN0cmluZywgVHlwZURlZkxpbmVbXT4ge1xuICBjb25zdCBuYW1lc3BhY2VHcm91cGVkID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lW10+KClcbiAgY29uc3QgY2xhc3NEZWZzID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lPigpXG5cbiAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGRlZi5qc19tb2QgPz8gVE9QX0xFVkVMX05BTUVTUEFDRVxuICAgIGlmICghbmFtZXNwYWNlR3JvdXBlZC5oYXMobmFtZXNwYWNlKSkge1xuICAgICAgbmFtZXNwYWNlR3JvdXBlZC5zZXQobmFtZXNwYWNlLCBbXSlcbiAgICB9XG5cbiAgICBjb25zdCBncm91cCA9IG5hbWVzcGFjZUdyb3VwZWQuZ2V0KG5hbWVzcGFjZSkhXG5cbiAgICBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgZ3JvdXAucHVzaChkZWYpXG4gICAgICBjbGFzc0RlZnMuc2V0KGRlZi5uYW1lLCBkZWYpXG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuSW1wbCkge1xuICAgICAgLy8gbWVyZ2UgYGltcGxgIGludG8gY2xhc3MgZGVmaW5pdGlvblxuICAgICAgY29uc3QgY2xhc3NEZWYgPSBjbGFzc0RlZnMuZ2V0KGRlZi5uYW1lKVxuICAgICAgaWYgKGNsYXNzRGVmKSB7XG4gICAgICAgIGlmIChjbGFzc0RlZi5kZWYpIHtcbiAgICAgICAgICBjbGFzc0RlZi5kZWYgKz0gJ1xcbidcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzRGVmLmRlZiArPSBkZWYuZGVmXG4gICAgICAgIC8vIENvbnZlcnQgYW55IHJlbWFpbmluZyBcXG4gc2VxdWVuY2VzIGluIHRoZSBtZXJnZWQgZGVmIHRvIGFjdHVhbCBuZXdsaW5lc1xuICAgICAgICBpZiAoY2xhc3NEZWYuZGVmKSB7XG4gICAgICAgICAgY2xhc3NEZWYuZGVmID0gY2xhc3NEZWYuZGVmLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnB1c2goZGVmKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VHcm91cGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3JyZWN0U3RyaW5nSWRlbnQoc3JjOiBzdHJpbmcsIGlkZW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgYnJhY2tldERlcHRoID0gMFxuICBjb25zdCByZXN1bHQgPSBzcmNcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzSW5NdWx0aWxpbmVDb21tZW50ID0gbGluZS5zdGFydHNXaXRoKCcqJylcbiAgICAgIGNvbnN0IGlzQ2xvc2luZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd9JylcbiAgICAgIGNvbnN0IGlzT3BlbmluZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd7JylcbiAgICAgIGNvbnN0IGlzVHlwZURlY2xhcmF0aW9uID0gbGluZS5lbmRzV2l0aCgnPScpXG4gICAgICBjb25zdCBpc1R5cGVWYXJpYW50ID0gbGluZS5zdGFydHNXaXRoKCd8JylcblxuICAgICAgbGV0IHJpZ2h0SW5kZW50ID0gaWRlbnRcbiAgICAgIGlmICgoaXNPcGVuaW5nQnJhY2tldCB8fCBpc1R5cGVEZWNsYXJhdGlvbikgJiYgIWlzSW5NdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgIGJyYWNrZXREZXB0aCArPSAxXG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IChicmFja2V0RGVwdGggLSAxKSAqIDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0Nsb3NpbmdCcmFja2V0ICYmXG4gICAgICAgICAgYnJhY2tldERlcHRoID4gMCAmJlxuICAgICAgICAgICFpc0luTXVsdGlsaW5lQ29tbWVudCAmJlxuICAgICAgICAgICFpc1R5cGVWYXJpYW50XG4gICAgICAgICkge1xuICAgICAgICAgIGJyYWNrZXREZXB0aCAtPSAxXG4gICAgICAgIH1cbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gYnJhY2tldERlcHRoICogMlxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbk11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gMVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzID0gYCR7JyAnLnJlcGVhdChyaWdodEluZGVudCl9JHtsaW5lfWBcblxuICAgICAgcmV0dXJuIHNcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsImltcG9ydCB7IHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi9jb25maWcuanMnXG5cbmludGVyZmFjZSBNaW5pbWFsTmFwaU9wdGlvbnMge1xuICBjd2Q6IHN0cmluZ1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENvbmZpZyhvcHRpb25zOiBNaW5pbWFsTmFwaU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZVBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKSA9PiByZXNvbHZlKG9wdGlvbnMuY3dkLCAuLi5wYXRocylcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgoXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPz8gb3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicsXG4gICAgKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG4gIHJldHVybiBjb25maWdcbn1cbiIsImltcG9ydCB7IGpvaW4sIHBhcnNlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zLFxuICBBcnRpZmFjdHNPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgcmVhZEZpbGVBc3luYyxcbiAgd3JpdGVGaWxlQXN5bmMsXG4gIFVuaUFyY2hzQnlQbGF0Zm9ybSxcbiAgcmVhZGRpckFzeW5jLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2FydGlmYWN0cycpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2xsZWN0QXJ0aWZhY3RzKHVzZXJPcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lIH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKHBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBkaXN0RGlycyA9IHRhcmdldHMubWFwKChwbGF0Zm9ybSkgPT5cbiAgICBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpciwgcGxhdGZvcm0ucGxhdGZvcm1BcmNoQUJJKSxcbiAgKVxuXG4gIGNvbnN0IHVuaXZlcnNhbFNvdXJjZUJpbnMgPSBuZXcgU2V0KFxuICAgIHRhcmdldHNcbiAgICAgIC5maWx0ZXIoKHBsYXRmb3JtKSA9PiBwbGF0Zm9ybS5hcmNoID09PSAndW5pdmVyc2FsJylcbiAgICAgIC5mbGF0TWFwKChwKSA9PlxuICAgICAgICBVbmlBcmNoc0J5UGxhdGZvcm1bcC5wbGF0Zm9ybV0/Lm1hcCgoYSkgPT4gYCR7cC5wbGF0Zm9ybX0tJHthfWApLFxuICAgICAgKVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBzdHJpbmdbXSxcbiAgKVxuXG4gIGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5vdXRwdXREaXIpKS50aGVuKFxuICAgIChvdXRwdXQpID0+XG4gICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgb3V0cHV0Lm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBSZWFkIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZmlsZVBhdGgpfV1gKVxuICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGVQYXRoKVxuICAgICAgICAgIGNvbnN0IHBhcnNlZE5hbWUgPSBwYXJzZShmaWxlUGF0aClcbiAgICAgICAgICBjb25zdCB0ZXJtcyA9IHBhcnNlZE5hbWUubmFtZS5zcGxpdCgnLicpXG4gICAgICAgICAgY29uc3QgcGxhdGZvcm1BcmNoQUJJID0gdGVybXMucG9wKCkhXG4gICAgICAgICAgY29uc3QgX2JpbmFyeU5hbWUgPSB0ZXJtcy5qb2luKCcuJylcblxuICAgICAgICAgIGlmIChfYmluYXJ5TmFtZSAhPT0gYmluYXJ5TmFtZSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske19iaW5hcnlOYW1lfV0gaXMgbm90IG1hdGNoZWQgd2l0aCBbJHtiaW5hcnlOYW1lfV0sIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpciA9IGRpc3REaXJzLmZpbmQoKGRpcikgPT4gZGlyLmluY2x1ZGVzKHBsYXRmb3JtQXJjaEFCSSkpXG4gICAgICAgICAgaWYgKCFkaXIgJiYgdW5pdmVyc2FsU291cmNlQmlucy5oYXMocGxhdGZvcm1BcmNoQUJJKSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske3BsYXRmb3JtQXJjaEFCSX1dIGhhcyBubyBkaXN0IGRpciBidXQgaXQgaXMgc291cmNlIGJpbiBmb3IgdW5pdmVyc2FsIGFyY2gsIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRpc3QgZGlyIGZvdW5kIGZvciAke2ZpbGVQYXRofWApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlzdEZpbGVQYXRoID0gam9pbihkaXIsIHBhcnNlZE5hbWUuYmFzZSlcbiAgICAgICAgICBkZWJ1Zy5pbmZvKFxuICAgICAgICAgICAgYFdyaXRlIGZpbGUgY29udGVudCB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGRpc3RGaWxlUGF0aCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aCwgc291cmNlQ29udGVudClcbiAgICAgICAgICBjb25zdCBkaXN0RmlsZVBhdGhMb2NhbCA9IGpvaW4oXG4gICAgICAgICAgICBwYXJzZShwYWNrYWdlSnNvblBhdGgpLmRpcixcbiAgICAgICAgICAgIHBhcnNlZE5hbWUuYmFzZSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcuaW5mbyhcbiAgICAgICAgICAgIGBXcml0ZSBmaWxlIGNvbnRlbnQgdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodChkaXN0RmlsZVBhdGhMb2NhbCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aExvY2FsLCBzb3VyY2VDb250ZW50KVxuICAgICAgICB9KSxcbiAgICAgICksXG4gIClcblxuICBjb25zdCB3YXNpVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKCh0KSA9PiB0LnBsYXRmb3JtID09PSAnd2FzaScpXG4gIGlmICh3YXNpVGFyZ2V0KSB7XG4gICAgY29uc3Qgd2FzaURpciA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgd2FzaVRhcmdldC5wbGF0Zm9ybUFyY2hBQkksXG4gICAgKVxuICAgIGNvbnN0IGNqc0ZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYCxcbiAgICApXG4gICAgY29uc3Qgd29ya2VyRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYHdhc2ktd29ya2VyLm1qc2AsXG4gICAgKVxuICAgIGNvbnN0IGJyb3dzZXJFbnRyeSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgY29uc3QgYnJvd3NlcldvcmtlckZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2AsXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJpbmRpbmcgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBjanNGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyhjanNGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgd29ya2VyIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgd29ya2VyRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYHdhc2ktd29ya2VyLm1qc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyh3b3JrZXJGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYnJvd3NlciBlbnRyeSBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJFbnRyeSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzg0MjdcbiAgICAgIChhd2FpdCByZWFkRmlsZUFzeW5jKGJyb3dzZXJFbnRyeSwgJ3V0ZjgnKSkucmVwbGFjZShcbiAgICAgICAgYG5ldyBVUkwoJy4vd2FzaS13b3JrZXItYnJvd3Nlci5tanMnLCBpbXBvcnQubWV0YS51cmwpYCxcbiAgICAgICAgYG5ldyBVUkwoJyR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKWAsXG4gICAgICApLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBicm93c2VyIHdvcmtlciBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMoYnJvd3NlcldvcmtlckZpbGUpLFxuICAgIClcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb2xsZWN0Tm9kZUJpbmFyaWVzKHJvb3Q6IHN0cmluZykge1xuICBjb25zdCBmaWxlcyA9IGF3YWl0IHJlYWRkaXJBc3luYyhyb290LCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgY29uc3Qgbm9kZUJpbmFyaWVzID0gZmlsZXNcbiAgICAuZmlsdGVyKFxuICAgICAgKGZpbGUpID0+XG4gICAgICAgIGZpbGUuaXNGaWxlKCkgJiZcbiAgICAgICAgKGZpbGUubmFtZS5lbmRzV2l0aCgnLm5vZGUnKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoJy53YXNtJykpLFxuICAgIClcbiAgICAubWFwKChmaWxlKSA9PiBqb2luKHJvb3QsIGZpbGUubmFtZSkpXG5cbiAgY29uc3QgZGlycyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5pc0RpcmVjdG9yeSgpKVxuICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgaWYgKGRpci5uYW1lICE9PSAnbm9kZV9tb2R1bGVzJykge1xuICAgICAgbm9kZUJpbmFyaWVzLnB1c2goLi4uKGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihyb290LCBkaXIubmFtZSkpKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVCaW5hcmllc1xufVxuIiwiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgY29sbGVjdEFydGlmYWN0cyB9IGZyb20gJy4uL2FwaS9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9hcnRpZmFjdHMuanMnXG5cbmV4cG9ydCBjbGFzcyBBcnRpZmFjdHNDb21tYW5kIGV4dGVuZHMgQmFzZUFydGlmYWN0c0NvbW1hbmQge1xuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBzcGVjaWZpZWQgZGlyJyxcbiAgICBleGFtcGxlczogW1xuICAgICAgW1xuICAgICAgICAnJDAgYXJ0aWZhY3RzIC0tb3V0cHV0LWRpciAuL2FydGlmYWN0cyAtLWRpc3QgLi9ucG0nLFxuICAgICAgICBgQ29weSBbYmluYXJ5TmFtZV0uW3BsYXRmb3JtXS5ub2RlIHVuZGVyIGN1cnJlbnQgZGlyKC4pIGludG8gcGFja2FnZXMgdW5kZXIgbnBtIGRpci5cbmUuZzogaW5kZXgubGludXgteDY0LWdudS5ub2RlIC0tPiAuL25wbS9saW51eC14NjQtZ251L2luZGV4LmxpbnV4LXg2NC1nbnUubm9kZWAsXG4gICAgICBdLFxuICAgIF0sXG4gIH0pXG5cbiAgc3RhdGljIHBhdGhzID0gW1snYXJ0aWZhY3RzJ11dXG5cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCBjb2xsZWN0QXJ0aWZhY3RzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2pzQmluZGluZyhcbiAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gIHBrZ05hbWU6IHN0cmluZyxcbiAgaWRlbnRzOiBzdHJpbmdbXSxcbik6IHN0cmluZyB7XG4gIHJldHVybiBgJHtiaW5kaW5nSGVhZGVyfVxuY29uc3QgeyBjcmVhdGVSZXF1aXJlIH0gPSByZXF1aXJlKCdub2RlOm1vZHVsZScpXG5yZXF1aXJlID0gY3JlYXRlUmVxdWlyZShfX2ZpbGVuYW1lKVxuXG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lKX1cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQmluZGluZ1xuJHtpZGVudHNcbiAgLm1hcCgoaWRlbnQpID0+IGBtb2R1bGUuZXhwb3J0cy4ke2lkZW50fSA9IG5hdGl2ZUJpbmRpbmcuJHtpZGVudH1gKVxuICAuam9pbignXFxuJyl9XG5gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFc21CaW5kaW5nKFxuICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgcGtnTmFtZTogc3RyaW5nLFxuICBpZGVudHM6IHN0cmluZ1tdLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5jb25zdCBfX2Rpcm5hbWUgPSBuZXcgVVJMKCcuJywgaW1wb3J0Lm1ldGEudXJsKS5wYXRobmFtZVxuXG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lKX1cbmNvbnN0IHsgJHtpZGVudHMuam9pbignLCAnKX0gfSA9IG5hdGl2ZUJpbmRpbmdcbiR7aWRlbnRzLm1hcCgoaWRlbnQpID0+IGBleHBvcnQgeyAke2lkZW50fSB9YCkuam9pbignXFxuJyl9XG5gXG59XG5cbmNvbnN0IGJpbmRpbmdIZWFkZXIgPSBgLy8gcHJldHRpZXItaWdub3JlXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbmBcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWU6IHN0cmluZywgcGtnTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgZnVuY3Rpb24gcmVxdWlyZVR1cGxlKHR1cGxlOiBzdHJpbmcsIGlkZW50U2l6ZSA9IDgpIHtcbiAgICBjb25zdCBpZGVudExvdyA9ICcgJy5yZXBlYXQoaWRlbnRTaXplIC0gMilcbiAgICBjb25zdCBpZGVudCA9ICcgJy5yZXBlYXQoaWRlbnRTaXplKVxuICAgIHJldHVybiBgdHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9LiR7dHVwbGV9Lm5vZGUnKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319XG4ke2lkZW50TG93fXRyeSB7XG4ke2lkZW50fXJldHVybiByZXF1aXJlKCcke3BrZ05hbWV9LSR7dHVwbGV9JylcbiR7aWRlbnRMb3d9fSBjYXRjaCAoZSkge1xuJHtpZGVudH1sb2FkRXJyb3JzLnB1c2goZSlcbiR7aWRlbnRMb3d9fWBcbiAgfVxuXG4gIHJldHVybiBgY29uc3QgeyByZWFkRmlsZVN5bmMgfSA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxubGV0IG5hdGl2ZUJpbmRpbmcgPSBudWxsXG5jb25zdCBsb2FkRXJyb3JzID0gW11cblxuY29uc3QgaXNNdXNsID0gKCkgPT4ge1xuICBsZXQgbXVzbCA9IGZhbHNlXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgbXVzbCA9IGlzTXVzbEZyb21GaWxlc3lzdGVtKClcbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21SZXBvcnQoKVxuICAgIH1cbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbXVzbFxufVxuXG5jb25zdCBpc0ZpbGVNdXNsID0gKGYpID0+IGYuaW5jbHVkZXMoJ2xpYmMubXVzbC0nKSB8fCBmLmluY2x1ZGVzKCdsZC1tdXNsLScpXG5cbmNvbnN0IGlzTXVzbEZyb21GaWxlc3lzdGVtID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiByZWFkRmlsZVN5bmMoJy91c3IvYmluL2xkZCcsICd1dGYtOCcpLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jb25zdCBpc011c2xGcm9tUmVwb3J0ID0gKCkgPT4ge1xuICBsZXQgcmVwb3J0ID0gbnVsbFxuICBpZiAodHlwZW9mIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLnJlcG9ydC5leGNsdWRlTmV0d29yayA9IHRydWVcbiAgICByZXBvcnQgPSBwcm9jZXNzLnJlcG9ydC5nZXRSZXBvcnQoKVxuICB9XG4gIGlmICghcmVwb3J0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAocmVwb3J0LmhlYWRlciAmJiByZXBvcnQuaGVhZGVyLmdsaWJjVmVyc2lvblJ1bnRpbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXBvcnQuc2hhcmVkT2JqZWN0cykpIHtcbiAgICBpZiAocmVwb3J0LnNoYXJlZE9iamVjdHMuc29tZShpc0ZpbGVNdXNsKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYygnbGRkIC0tdmVyc2lvbicsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS5pbmNsdWRlcygnbXVzbCcpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZiB3ZSByZWFjaCB0aGlzIGNhc2UsIHdlIGRvbid0IGtub3cgaWYgdGhlIHN5c3RlbSBpcyBtdXNsIG9yIG5vdCwgc28gaXMgYmV0dGVyIHRvIGp1c3QgZmFsbGJhY2sgdG8gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1aXJlTmF0aXZlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlKHByb2Nlc3MuZW52Lk5BUElfUlNfTkFUSVZFX0xJQlJBUllfUEFUSCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm02NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2FuZHJvaWQtYXJtLWVhYmknKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gQW5kcm9pZCBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLXg2NC1tc3ZjJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLWlhMzItbXN2YycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzItYXJtNjQtbXN2YycpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBXaW5kb3dzOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi11bml2ZXJzYWwnLCA2KX1cbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2Rhcndpbi1hcm02NCcpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBtYWNPUzogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZnJlZWJzZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2ZyZWVic2QteDY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdmcmVlYnNkLWFybTY0Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIEZyZWVCU0Q6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXg2NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1tdXNsZWFiaWhmJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1nbnVlYWJpaGYnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdyaXNjdjY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1yaXNjdjY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcmlzY3Y2NC1nbnUnLCAxMCl9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdwcGM2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1wcGM2NC1nbnUnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3MzOTB4Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXMzOTB4LWdudScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBMaW51eDogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnb3Blbmhhcm1vbnknKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LW9ob3MnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtb2hvcycpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybS1vaG9zJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIE9wZW5IYXJtb255OiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgT1M6IFxcJHtwcm9jZXNzLnBsYXRmb3JtfSwgYXJjaGl0ZWN0dXJlOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gIH1cbn1cblxubmF0aXZlQmluZGluZyA9IHJlcXVpcmVOYXRpdmUoKVxuXG5pZiAoIW5hdGl2ZUJpbmRpbmcgfHwgcHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gIHRyeSB7XG4gICAgbmF0aXZlQmluZGluZyA9IHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9Lndhc2kuY2pzJylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICB9XG4gIH1cbiAgaWYgKCFuYXRpdmVCaW5kaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlKCcke3BrZ05hbWV9LXdhc20zMi13YXNpJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKCFuYXRpdmVCaW5kaW5nKSB7XG4gIGlmIChsb2FkRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcXGBDYW5ub3QgZmluZCBuYXRpdmUgYmluZGluZy4gXFxgICtcbiAgICAgICAgXFxgbnBtIGhhcyBhIGJ1ZyByZWxhdGVkIHRvIG9wdGlvbmFsIGRlcGVuZGVuY2llcyAoaHR0cHM6Ly9naXRodWIuY29tL25wbS9jbGkvaXNzdWVzLzQ4MjgpLiBcXGAgK1xuICAgICAgICAnUGxlYXNlIHRyeSBcXGBucG0gaVxcYCBhZ2FpbiBhZnRlciByZW1vdmluZyBib3RoIHBhY2thZ2UtbG9jay5qc29uIGFuZCBub2RlX21vZHVsZXMgZGlyZWN0b3J5LicsXG4gICAgICB7IGNhdXNlOiBsb2FkRXJyb3JzIH1cbiAgICApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxcYEZhaWxlZCB0byBsb2FkIG5hdGl2ZSBiaW5kaW5nXFxgKVxufVxuYFxufVxuIiwiZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyA9IChcbiAgd2FzaUZpbGVuYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4gIGZzID0gZmFsc2UsXG4gIGFzeW5jSW5pdCA9IGZhbHNlLFxuICBidWZmZXIgPSBmYWxzZSxcbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzID8gYGltcG9ydCB7IG1lbWZzIH0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lL2ZzJ2AgOiAnJ1xuICBjb25zdCBidWZmZXJJbXBvcnQgPSBidWZmZXJcbiAgICA/IGZzXG4gICAgICA/IGBgXG4gICAgICA6IGBpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInYFxuICAgIDogJydcbiAgY29uc3Qgd2FzaUNyZWF0aW9uID0gZnNcbiAgICA/IGBcbmV4cG9ydCBjb25zdCB7IGZzOiBfX2ZzLCB2b2w6IF9fdm9sdW1lIH0gPSBtZW1mcygpXG5cbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBmczogX19mcyxcbiAgcHJlb3BlbnM6IHtcbiAgICAnLyc6ICcvJyxcbiAgfSxcbn0pYFxuICAgIDogYFxuY29uc3QgX193YXNpID0gbmV3IF9fV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG59KWBcblxuICBjb25zdCB3b3JrZXJGc0hhbmRsZXIgPSBmc1xuICAgID8gYCAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHkoX19mcykpXFxuYFxuICAgIDogJydcblxuICBjb25zdCBlbW5hcGlJbmplY3RCdWZmZXIgPSBidWZmZXJcbiAgICA/ICdfX2VtbmFwaUNvbnRleHQuZmVhdHVyZS5CdWZmZXIgPSBCdWZmZXInXG4gICAgOiAnJ1xuICBjb25zdCBlbW5hcGlJbnN0YW50aWF0ZUltcG9ydCA9IGFzeW5jSW5pdFxuICAgID8gYGluc3RhbnRpYXRlTmFwaU1vZHVsZSBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZWBcbiAgICA6IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jIGFzIF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVDYWxsID0gYXN5bmNJbml0XG4gICAgPyBgYXdhaXQgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jYFxuXG4gIHJldHVybiBgaW1wb3J0IHtcbiAgY3JlYXRlT25NZXNzYWdlIGFzIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHksXG4gIGdldERlZmF1bHRDb250ZXh0IGFzIF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gICR7ZW1uYXBpSW5zdGFudGlhdGVJbXBvcnR9LFxuICBXQVNJIGFzIF9fV0FTSSxcbn0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lJ1xuJHtmc0ltcG9ydH1cbiR7YnVmZmVySW1wb3J0fVxuJHt3YXNpQ3JlYXRpb259XG5cbmNvbnN0IF9fd2FzbVVybCA9IG5ldyBVUkwoJy4vJHt3YXNpRmlsZW5hbWV9Lndhc20nLCBpbXBvcnQubWV0YS51cmwpLmhyZWZcbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuJHtlbW5hcGlJbmplY3RCdWZmZXJ9XG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmNvbnN0IF9fd2FzbUZpbGUgPSBhd2FpdCBmZXRjaChfX3dhc21VcmwpLnRoZW4oKHJlcykgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cbmNvbnN0IHtcbiAgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLFxuICBtb2R1bGU6IF9fd2FzaU1vZHVsZSxcbiAgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlLFxufSA9ICR7ZW1uYXBpSW5zdGFudGlhdGVDYWxsfShfX3dhc21GaWxlLCB7XG4gIGNvbnRleHQ6IF9fZW1uYXBpQ29udGV4dCxcbiAgYXN5bmNXb3JrUG9vbFNpemU6IDQsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKSwge1xuICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgfSlcbiR7d29ya2VyRnNIYW5kbGVyfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfSxcbiAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgIG1lbW9yeTogX19zaGFyZWRNZW1vcnksXG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRPYmplY3RcbiAgfSxcbiAgYmVmb3JlSW5pdCh7IGluc3RhbmNlIH0pIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykpIHtcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ19fbmFwaV9yZWdpc3Rlcl9fJykpIHtcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tuYW1lXSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxufSlcbmBcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCaW5kaW5nID0gKFxuICB3YXNtRmlsZU5hbWU6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbikgPT4gYC8qIGVzbGludC1kaXNhYmxlICovXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cblxuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuXG5jb25zdCBfX25vZGVGcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxuY29uc3QgX19ub2RlUGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCB7IFdBU0k6IF9fbm9kZVdBU0kgfSA9IHJlcXVpcmUoJ25vZGU6d2FzaScpXG5jb25zdCB7IFdvcmtlciB9ID0gcmVxdWlyZSgnbm9kZTp3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IHtcbiAgY3JlYXRlT25NZXNzYWdlOiBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dDogX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCxcbiAgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYzogX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLFxufSA9IHJlcXVpcmUoJ0BuYXBpLXJzL3dhc20tcnVudGltZScpXG5cbmNvbnN0IF9fcm9vdERpciA9IF9fbm9kZVBhdGgucGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdFxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19ub2RlV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG4gIGVudjogcHJvY2Vzcy5lbnYsXG4gIHByZW9wZW5zOiB7XG4gICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgfVxufSlcblxuY29uc3QgX19lbW5hcGlDb250ZXh0ID0gX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCgpXG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmxldCBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0ud2FzbScpXG5jb25zdCBfX3dhc21EZWJ1Z0ZpbGVQYXRoID0gX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJyR7d2FzbUZpbGVOYW1lfS5kZWJ1Zy53YXNtJylcblxuaWYgKF9fbm9kZUZzLmV4aXN0c1N5bmMoX193YXNtRGVidWdGaWxlUGF0aCkpIHtcbiAgX193YXNtRmlsZVBhdGggPSBfX3dhc21EZWJ1Z0ZpbGVQYXRoXG59IGVsc2UgaWYgKCFfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbUZpbGVQYXRoKSkge1xuICB0cnkge1xuICAgIF9fd2FzbUZpbGVQYXRoID0gX19ub2RlUGF0aC5yZXNvbHZlKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaScpXG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgJHt3YXNtRmlsZU5hbWV9Lndhc20gZmlsZSwgYW5kICR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpIHBhY2thZ2UgaXMgbm90IGluc3RhbGxlZC4nKVxuICB9XG59XG5cbmNvbnN0IHsgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLCBtb2R1bGU6IF9fd2FzaU1vZHVsZSwgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlIH0gPSBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMoX19ub2RlRnMucmVhZEZpbGVTeW5jKF9fd2FzbUZpbGVQYXRoKSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdGhyZWFkc1NpemVGcm9tRW52ID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5BUElfUlNfQVNZTkNfV09SS19QT09MX1NJWkUgPz8gcHJvY2Vzcy5lbnYuVVZfVEhSRUFEUE9PTF9TSVpFKVxuICAgIC8vIE5hTiA+IDAgaXMgZmFsc2VcbiAgICBpZiAodGhyZWFkc1NpemVGcm9tRW52ID4gMCkge1xuICAgICAgcmV0dXJuIHRocmVhZHNTaXplRnJvbUVudlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNFxuICAgIH1cbiAgfSkoKSxcbiAgcmV1c2VXb3JrZXI6IHRydWUsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnd2FzaS13b3JrZXIubWpzJyksIHtcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgfSlcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fbm9kZUZzKShkYXRhKVxuICAgIH1cblxuICAgIC8vIFRoZSBtYWluIHRocmVhZCBvZiBOb2RlLmpzIHdhaXRzIGZvciBhbGwgdGhlIGFjdGl2ZSBoYW5kbGVzIGJlZm9yZSBleGl0aW5nLlxuICAgIC8vIEJ1dCBSdXN0IHRocmVhZHMgYXJlIG5ldmVyIHdhaXRlZCB3aXRob3V0IFxcYHRocmVhZDo6am9pblxcYC5cbiAgICAvLyBTbyBoZXJlIHdlIGhhY2sgdGhlIGNvZGUgb2YgTm9kZS5qcyB0byBwcmV2ZW50IHRoZSB3b3JrZXJzIGZyb20gYmVpbmcgcmVmZXJlbmNlZCAoYWN0aXZlKS5cbiAgICAvLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMTllMGQ0NzI3MjhjNzlkNDE4Yjc0YmRkZmY1ODhiZWE3MGE0MDNkMC9saWIvaW50ZXJuYWwvd29ya2VyLmpzI0w0MTUsXG4gICAgLy8gYSB3b3JrZXIgaXMgY29uc2lzdCBvZiB0d28gaGFuZGxlczoga1B1YmxpY1BvcnQgYW5kIGtIYW5kbGUuXG4gICAge1xuICAgICAgY29uc3Qga1B1YmxpY1BvcnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtQdWJsaWNQb3J0XCIpXG4gICAgICApO1xuICAgICAgaWYgKGtQdWJsaWNQb3J0KSB7XG4gICAgICAgIHdvcmtlcltrUHVibGljUG9ydF0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtIYW5kbGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtIYW5kbGVcIilcbiAgICAgICk7XG4gICAgICBpZiAoa0hhbmRsZSkge1xuICAgICAgICB3b3JrZXJba0hhbmRsZV0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIHdvcmtlci51bnJlZigpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG4iLCJleHBvcnQgY29uc3QgV0FTSV9XT1JLRVJfVEVNUExBVEUgPSBgaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IFdBU0kgfSBmcm9tIFwibm9kZTp3YXNpXCI7XG5pbXBvcnQgeyBwYXJlbnRQb3J0LCBXb3JrZXIgfSBmcm9tIFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiO1xuXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuXG5jb25zdCB7IGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMsIE1lc3NhZ2VIYW5kbGVyLCBnZXREZWZhdWx0Q29udGV4dCB9ID0gcmVxdWlyZShcIkBuYXBpLXJzL3dhc20tcnVudGltZVwiKTtcblxuaWYgKHBhcmVudFBvcnQpIHtcbiAgcGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIiwgKGRhdGEpID0+IHtcbiAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSh7IGRhdGEgfSk7XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgc2VsZjogZ2xvYmFsVGhpcyxcbiAgcmVxdWlyZSxcbiAgV29ya2VyLFxuICBpbXBvcnRTY3JpcHRzOiBmdW5jdGlvbiAoZikge1xuICAgIDsoMCwgZXZhbCkoZnMucmVhZEZpbGVTeW5jKGYsIFwidXRmOFwiKSArIFwiLy8jIHNvdXJjZVVSTD1cIiArIGYpO1xuICB9LFxuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChwYXJlbnRQb3J0KSB7XG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9LFxufSk7XG5cbmNvbnN0IGVtbmFwaUNvbnRleHQgPSBnZXREZWZhdWx0Q29udGV4dCgpO1xuXG5jb25zdCBfX3Jvb3REaXIgPSBwYXJzZShwcm9jZXNzLmN3ZCgpKS5yb290O1xuXG5jb25zdCBoYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHtcbiAgb25Mb2FkKHsgd2FzbU1vZHVsZSwgd2FzbU1lbW9yeSB9KSB7XG4gICAgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIHZlcnNpb246ICdwcmV2aWV3MScsXG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBjb250ZXh0OiBlbW5hcGlDb250ZXh0LFxuICAgICAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICAgICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufSk7XG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSk7XG59O1xuYFxuXG5leHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nID0gKGZzOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSwgY3JlYXRlRnNQcm94eSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbmltcG9ydCB7IG1lbWZzRXhwb3J0ZWQgYXMgX19tZW1mc0V4cG9ydGVkIH0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lL2ZzJ1xuXG5jb25zdCBmcyA9IGNyZWF0ZUZzUHJveHkoX19tZW1mc0V4cG9ydGVkKWBcbiAgICA6IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdgXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIGZzLFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICAgIDogYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgICAgcHJpbnRFcnI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgfSlgXG4gIHJldHVybiBgJHtmc0ltcG9ydH1cblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgICR7d2FzaUNyZWF0aW9ufVxuICAgIHJldHVybiBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKHdhc21Nb2R1bGUsIHtcbiAgICAgIGNoaWxkVGhyZWFkOiB0cnVlLFxuICAgICAgd2FzaSxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9LFxufSlcblxuZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICBoYW5kbGVyLmhhbmRsZShlKVxufVxuYFxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJtU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCB7IHBhcnNlLCBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuaW1wb3J0IHsgaW5jbHVkZSBhcyBzZXRqbXBJbmNsdWRlLCBsaWIgYXMgc2V0am1wTGliIH0gZnJvbSAnd2FzbS1zamxqJ1xuXG5pbXBvcnQgeyBCdWlsZE9wdGlvbnMgYXMgUmF3QnVpbGRPcHRpb25zIH0gZnJvbSAnLi4vZGVmL2J1aWxkLmpzJ1xuaW1wb3J0IHtcbiAgQ0xJX1ZFUlNJT04sXG4gIGNvcHlGaWxlQXN5bmMsXG4gIENyYXRlLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVFlQRV9ERUZfSEVBREVSLFxuICBmaWxlRXhpc3RzLFxuICBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0LFxuICBnZXRUYXJnZXRMaW5rZXIsXG4gIG1rZGlyQXN5bmMsXG4gIE5hcGlDb25maWcsXG4gIHBhcnNlTWV0YWRhdGEsXG4gIHBhcnNlVHJpcGxlLFxuICBwcm9jZXNzVHlwZURlZixcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIFRhcmdldCxcbiAgdGFyZ2V0VG9FbnZWYXIsXG4gIHRyeUluc3RhbGxDYXJnb0JpbmFyeSxcbiAgdW5saW5rQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBkaXJFeGlzdHNBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgY3JlYXRlQ2pzQmluZGluZywgY3JlYXRlRXNtQmluZGluZyB9IGZyb20gJy4vdGVtcGxhdGVzL2luZGV4LmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJpbmRpbmcsXG4gIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLmpzJ1xuaW1wb3J0IHtcbiAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nLFxuICBXQVNJX1dPUktFUl9URU1QTEFURSxcbn0gZnJvbSAnLi90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUuanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdidWlsZCcpXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5cbnR5cGUgT3V0cHV0S2luZCA9ICdqcycgfCAnZHRzJyB8ICdub2RlJyB8ICdleGUnIHwgJ3dhc20nXG50eXBlIE91dHB1dCA9IHsga2luZDogT3V0cHV0S2luZDsgcGF0aDogc3RyaW5nIH1cblxudHlwZSBCdWlsZE9wdGlvbnMgPSBSYXdCdWlsZE9wdGlvbnMgJiB7IGNhcmdvT3B0aW9ucz86IHN0cmluZ1tdIH1cbnR5cGUgUGFyc2VkQnVpbGRPcHRpb25zID0gT21pdDxCdWlsZE9wdGlvbnMsICdjd2QnPiAmIHsgY3dkOiBzdHJpbmcgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRQcm9qZWN0KHJhd09wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICBkZWJ1ZygnbmFwaSBidWlsZCBjb21tYW5kIHJlY2VpdmUgb3B0aW9uczogJU8nLCByYXdPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyA9IHtcbiAgICBkdHNDYWNoZTogdHJ1ZSxcbiAgICAuLi5yYXdPcHRpb25zLFxuICAgIGN3ZDogcmF3T3B0aW9ucy5jd2QgPz8gcHJvY2Vzcy5jd2QoKSxcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVQYXRoID0gKC4uLnBhdGhzOiBzdHJpbmdbXSkgPT4gcmVzb2x2ZShvcHRpb25zLmN3ZCwgLi4ucGF0aHMpXG5cbiAgY29uc3QgbWFuaWZlc3RQYXRoID0gcmVzb2x2ZVBhdGgob3B0aW9ucy5tYW5pZmVzdFBhdGggPz8gJ0NhcmdvLnRvbWwnKVxuICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHBhcnNlTWV0YWRhdGEobWFuaWZlc3RQYXRoKVxuXG4gIGNvbnN0IGNyYXRlID0gbWV0YWRhdGEucGFja2FnZXMuZmluZCgocCkgPT4ge1xuICAgIC8vIHBhY2thZ2Ugd2l0aCBnaXZlbiBuYW1lXG4gICAgaWYgKG9wdGlvbnMucGFja2FnZSkge1xuICAgICAgcmV0dXJuIHAubmFtZSA9PT0gb3B0aW9ucy5wYWNrYWdlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwLm1hbmlmZXN0X3BhdGggPT09IG1hbmlmZXN0UGF0aFxuICAgIH1cbiAgfSlcblxuICBpZiAoIWNyYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1VuYWJsZSB0byBmaW5kIGNyYXRlIHRvIGJ1aWxkLiBJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byBidWlsZCBhIGNyYXRlIGluIGEgd29ya3NwYWNlLCB0cnkgdXNpbmcgYC0tcGFja2FnZWAgb3B0aW9uIHRvIHNwZWNpZnkgdGhlIHBhY2thZ2UgdG8gYnVpbGQuJyxcbiAgICApXG4gIH1cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgoXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPz8gb3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicsXG4gICAgKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZGVyKG1ldGFkYXRhLCBjcmF0ZSwgY29uZmlnLCBvcHRpb25zKVxuXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxuY2xhc3MgQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXJnczogc3RyaW5nW10gPSBbXVxuICBwcml2YXRlIHJlYWRvbmx5IGVudnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dFtdID0gW11cblxuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldDogVGFyZ2V0XG4gIHByaXZhdGUgcmVhZG9ubHkgY3JhdGVEaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0RGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVUeXBlRGVmOiBib29sZWFuID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhOiBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY3JhdGU6IENyYXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBOYXBpQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0XG4gICAgICA/IHBhcnNlVHJpcGxlKG9wdGlvbnMudGFyZ2V0KVxuICAgICAgOiBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVRcbiAgICAgICAgPyBwYXJzZVRyaXBsZShwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVQpXG4gICAgICAgIDogZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpXG4gICAgdGhpcy5jcmF0ZURpciA9IHBhcnNlKGNyYXRlLm1hbmlmZXN0X3BhdGgpLmRpclxuICAgIHRoaXMub3V0cHV0RGlyID0gcmVzb2x2ZShcbiAgICAgIHRoaXMub3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpciA/PyB0aGlzLmNyYXRlRGlyLFxuICAgIClcbiAgICB0aGlzLnRhcmdldERpciA9XG4gICAgICBvcHRpb25zLnRhcmdldERpciA/P1xuICAgICAgcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUX0RJUiA/P1xuICAgICAgbWV0YWRhdGEudGFyZ2V0X2RpcmVjdG9yeVxuICAgIHRoaXMuZW5hYmxlVHlwZURlZiA9IHRoaXMuY3JhdGUuZGVwZW5kZW5jaWVzLnNvbWUoXG4gICAgICAoZGVwKSA9PlxuICAgICAgICBkZXAubmFtZSA9PT0gJ25hcGktZGVyaXZlJyAmJlxuICAgICAgICAoZGVwLnVzZXNfZGVmYXVsdF9mZWF0dXJlcyB8fCBkZXAuZmVhdHVyZXMuaW5jbHVkZXMoJ3R5cGUtZGVmJykpLFxuICAgIClcblxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICBjb25zdCByZXF1aXJlbWVudFdhcm5pbmcgPVxuICAgICAgICAnYG5hcGktZGVyaXZlYCBjcmF0ZSBpcyBub3QgdXNlZCBvciBgdHlwZS1kZWZgIGZlYXR1cmUgaXMgbm90IGVuYWJsZWQgZm9yIGBuYXBpLWRlcml2ZWAgY3JhdGUnXG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBXaWxsIHNraXAgYmluZGluZyBnZW5lcmF0aW9uIGZvciBcXGAubm9kZVxcYCwgXFxgLndhc2lcXGAgYW5kIFxcYC5kLnRzXFxgIGZpbGVzLmAsXG4gICAgICApXG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0cyB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZHRzSGVhZGVyIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlXG4gICAgICApIHtcbiAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBcXGBkdHNcXGAgcmVsYXRlZCBvcHRpb25zIGFyZSBlbmFibGVkIGJ1dCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjZHlMaWJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnY2R5bGliJykpXG4gICAgICA/Lm5hbWVcbiAgfVxuXG4gIGdldCBiaW5OYW1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMuYmluID8/XG4gICAgICAvLyBvbmx5IGF2YWlsYWJsZSBpZiBub3QgY2R5bGliIG9yIGJpbiBuYW1lIHNwZWNpZmllZFxuICAgICAgKHRoaXMuY2R5TGliTmFtZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnYmluJykpPy5uYW1lKVxuICAgIClcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCB3YXJuaW5nID1cbiAgICAgICAgJ01pc3NpbmcgYGNyYXRlLXR5cGUgPSBbXCJjZHlsaWJcIl1gIGluIFtsaWJdIGNvbmZpZy4gVGhlIGJ1aWxkIHJlc3VsdCB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgbm9kZSBhZGRvbi4nXG5cbiAgICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgICAgZGVidWcud2Fybih3YXJuaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGlja0JpbmFyeSgpXG4gICAgICAuc2V0UGFja2FnZSgpXG4gICAgICAuc2V0RmVhdHVyZXMoKVxuICAgICAgLnNldFRhcmdldCgpXG4gICAgICAucGlja0Nyb3NzVG9vbGNoYWluKClcbiAgICAgIC5zZXRFbnZzKClcbiAgICAgIC5zZXRCeXBhc3NBcmdzKClcbiAgICAgIC5leGVjKClcbiAgfVxuXG4gIHByaXZhdGUgcGlja0Nyb3NzVG9vbGNoYWluKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU5hcGlDcm9zcykge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIHVzZSBib3RoIGAtLWNyb3NzYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLXVzZS1jcm9zc2Agd2lsbCBiZSBpZ25vcmVkLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zcy1jb21waWxlYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLWNyb3NzLWNvbXBpbGVgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZlcnNpb24sIGRvd25sb2FkIH0gPSByZXF1aXJlKCdAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4nKVxuXG4gICAgICBjb25zdCBhbGlhczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWlibS1saW51eC1nbnUnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b29sY2hhaW5QYXRoID0gam9pbihcbiAgICAgICAgaG9tZWRpcigpLFxuICAgICAgICAnLm5hcGktcnMnLFxuICAgICAgICAnY3Jvc3MtdG9vbGNoYWluJyxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgdGhpcy50YXJnZXQudHJpcGxlLFxuICAgICAgKVxuICAgICAgbWtkaXJTeW5jKHRvb2xjaGFpblBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBpZiAoZXhpc3RzU3luYyhqb2luKHRvb2xjaGFpblBhdGgsICdwYWNrYWdlLmpzb24nKSkpIHtcbiAgICAgICAgZGVidWcoYFRvb2xjaGFpbiAke3Rvb2xjaGFpblBhdGh9IGV4aXN0cywgc2tpcCBleHRyYWN0aW5nYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhckFyY2hpdmUgPSBkb3dubG9hZChwcm9jZXNzLmFyY2gsIHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgICAgdGFyQXJjaGl2ZS51bnBhY2sodG9vbGNoYWluUGF0aClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhcmdldCA9IHRhcmdldFRvRW52VmFyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgIGNvbnN0IGNyb3NzVGFyZ2V0TmFtZSA9IGFsaWFzW3RoaXMudGFyZ2V0LnRyaXBsZV0gPz8gdGhpcy50YXJnZXQudHJpcGxlXG4gICAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dXBwZXJDYXNlVGFyZ2V0fV9MSU5LRVJgXG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGpvaW4oXG4gICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICApXG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9TWVNST09UKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1NZU1JPT1RgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICBjcm9zc1RhcmdldE5hbWUsXG4gICAgICAgICAgJ3N5c3Jvb3QnLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9BUikge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9BUmBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgICdiaW4nLFxuICAgICAgICAgIGAke2Nyb3NzVGFyZ2V0TmFtZX0tYXJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SQU5MSUIpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfUkFOTElCYF0gPSBqb2luKFxuICAgICAgICAgIHRvb2xjaGFpblBhdGgsXG4gICAgICAgICAgJ2JpbicsXG4gICAgICAgICAgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yYW5saWJgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9SRUFERUxGKSB7XG4gICAgICAgIHRoaXMuZW52c1tgVEFSR0VUX1JFQURFTEZgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LXJlYWRlbGZgLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LlRBUkdFVF9DX0lOQ0xVREVfUEFUSCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DX0lOQ0xVREVfUEFUSGBdID0gam9pbihcbiAgICAgICAgICB0b29sY2hhaW5QYXRoLFxuICAgICAgICAgIGNyb3NzVGFyZ2V0TmFtZSxcbiAgICAgICAgICAnc3lzcm9vdCcsXG4gICAgICAgICAgJ3VzcicsXG4gICAgICAgICAgJ2luY2x1ZGUvJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFwcm9jZXNzLmVudi5UQVJHRVRfQ0MpIHtcbiAgICAgICAgdGhpcy5lbnZzW2BUQVJHRVRfQ0NgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkge1xuICAgICAgICB0aGlzLmVudnNbYFRBUkdFVF9DWFhgXSA9IGpvaW4oXG4gICAgICAgICAgdG9vbGNoYWluUGF0aCxcbiAgICAgICAgICAnYmluJyxcbiAgICAgICAgICBgJHtjcm9zc1RhcmdldE5hbWV9LWcrK2AsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NDPy5zdGFydHNXaXRoKCdjbGFuZycpIHx8XG4gICAgICAgIChwcm9jZXNzLmVudi5DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NDKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IFRBUkdFVF9DRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ0ZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ0ZMQUdTID0gYC0tc3lzcm9vdD0ke3RoaXMuZW52cy5UQVJHRVRfU1lTUk9PVH0gLS1nY2MtdG9vbGNoYWluPSR7dG9vbGNoYWluUGF0aH0gJHtUQVJHRVRfQ0ZMQUdTfWBcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgKHByb2Nlc3MuZW52LkNYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpICYmICFwcm9jZXNzLmVudi5UQVJHRVRfQ1hYKSB8fFxuICAgICAgICBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYPy5zdGFydHNXaXRoKCdjbGFuZysrJylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ1hYRkxBR1MgPSBwcm9jZXNzLmVudi5UQVJHRVRfQ1hYRkxBR1MgPz8gJydcbiAgICAgICAgdGhpcy5lbnZzLlRBUkdFVF9DWFhGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NYWEZMQUdTfWBcbiAgICAgIH1cbiAgICAgIHRoaXMuZW52cy5QQVRIID0gdGhpcy5lbnZzLlBBVEhcbiAgICAgICAgPyBgJHt0b29sY2hhaW5QYXRofS9iaW46JHt0aGlzLmVudnMuUEFUSH06JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICAgICAgOiBgJHt0b29sY2hhaW5QYXRofS9iaW46JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy53YXJuKCdQaWNrIGNyb3NzIHRvb2xjaGFpbiBmYWlsZWQnLCBlIGFzIEVycm9yKVxuICAgICAgLy8gaWdub3JlLCBkbyBub3RoaW5nXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGV4ZWMoKSB7XG4gICAgZGVidWcoYFN0YXJ0IGJ1aWxkaW5nIGNyYXRlOiAke3RoaXMuY3JhdGUubmFtZX1gKVxuICAgIGRlYnVnKCcgICVpJywgYGNhcmdvICR7dGhpcy5hcmdzLmpvaW4oJyAnKX1gKVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgY29uc3Qgd2F0Y2ggPSB0aGlzLm9wdGlvbnMud2F0Y2hcbiAgICBjb25zdCBidWlsZFRhc2sgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUNyb3NzICYmIHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdgLS11c2UtY3Jvc3NgIGFuZCBgLS1jcm9zcy1jb21waWxlYCBjYW4gbm90IGJlIHVzZWQgdG9nZXRoZXInLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBjb25zdCBjb21tYW5kID1cbiAgICAgICAgcHJvY2Vzcy5lbnYuQ0FSR08gPz8gKHRoaXMub3B0aW9ucy51c2VDcm9zcyA/ICdjcm9zcycgOiAnY2FyZ28nKVxuICAgICAgY29uc3QgYnVpbGRQcm9jZXNzID0gc3Bhd24oY29tbWFuZCwgdGhpcy5hcmdzLCB7XG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgLi4udGhpcy5lbnZzIH0sXG4gICAgICAgIHN0ZGlvOiB3YXRjaCA/IFsnaW5oZXJpdCcsICdpbmhlcml0JywgJ3BpcGUnXSA6ICdpbmhlcml0JyxcbiAgICAgICAgY3dkOiB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnKCclaScsIGBCdWlsZCBjcmF0ZSAke3RoaXMuY3JhdGUubmFtZX0gc3VjY2Vzc2Z1bGx5IWApXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXhpdCBjb2RlICR7Y29kZX1gKSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgYnVpbGRQcm9jZXNzLm9uY2UoJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQnVpbGQgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZS5tZXNzYWdlfWAsIHsgY2F1c2U6IGUgfSkpXG4gICAgICB9KVxuXG4gICAgICAvLyB3YXRjaCBtb2RlIG9ubHksIHRoZXkgYXJlIHBpcGVkIHRocm91Z2ggc3RkZXJyXG4gICAgICBidWlsZFByb2Nlc3Muc3RkZXJyPy5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICBjb25zb2xlLmVycm9yKG91dHB1dClcbiAgICAgICAgaWYgKC9GaW5pc2hlZFxccyhgZGV2YHxgcmVsZWFzZWApLy50ZXN0KG91dHB1dCkpIHtcbiAgICAgICAgICB0aGlzLnBvc3RCdWlsZCgpLmNhdGNoKCgpID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFzazogYnVpbGRUYXNrLnRoZW4oKCkgPT4gdGhpcy5wb3N0QnVpbGQoKSksXG4gICAgICBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGlja0JpbmFyeSgpIHtcbiAgICBsZXQgc2V0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLndhdGNoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuQ0kpIHtcbiAgICAgICAgZGVidWcud2FybignV2F0Y2ggbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIENJIGVudmlyb25tZW50JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28td2F0Y2gnKVxuICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXdhdGNoJywgJ3dhdGNoJylcbiAgICAgICAgLy8geWFybiBuYXBpIHdhdGNoIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudSBbLS1jcm9zcy1jb21waWxlXVxuICAgICAgICAvLyA9PT0+XG4gICAgICAgIC8vIGNhcmdvIHdhdGNoIFsuLi5dIC0tIGJ1aWxkIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudVxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSB6aWdidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgdGhpcy5hcmdzLnB1c2goXG4gICAgICAgICAgJ3dhdGNoJyxcbiAgICAgICAgICAnLS13aHknLFxuICAgICAgICAgICctaScsXG4gICAgICAgICAgJyoue2pzLHRzLG5vZGV9JyxcbiAgICAgICAgICAnLXcnLFxuICAgICAgICAgIHRoaXMuY3JhdGVEaXIsXG4gICAgICAgICAgJy0tJyxcbiAgICAgICAgICAnY2FyZ28nLFxuICAgICAgICAgICdidWlsZCcsXG4gICAgICAgIClcbiAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm0gb24gd2luMzIgcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXh3aW4gdG8gY3Jvc3MgY29tcGlsZSB0byB3aW4zMiBwbGF0Zm9ybVxuICAgICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28teHdpbicpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby14d2luJywgJ3h3aW4nKVxuICAgICAgICAgIHRoaXMuYXJncy5wdXNoKCd4d2luJywgJ2J1aWxkJylcbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAgICAgICB0aGlzLmVudnMuWFdJTl9BUkNIID0gJ3g4NidcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdsaW51eCcgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gcHJvY2Vzcy5hcmNoICYmXG4gICAgICAgICAgKGZ1bmN0aW9uIChhYmk6IHN0cmluZyB8IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsaWJjVmVyc2lvblJ1bnRpbWUgPVxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQoKT8uaGVhZGVyPy5nbGliY1ZlcnNpb25SdW50aW1lXG4gICAgICAgICAgICBjb25zdCBsaWJjID0gZ2xpYmNWZXJzaW9uUnVudGltZSA/ICdnbnUnIDogJ211c2wnXG4gICAgICAgICAgICByZXR1cm4gYWJpID09PSBsaWJjXG4gICAgICAgICAgfSkodGhpcy50YXJnZXQuYWJpKVxuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gbGludXggdGFyZ2V0IG9uIGxpbnV4IHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJyAmJlxuICAgICAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gY3Jvc3MgY29tcGlsZSB0byBkYXJ3aW4gdGFyZ2V0IG9uIGRhcndpbiBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgY2FyZ28temlnYnVpbGQgdG8gY3Jvc3MgY29tcGlsZSB0byBvdGhlciBwbGF0Zm9ybXNcbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXppZ2J1aWxkJylcbiAgICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXppZ2J1aWxkJywgJ3ppZ2J1aWxkJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgnemlnYnVpbGQnKVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2V0KSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnYnVpbGQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQYWNrYWdlKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYWNrYWdlKSB7XG4gICAgICBhcmdzLnB1c2goJy0tcGFja2FnZScsIHRoaXMub3B0aW9ucy5wYWNrYWdlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1iaW4nLCB0aGlzLmJpbk5hbWUpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnU2V0IHBhY2thZ2UgZmxhZ3M6ICcpXG4gICAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldFRhcmdldCgpIHtcbiAgICBkZWJ1ZygnU2V0IGNvbXBpbGluZyB0YXJnZXQgdG86ICcpXG4gICAgZGVidWcoJyAgJWknLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQnLCB0aGlzLnRhcmdldC50cmlwbGUpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZzKCkge1xuICAgIC8vIFRZUEUgREVGXG4gICAgaWYgKHRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUiA9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbnRlcm1lZGlhdGVUeXBlRGVmRm9sZGVyKClcbiAgICAgIHRoaXMuc2V0Rm9yY2VCdWlsZEVudnModGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUilcbiAgICB9XG5cbiAgICAvLyBSVVNURkxBR1NcbiAgICBsZXQgcnVzdGZsYWdzID1cbiAgICAgIHByb2Nlc3MuZW52LlJVU1RGTEFHUyA/PyBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9SVVNURkxBR1MgPz8gJydcblxuICAgIGlmIChcbiAgICAgIHRoaXMudGFyZ2V0LmFiaT8uaW5jbHVkZXMoJ211c2wnKSAmJlxuICAgICAgIXJ1c3RmbGFncy5pbmNsdWRlcygndGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnKVxuICAgICkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgdGFyZ2V0LWZlYXR1cmU9LWNydC1zdGF0aWMnXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpcCAmJiAhcnVzdGZsYWdzLmluY2x1ZGVzKCdsaW5rLWFyZz0tcycpKSB7XG4gICAgICBydXN0ZmxhZ3MgKz0gJyAtQyBsaW5rLWFyZz0tcydcbiAgICB9XG5cbiAgICBpZiAocnVzdGZsYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbnZzLlJVU1RGTEFHUyA9IHJ1c3RmbGFnc1xuICAgIH1cbiAgICAvLyBFTkQgUlVTVEZMQUdTXG5cbiAgICAvLyBMSU5LRVJcbiAgICBjb25zdCBsaW5rZXIgPSB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlXG4gICAgICA/IHZvaWQgMFxuICAgICAgOiBnZXRUYXJnZXRMaW5rZXIodGhpcy50YXJnZXQudHJpcGxlKVxuICAgIC8vIFRPRE86XG4gICAgLy8gICBkaXJlY3RseSBzZXQgQ0FSR09fVEFSR0VUXzx0YXJnZXQ+X0xJTktFUiB3aWxsIGNvdmVyIC5jYXJnby9jb25maWcudG9tbFxuICAgIC8vICAgd2lsbCBkZXRlY3QgYnkgY2FyZ28gY29uZmlnIHdoZW4gaXQgYmVjb21lcyBzdGFibGVcbiAgICAvLyAgIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3J1c3QtbGFuZy9jYXJnby9pc3N1ZXMvOTMwMVxuICAgIGNvbnN0IGxpbmtlckVudiA9IGBDQVJHT19UQVJHRVRfJHt0YXJnZXRUb0VudlZhcihcbiAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICApfV9MSU5LRVJgXG4gICAgaWYgKGxpbmtlciAmJiAhcHJvY2Vzcy5lbnZbbGlua2VyRW52XSAmJiAhdGhpcy5lbnZzW2xpbmtlckVudl0pIHtcbiAgICAgIHRoaXMuZW52c1tsaW5rZXJFbnZdID0gbGlua2VyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHRoaXMuc2V0QW5kcm9pZEVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScpIHtcbiAgICAgIHRoaXMuc2V0V2FzaUVudigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnb3Blbmhhcm1vbnknKSB7XG4gICAgICB0aGlzLnNldE9wZW5IYXJtb255RW52KClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGVudnM6ICcpXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnZzKS5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgIGRlYnVnKCcgICVpJywgYCR7a309JHt2fWApXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEZvcmNlQnVpbGRFbnZzKHR5cGVEZWZUbXBGb2xkZXI6IHN0cmluZykge1xuICAgIC8vIGR5bmFtaWNhbGx5IGNoZWNrIGFsbCBuYXBpLXJzIGRlcHMgYW5kIHNldCBgTkFQSV9GT1JDRV9CVUlMRF97dXBwZXJjYXNlKHNuYWtlX2Nhc2UobmFtZSkpfSA9IHRpbWVzdGFtcGBcbiAgICB0aGlzLm1ldGFkYXRhLnBhY2thZ2VzLmZvckVhY2goKGNyYXRlKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGNyYXRlLmRlcGVuZGVuY2llcy5zb21lKChkKSA9PiBkLm5hbWUgPT09ICduYXBpLWRlcml2ZScpICYmXG4gICAgICAgICFleGlzdHNTeW5jKGpvaW4odHlwZURlZlRtcEZvbGRlciwgY3JhdGUubmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5lbnZzW1xuICAgICAgICAgIGBOQVBJX0ZPUkNFX0JVSUxEXyR7Y3JhdGUubmFtZS5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKX1gXG4gICAgICAgIF0gPSBEYXRlLm5vdygpLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRBbmRyb2lkRW52KCkge1xuICAgIGNvbnN0IHsgQU5EUk9JRF9OREtfTEFURVNUX0hPTUUgfSA9IHByb2Nlc3MuZW52XG4gICAgaWYgKCFBTkRST0lEX05ES19MQVRFU1RfSE9NRSkge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZChcbiAgICAgICAgICAnQU5EUk9JRF9OREtfTEFURVNUX0hPTUUnLFxuICAgICAgICApfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBza2lwIGNyb3NzIGNvbXBpbGUgc2V0dXAgaWYgaG9zdCBpcyBhbmRyb2lkXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0QXJjaCA9IHRoaXMudGFyZ2V0LmFyY2ggPT09ICdhcm0nID8gJ2FybXY3YScgOiAnYWFyY2g2NCdcbiAgICBjb25zdCB0YXJnZXRQbGF0Zm9ybSA9XG4gICAgICB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhbmRyb2lkZWFiaTI0JyA6ICdhbmRyb2lkMjQnXG4gICAgY29uc3QgaG9zdFBsYXRmb3JtID1cbiAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgID8gJ2RhcndpbidcbiAgICAgICAgOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgPyAnd2luZG93cydcbiAgICAgICAgICA6ICdsaW51eCdcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuZW52cywge1xuICAgICAgQ0FSR09fVEFSR0VUX0FBUkNINjRfTElOVVhfQU5EUk9JRF9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkMjQtY2xhbmdgLFxuICAgICAgQ0FSR09fVEFSR0VUX0FSTVY3X0xJTlVYX0FORFJPSURFQUJJX0xJTktFUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LWFuZHJvaWRlYWJpMjQtY2xhbmdgLFxuICAgICAgVEFSR0VUX0NDOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtJHt0YXJnZXRQbGF0Zm9ybX0tY2xhbmdgLFxuICAgICAgVEFSR0VUX0NYWDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nKytgLFxuICAgICAgVEFSR0VUX0FSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluL2xsdm0tYXJgLFxuICAgICAgVEFSR0VUX1JBTkxJQjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLXJhbmxpYmAsXG4gICAgICBBTkRST0lEX05ESzogQU5EUk9JRF9OREtfTEFURVNUX0hPTUUsXG4gICAgICBQQVRIOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluJHtwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJzsnIDogJzonfSR7cHJvY2Vzcy5lbnYuUEFUSH1gLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIHNldFdhc2lFbnYoKSB7XG4gICAgY29uc3QgZW1uYXBpID0gam9pbihcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnZW1uYXBpJyksXG4gICAgICAnLi4nLFxuICAgICAgJ2xpYicsXG4gICAgICAnd2FzbTMyLXdhc2ktdGhyZWFkcycsXG4gICAgKVxuICAgIHRoaXMuZW52cy5FTU5BUElfTElOS19ESVIgPSBlbW5hcGlcbiAgICB0aGlzLmVudnMuU0VUSk1QX0xJTktfRElSID0gc2V0am1wTGliXG4gICAgY29uc3QgeyBXQVNJX1NES19QQVRIIH0gPSBwcm9jZXNzLmVudlxuXG4gICAgaWYgKFdBU0lfU0RLX1BBVEggJiYgZXhpc3RzU3luYyhXQVNJX1NES19QQVRIKSkge1xuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSV9QUkVWSUVXMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDFfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDJfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DQycsIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdjbGFuZycpKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DWFgnLFxuICAgICAgICBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnY2xhbmcrKycpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2FyJykpXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1JBTkxJQicsXG4gICAgICAgIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdyYW5saWInKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ0ZMQUdTJyxcbiAgICAgICAgYC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHMgLS1zeXNyb290PSR7V0FTSV9TREtfUEFUSH0vc2hhcmUvd2FzaS1zeXNyb290IC1wdGhyZWFkIC1tbGx2bSAtd2FzbS1lbmFibGUtc2psaiAtSSR7c2V0am1wSW5jbHVkZX1gLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DWFhGTEFHUycsXG4gICAgICAgIGAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzIC0tc3lzcm9vdD0ke1dBU0lfU0RLX1BBVEh9L3NoYXJlL3dhc2ktc3lzcm9vdCAtcHRocmVhZCAtbWxsdm0gLXdhc20tZW5hYmxlLXNqbGogLUkke3NldGptcEluY2x1ZGV9YCxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgIGBUQVJHRVRfTERGTEFHU2AsXG4gICAgICAgIGAtZnVzZS1sZD0ke1dBU0lfU0RLX1BBVEh9L2Jpbi93YXNtLWxkIC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHNgLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0T3Blbkhhcm1vbnlFbnYoKSB7XG4gICAgY29uc3QgeyBPSE9TX1NES19QQVRILCBPSE9TX1NES19OQVRJVkUgfSA9IHByb2Nlc3MuZW52XG4gICAgY29uc3QgbmRrUGF0aCA9IE9IT1NfU0RLX1BBVEhcbiAgICAgID8gYCR7T0hPU19TREtfTkFUSVZFfS9uYXRpdmVgXG4gICAgICA6IE9IT1NfU0RLX05BVElWRVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoIW5ka1BhdGggJiYgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZCgnT0hPU19TREtfUEFUSCcpfSBvciAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX05BVElWRScpfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBsaW5rZXJOYW1lID0gYENBUkdPX1RBUkdFVF8ke3RoaXMudGFyZ2V0LnRyaXBsZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKX1fTElOS0VSYFxuICAgIGNvbnN0IHJhblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLXJhbmxpYmBcbiAgICBjb25zdCBhclBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLWFyYFxuICAgIGNvbnN0IGNjUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZ2BcbiAgICBjb25zdCBjeHhQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vJHt0aGlzLnRhcmdldC50cmlwbGV9LWNsYW5nKytgXG4gICAgY29uc3QgYXNQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hc2BcbiAgICBjb25zdCBsZFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sZC5sbGRgXG4gICAgY29uc3Qgc3RyaXBQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1zdHJpcGBcbiAgICBjb25zdCBvYmpEdW1wUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqZHVtcGBcbiAgICBjb25zdCBvYmpDb3B5UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqY29weWBcbiAgICBjb25zdCBubVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW5tYFxuICAgIGNvbnN0IGJpblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2JpbmBcbiAgICBjb25zdCBsaWJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9saWJgXG5cbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdMSUJDTEFOR19QQVRIJywgbGliUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdERVBfQVRPTUlDJywgJ2NsYW5nX3J0LmJ1aWx0aW5zJylcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKGxpbmtlck5hbWUsIGNjUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NYWCcsIGN4eFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgYXJQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9SQU5MSUInLCByYW5QYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUycsIGFzUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTEQnLCBsZFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX1NUUklQJywgc3RyaXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpEVU1QJywgb2JqRHVtcFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX09CSkNPUFknLCBvYmpDb3B5UGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTk0nLCBubVBhdGgpXG4gICAgdGhpcy5lbnZzLlBBVEggPSBgJHtiaW5QYXRofSR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YFxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBhcmdzID0gW11cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzICYmIHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHNwZWNpZnkgLS1hbGwtZmVhdHVyZXMgYW5kIC0tbm8tZGVmYXVsdC1mZWF0dXJlcyB0b2dldGhlcicsXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsRmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1hbGwtZmVhdHVyZXMnKVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm5vRGVmYXVsdEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1mZWF0dXJlcycsIC4uLnRoaXMub3B0aW9ucy5mZWF0dXJlcylcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGZlYXR1cmVzIGZsYWdzOiAnKVxuICAgIGRlYnVnKCcgICVPJywgYXJncylcbiAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnlwYXNzQXJncygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbGVhc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXJlbGVhc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tdmVyYm9zZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXREaXIpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXRhcmdldC1kaXInLCB0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tcHJvZmlsZScsIHRoaXMub3B0aW9ucy5wcm9maWxlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWFuaWZlc3RQYXRoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1tYW5pZmVzdC1wYXRoJywgdGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi50aGlzLm9wdGlvbnMuY2FyZ29PcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpIHtcbiAgICBsZXQgZm9sZGVyID0gam9pbihcbiAgICAgIHRoaXMudGFyZ2V0RGlyLFxuICAgICAgJ25hcGktcnMnLFxuICAgICAgYCR7dGhpcy5jcmF0ZS5uYW1lfS0ke2NyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUodGhpcy5jcmF0ZS5tYW5pZmVzdF9wYXRoKVxuICAgICAgICAudXBkYXRlKENMSV9WRVJTSU9OKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKVxuICAgICAgICAuc3Vic3RyaW5nKDAsIDgpfWAsXG4gICAgKVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZHRzQ2FjaGUpIHtcbiAgICAgIHJtU3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KVxuICAgICAgZm9sZGVyICs9IGBfJHtEYXRlLm5vdygpfWBcbiAgICB9XG5cbiAgICBta2RpckFzeW5jKGZvbGRlciwgeyByZWN1cnNpdmU6IHRydWUgfSlcblxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9zdEJ1aWxkKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5OmApXG4gICAgICBkZWJ1ZygnICAlaScsIHRoaXMub3V0cHV0RGlyKVxuICAgICAgYXdhaXQgbWtkaXJBc3luYyh0aGlzLm91dHB1dERpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIGRlYnVnKGBPdXRwdXQgZGlyZWN0b3J5IGNyZWF0ZWRgKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7dGhpcy5vdXRwdXREaXJ9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzbUJpbmFyeU5hbWUgPSBhd2FpdCB0aGlzLmNvcHlBcnRpZmFjdCgpXG5cbiAgICAvLyBvbmx5IGZvciBjZHlsaWJcbiAgICBpZiAodGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCBpZGVudHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZURlZigpXG4gICAgICBjb25zdCBqc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVKc0JpbmRpbmcoaWRlbnRzKVxuICAgICAgY29uc3Qgd2FzbUJpbmRpbmdzT3V0cHV0ID0gYXdhaXQgdGhpcy53cml0ZVdhc2lCaW5kaW5nKFxuICAgICAgICB3YXNtQmluYXJ5TmFtZSxcbiAgICAgICAgaWRlbnRzLFxuICAgICAgKVxuICAgICAgaWYgKGpzT3V0cHV0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGpzT3V0cHV0KVxuICAgICAgfVxuICAgICAgaWYgKHdhc21CaW5kaW5nc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaCguLi53YXNtQmluZGluZ3NPdXRwdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3B5QXJ0aWZhY3QoKSB7XG4gICAgY29uc3QgW3NyY05hbWUsIGRlc3ROYW1lLCB3YXNtQmluYXJ5TmFtZV0gPSB0aGlzLmdldEFydGlmYWN0TmFtZXMoKVxuICAgIGlmICghc3JjTmFtZSB8fCAhZGVzdE5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByb2ZpbGUgPVxuICAgICAgdGhpcy5vcHRpb25zLnByb2ZpbGUgPz8gKHRoaXMub3B0aW9ucy5yZWxlYXNlID8gJ3JlbGVhc2UnIDogJ2RlYnVnJylcbiAgICBjb25zdCBzcmMgPSBqb2luKHRoaXMudGFyZ2V0RGlyLCB0aGlzLnRhcmdldC50cmlwbGUsIHByb2ZpbGUsIHNyY05hbWUpXG4gICAgZGVidWcoYENvcHkgYXJ0aWZhY3QgZnJvbTogWyR7c3JjfV1gKVxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBkZXN0TmFtZSlcbiAgICBjb25zdCBpc1dhc20gPSBkZXN0LmVuZHNXaXRoKCcud2FzbScpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoZGVzdCkpIHtcbiAgICAgICAgZGVidWcoJ09sZCBhcnRpZmFjdCBmb3VuZCwgcmVtb3ZlIGl0IGZpcnN0JylcbiAgICAgICAgYXdhaXQgdW5saW5rQXN5bmMoZGVzdClcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdDb3B5IGFydGlmYWN0IHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBpZiAoaXNXYXNtKSB7XG4gICAgICAgIGNvbnN0IHsgTW9kdWxlQ29uZmlnIH0gPSBhd2FpdCBpbXBvcnQoJ0BuYXBpLXJzL3dhc20tdG9vbHMnKVxuICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbU1vZHVsZSA9IG5ldyBNb2R1bGVDb25maWcoKVxuICAgICAgICAgICAgLmdlbmVyYXRlRHdhcmYodHJ1ZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAucHJlc2VydmVDb2RlVHJhbnNmb3JtKHRydWUpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoYXdhaXQgcmVhZEZpbGVBc3luYyhzcmMpKVxuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbUJpbmFyeSA9IGRlYnVnV2FzbU1vZHVsZS5lbWl0V2FzbSh0cnVlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZGVzdC5yZXBsYWNlKC9cXC53YXNtJC8sICcuZGVidWcud2FzbScpLFxuICAgICAgICAgICAgZGVidWdXYXNtQmluYXJ5LFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgcmVsZWFzZSB3YXNtIG1vZHVsZScpXG4gICAgICAgICAgY29uc3QgcmVsZWFzZVdhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlTmFtZVNlY3Rpb24oZmFsc2UpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybShmYWxzZSlcbiAgICAgICAgICAgIC5zdHJpY3RWYWxpZGF0ZShmYWxzZSlcbiAgICAgICAgICAgIC5vbmx5U3RhYmxlRmVhdHVyZXMoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoZGVidWdXYXNtQmluYXJ5KVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtQmluYXJ5ID0gcmVsZWFzZVdhc21Nb2R1bGUuZW1pdFdhc20oZmFsc2UpXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgcmVsZWFzZVdhc21CaW5hcnkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSBkZWJ1ZyB3YXNtIG1vZHVsZTogJHsoZSBhcyBhbnkpLm1lc3NhZ2UgPz8gZX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCBjb3B5RmlsZUFzeW5jKHNyYywgZGVzdClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgIGtpbmQ6IGRlc3QuZW5kc1dpdGgoJy5ub2RlJykgPyAnbm9kZScgOiBpc1dhc20gPyAnd2FzbScgOiAnZXhlJyxcbiAgICAgICAgcGF0aDogZGVzdCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gd2FzbUJpbmFyeU5hbWUgPyBqb2luKHRoaXMub3V0cHV0RGlyLCB3YXNtQmluYXJ5TmFtZSkgOiBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29weSBhcnRpZmFjdCcsIHsgY2F1c2U6IGUgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFydGlmYWN0TmFtZXMoKSB7XG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgY2R5TGliID0gdGhpcy5jZHlMaWJOYW1lLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgY29uc3Qgd2FzaVRhcmdldCA9IHRoaXMuY29uZmlnLnRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuXG4gICAgICBjb25zdCBzcmNOYW1lID1cbiAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICAgPyBgbGliJHtjZHlMaWJ9LmR5bGliYFxuICAgICAgICAgIDogdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgICAgID8gYCR7Y2R5TGlifS5kbGxgXG4gICAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJ1xuICAgICAgICAgICAgICA/IGAke2NkeUxpYn0ud2FzbWBcbiAgICAgICAgICAgICAgOiBgbGliJHtjZHlMaWJ9LnNvYFxuXG4gICAgICBsZXQgZGVzdE5hbWUgPSB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lXG4gICAgICAvLyBhZGQgcGxhdGZvcm0gc3VmZml4IHRvIGJpbmFyeSBuYW1lXG4gICAgICAvLyBpbmRleFsubGludXgteDY0LWdudV0ubm9kZVxuICAgICAgLy8gICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhdGZvcm0pIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gYC4ke3RoaXMudGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXG4gICAgICB9XG4gICAgICBpZiAoc3JjTmFtZS5lbmRzV2l0aCgnLndhc20nKSkge1xuICAgICAgICBkZXN0TmFtZSArPSAnLndhc20nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0TmFtZSArPSAnLm5vZGUnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNyY05hbWUsXG4gICAgICAgIGRlc3ROYW1lLFxuICAgICAgICB3YXNpVGFyZ2V0XG4gICAgICAgICAgPyBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS4ke3dhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJfS53YXNtYFxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIF1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmluTmFtZSkge1xuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInID8gYCR7dGhpcy5iaW5OYW1lfS5leGVgIDogdGhpcy5iaW5OYW1lXG5cbiAgICAgIHJldHVybiBbc3JjTmFtZSwgc3JjTmFtZV1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlRGVmKCkge1xuICAgIGNvbnN0IHR5cGVEZWZEaXIgPSB0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSXG4gICAgaWYgKCF0aGlzLmVuYWJsZVR5cGVEZWYgfHwgIShhd2FpdCBkaXJFeGlzdHNBc3luYyh0eXBlRGVmRGlyKSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCB0aGlzLm9wdGlvbnMuZHRzID8/ICdpbmRleC5kLnRzJylcblxuICAgIGxldCBoZWFkZXIgPSAnJ1xuICAgIGxldCBkdHMgPSAnJ1xuICAgIGxldCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5ub0R0c0hlYWRlcikge1xuICAgICAgY29uc3QgZHRzSGVhZGVyID0gdGhpcy5vcHRpb25zLmR0c0hlYWRlciA/PyB0aGlzLmNvbmZpZy5kdHNIZWFkZXJcbiAgICAgIC8vIGBkdHNIZWFkZXJGaWxlYCBpbiBjb25maWcgPiBgZHRzSGVhZGVyYCBpbiBjbGkgZmxhZyA+IGBkdHNIZWFkZXJgIGluIGNvbmZpZ1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmR0c0hlYWRlckZpbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoZWFkZXIgPSBhd2FpdCByZWFkRmlsZUFzeW5jKFxuICAgICAgICAgICAgam9pbih0aGlzLm9wdGlvbnMuY3dkLCB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlKSxcbiAgICAgICAgICAgICd1dGYtOCcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCBkdHMgaGVhZGVyIGZpbGUgJHt0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlfWAsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkdHNIZWFkZXIpIHtcbiAgICAgICAgaGVhZGVyID0gZHRzSGVhZGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXIgPSBERUZBVUxUX1RZUEVfREVGX0hFQURFUlxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHR5cGVEZWZEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdObyB0eXBlIGRlZiBmaWxlcyBmb3VuZC4gU2tpcCBnZW5lcmF0aW5nIGR0cyBmaWxlLicpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGlmICghZmlsZS5pc0ZpbGUoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGR0czogZmlsZUR0cywgZXhwb3J0czogZmlsZUV4cG9ydHMgfSA9IGF3YWl0IHByb2Nlc3NUeXBlRGVmKFxuICAgICAgICBqb2luKHR5cGVEZWZEaXIsIGZpbGUubmFtZSksXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25zdEVudW0gPz8gdGhpcy5jb25maWcuY29uc3RFbnVtID8/IHRydWUsXG4gICAgICApXG5cbiAgICAgIGR0cyArPSBmaWxlRHRzXG4gICAgICBleHBvcnRzLnB1c2goLi4uZmlsZUV4cG9ydHMpXG4gICAgfVxuXG4gICAgaWYgKGR0cy5pbmRleE9mKCdFeHRlcm5hbE9iamVjdDwnKSA+IC0xKSB7XG4gICAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRXh0ZXJuYWxPYmplY3Q8VD4ge1xuICByZWFkb25seSAnJzoge1xuICAgIHJlYWRvbmx5ICcnOiB1bmlxdWUgc3ltYm9sXG4gICAgW0s6IHN5bWJvbF06IFRcbiAgfVxufVxuYFxuICAgIH1cblxuICAgIGlmIChkdHMuaW5kZXhPZignVHlwZWRBcnJheScpID4gLTEpIHtcbiAgICAgIGhlYWRlciArPSBgXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5IHwgQmlnSW50NjRBcnJheSB8IEJpZ1VpbnQ2NEFycmF5XG5gXG4gICAgfVxuXG4gICAgZHRzID0gaGVhZGVyICsgZHRzXG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoJ1dyaXRpbmcgdHlwZSBkZWYgdG86JylcbiAgICAgIGRlYnVnKCcgICVpJywgZGVzdClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIGR0cywgJ3V0Zi04JylcbiAgICAgIHRoaXMub3V0cHV0cy5wdXNoKHsga2luZDogJ2R0cycsIHBhdGg6IGRlc3QgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy5lcnJvcignRmFpbGVkIHRvIHdyaXRlIHR5cGUgZGVmIGZpbGUnKVxuICAgICAgZGVidWcuZXJyb3IoZSBhcyBFcnJvcilcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZUpzQmluZGluZyhpZGVudHM6IHN0cmluZ1tdKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMub3B0aW9ucy5wbGF0Zm9ybSB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICB0aGlzLm9wdGlvbnMubm9Kc0JpbmRpbmcgfHxcbiAgICAgIGlkZW50cy5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLm9wdGlvbnMuanNCaW5kaW5nID8/ICdpbmRleC5qcydcblxuICAgIGNvbnN0IGNyZWF0ZUJpbmRpbmcgPSB0aGlzLm9wdGlvbnMuZXNtID8gY3JlYXRlRXNtQmluZGluZyA6IGNyZWF0ZUNqc0JpbmRpbmdcbiAgICBjb25zdCBiaW5kaW5nID0gY3JlYXRlQmluZGluZyhcbiAgICAgIHRoaXMuY29uZmlnLmJpbmFyeU5hbWUsXG4gICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgIGlkZW50cyxcbiAgICApXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVzdCA9IGpvaW4odGhpcy5vdXRwdXREaXIsIG5hbWUpXG4gICAgICBkZWJ1ZygnV3JpdGluZyBqcyBiaW5kaW5nIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBiaW5kaW5nLCAndXRmLTgnKVxuICAgICAgcmV0dXJuIHsga2luZDogJ2pzJywgcGF0aDogZGVzdCB9IHNhdGlzZmllcyBPdXRwdXRcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSBqcyBiaW5kaW5nIGZpbGUnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3cml0ZVdhc2lCaW5kaW5nKFxuICAgIGRpc3RGaWxlTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBpZGVudHM6IHN0cmluZ1tdLFxuICApIHtcbiAgICBpZiAoZGlzdEZpbGVOYW1lKSB7XG4gICAgICBjb25zdCB7IG5hbWUsIGRpciB9ID0gcGFyc2UoZGlzdEZpbGVOYW1lKVxuICAgICAgY29uc3QgYmluZGluZ1BhdGggPSBqb2luKGRpciwgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgY29uc3QgYnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgICAgZGlyLFxuICAgICAgICBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgKVxuICAgICAgY29uc3Qgd29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXIubWpzJylcbiAgICAgIGNvbnN0IGJyb3dzZXJXb3JrZXJQYXRoID0gam9pbihkaXIsICd3YXNpLXdvcmtlci1icm93c2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyRW50cnlQYXRoID0gam9pbihkaXIsICdicm93c2VyLmpzJylcbiAgICAgIGNvbnN0IGV4cG9ydHNDb2RlID1cbiAgICAgICAgYG1vZHVsZS5leHBvcnRzID0gX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgaWRlbnRzXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgIClcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBiaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJpbmRpbmcoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5pbml0aWFsTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/Lm1heGltdW1NZW1vcnksXG4gICAgICAgICkgK1xuICAgICAgICAgIGV4cG9ydHNDb2RlICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmFzeW5jSW5pdCxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5idWZmZXIsXG4gICAgICAgICkgK1xuICAgICAgICAgIGBleHBvcnQgZGVmYXVsdCBfX25hcGlNb2R1bGUuZXhwb3J0c1xcbmAgK1xuICAgICAgICAgIGlkZW50c1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgKGlkZW50KSA9PlxuICAgICAgICAgICAgICAgIGBleHBvcnQgY29uc3QgJHtpZGVudH0gPSBfX25hcGlNb2R1bGUuZXhwb3J0cy4ke2lkZW50fWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICdcXG4nLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyh3b3JrZXJQYXRoLCBXQVNJX1dPUktFUl9URU1QTEFURSwgJ3V0ZjgnKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJQYXRoLFxuICAgICAgICBjcmVhdGVXYXNpQnJvd3NlcldvcmtlckJpbmRpbmcodGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uZnMgPz8gZmFsc2UpLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYnJvd3NlckVudHJ5UGF0aCxcbiAgICAgICAgYGV4cG9ydCAqIGZyb20gJyR7dGhpcy5jb25maWcucGFja2FnZU5hbWV9LXdhc20zMi13YXNpJ1xcbmAsXG4gICAgICApXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckJpbmRpbmdQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogd29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJXb3JrZXJQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlckVudHJ5UGF0aCB9LFxuICAgICAgXSBzYXRpc2ZpZXMgT3V0cHV0W11cbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIHNldEVudklmTm90RXhpc3RzKGVudjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudltlbnZdKSB7XG4gICAgICB0aGlzLmVudnNbZW52XSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUJ1aWxkQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydidWlsZCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0Pzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS10YXJnZXQsLXQnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQnVpbGQgZm9yIHRoZSB0YXJnZXQgdHJpcGxlLCBieXBhc3NlZCB0byBgY2FyZ28gYnVpbGQgLS10YXJnZXRgJyxcbiAgfSlcblxuICBjd2Q/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYENhcmdvLnRvbWxgJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICB0YXJnZXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXRhcmdldC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgJyxcbiAgfSlcblxuICBvdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB3aGVyZSBhbGwgdGhlIGJ1aWx0IGZpbGVzIHdvdWxkIGJlIHB1dC4gRGVmYXVsdCB0byB0aGUgY3JhdGUgZm9sZGVyJyxcbiAgfSlcblxuICBwbGF0Zm9ybT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1wbGF0Zm9ybScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYCcsXG4gIH0pXG5cbiAganNQYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tanMtcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhY2thZ2UgbmFtZSBpbiBnZW5lcmF0ZWQganMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcnLFxuICB9KVxuXG4gIGNvbnN0RW51bT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1jb25zdC1lbnVtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzJyxcbiAgfSlcblxuICBqc0JpbmRpbmc/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWpzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuJyxcbiAgfSlcblxuICBub0pzQmluZGluZz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1uby1qcycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGdlbmVyYXRpb24gSlMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuJyxcbiAgfSlcblxuICBkdHM/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWR0cycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIGFuZCBmaWxlbmFtZSBvZiBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAnLFxuICB9KVxuXG4gIGR0c0hlYWRlcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZHRzLWhlYWRlcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDdXN0b20gZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC4nLFxuICB9KVxuXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLW5vLWR0cy1oZWFkZXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnV2hldGhlciB0byBkaXNhYmxlIHRoZSBkZWZhdWx0IGZpbGUgaGVhZGVyIGZvciBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gT25seSB3b3JrcyB3aGVuIGB0eXBlZGVmYCBmZWF0dXJlIGVuYWJsZWQuJyxcbiAgfSlcblxuICBkdHNDYWNoZSA9IE9wdGlvbi5Cb29sZWFuKCctLWR0cy1jYWNoZScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gZW5hYmxlIHRoZSBkdHMgY2FjaGUsIGRlZmF1bHQgdG8gdHJ1ZScsXG4gIH0pXG5cbiAgZXNtPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWVzbScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGVtaXQgYW4gRVNNIEpTIGJpbmRpbmcgZmlsZSBpbnN0ZWFkIG9mIENKUyBmb3JtYXQuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4nLFxuICB9KVxuXG4gIHN0cmlwPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXN0cmlwLC1zJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBzdHJpcCB0aGUgbGlicmFyeSB0byBhY2hpZXZlIHRoZSBtaW5pbXVtIGZpbGUgc2l6ZScsXG4gIH0pXG5cbiAgcmVsZWFzZT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1yZWxlYXNlLC1yJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgaW4gcmVsZWFzZSBtb2RlJyxcbiAgfSlcblxuICB2ZXJib3NlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXZlcmJvc2UsLXYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdWZXJib3NlbHkgbG9nIGJ1aWxkIGNvbW1hbmQgdHJhY2UnLFxuICB9KVxuXG4gIGJpbj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYmluJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgb25seSB0aGUgc3BlY2lmaWVkIGJpbmFyeScsXG4gIH0pXG5cbiAgcGFja2FnZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZSwtcCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIHRoZSBzcGVjaWZpZWQgbGlicmFyeSBvciB0aGUgb25lIGF0IGN3ZCcsXG4gIH0pXG5cbiAgcHJvZmlsZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcHJvZmlsZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIGFydGlmYWN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvZmlsZScsXG4gIH0pXG5cbiAgY3Jvc3NDb21waWxlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWNyb3NzLWNvbXBpbGUsLXgnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gY3Jvc3MtY29tcGlsZSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgd2l0aCBgY2FyZ28teHdpbmAgb24gd2luZG93cyBhbmQgYGNhcmdvLXppZ2J1aWxkYCBvbiBvdGhlciBwbGF0Zm9ybScsXG4gIH0pXG5cbiAgdXNlQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLWNyb3NzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1tleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gJyxcbiAgfSlcblxuICB1c2VOYXBpQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLW5hcGktY3Jvc3MnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gdXNlIEBuYXBpLXJzL2Nyb3NzLXRvb2xjaGFpbiB0byBjcm9zcy1jb21waWxlIExpbnV4IGFybS9hcm02NC94NjQgZ251IHRhcmdldHMuJyxcbiAgfSlcblxuICB3YXRjaD86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS13YXRjaCwtdycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICd3YXRjaCB0aGUgY3JhdGUgY2hhbmdlcyBhbmQgYnVpbGQgY29udGludW91c2x5IHdpdGggYGNhcmdvLXdhdGNoYCBjcmF0ZXMnLFxuICB9KVxuXG4gIGZlYXR1cmVzPzogc3RyaW5nW10gPSBPcHRpb24uQXJyYXkoJy0tZmVhdHVyZXMsLUYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdTcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBmZWF0dXJlcyB0byBhY3RpdmF0ZScsXG4gIH0pXG5cbiAgYWxsRmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tYWxsLWZlYXR1cmVzJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQWN0aXZhdGUgYWxsIGF2YWlsYWJsZSBmZWF0dXJlcycsXG4gIH0pXG5cbiAgbm9EZWZhdWx0RmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgbWFuaWZlc3RQYXRoOiB0aGlzLm1hbmlmZXN0UGF0aCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICB0YXJnZXREaXI6IHRoaXMudGFyZ2V0RGlyLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAganNQYWNrYWdlTmFtZTogdGhpcy5qc1BhY2thZ2VOYW1lLFxuICAgICAgY29uc3RFbnVtOiB0aGlzLmNvbnN0RW51bSxcbiAgICAgIGpzQmluZGluZzogdGhpcy5qc0JpbmRpbmcsXG4gICAgICBub0pzQmluZGluZzogdGhpcy5ub0pzQmluZGluZyxcbiAgICAgIGR0czogdGhpcy5kdHMsXG4gICAgICBkdHNIZWFkZXI6IHRoaXMuZHRzSGVhZGVyLFxuICAgICAgbm9EdHNIZWFkZXI6IHRoaXMubm9EdHNIZWFkZXIsXG4gICAgICBkdHNDYWNoZTogdGhpcy5kdHNDYWNoZSxcbiAgICAgIGVzbTogdGhpcy5lc20sXG4gICAgICBzdHJpcDogdGhpcy5zdHJpcCxcbiAgICAgIHJlbGVhc2U6IHRoaXMucmVsZWFzZSxcbiAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSxcbiAgICAgIGJpbjogdGhpcy5iaW4sXG4gICAgICBwYWNrYWdlOiB0aGlzLnBhY2thZ2UsXG4gICAgICBwcm9maWxlOiB0aGlzLnByb2ZpbGUsXG4gICAgICBjcm9zc0NvbXBpbGU6IHRoaXMuY3Jvc3NDb21waWxlLFxuICAgICAgdXNlQ3Jvc3M6IHRoaXMudXNlQ3Jvc3MsXG4gICAgICB1c2VOYXBpQ3Jvc3M6IHRoaXMudXNlTmFwaUNyb3NzLFxuICAgICAgd2F0Y2g6IHRoaXMud2F0Y2gsXG4gICAgICBmZWF0dXJlczogdGhpcy5mZWF0dXJlcyxcbiAgICAgIGFsbEZlYXR1cmVzOiB0aGlzLmFsbEZlYXR1cmVzLFxuICAgICAgbm9EZWZhdWx0RmVhdHVyZXM6IHRoaXMubm9EZWZhdWx0RmVhdHVyZXMsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBCdWlsZCBmb3IgdGhlIHRhcmdldCB0cmlwbGUsIGJ5cGFzc2VkIHRvIGBjYXJnbyBidWlsZCAtLXRhcmdldGBcbiAgICovXG4gIHRhcmdldD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYENhcmdvLnRvbWxgXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgXG4gICAqL1xuICB0YXJnZXREaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gd2hlcmUgYWxsIHRoZSBidWlsdCBmaWxlcyB3b3VsZCBiZSBwdXQuIERlZmF1bHQgdG8gdGhlIGNyYXRlIGZvbGRlclxuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYFxuICAgKi9cbiAgcGxhdGZvcm0/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUgaW4gZ2VuZXJhdGVkIGpzIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnXG4gICAqL1xuICBqc1BhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIGNvbnN0IGVudW0gZm9yIHR5cGVzY3JpcHQgYmluZGluZ3NcbiAgICovXG4gIGNvbnN0RW51bT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFBhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuXG4gICAqL1xuICBqc0JpbmRpbmc/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgZ2VuZXJhdGlvbiBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy5cbiAgICovXG4gIG5vSnNCaW5kaW5nPzogYm9vbGVhblxuICAvKipcbiAgICogUGF0aCBhbmQgZmlsZW5hbWUgb2YgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIFJlbGF0aXZlIHRvIGAtLW91dHB1dC1kaXJgXG4gICAqL1xuICBkdHM/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEN1c3RvbSBmaWxlIGhlYWRlciBmb3IgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIE9ubHkgd29ya3Mgd2hlbiBgdHlwZWRlZmAgZmVhdHVyZSBlbmFibGVkLlxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC5cbiAgICovXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgdGhlIGR0cyBjYWNoZSwgZGVmYXVsdCB0byB0cnVlXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGR0c0NhY2hlPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbWl0IGFuIEVTTSBKUyBiaW5kaW5nIGZpbGUgaW5zdGVhZCBvZiBDSlMgZm9ybWF0LiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuXG4gICAqL1xuICBlc20/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN0cmlwIHRoZSBsaWJyYXJ5IHRvIGFjaGlldmUgdGhlIG1pbmltdW0gZmlsZSBzaXplXG4gICAqL1xuICBzdHJpcD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIGluIHJlbGVhc2UgbW9kZVxuICAgKi9cbiAgcmVsZWFzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFZlcmJvc2VseSBsb2cgYnVpbGQgY29tbWFuZCB0cmFjZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIG9ubHkgdGhlIHNwZWNpZmllZCBiaW5hcnlcbiAgICovXG4gIGJpbj86IHN0cmluZ1xuICAvKipcbiAgICogQnVpbGQgdGhlIHNwZWNpZmllZCBsaWJyYXJ5IG9yIHRoZSBvbmUgYXQgY3dkXG4gICAqL1xuICBwYWNrYWdlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBCdWlsZCBhcnRpZmFjdHMgd2l0aCB0aGUgc3BlY2lmaWVkIHByb2ZpbGVcbiAgICovXG4gIHByb2ZpbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIGNyb3NzLWNvbXBpbGUgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IHdpdGggYGNhcmdvLXh3aW5gIG9uIHdpbmRvd3MgYW5kIGBjYXJnby16aWdidWlsZGAgb24gb3RoZXIgcGxhdGZvcm1cbiAgICovXG4gIGNyb3NzQ29tcGlsZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gXG4gICAqL1xuICB1c2VDcm9zcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4gdG8gY3Jvc3MtY29tcGlsZSBMaW51eCBhcm0vYXJtNjQveDY0IGdudSB0YXJnZXRzLlxuICAgKi9cbiAgdXNlTmFwaUNyb3NzPzogYm9vbGVhblxuICAvKipcbiAgICogd2F0Y2ggdGhlIGNyYXRlIGNoYW5nZXMgYW5kIGJ1aWxkIGNvbnRpbnVvdXNseSB3aXRoIGBjYXJnby13YXRjaGAgY3JhdGVzXG4gICAqL1xuICB3YXRjaD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGZlYXR1cmVzIHRvIGFjdGl2YXRlXG4gICAqL1xuICBmZWF0dXJlcz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzXG4gICAqL1xuICBhbGxGZWF0dXJlcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmVcbiAgICovXG4gIG5vRGVmYXVsdEZlYXR1cmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0QnVpbGRPcHRpb25zKG9wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGR0c0NhY2hlOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmltcG9ydCB7IGJ1aWxkUHJvamVjdCB9IGZyb20gJy4uL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IEJhc2VCdWlsZENvbW1hbmQgfSBmcm9tICcuLi9kZWYvYnVpbGQuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2J1aWxkJylcblxuZXhwb3J0IGNsYXNzIEJ1aWxkQ29tbWFuZCBleHRlbmRzIEJhc2VCdWlsZENvbW1hbmQge1xuICBwaXBlID0gT3B0aW9uLlN0cmluZygnLS1waXBlJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BpcGUgYWxsIG91dHB1dHMgZmlsZSB0byBnaXZlbiBjb21tYW5kLiBlLmcuIGBuYXBpIGJ1aWxkIC0tcGlwZSBcIm5weCBwcmV0dGllciAtLXdyaXRlXCJgJyxcbiAgfSlcblxuICBjYXJnb09wdGlvbnMgPSBPcHRpb24uUmVzdCgpXG5cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBjb25zdCB7IHRhc2sgfSA9IGF3YWl0IGJ1aWxkUHJvamVjdCh7XG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKSxcbiAgICAgIGNhcmdvT3B0aW9uczogdGhpcy5jYXJnb09wdGlvbnMsXG4gICAgfSlcblxuICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCB0YXNrXG5cbiAgICBpZiAodGhpcy5waXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIGRlYnVnKCdQaXBpbmcgb3V0cHV0IGZpbGUgdG8gY29tbWFuZDogJXMnLCB0aGlzLnBpcGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYCR7dGhpcy5waXBlfSAke291dHB1dC5wYXRofWAsIHtcbiAgICAgICAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihgRmFpbGVkIHRvIHBpcGUgb3V0cHV0IGZpbGUgJHtvdXRwdXQucGF0aH0gdG8gY29tbWFuZGApXG4gICAgICAgICAgZGVidWcuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydjcmVhdGUtbnBtLWRpcnMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbnBtIHBhY2thZ2UgZGlycyBmb3IgZGlmZmVyZW50IHBsYXRmb3Jtc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5wbURpcnNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnMoXG4gIG9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zLFxuKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnc2VtdmVyJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbiAgQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQge1xuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWROYXBpQ29uZmlnLFxuICBta2RpckFzeW5jIGFzIHJhd01rZGlyQXN5bmMsXG4gIHBpY2ssXG4gIHdyaXRlRmlsZUFzeW5jIGFzIHJhd1dyaXRlRmlsZUFzeW5jLFxuICBUYXJnZXQsXG4gIHR5cGUgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnY3JlYXRlLW5wbS1kaXJzJylcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlTWV0YSB7XG4gICdkaXN0LXRhZ3MnOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5wbURpcnModXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBhc3luYyBmdW5jdGlvbiBta2RpckFzeW5jKGRpcjogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1RyeSB0byBjcmVhdGUgZGlyOiAlaScsIGRpcilcbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd01rZGlyQXN5bmMoZGlyLCB7XG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUFzeW5jKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1dyaXRpbmcgZmlsZSAlaScsIGZpbGUpXG5cbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGRlYnVnKGNvbnRlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdXcml0ZUZpbGVBc3luYyhmaWxlLCBjb250ZW50KVxuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IG5wbVBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpcilcblxuICBkZWJ1ZyhgUmVhZCBjb250ZW50IGZyb20gWyR7b3B0aW9ucy5jb25maWdQYXRoID8/IHBhY2thZ2VKc29uUGF0aH1dYClcblxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbiB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBqb2luKG5wbVBhdGgsIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YClcbiAgICBhd2FpdCBta2RpckFzeW5jKHRhcmdldERpcilcblxuICAgIGNvbnN0IGJpbmFyeUZpbGVOYW1lID1cbiAgICAgIHRhcmdldC5hcmNoID09PSAnd2FzbTMyJ1xuICAgICAgICA/IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgOiBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lm5vZGVgXG4gICAgY29uc3Qgc2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzID0ge1xuICAgICAgbmFtZTogYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIGNwdTogdGFyZ2V0LmFyY2ggIT09ICd1bml2ZXJzYWwnID8gW3RhcmdldC5hcmNoXSA6IHVuZGVmaW5lZCxcbiAgICAgIG1haW46IGJpbmFyeUZpbGVOYW1lLFxuICAgICAgZmlsZXM6IFtiaW5hcnlGaWxlTmFtZV0sXG4gICAgICAuLi5waWNrKFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2tleXdvcmRzJyxcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdhdXRob3JzJyxcbiAgICAgICAgJ2hvbWVwYWdlJyxcbiAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAnZW5naW5lcycsXG4gICAgICAgICdyZXBvc2l0b3J5JyxcbiAgICAgICAgJ2J1Z3MnLFxuICAgICAgKSxcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcgPSBwaWNrKFxuICAgICAgICBwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnLFxuICAgICAgICAncmVnaXN0cnknLFxuICAgICAgICAnYWNjZXNzJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhcmdldC5hcmNoICE9PSAnd2FzbTMyJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ub3MgPSBbdGFyZ2V0LnBsYXRmb3JtXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubWFpbiA9IGVudHJ5XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyID0gYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZmlsZXM/LnB1c2goXG4gICAgICAgIGVudHJ5LFxuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyLFxuICAgICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICAgIClcbiAgICAgIGxldCBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IHRydWVcbiAgICAgIGlmIChzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzPy5ub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBtYWpvciB9ID0gcGFyc2Uoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcy5ub2RlKSA/PyB7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ham9yID49IDE0KSB7XG4gICAgICAgICAgICBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMgPSB7XG4gICAgICAgICAgbm9kZTogJz49MTQuMC4wJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzbVJ1bnRpbWUgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL0BuYXBpLXJzL3dhc20tcnVudGltZWAsXG4gICAgICApLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSBhcyBQcm9taXNlPFBhY2thZ2VNZXRhPilcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgJ0BuYXBpLXJzL3dhc20tcnVudGltZSc6IGBeJHt3YXNtUnVudGltZVsnZGlzdC10YWdzJ10ubGF0ZXN0fWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hYmkgPT09ICdnbnUnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydnbGliYyddXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWJpID09PSAnbXVzbCcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ211c2wnXVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBhY2thZ2VKc29uID0gam9pbih0YXJnZXREaXIsICdwYWNrYWdlLmpzb24nKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgdGFyZ2V0UGFja2FnZUpzb24sXG4gICAgICBKU09OLnN0cmluZ2lmeShzY29wZWRQYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJyxcbiAgICApXG4gICAgY29uc3QgdGFyZ2V0UmVhZG1lID0gam9pbih0YXJnZXREaXIsICdSRUFETUUubWQnKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHRhcmdldFJlYWRtZSwgcmVhZG1lKHBhY2thZ2VOYW1lLCB0YXJnZXQpKVxuXG4gICAgZGVidWcuaW5mbyhgJHtwYWNrYWdlTmFtZX0gLSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0gY3JlYXRlZGApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHRhcmdldDogVGFyZ2V0KSB7XG4gIHJldHVybiBgIyBcXGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9XFxgXG5cblRoaXMgaXMgdGhlICoqJHt0YXJnZXQudHJpcGxlfSoqIGJpbmFyeSBmb3IgXFxgJHtwYWNrYWdlTmFtZX1cXGBcbmBcbn1cbiIsImltcG9ydCB7IGNyZWF0ZU5wbURpcnMgfSBmcm9tICcuLi9hcGkvY3JlYXRlLW5wbS1kaXJzLmpzJ1xuaW1wb3J0IHsgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIH0gZnJvbSAnLi4vZGVmL2NyZWF0ZS1ucG0tZGlycy5qcydcblxuZXhwb3J0IGNsYXNzIENyZWF0ZU5wbURpcnNDb21tYW5kIGV4dGVuZHMgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCBjcmVhdGVOcG1EaXJzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG4vKipcbiAqIEEgY29tbWFuZCB0aGF0IHByaW50cyB0aGUgdXNhZ2Ugb2YgYWxsIGNvbW1hbmRzLlxuICpcbiAqIFBhdGhzOiBgLWhgLCBgLS1oZWxwYFxuICovXG5leHBvcnQgY2xhc3MgSGVscENvbW1hbmQgZXh0ZW5kcyBDb21tYW5kPGFueT4ge1xuICBzdGF0aWMgcGF0aHMgPSBbW2AtaGBdLCBbYC0taGVscGBdXVxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IHRoaXMuY29udGV4dC5zdGRvdXQud3JpdGUodGhpcy5jbGkudXNhZ2UoKSlcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcbmltcG9ydCAqIGFzIHR5cGFuaW9uIGZyb20gJ3R5cGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZU5ld0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snbmV3J11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlJyxcbiAgfSlcblxuICAkJHBhdGggPSBPcHRpb24uU3RyaW5nKHsgcmVxdWlyZWQ6IGZhbHNlIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkJyxcbiAgfSlcblxuICBtaW5Ob2RlQXBpVmVyc2lvbiA9IE9wdGlvbi5TdHJpbmcoJy0tbWluLW5vZGUtYXBpLC12JywgJzQnLCB7XG4gICAgdmFsaWRhdG9yOiB0eXBhbmlvbi5pc051bWJlcigpLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG1pbmltdW0gTm9kZS1BUEkgdmVyc2lvbiB0byBzdXBwb3J0JyxcbiAgfSlcblxuICBwYWNrYWdlTWFuYWdlciA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1tYW5hZ2VyJywgJ3lhcm4nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgcGFja2FnZSBtYW5hZ2VyIHRvIHVzZS4gT25seSBzdXBwb3J0IHlhcm4gNC54IGZvciBub3cuJyxcbiAgfSlcblxuICBsaWNlbnNlID0gT3B0aW9uLlN0cmluZygnLS1saWNlbnNlLC1sJywgJ01JVCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0xpY2Vuc2UgZm9yIG9wZW4tc291cmNlZCBwcm9qZWN0JyxcbiAgfSlcblxuICB0YXJnZXRzID0gT3B0aW9uLkFycmF5KCctLXRhcmdldHMsLXQnLCBbXSwge1xuICAgIGRlc2NyaXB0aW9uOiAnQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLicsXG4gIH0pXG5cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHMgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtZGVmYXVsdC10YXJnZXRzJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVBbGxUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWFsbC10YXJnZXRzJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGFsbCB0YXJnZXRzJyxcbiAgfSlcblxuICBlbmFibGVUeXBlRGVmID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLXR5cGUtZGVmJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1doZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uJyxcbiAgfSlcblxuICBlbmFibGVHaXRodWJBY3Rpb25zID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWdpdGh1Yi1hY3Rpb25zJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93JyxcbiAgfSlcblxuICB0ZXN0RnJhbWV3b3JrID0gT3B0aW9uLlN0cmluZygnLS10ZXN0LWZyYW1ld29yaycsICdhdmEnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIEphdmFTY3JpcHQgdGVzdCBmcmFtZXdvcmsgdG8gdXNlLCBvbmx5IHN1cHBvcnQgYGF2YWAgZm9yIG5vdycsXG4gIH0pXG5cbiAgZHJ5UnVuID0gT3B0aW9uLkJvb2xlYW4oJy0tZHJ5LXJ1bicsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHRoaXMuJCRwYXRoLFxuICAgICAgbmFtZTogdGhpcy4kJG5hbWUsXG4gICAgICBtaW5Ob2RlQXBpVmVyc2lvbjogdGhpcy5taW5Ob2RlQXBpVmVyc2lvbixcbiAgICAgIHBhY2thZ2VNYW5hZ2VyOiB0aGlzLnBhY2thZ2VNYW5hZ2VyLFxuICAgICAgbGljZW5zZTogdGhpcy5saWNlbnNlLFxuICAgICAgdGFyZ2V0czogdGhpcy50YXJnZXRzLFxuICAgICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRoaXMuZW5hYmxlRGVmYXVsdFRhcmdldHMsXG4gICAgICBlbmFibGVBbGxUYXJnZXRzOiB0aGlzLmVuYWJsZUFsbFRhcmdldHMsXG4gICAgICBlbmFibGVUeXBlRGVmOiB0aGlzLmVuYWJsZVR5cGVEZWYsXG4gICAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgICB0ZXN0RnJhbWV3b3JrOiB0aGlzLnRlc3RGcmFtZXdvcmssXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwcm9qZWN0IHdpdGggcHJlLWNvbmZpZ3VyZWQgYm9pbGVycGxhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHdoZXJlIHRoZSBOQVBJLVJTIHByb2plY3Qgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgcGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIHByb2plY3QsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSBpZiBub3QgcHJvdmlkZWRcbiAgICovXG4gIG5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydFxuICAgKlxuICAgKiBAZGVmYXVsdCA0XG4gICAqL1xuICBtaW5Ob2RlQXBpVmVyc2lvbj86IG51bWJlclxuICAvKipcbiAgICogVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LlxuICAgKlxuICAgKiBAZGVmYXVsdCAneWFybidcbiAgICovXG4gIHBhY2thZ2VNYW5hZ2VyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAnTUlUJ1xuICAgKi9cbiAgbGljZW5zZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbXVxuICAgKi9cbiAgdGFyZ2V0cz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBkZWZhdWx0IHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlRGVmYXVsdFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0c1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZW5hYmxlQWxsVGFyZ2V0cz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZW5hYmxlIHRoZSBgdHlwZS1kZWZgIGZlYXR1cmUgZm9yIHR5cGVzY3JpcHQgZGVmaW5pdGlvbnMgYXV0by1nZW5lcmF0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZVR5cGVEZWY/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIHByZWNvbmZpZ3VyZWQgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3dcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlR2l0aHViQWN0aW9ucz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3dcbiAgICpcbiAgICogQGRlZmF1bHQgJ2F2YSdcbiAgICovXG4gIHRlc3RGcmFtZXdvcms/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcnVuIHRoZSBjb21tYW5kIGluIGRyeS1ydW4gbW9kZVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zOiBOZXdPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgbWluTm9kZUFwaVZlcnNpb246IDQsXG4gICAgcGFja2FnZU1hbmFnZXI6ICd5YXJuJyxcbiAgICBsaWNlbnNlOiAnTUlUJyxcbiAgICB0YXJnZXRzOiBbXSxcbiAgICBlbmFibGVEZWZhdWx0VGFyZ2V0czogdHJ1ZSxcbiAgICBlbmFibGVBbGxUYXJnZXRzOiBmYWxzZSxcbiAgICBlbmFibGVUeXBlRGVmOiB0cnVlLFxuICAgIGVuYWJsZUdpdGh1YkFjdGlvbnM6IHRydWUsXG4gICAgdGVzdEZyYW1ld29yazogJ2F2YScsXG4gICAgZHJ5UnVuOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJmdW5jdGlvbiBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSB7XG4gIGlmICh0LmhhcyhlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBjaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uID0gcmVxdWlyZShcIi4vY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbi5qc1wiKTtcbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyhlLCBhKSB7XG4gIGNoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgYSksIGEuYWRkKGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbiA9IHJlcXVpcmUoXCIuL2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24uanNcIik7XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhlLCB0LCBhKSB7XG4gIGNoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCksIHQuc2V0KGUsIGEpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hc3NlcnRDbGFzc0JyYW5kKGUsIHQsIG4pIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IGUgPT09IHQgOiBlLmhhcyh0KSkgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdCA6IG47XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGVsZW1lbnQgaXMgbm90IHByZXNlbnQgb24gdGhpcyBvYmplY3RcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRDbGFzc0JyYW5kLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFzc2VydENsYXNzQnJhbmQgPSByZXF1aXJlKFwiLi9hc3NlcnRDbGFzc0JyYW5kLmpzXCIpO1xuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihzLCBhKSB7XG4gIHJldHVybiBzLmdldChhc3NlcnRDbGFzc0JyYW5kKHMsIGEpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG4vLyBCYXJlIGtleXMgbWF5IG9ubHkgY29udGFpbiBBU0NJSSBsZXR0ZXJzLFxuLy8gQVNDSUkgZGlnaXRzLCB1bmRlcnNjb3JlcywgYW5kIGRhc2hlcyAoQS1aYS16MC05Xy0pLlxuZnVuY3Rpb24gam9pbktleXMoa2V5cykge1xuICAvLyBEb3R0ZWQga2V5cyBhcmUgYSBzZXF1ZW5jZSBvZiBiYXJlIG9yIHF1b3RlZCBrZXlzIGpvaW5lZCB3aXRoIGEgZG90LlxuICAvLyBUaGlzIGFsbG93cyBmb3IgZ3JvdXBpbmcgc2ltaWxhciBwcm9wZXJ0aWVzIHRvZ2V0aGVyOlxuICByZXR1cm4ga2V5cy5tYXAoKHN0cik9PntcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMCB8fCBzdHIubWF0Y2goL1teQS1aYS16MC05Xy1dLykgPyBKU09OLnN0cmluZ2lmeShzdHIpIDogc3RyO1xuICB9KS5qb2luKFwiLlwiKTtcbn1cbmNsYXNzIER1bXBlciB7XG4gIG1heFBhZCA9IDA7XG4gIHNyY09iamVjdDtcbiAgb3V0cHV0ID0gW107XG4gICNhcnJheVR5cGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioc3JjT2JqYyl7XG4gICAgdGhpcy5zcmNPYmplY3QgPSBzcmNPYmpjO1xuICB9XG4gIGR1bXAoZm10T3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuI3ByaW50T2JqZWN0KHRoaXMuc3JjT2JqZWN0KTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuI2Zvcm1hdChmbXRPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQ7XG4gIH1cbiAgI3ByaW50T2JqZWN0KG9iaiwga2V5cyA9IFtdKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGlubGluZVByb3BzID0gW107XG4gICAgY29uc3QgbXVsdGlsaW5lUHJvcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpe1xuICAgICAgaWYgKHRoaXMuI2lzU2ltcGx5U2VyaWFsaXphYmxlKG9ialtwcm9wXSkpIHtcbiAgICAgICAgaW5saW5lUHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpbGluZVByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvcnRlZFByb3BzID0gaW5saW5lUHJvcHMuY29uY2F0KG11bHRpbGluZVByb3BzKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc29ydGVkUHJvcHMpe1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2RhdGVEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jc3RyRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jbnVtYmVyRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNib29sRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjb25zdCBhcnJheVR5cGUgPSB0aGlzLiNnZXRUeXBlT2ZBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChhcnJheVR5cGUgPT09IFwiT05MWV9QUklNSVRJVkVcIikge1xuICAgICAgICAgIG91dC5wdXNoKHRoaXMuI2FycmF5RGVjbGFyYXRpb24oW1xuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXlUeXBlID09PSBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBvdXQucHVzaChcIlwiKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHRoaXMuI2hlYWRlckdyb3VwKFtcbiAgICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgb3V0LnB1c2goLi4udGhpcy4jcHJpbnRPYmplY3QodmFsdWVbaV0sIFtcbiAgICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgY29tcGxleCBhcnJheSwgdXNlIHRoZSBpbmxpbmUgZm9ybWF0LlxuICAgICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLm1hcCgoeCk9PnRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh4KSkuam9pbihcIixcIik7XG4gICAgICAgICAgb3V0LnB1c2goYCR7dGhpcy4jZGVjbGFyYXRpb24oW1xuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0pfVske3N0cn1dYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG91dC5wdXNoKFwiXCIpO1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNoZWFkZXIoW1xuICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdKSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHRvUGFyc2UgPSB2YWx1ZTtcbiAgICAgICAgICBvdXQucHVzaCguLi50aGlzLiNwcmludE9iamVjdCh0b1BhcnNlLCBbXG4gICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0pKTtcbiAgICAgICAgfVxuICAgICAgLy8gb3V0LnB1c2goLi4udGhpcy5fcGFyc2UodmFsdWUsIGAke3BhdGh9JHtwcm9wfS5gKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKFwiXCIpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgI2lzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBbXG4gICAgICBcInN0cmluZ1wiLFxuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiYm9vbGVhblwiXG4gICAgXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpO1xuICB9XG4gICNnZXRUeXBlT2ZBcnJheShhcnIpIHtcbiAgICBpZiAodGhpcy4jYXJyYXlUeXBlQ2FjaGUuaGFzKGFycikpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcnJheVR5cGVDYWNoZS5nZXQoYXJyKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuI2RvR2V0VHlwZU9mQXJyYXkoYXJyKTtcbiAgICB0aGlzLiNhcnJheVR5cGVDYWNoZS5zZXQoYXJyLCB0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICAjZG9HZXRUeXBlT2ZBcnJheShhcnIpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgIC8vIGFueSB0eXBlIHNob3VsZCBiZSBmaW5lXG4gICAgICByZXR1cm4gXCJPTkxZX1BSSU1JVElWRVwiO1xuICAgIH1cbiAgICBjb25zdCBvbmx5UHJpbWl0aXZlID0gdGhpcy4jaXNQcmltaXRpdmUoYXJyWzBdKTtcbiAgICBpZiAoYXJyWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBcIk1JWEVEXCI7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgICAgaWYgKG9ubHlQcmltaXRpdmUgIT09IHRoaXMuI2lzUHJpbWl0aXZlKGFycltpXSkgfHwgYXJyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwiTUlYRURcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ubHlQcmltaXRpdmUgPyBcIk9OTFlfUFJJTUlUSVZFXCIgOiBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiO1xuICB9XG4gICNwcmludEFzSW5saW5lVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gYFwiJHt0aGlzLiNwcmludERhdGUodmFsdWUpfVwiYDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLm1hcCgoeCk9PnRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh4KSkuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYFske3N0cn1dYDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2hcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHIgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChrZXkpPT57XG4gICAgICAgIHJldHVybiBgJHtqb2luS2V5cyhbXG4gICAgICAgICAga2V5XG4gICAgICAgIF0pfSA9ICR7Ly8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHZhbHVlW2tleV0pfWA7XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBgeyR7c3RyfX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2hcIik7XG4gIH1cbiAgI2lzU2ltcGx5U2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB0aGlzLiNnZXRUeXBlT2ZBcnJheSh2YWx1ZSkgIT09IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCI7XG4gIH1cbiAgI2hlYWRlcihrZXlzKSB7XG4gICAgcmV0dXJuIGBbJHtqb2luS2V5cyhrZXlzKX1dYDtcbiAgfVxuICAjaGVhZGVyR3JvdXAoa2V5cykge1xuICAgIHJldHVybiBgW1ske2pvaW5LZXlzKGtleXMpfV1dYDtcbiAgfVxuICAjZGVjbGFyYXRpb24oa2V5cykge1xuICAgIGNvbnN0IHRpdGxlID0gam9pbktleXMoa2V5cyk7XG4gICAgaWYgKHRpdGxlLmxlbmd0aCA+IHRoaXMubWF4UGFkKSB7XG4gICAgICB0aGlzLm1heFBhZCA9IHRpdGxlLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RpdGxlfSA9IGA7XG4gIH1cbiAgI2FycmF5RGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgfVxuICAjc3RyRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgfVxuICAjbnVtYmVyRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfW5hbmA7XG4gICAgfVxuICAgIHN3aXRjaCh2YWx1ZSl7XG4gICAgICBjYXNlIEluZmluaXR5OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9aW5mYDtcbiAgICAgIGNhc2UgLUluZmluaXR5OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9LWluZmA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt2YWx1ZX1gO1xuICAgIH1cbiAgfVxuICAjYm9vbERlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dmFsdWV9YDtcbiAgfVxuICAjcHJpbnREYXRlKHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gZHRQYWQodiwgbFBhZCA9IDIpIHtcbiAgICAgIHJldHVybiB2LnBhZFN0YXJ0KGxQYWQsIFwiMFwiKTtcbiAgICB9XG4gICAgY29uc3QgbSA9IGR0UGFkKCh2YWx1ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgZCA9IGR0UGFkKHZhbHVlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBoID0gZHRQYWQodmFsdWUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBtaW4gPSBkdFBhZCh2YWx1ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgcyA9IGR0UGFkKHZhbHVlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBtcyA9IGR0UGFkKHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCksIDMpO1xuICAgIC8vIGZvcm1hdHRlZCBkYXRlXG4gICAgY29uc3QgZkRhdGEgPSBgJHt2YWx1ZS5nZXRVVENGdWxsWWVhcigpfS0ke219LSR7ZH1UJHtofToke21pbn06JHtzfS4ke21zfWA7XG4gICAgcmV0dXJuIGZEYXRhO1xuICB9XG4gICNkYXRlRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt0aGlzLiNwcmludERhdGUodmFsdWUpfWA7XG4gIH1cbiAgI2Zvcm1hdChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGtleUFsaWdubWVudCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJEZWNsYXJhdGlvbiA9IC9eKFxcXCIuKlxcXCJ8W149XSopXFxzPS87XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLm91dHB1dFtpXTtcbiAgICAgIC8vIHdlIGtlZXAgZW1wdHkgZW50cnkgZm9yIGFycmF5IG9mIG9iamVjdHNcbiAgICAgIGlmIChsWzBdID09PSBcIltcIiAmJiBsWzFdICE9PSBcIltcIikge1xuICAgICAgICAvLyBub24tZW1wdHkgb2JqZWN0IHdpdGggb25seSBzdWJvYmplY3RzIGFzIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0W2kgKyAxXSA9PT0gXCJcIiAmJiB0aGlzLm91dHB1dFtpICsgMl0/LnNsaWNlKDAsIGwubGVuZ3RoKSA9PT0gbC5zbGljZSgwLCAtMSkgKyBcIi5cIikge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXlBbGlnbm1lbnQpIHtcbiAgICAgICAgICBjb25zdCBtID0gckRlY2xhcmF0aW9uLmV4ZWMobCk7XG4gICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgb3V0LnB1c2gobC5yZXBsYWNlKG1bMV0sIG1bMV0ucGFkRW5kKHRoaXMubWF4UGFkKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYW5pbmcgbXVsdGlwbGUgc3BhY2VzXG4gICAgY29uc3QgY2xlYW5lZE91dHB1dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspe1xuICAgICAgY29uc3QgbCA9IG91dFtpXTtcbiAgICAgIGlmICghKGwgPT09IFwiXCIgJiYgb3V0W2kgKyAxXSA9PT0gXCJcIikpIHtcbiAgICAgICAgY2xlYW5lZE91dHB1dC5wdXNoKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xlYW5lZE91dHB1dDtcbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gYSB7QGxpbmsgaHR0cHM6Ly90b21sLmlvIHwgVE9NTH0gc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSBcIkBzdGQvdG9tbC9zdHJpbmdpZnlcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IG9iaiA9IHtcbiAqICAgdGl0bGU6IFwiVE9NTCBFeGFtcGxlXCIsXG4gKiAgIG93bmVyOiB7XG4gKiAgICAgbmFtZTogXCJCb2JcIixcbiAqICAgICBiaW86IFwiQm9iIGlzIGEgY29vbCBndXlcIixcbiAqICB9XG4gKiB9O1xuICogY29uc3QgdG9tbFN0cmluZyA9IHN0cmluZ2lmeShvYmopO1xuICogYXNzZXJ0RXF1YWxzKHRvbWxTdHJpbmcsIGB0aXRsZSA9IFwiVE9NTCBFeGFtcGxlXCJcXG5cXG5bb3duZXJdXFxubmFtZSA9IFwiQm9iXCJcXG5iaW8gPSBcIkJvYiBpcyBhIGNvb2wgZ3V5XCJcXG5gKTtcbiAqIGBgYFxuICogQHBhcmFtIG9iaiBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzdHJpbmdpZnlpbmcuXG4gKiBAcmV0dXJucyBUT01MIHN0cmluZ1xuICovIGV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRHVtcGVyKG9iaikuZHVtcChvcHRpb25zKS5qb2luKFwiXFxuXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5naWZ5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG4vKipcbiAqIEZpbHRlcnMgdGhlIGdpdmVuIGFycmF5LCByZW1vdmluZyBhbGwgZWxlbWVudHMgdGhhdCBkbyBub3QgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZVxuICogKippbiBwbGFjZS4gVGhpcyBtZWFucyBgYXJyYXlgIHdpbGwgYmUgbW9kaWZpZWQhKiouXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckluUGxhY2UoYXJyYXksIHByZWRpY2F0ZSkge1xuICBsZXQgb3V0cHV0SW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGN1ciBvZiBhcnJheSl7XG4gICAgaWYgKCFwcmVkaWNhdGUoY3VyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFycmF5W291dHB1dEluZGV4XSA9IGN1cjtcbiAgICBvdXRwdXRJbmRleCArPSAxO1xuICB9XG4gIGFycmF5LnNwbGljZShvdXRwdXRJbmRleCk7XG4gIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91dGlscy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuaW1wb3J0IHsgZmlsdGVySW5QbGFjZSB9IGZyb20gXCIuL191dGlscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNZXJnZShyZWNvcmQsIG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBkZWVwTWVyZ2VJbnRlcm5hbChyZWNvcmQsIG90aGVyLCBuZXcgU2V0KCksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlSW50ZXJuYWwocmVjb3JkLCBvdGhlciwgc2Vlbiwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoW1xuICAgIC4uLmdldEtleXMocmVjb3JkKSxcbiAgICAuLi5nZXRLZXlzKG90aGVyKVxuICBdKTtcbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IG9mIG90aGVyIG9iamVjdCBhbmQgdXNlIGNvcnJlY3QgbWVyZ2luZyBzdHJhdGVneVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKXtcbiAgICAvLyBTa2lwIHRvIHByZXZlbnQgT2JqZWN0LnByb3RvdHlwZS5fX3Byb3RvX18gYWNjZXNzb3IgcHJvcGVydHkgY2FsbHMgb24gbm9uLURlbm8gcGxhdGZvcm1zXG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGEgPSByZWNvcmRba2V5XTtcbiAgICBpZiAoIU9iamVjdC5oYXNPd24ob3RoZXIsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gYTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBiID0gb3RoZXJba2V5XTtcbiAgICBpZiAoaXNOb25OdWxsT2JqZWN0KGEpICYmIGlzTm9uTnVsbE9iamVjdChiKSAmJiAhc2Vlbi5oYXMoYSkgJiYgIXNlZW4uaGFzKGIpKSB7XG4gICAgICBzZWVuLmFkZChhKTtcbiAgICAgIHNlZW4uYWRkKGIpO1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHMoYSwgYiwgc2Vlbiwgb3B0aW9ucyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGUgdmFsdWVcbiAgICByZXN1bHRba2V5XSA9IGI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhsZWZ0LCByaWdodCwgc2Vlbiwgb3B0aW9ucyA9IHtcbiAgYXJyYXlzOiBcIm1lcmdlXCIsXG4gIHNldHM6IFwibWVyZ2VcIixcbiAgbWFwczogXCJtZXJnZVwiXG59KSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG1lcmdlYWJsZSBvYmplY3RzXG4gIGlmIChpc01lcmdlYWJsZShsZWZ0KSAmJiBpc01lcmdlYWJsZShyaWdodCkpIHtcbiAgICByZXR1cm4gZGVlcE1lcmdlSW50ZXJuYWwobGVmdCwgcmlnaHQsIHNlZW4sIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0l0ZXJhYmxlKGxlZnQpICYmIGlzSXRlcmFibGUocmlnaHQpKSB7XG4gICAgLy8gSGFuZGxlIGFycmF5c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgbWFwc1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgTWFwICYmIHJpZ2h0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXBzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoW1xuICAgICAgICAgIC4uLmxlZnQsXG4gICAgICAgICAgLi4ucmlnaHRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBzZXRzXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBTZXQgJiYgcmlnaHQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGlmIChvcHRpb25zLnNldHMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNldChbXG4gICAgICAgICAgLi4ubGVmdCxcbiAgICAgICAgICAuLi5yaWdodFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJpZ2h0O1xufVxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBtZXJnZWFibGUgb3Igbm90XG4gKiBCdWlsdGlucyB0aGF0IGxvb2sgbGlrZSBvYmplY3RzLCBudWxsIGFuZCB1c2VyIGRlZmluZWQgY2xhc3Nlc1xuICogYXJlIG5vdCBjb25zaWRlcmVkIG1lcmdlYWJsZSAoaXQgbWVhbnMgdGhhdCByZWZlcmVuY2Ugd2lsbCBiZSBjb3BpZWQpXG4gKi8gZnVuY3Rpb24gaXNNZXJnZWFibGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBnZXRLZXlzKHJlY29yZCkge1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHJlY29yZCk7XG4gIGZpbHRlckluUGxhY2UocmVzdWx0LCAoa2V5KT0+T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHJlY29yZCwga2V5KSk7XG4gIHJlc3VsdC5wdXNoKC4uLk9iamVjdC5rZXlzKHJlY29yZCkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVlcF9tZXJnZS5qcy5tYXAiLCJ2YXIgYXNzZXJ0Q2xhc3NCcmFuZCA9IHJlcXVpcmUoXCIuL2Fzc2VydENsYXNzQnJhbmQuanNcIik7XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQyKHMsIGEsIHIpIHtcbiAgcmV0dXJuIHMuc2V0KGFzc2VydENsYXNzQnJhbmQocywgYSksIHIpLCByO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NQcml2YXRlRmllbGRTZXQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gXCJAanNyL3N0ZF9fY29sbGVjdGlvbnMvZGVlcC1tZXJnZVwiO1xuLyoqXG4gKiBDb3B5IG9mIGBpbXBvcnQgeyBpc0xlYXAgfSBmcm9tIFwiQHN0ZC9kYXRldGltZVwiO2AgYmVjYXVzZSBpdCBjYW5ub3QgYmUgaW1wb3RlZCBhcyBsb25nIGFzIGl0IGlzIHVuc3RhYmxlLlxuICovIGZ1bmN0aW9uIGlzTGVhcCh5ZWFyTnVtYmVyKSB7XG4gIHJldHVybiB5ZWFyTnVtYmVyICUgNCA9PT0gMCAmJiB5ZWFyTnVtYmVyICUgMTAwICE9PSAwIHx8IHllYXJOdW1iZXIgJSA0MDAgPT09IDA7XG59XG5leHBvcnQgY2xhc3MgU2Nhbm5lciB7XG4gICN3aGl0ZXNwYWNlID0gL1sgXFx0XS87XG4gICNwb3NpdGlvbiA9IDA7XG4gICNzb3VyY2U7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSl7XG4gICAgdGhpcy4jc291cmNlID0gc291cmNlO1xuICB9XG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb247XG4gIH1cbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjaGFyYWN0ZXJcbiAgICogQHBhcmFtIGluZGV4IC0gcmVsYXRpdmUgaW5kZXggZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBjaGFyKGluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2VbdGhpcy4jcG9zaXRpb24gKyBpbmRleF0gPz8gXCJcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHNsaWNlZCBzdHJpbmdcbiAgICogQHBhcmFtIHN0YXJ0IC0gc3RhcnQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqIEBwYXJhbSBlbmQgLSBlbmQgcG9zaXRpb24gcmVsYXRpdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uXG4gICAqLyBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zbGljZSh0aGlzLiNwb3NpdGlvbiArIHN0YXJ0LCB0aGlzLiNwb3NpdGlvbiArIGVuZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgcG9zaXRpb24gdG8gbmV4dFxuICAgKi8gbmV4dChjb3VudCA9IDEpIHtcbiAgICB0aGlzLiNwb3NpdGlvbiArPSBjb3VudDtcbiAgfVxuICBza2lwV2hpdGVzcGFjZXMoKSB7XG4gICAgd2hpbGUodGhpcy4jd2hpdGVzcGFjZS50ZXN0KHRoaXMuY2hhcigpKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgLy8gSW52YWxpZCBpZiBjdXJyZW50IGNoYXIgaXMgb3RoZXIga2luZHMgb2Ygd2hpdGVzcGFjZVxuICAgIGlmICghdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkgJiYgL1xccy8udGVzdCh0aGlzLmNoYXIoKSkpIHtcbiAgICAgIGNvbnN0IGVzY2FwZWQgPSBcIlxcXFx1XCIgKyB0aGlzLmNoYXIoKS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy4jcG9zaXRpb247XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgVE9NTDogSXQgY29udGFpbnMgaW52YWxpZCB3aGl0ZXNwYWNlIGF0IHBvc2l0aW9uICcke3Bvc2l0aW9ufSc6IFxcYCR7ZXNjYXBlZH1cXGBgKTtcbiAgICB9XG4gIH1cbiAgbmV4dFVudGlsQ2hhcihvcHRpb25zID0ge1xuICAgIHNraXBDb21tZW50czogdHJ1ZVxuICB9KSB7XG4gICAgd2hpbGUoIXRoaXMuZW9mKCkpe1xuICAgICAgY29uc3QgY2hhciA9IHRoaXMuY2hhcigpO1xuICAgICAgaWYgKHRoaXMuI3doaXRlc3BhY2UudGVzdChjaGFyKSB8fCB0aGlzLmlzQ3VycmVudENoYXJFT0woKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5za2lwQ29tbWVudHMgJiYgdGhpcy5jaGFyKCkgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIGVudGVyaW5nIGNvbW1lbnRcbiAgICAgICAgd2hpbGUoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmICF0aGlzLmVvZigpKXtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQb3NpdGlvbiByZWFjaGVkIEVPRiBvciBub3RcbiAgICovIGVvZigpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPj0gdGhpcy4jc291cmNlLmxlbmd0aDtcbiAgfVxuICBpc0N1cnJlbnRDaGFyRU9MKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXIoKSA9PT0gXCJcXG5cIiB8fCB0aGlzLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIik7XG4gIH1cbiAgc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nLCB0aGlzLiNwb3NpdGlvbik7XG4gIH1cbiAgbWF0Y2gocmVnRXhwKSB7XG4gICAgaWYgKCFyZWdFeHAuc3RpY2t5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ0V4cCAke3JlZ0V4cH0gZG9lcyBub3QgaGF2ZSBhIHN0aWNreSAneScgZmxhZ2ApO1xuICAgIH1cbiAgICByZWdFeHAubGFzdEluZGV4ID0gdGhpcy4jcG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5tYXRjaChyZWdFeHApO1xuICB9XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVXRpbGl0aWVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3VjY2Vzcyhib2R5KSB7XG4gIHJldHVybiB7XG4gICAgb2s6IHRydWUsXG4gICAgYm9keVxuICB9O1xufVxuZnVuY3Rpb24gZmFpbHVyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogZmFsc2VcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGUga2V5cyBhbmQgdmFsdWVzLlxuICpcbiAqIGUuZy4gYHVuZmxhdChbXCJhXCIsIFwiYlwiLCBcImNcIl0sIDEpYCByZXR1cm5zIGB7IGE6IHsgYjogeyBjOiAxIH0gfSB9YFxuICovIGV4cG9ydCBmdW5jdGlvbiB1bmZsYXQoa2V5cywgdmFsdWVzID0ge30pIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlUmlnaHQoKGFjYywga2V5KT0+KHtcbiAgICAgIFtrZXldOiBhY2NcbiAgICB9KSwgdmFsdWVzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpIHtcbiAgY29uc3Qga2V5ID0ga2V5c1swXTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IGtleSBsZW5ndGggaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiB0YXJnZXRba2V5XTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIHRhYmxlKSB7XG4gIGNvbnN0IHsga2V5cywgdHlwZSwgdmFsdWUgfSA9IHRhYmxlO1xuICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpO1xuICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHVuZmxhdChrZXlzLCB2YWx1ZSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBjb25zdCBsYXN0ID0gY3VycmVudFZhbHVlLmF0KC0xKTtcbiAgICBkZWVwQXNzaWduKGxhc3QsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZnVuY3Rpb24gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IHR5cGUsIGtleXMsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgW1xuICAgICAgdmFsdWVcbiAgICBdKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpKSB7XG4gICAgZGVlcEFzc2lnbihjdXJyZW50VmFsdWUsIHtcbiAgICAgIHR5cGUsXG4gICAgICBrZXlzOiBrZXlzLnNsaWNlKDEpLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXNzaWduXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBBc3NpZ24odGFyZ2V0LCBib2R5KSB7XG4gIHN3aXRjaChib2R5LnR5cGUpe1xuICAgIGNhc2UgXCJCbG9ja1wiOlxuICAgICAgcmV0dXJuIGRlZXBNZXJnZSh0YXJnZXQsIGJvZHkudmFsdWUpO1xuICAgIGNhc2UgXCJUYWJsZVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZSh0YXJnZXQsIGJvZHkpO1xuICAgIGNhc2UgXCJUYWJsZUFycmF5XCI6XG4gICAgICByZXR1cm4gZGVlcEFzc2lnblRhYmxlQXJyYXkodGFyZ2V0LCBib2R5KTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXJzZXIgY29tYmluYXRvcnMgYW5kIGdlbmVyYXRvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIG9yKHBhcnNlcnMpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGZvciAoY29uc3QgcGFyc2Ugb2YgcGFyc2Vycyl7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZShzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2spIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBmYWlsdXJlKCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogSWYgdGhlIHBhcnNlciBmYWlscyBhdCB0aGUgZmlyc3QgYXR0ZW1wdCwgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gKi8gZnVuY3Rpb24gam9pbihwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBzdWNjZXNzKG91dCk7XG4gICAgb3V0LnB1c2goZmlyc3QuYm9keSk7XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbi8qKiBKb2luIHRoZSBwYXJzZSByZXN1bHRzIG9mIHRoZSBnaXZlbiBwYXJzZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBwYXJzZXIgdG8gc3VjY2VlZCBhdCBsZWFzdCBvbmNlLlxuICovIGZ1bmN0aW9uIGpvaW4xKHBhcnNlciwgc2VwYXJhdG9yKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgZmlyc3QgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFmaXJzdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBvdXQgPSBbXG4gICAgICBmaXJzdC5ib2R5XG4gICAgXTtcbiAgICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgICBpZiAoIVNlcGFyYXRvcihzY2FubmVyKS5vaykgYnJlYWs7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke3NlcGFyYXRvcn1cImApO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICB9O1xufVxuZnVuY3Rpb24ga3Yoa2V5UGFyc2VyLCBzZXBhcmF0b3IsIHZhbHVlUGFyc2VyKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcG9zaXRpb24gPSBzY2FubmVyLnBvc2l0aW9uO1xuICAgIGNvbnN0IGtleSA9IGtleVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWtleS5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBjb25zdCBzZXAgPSBTZXBhcmF0b3Ioc2Nhbm5lcik7XG4gICAgaWYgKCFzZXAub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihga2V5L3ZhbHVlIHBhaXIgZG9lc24ndCBoYXZlIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXZhbHVlLm9rKSB7XG4gICAgICBjb25zdCBsaW5lRW5kSW5kZXggPSBzY2FubmVyLnNvdXJjZS5pbmRleE9mKFwiXFxuXCIsIHNjYW5uZXIucG9zaXRpb24pO1xuICAgICAgY29uc3QgZW5kUG9zaXRpb24gPSBsaW5lRW5kSW5kZXggPiAwID8gbGluZUVuZEluZGV4IDogc2Nhbm5lci5zb3VyY2UubGVuZ3RoO1xuICAgICAgY29uc3QgbGluZSA9IHNjYW5uZXIuc291cmNlLnNsaWNlKHBvc2l0aW9uLCBlbmRQb3NpdGlvbik7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENhbm5vdCBwYXJzZSB2YWx1ZSBvbiBsaW5lICcke2xpbmV9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzcyh1bmZsYXQoa2V5LmJvZHksIHZhbHVlLmJvZHkpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlKHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIGxldCBib2R5ID0ge307XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVzdWx0LmJvZHkpe1xuICAgICAgaWYgKHR5cGVvZiByZWNvcmQgPT09IFwib2JqZWN0XCIgJiYgcmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBkZWVwTWVyZ2UoYm9keSwgcmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiByZXBlYXQocGFyc2VyKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgICAgYm9keS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIH1cbiAgICBpZiAoYm9keS5sZW5ndGggPT09IDApIHJldHVybiBmYWlsdXJlKCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiBzdXJyb3VuZChsZWZ0LCBwYXJzZXIsIHJpZ2h0KSB7XG4gIGNvbnN0IExlZnQgPSBjaGFyYWN0ZXIobGVmdCk7XG4gIGNvbnN0IFJpZ2h0ID0gY2hhcmFjdGVyKHJpZ2h0KTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGlmICghTGVmdChzY2FubmVyKS5vaykge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFSaWdodChzY2FubmVyKS5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb3QgY2xvc2VkIGJ5IFwiJHtyaWdodH1cIiBhZnRlciBzdGFydGVkIHdpdGggXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MocmVzdWx0LmJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gY2hhcmFjdGVyKHN0cikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChzdHIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHNjYW5uZXIubmV4dChzdHIubGVuZ3RoKTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIHJldHVybiBzdWNjZXNzKHVuZGVmaW5lZCk7XG4gIH07XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbXBvbmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBCQVJFX0tFWV9SRUdFWFAgPSAvW0EtWmEtejAtOV8tXSsveTtcbmV4cG9ydCBmdW5jdGlvbiBiYXJlS2V5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3Qga2V5ID0gc2Nhbm5lci5tYXRjaChCQVJFX0tFWV9SRUdFWFApPy5bMF07XG4gIGlmICgha2V5KSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoa2V5Lmxlbmd0aCk7XG4gIHJldHVybiBzdWNjZXNzKGtleSk7XG59XG5mdW5jdGlvbiBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKSB7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJcXFxcXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICAvLyBTZWUgaHR0cHM6Ly90b21sLmlvL2VuL3YxLjAuMC1yYy4zI3N0cmluZ1xuICBzd2l0Y2goc2Nhbm5lci5jaGFyKCkpe1xuICAgIGNhc2UgXCJiXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxiXCIpO1xuICAgIGNhc2UgXCJ0XCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFx0XCIpO1xuICAgIGNhc2UgXCJuXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxuXCIpO1xuICAgIGNhc2UgXCJmXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxmXCIpO1xuICAgIGNhc2UgXCJyXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxyXCIpO1xuICAgIGNhc2UgXCJ1XCI6XG4gICAgY2FzZSBcIlVcIjpcbiAgICAgIHtcbiAgICAgICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgY29kZVBvaW50TGVuID0gc2Nhbm5lci5jaGFyKCkgPT09IFwidVwiID8gNCA6IDY7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHBhcnNlSW50KFwiMHhcIiArIHNjYW5uZXIuc2xpY2UoMSwgMSArIGNvZGVQb2ludExlbiksIDE2KTtcbiAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgc2Nhbm5lci5uZXh0KGNvZGVQb2ludExlbiArIDEpO1xuICAgICAgICByZXR1cm4gc3VjY2VzcyhzdHIpO1xuICAgICAgfVxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoJ1wiJyk7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoXCJcXFxcXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlOiBcXFxcJHtzY2FubmVyLmNoYXIoKX1gKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSAnXCInKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSAnXCInICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlNpbmdsZS1saW5lIHN0cmluZyBjYW5ub3QgY29udGFpbiBFT0xcIik7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcik7XG4gICAgaWYgKGVzY2FwZWRDaGFyLm9rKSB7XG4gICAgICBhY2MucHVzaChlc2NhcGVkQ2hhci5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgJ1wiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiJ1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIiAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFNpbmdsZS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KCk7IC8vIHNraXAgbGFzdCBcIidcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lQmFzaWNTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aCgnXCJcIlwiJykpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgzKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKExGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxyXFxuXCIpKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKENSTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoMik7XG4gIH1cbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICAvLyBsaW5lIGVuZGluZyBiYWNrc2xhc2hcbiAgICBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcclxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTXVsdGktbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIC8vIGlmIGVuZHMgd2l0aCA0IGBcImAsIHB1c2ggdGhlIGZpc3QgYFwiYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gJ1wiJykge1xuICAgIGFjYy5wdXNoKCdcIicpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dCgzKTsgLy8gc2tpcCBsYXN0ICdcIlwiXCJcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lTGl0ZXJhbFN0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmICghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgJ2AsIHB1c2ggdGhlIGZpc3QgYCdgIHRvIHN0cmluZ1xuICBpZiAoc2Nhbm5lci5jaGFyKDMpID09PSBcIidcIikge1xuICAgIGFjYy5wdXNoKFwiJ1wiKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCBcIicnJ1wiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmNvbnN0IEJPT0xFQU5fUkVHRVhQID0gLyg/OnRydWV8ZmFsc2UpXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCT09MRUFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gc3RyaW5nID09PSBcInRydWVcIjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuY29uc3QgSU5GSU5JVFlfTUFQID0gbmV3IE1hcChbXG4gIFtcbiAgICBcImluZlwiLFxuICAgIEluZmluaXR5XG4gIF0sXG4gIFtcbiAgICBcIitpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCItaW5mXCIsXG4gICAgLUluZmluaXR5XG4gIF1cbl0pO1xuY29uc3QgSU5GSU5JVFlfUkVHRVhQID0gL1srLV0/aW5mXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW5maW5pdHkoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goSU5GSU5JVFlfUkVHRVhQKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgY29uc3Qgc3RyaW5nID0gbWF0Y2hbMF07XG4gIHNjYW5uZXIubmV4dChzdHJpbmcubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBJTkZJTklUWV9NQVAuZ2V0KHN0cmluZyk7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IE5BTl9SRUdFWFAgPSAvWystXT9uYW5cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTkFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gTmFOO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgZG90dGVkS2V5ID0gam9pbjEob3IoW1xuICBiYXJlS2V5LFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZ1xuXSksIFwiLlwiKTtcbmNvbnN0IEJJTkFSWV9SRUdFWFAgPSAvMGJbMDFdKyg/Ol9bMDFdKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEJJTkFSWV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMik7XG4gIHJldHVybiBpc05hTihudW1iZXIpID8gZmFpbHVyZSgpIDogc3VjY2VzcyhudW1iZXIpO1xufVxuY29uc3QgT0NUQUxfUkVHRVhQID0gLzBvWzAtN10rKD86X1swLTddKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gb2N0YWwoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goT0NUQUxfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDgpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IEhFWF9SRUdFWFAgPSAvMHhbMC05YS1mXSsoPzpfWzAtOWEtZl0rKSpcXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gaGV4KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEhFWF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IElOVEVHRVJfUkVHRVhQID0gL1srLV0/KD86MHxbMS05XVswLTldKig/Ol9bMC05XSspKilcXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElOVEVHRVJfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgaW50ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoaW50KTtcbn1cbmNvbnN0IEZMT0FUX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopKD86XFwuWzAtOV0rKD86X1swLTldKykqKT8oPzplWystXT9bMC05XSsoPzpfWzAtOV0rKSopP1xcYi95aTtcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChGTE9BVF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoaXNOYU4oZmxvYXQpKSByZXR1cm4gZmFpbHVyZSgpO1xuICByZXR1cm4gc3VjY2VzcyhmbG9hdCk7XG59XG5jb25zdCBEQVRFX1RJTUVfUkVHRVhQID0gLyg/PHllYXI+XFxkezR9KS0oPzxtb250aD5cXGR7Mn0pLSg/PGRheT5cXGR7Mn0pKD86WyAwLTlUWi46Ky1dKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goREFURV9USU1FX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgLy8gc3BlY2lhbCBjYXNlIGlmIG1vbnRoIGlzIEZlYnJ1YXJ5XG4gIGlmIChncm91cHMubW9udGggPT0gXCIwMlwiKSB7XG4gICAgY29uc3QgZGF5cyA9IHBhcnNlSW50KGdyb3Vwcy5kYXkpO1xuICAgIGlmIChkYXlzID4gMjkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGdyb3Vwcy55ZWFyKTtcbiAgICBpZiAoZGF5cyA+IDI4ICYmICFpc0xlYXAoeWVhcikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZy50cmltKCkpO1xuICAvLyBpbnZhbGlkIGRhdGVcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgfVxuICByZXR1cm4gc3VjY2VzcyhkYXRlKTtcbn1cbmNvbnN0IExPQ0FMX1RJTUVfUkVHRVhQID0gLyhcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pKD86XFwuWzAtOV0rKT9cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTE9DQUxfVElNRV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhtYXRjaCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlWYWx1ZShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJbXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoc2Nhbm5lcik7XG4gICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgIGFycmF5LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgLy8gbWF5IGhhdmUgYSBuZXh0IGl0ZW0sIGJ1dCB0cmFpbGluZyBjb21tYSBpcyBhbGxvd2VkIGF0IGFycmF5XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIixcIikgYnJlYWs7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJdXCIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFycmF5IGlzIG5vdCBjbG9zZWRcIik7XG4gIHNjYW5uZXIubmV4dCgpO1xuICByZXR1cm4gc3VjY2VzcyhhcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5saW5lVGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigxKSA9PT0gXCJ9XCIpIHtcbiAgICBzY2FubmVyLm5leHQoMik7XG4gICAgcmV0dXJuIHN1Y2Nlc3Moe30pO1xuICB9XG4gIGNvbnN0IHBhaXJzID0gc3Vycm91bmQoXCJ7XCIsIGpvaW4ocGFpciwgXCIsXCIpLCBcIn1cIikoc2Nhbm5lcik7XG4gIGlmICghcGFpcnMub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIGxldCB0YWJsZSA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMuYm9keSl7XG4gICAgdGFibGUgPSBkZWVwTWVyZ2UodGFibGUsIHBhaXIpO1xuICB9XG4gIHJldHVybiBzdWNjZXNzKHRhYmxlKTtcbn1cbmV4cG9ydCBjb25zdCB2YWx1ZSA9IG9yKFtcbiAgbXVsdGlsaW5lQmFzaWNTdHJpbmcsXG4gIG11bHRpbGluZUxpdGVyYWxTdHJpbmcsXG4gIGJhc2ljU3RyaW5nLFxuICBsaXRlcmFsU3RyaW5nLFxuICBib29sZWFuLFxuICBpbmZpbml0eSxcbiAgbmFuLFxuICBkYXRlVGltZSxcbiAgbG9jYWxUaW1lLFxuICBiaW5hcnksXG4gIG9jdGFsLFxuICBoZXgsXG4gIGZsb2F0LFxuICBpbnRlZ2VyLFxuICBhcnJheVZhbHVlLFxuICBpbmxpbmVUYWJsZVxuXSk7XG5leHBvcnQgY29uc3QgcGFpciA9IGt2KGRvdHRlZEtleSwgXCI9XCIsIHZhbHVlKTtcbmV4cG9ydCBmdW5jdGlvbiBibG9jayhzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCByZXN1bHQgPSBtZXJnZShyZXBlYXQocGFpcikpKHNjYW5uZXIpO1xuICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJCbG9ja1wiLFxuICAgIHZhbHVlOiByZXN1bHQuYm9keVxuICB9KTtcbiAgcmV0dXJuIGZhaWx1cmUoKTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUhlYWRlciA9IHN1cnJvdW5kKFwiW1wiLCBkb3R0ZWRLZXksIFwiXVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB0YWJsZShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlXCIsXG4gICAga2V5czogaGVhZGVyLmJvZHksXG4gICAgdmFsdWU6IGIub2sgPyBiLmJvZHkudmFsdWUgOiB7fVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUFycmF5SGVhZGVyID0gc3Vycm91bmQoXCJbW1wiLCBkb3R0ZWRLZXksIFwiXV1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGVBcnJheShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUFycmF5SGVhZGVyKHNjYW5uZXIpO1xuICBpZiAoIWhlYWRlci5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGNvbnN0IGIgPSBibG9jayhzY2FubmVyKTtcbiAgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiVGFibGVBcnJheVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge31cbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9tbChzY2FubmVyKSB7XG4gIGNvbnN0IGJsb2NrcyA9IHJlcGVhdChvcihbXG4gICAgYmxvY2ssXG4gICAgdGFibGVBcnJheSxcbiAgICB0YWJsZVxuICBdKSkoc2Nhbm5lcik7XG4gIGlmICghYmxvY2tzLm9rKSByZXR1cm4gc3VjY2Vzcyh7fSk7XG4gIGNvbnN0IGJvZHkgPSBibG9ja3MuYm9keS5yZWR1Y2UoZGVlcEFzc2lnbiwge30pO1xuICByZXR1cm4gc3VjY2Vzcyhib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpIHtcbiAgY29uc3Qgc3RyaW5nID0gc2Nhbm5lci5zb3VyY2Uuc2xpY2UoMCwgc2Nhbm5lci5wb3NpdGlvbik7XG4gIGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCByb3cgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbiA9IGxpbmVzLmF0KC0xKT8ubGVuZ3RoID8/IDA7XG4gIHJldHVybiBgUGFyc2UgZXJyb3Igb24gbGluZSAke3Jvd30sIGNvbHVtbiAke2NvbHVtbn06ICR7bWVzc2FnZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZhY3RvcnkocGFyc2VyKSB7XG4gIHJldHVybiAodG9tbFN0cmluZyk9PntcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IFNjYW5uZXIodG9tbFN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2sgJiYgc2Nhbm5lci5lb2YoKSkgcmV0dXJuIHJlc3VsdC5ib2R5O1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIke3NjYW5uZXIuY2hhcigpfVwiYDtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIGVycm9yIHR5cGUgY2F1Z2h0XCI7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wYXJzZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IHBhcnNlckZhY3RvcnksIHRvbWwgfSBmcm9tIFwiLi9fcGFyc2VyLmpzXCI7XG4vKipcbiAqIFBhcnNlcyBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAc3RkL3RvbWwvcGFyc2VcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXG4gKiBbb3duZXJdXG4gKiBuYW1lID0gXCJBbGljZVwiXG4gKiBiaW8gPSBcIkFsaWNlIGlzIGEgcHJvZ3JhbW1lci5cImA7XG4gKlxuICogY29uc3Qgb2JqID0gcGFyc2UodG9tbFN0cmluZyk7XG4gKiBhc3NlcnRFcXVhbHMob2JqLCB7IHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLCBvd25lcjogeyBuYW1lOiBcIkFsaWNlXCIsIGJpbzogXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCIgfSB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHRvbWxTdHJpbmcgVE9NTCBzdHJpbmcgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKUyBvYmplY3QuXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRvbWxTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlckZhY3RvcnkodG9tbCkodG9tbFN0cmluZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncmVuYW1lJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdSZW5hbWUgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBiaW5hcnlOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1iaW5hcnktbmFtZSwtYicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzJyxcbiAgfSlcblxuICBwYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBwYWNrYWdlIG5hbWUgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsICdDYXJnby50b21sJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgQ2FyZ28udG9tbGAnLFxuICB9KVxuXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXJlcG9zaXRvcnknLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1kZXNjcmlwdGlvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgYmluYXJ5TmFtZTogdGhpcy5iaW5hcnlOYW1lLFxuICAgICAgcGFja2FnZU5hbWU6IHRoaXMucGFja2FnZU5hbWUsXG4gICAgICBtYW5pZmVzdFBhdGg6IHRoaXMubWFuaWZlc3RQYXRoLFxuICAgICAgcmVwb3NpdG9yeTogdGhpcy5yZXBvc2l0b3J5LFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW5hbWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBiaW5hcnkgbmFtZSAqLm5vZGUgZmlsZXNcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgQ2FyZ28udG9tbGBcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NhcmdvLnRvbWwnXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcmVwb3NpdG9yeSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcmVwb3NpdG9yeT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnMob3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgbWFuaWZlc3RQYXRoOiAnQ2FyZ28udG9tbCcsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyByZW5hbWUgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHsgcmVzb2x2ZSwgam9pbiB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VUb21sLCBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5VG9tbCB9IGZyb20gJ0BzdGQvdG9tbCdcbmltcG9ydCB7IGxvYWQgYXMgeWFtbFBhcnNlLCBkdW1wIGFzIHlhbWxTdHJpbmdpZnkgfSBmcm9tICdqcy15YW1sJ1xuaW1wb3J0IHsgaXNOaWwsIG1lcmdlLCBvbWl0QnksIHBpY2sgfSBmcm9tICdsb2Rhc2gtZXMnXG5pbXBvcnQgeyBmaW5kVXAgfSBmcm9tICdmaW5kLXVwJ1xuXG5pbXBvcnQgeyBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zLCBSZW5hbWVPcHRpb25zIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcbmltcG9ydCB7IHJlYWRDb25maWcsIHJlYWRGaWxlQXN5bmMsIHdyaXRlRmlsZUFzeW5jIH0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5hbWVQcm9qZWN0KHVzZXJPcHRpb25zOiBSZW5hbWVPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zKHVzZXJPcHRpb25zKVxuICBjb25zdCBuYXBpQ29uZmlnID0gYXdhaXQgcmVhZENvbmZpZyhvcHRpb25zKVxuICBjb25zdCBvbGROYW1lID0gbmFwaUNvbmZpZy5iaW5hcnlOYW1lXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IGNhcmdvVG9tbFBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm1hbmlmZXN0UGF0aClcblxuICBjb25zdCBwYWNrYWdlSnNvbkNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhY2thZ2VKc29uUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBwYWNrYWdlSnNvbkRhdGEgPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uQ29udGVudClcblxuICBtZXJnZShcbiAgICBwYWNrYWdlSnNvbkRhdGEsXG4gICAgb21pdEJ5KHBpY2sob3B0aW9ucywgWyduYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ2F1dGhvcicsICdsaWNlbnNlJ10pLCBpc05pbCksXG4gICAge1xuICAgICAgbmFwaTogb21pdEJ5KFxuICAgICAgICB7XG4gICAgICAgICAgYmluYXJ5TmFtZTogb3B0aW9ucy5iaW5hcnlOYW1lLFxuICAgICAgICAgIHBhY2thZ2VOYW1lOiBvcHRpb25zLnBhY2thZ2VOYW1lLFxuICAgICAgICB9LFxuICAgICAgICBpc05pbCxcbiAgICAgICksXG4gICAgfSxcbiAgKVxuXG4gIGlmIChvcHRpb25zLmNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKVxuICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGNvbmZpZ1BhdGgsICd1dGY4JylcbiAgICBjb25zdCBjb25maWdEYXRhID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgIGNvbmZpZ0RhdGEuYmluYXJ5TmFtZSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgIGNvbmZpZ0RhdGEucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2VOYW1lXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoY29uZmlnUGF0aCwgSlNPTi5zdHJpbmdpZnkoY29uZmlnRGF0YSwgbnVsbCwgMikpXG4gIH1cblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb25EYXRhLCBudWxsLCAyKSxcbiAgKVxuXG4gIGNvbnN0IHRvbWxDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCAndXRmOCcpXG4gIGNvbnN0IGNhcmdvVG9tbCA9IHBhcnNlVG9tbCh0b21sQ29udGVudCkgYXMgYW55XG5cbiAgLy8gVXBkYXRlIHRoZSBwYWNrYWdlIG5hbWVcbiAgaWYgKGNhcmdvVG9tbC5wYWNrYWdlICYmIG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIC8vIFNhbml0aXplIHRoZSBiaW5hcnkgbmFtZSBmb3IgUnVzdCBwYWNrYWdlIG5hbWluZyBjb252ZW50aW9uc1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICAgIC5yZXBsYWNlKCdAJywgJycpXG4gICAgICAucmVwbGFjZSgnLycsICdfJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgY2FyZ29Ub21sLnBhY2thZ2UubmFtZSA9IHNhbml0aXplZE5hbWVcbiAgfVxuXG4gIC8vIFN0cmluZ2lmeSB0aGUgdXBkYXRlZCBUT01MXG4gIGNvbnN0IHVwZGF0ZWRUb21sQ29udGVudCA9IHN0cmluZ2lmeVRvbWwoY2FyZ29Ub21sKVxuXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNhcmdvVG9tbFBhdGgsIHVwZGF0ZWRUb21sQ29udGVudClcbiAgaWYgKG9sZE5hbWUgIT09IG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNQYXRoID0gYXdhaXQgZmluZFVwKCcuZ2l0aHViJywge1xuICAgICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgIH0pXG4gICAgaWYgKGdpdGh1YkFjdGlvbnNQYXRoKSB7XG4gICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoID0gam9pbihcbiAgICAgICAgZ2l0aHViQWN0aW9uc1BhdGgsXG4gICAgICAgICd3b3JrZmxvd3MnLFxuICAgICAgICAnQ0kueW1sJyxcbiAgICAgIClcbiAgICAgIGlmIChleGlzdHNTeW5jKGdpdGh1YkFjdGlvbnNDSVltbFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICd1dGY4JyxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zRGF0YSA9IHlhbWxQYXJzZShnaXRodWJBY3Rpb25zQ29udGVudCkgYXMgYW55XG4gICAgICAgIGlmIChnaXRodWJBY3Rpb25zRGF0YS5lbnY/LkFQUF9OQU1FKSB7XG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0RhdGEuZW52LkFQUF9OQU1FID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICAgeWFtbFN0cmluZ2lmeShnaXRodWJBY3Rpb25zRGF0YSwge1xuICAgICAgICAgICAgICBsaW5lV2lkdGg6IC0xLFxuICAgICAgICAgICAgICBub1JlZnM6IHRydWUsXG4gICAgICAgICAgICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbGRXYXNpQnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgaWYgKGV4aXN0c1N5bmMob2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJpbmRpbmdQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgYCR7b2xkTmFtZX0ud2FzaS5janNgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJpbmRpbmdQYXRoLFxuICAgICAgICBqb2luKG9wdGlvbnMuY3dkLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgJy5naXRhdHRyaWJ1dGVzJylcbiAgICBpZiAoZXhpc3RzU3luYyhnaXRBdHRyaWJ1dGVzUGF0aCkpIHtcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgZ2l0QXR0cmlidXRlc1BhdGgsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNEYXRhID0gZ2l0QXR0cmlidXRlc0NvbnRlbnRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICBgJHtvbGROYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgICBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAucmVwbGFjZShgJHtvbGROYW1lfS53YXNpLmNqc2AsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGdpdEF0dHJpYnV0ZXNQYXRoLCBnaXRBdHRyaWJ1dGVzRGF0YSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWMsIGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnbm9kZTpmcydcblxuaW1wb3J0IHsgbG9hZCBhcyB5YW1sTG9hZCwgZHVtcCBhcyB5YW1sRHVtcCB9IGZyb20gJ2pzLXlhbWwnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMsXG4gIE5ld09wdGlvbnMgYXMgUmF3TmV3T3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgbWtkaXJBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBzdGF0QXN5bmMsXG4gIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi9yZW5hbWUuanMnXG5cbi8vIFRlbXBsYXRlIGltcG9ydHMgcmVtb3ZlZCBhcyB3ZSdyZSBub3cgdXNpbmcgZXh0ZXJuYWwgdGVtcGxhdGVzXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG50eXBlIE5ld09wdGlvbnMgPSBSZXF1aXJlZDxSYXdOZXdPcHRpb25zPlxuXG5jb25zdCBURU1QTEFURV9SRVBPUyA9IHtcbiAgeWFybjogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUnLFxuICBwbnBtOiAnaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvcGFja2FnZS10ZW1wbGF0ZS1wbnBtJyxcbn0gYXMgY29uc3RcblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tHaXRDb21tYW5kKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCAtLXZlcnNpb24nKVxuICAgICAgY3Aub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGZhbHNlKVxuICAgICAgfSlcbiAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUNhY2hlRGlyKFxuICBwYWNrYWdlTWFuYWdlcjogU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBjYWNoZURpciA9IHBhdGguam9pbihob21lZGlyKCksICcubmFwaS1ycycsICd0ZW1wbGF0ZScsIHBhY2thZ2VNYW5hZ2VyKVxuICBhd2FpdCBta2RpckFzeW5jKGNhY2hlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICByZXR1cm4gY2FjaGVEaXJcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRUZW1wbGF0ZShcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuICBjYWNoZURpcjogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9VcmwgPSBURU1QTEFURV9SRVBPU1twYWNrYWdlTWFuYWdlcl1cbiAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG5cbiAgaWYgKGV4aXN0c1N5bmModGVtcGxhdGVQYXRoKSkge1xuICAgIGRlYnVnKGBUZW1wbGF0ZSBjYWNoZSBmb3VuZCBhdCAke3RlbXBsYXRlUGF0aH0sIHVwZGF0aW5nLi4uYClcbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggbGF0ZXN0IGNoYW5nZXMgYW5kIHJlc2V0IHRvIHJlbW90ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjcCA9IGV4ZWMoJ2dpdCBmZXRjaCBvcmlnaW4nLCB7IGN3ZDogdGVtcGxhdGVQYXRoIH0pXG4gICAgICAgIGNwLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgY3Aub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBsYXRlc3QgY2hhbmdlcywgZ2l0IHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgZXhlY1N5bmMoJ2dpdCByZXNldCAtLWhhcmQgb3JpZ2luL21haW4nLCB7XG4gICAgICAgIGN3ZDogdGVtcGxhdGVQYXRoLFxuICAgICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgICB9KVxuICAgICAgZGVidWcoJ1RlbXBsYXRlIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGU6ICR7ZXJyb3J9YClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSB0ZW1wbGF0ZSBmcm9tICR7cmVwb1VybH06ICR7ZXJyb3J9YClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoYENsb25pbmcgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9Li4uYClcbiAgICB0cnkge1xuICAgICAgZXhlY1N5bmMoYGdpdCBjbG9uZSAke3JlcG9Vcmx9IHJlcG9gLCB7IGN3ZDogY2FjaGVEaXIsIHN0ZGlvOiAnaW5oZXJpdCcgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSBjbG9uZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2xvbmUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlEaXJlY3RvcnkoXG4gIHNyYzogc3RyaW5nLFxuICBkZXN0OiBzdHJpbmcsXG4gIGluY2x1ZGVXYXNpQmluZGluZ3M6IGJvb2xlYW4sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgbWtkaXJBc3luYyhkZXN0LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihzcmMsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuXG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGNvbnN0IHNyY1BhdGggPSBwYXRoLmpvaW4oc3JjLCBlbnRyeS5uYW1lKVxuICAgIGNvbnN0IGRlc3RQYXRoID0gcGF0aC5qb2luKGRlc3QsIGVudHJ5Lm5hbWUpXG5cbiAgICAvLyBTa2lwIC5naXQgZGlyZWN0b3J5XG4gICAgaWYgKGVudHJ5Lm5hbWUgPT09ICcuZ2l0Jykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShzcmNQYXRoLCBkZXN0UGF0aCwgaW5jbHVkZVdhc2lCaW5kaW5ncylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICAhaW5jbHVkZVdhc2lCaW5kaW5ncyAmJlxuICAgICAgICAoZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2ktYnJvd3Nlci5qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnLndhc2kuY2pzJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5icm93c2VyLm1qcyAnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ3dhc2ktd29ya2VyLm1qcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnYnJvd3Nlci5qcycpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBhd2FpdCBmcy5jb3B5RmlsZShzcmNQYXRoLCBkZXN0UGF0aClcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24oXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShjb250ZW50KVxuXG4gIC8vIEZpbHRlciBuYXBpLnRhcmdldHNcbiAgaWYgKHBhY2thZ2VKc29uLm5hcGk/LnRhcmdldHMpIHtcbiAgICBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMgPSBwYWNrYWdlSnNvbi5uYXBpLnRhcmdldHMuZmlsdGVyKFxuICAgICAgKHRhcmdldDogc3RyaW5nKSA9PiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpLFxuICAgIClcbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb24sIG51bGwsIDIpICsgJ1xcbicpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGVuYWJsZWRUYXJnZXRzOiBzdHJpbmdbXSxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpXG4gIGNvbnN0IHlhbWwgPSB5YW1sTG9hZChjb250ZW50KSBhcyBhbnlcblxuICBjb25zdCBtYWNPU0FuZFdpbmRvd3NUYXJnZXRzID0gbmV3IFNldChbXG4gICAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICAgJ3g4Nl82NC1hcHBsZS1kYXJ3aW4nLFxuICBdKVxuXG4gIGNvbnN0IGxpbnV4VGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICd4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAgICdhcm12Ny11bmtub3duLWxpbnV4LW11c2xlYWJpaGYnLFxuICAgICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICBdKVxuXG4gIC8vIENoZWNrIGlmIGFueSBMaW51eCB0YXJnZXRzIGFyZSBlbmFibGVkXG4gIGNvbnN0IGhhc0xpbnV4VGFyZ2V0cyA9IGVuYWJsZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT5cbiAgICBsaW51eFRhcmdldHMuaGFzKHRhcmdldCksXG4gIClcblxuICAvLyBGaWx0ZXIgdGhlIG1hdHJpeCBjb25maWd1cmF0aW9ucyBpbiB0aGUgYnVpbGQgam9iXG4gIGlmICh5YW1sPy5qb2JzPy5idWlsZD8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3MpIHtcbiAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgIHlhbWwuam9icy5idWlsZC5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MuZmlsdGVyKChzZXR0aW5nOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICB9XG5cbiAgY29uc3Qgam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKGVuYWJsZWRUYXJnZXRzLmV2ZXJ5KCh0YXJnZXQpID0+ICFtYWNPU0FuZFdpbmRvd3NUYXJnZXRzLmhhcyh0YXJnZXQpKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nIGpvYlxuICAgIGlmIChcbiAgICAgIHlhbWw/LmpvYnM/LlsndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3NcbiAgICApIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXS5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MgPVxuICAgICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcihcbiAgICAgICAgICAoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZCwgcmVtb3ZlIExpbnV4LXNwZWNpZmljIGpvYnNcbiAgaWYgKCFoYXNMaW51eFRhcmdldHMpIHtcbiAgICAvLyBSZW1vdmUgdGVzdC1saW51eC1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddKSB7XG4gICAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1saW51eC1iaW5kaW5nJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbGludXgteDY0LWdudS1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddPy5zdHJhdGVneT8ubWF0cml4Py50YXJnZXQpIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1saW51eC1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnRhcmdldCA9IHlhbWwuam9ic1tcbiAgICAgICAgJ3Rlc3QtbGludXgtYmluZGluZydcbiAgICAgIF0uc3RyYXRlZ3kubWF0cml4LnRhcmdldC5maWx0ZXIoKHRhcmdldDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghZW5hYmxlZFRhcmdldHMuaW5jbHVkZXMoJ3dhc20zMi13YXNpcDEtdGhyZWFkcycpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3Qtd2FzaScpXG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJykpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgnYnVpbGQtZnJlZWJzZCcpXG4gIH1cblxuICAvLyBGaWx0ZXIgb3RoZXIgdGVzdCBqb2JzIGJhc2VkIG9uIHRhcmdldFxuICBmb3IgKGNvbnN0IFtqb2JOYW1lLCBqb2JDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHlhbWwuam9icyB8fCB7fSkpIHtcbiAgICBpZiAoXG4gICAgICBqb2JOYW1lLnN0YXJ0c1dpdGgoJ3Rlc3QtJykgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZydcbiAgICApIHtcbiAgICAgIC8vIEV4dHJhY3QgdGFyZ2V0IGZyb20gam9iIG5hbWUgb3IgY29uZmlnXG4gICAgICBjb25zdCBqb2IgPSBqb2JDb25maWcgYXMgYW55XG4gICAgICBpZiAoam9iLnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzPy5bMF0/LnRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBqb2Iuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzWzBdLnRhcmdldFxuICAgICAgICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICBqb2JzVG9SZW1vdmUucHVzaChqb2JOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGpvYnMgZm9yIGRpc2FibGVkIHRhcmdldHNcbiAgZm9yIChjb25zdCBqb2JOYW1lIG9mIGpvYnNUb1JlbW92ZSkge1xuICAgIGRlbGV0ZSB5YW1sLmpvYnNbam9iTmFtZV1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHlhbWwuam9icz8ucHVibGlzaD8ubmVlZHMpKSB7XG4gICAgeWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMgPSB5YW1sLmpvYnMucHVibGlzaC5uZWVkcy5maWx0ZXIoXG4gICAgICAobmVlZDogc3RyaW5nKSA9PiAham9ic1RvUmVtb3ZlLmluY2x1ZGVzKG5lZWQpLFxuICAgIClcbiAgfVxuXG4gIC8vIFdyaXRlIGJhY2sgdGhlIGZpbHRlcmVkIFlBTUxcbiAgY29uc3QgdXBkYXRlZFlhbWwgPSB5YW1sRHVtcCh5YW1sLCB7XG4gICAgbGluZVdpZHRoOiAtMSxcbiAgICBub1JlZnM6IHRydWUsXG4gICAgc29ydEtleXM6IGZhbHNlLFxuICB9KVxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIHVwZGF0ZWRZYW1sKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdQcm9jZXNzaW5nIG9wdGlvbnMuLi4nKVxuICBpZiAoIW9wdGlvbnMucGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIHBhdGggYXMgdGhlIGFyZ3VtZW50JylcbiAgfVxuICBvcHRpb25zLnBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgb3B0aW9ucy5wYXRoKVxuICBkZWJ1ZyhgUmVzb2x2ZWQgdGFyZ2V0IHBhdGggdG86ICR7b3B0aW9ucy5wYXRofWApXG5cbiAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICBvcHRpb25zLm5hbWUgPSBwYXRoLnBhcnNlKG9wdGlvbnMucGF0aCkuYmFzZVxuICAgIGRlYnVnKGBObyBwcm9qZWN0IG5hbWUgcHJvdmlkZWQsIGZpeCBpdCB0byBkaXIgbmFtZTogJHtvcHRpb25zLm5hbWV9YClcbiAgfVxuXG4gIGlmICghb3B0aW9ucy50YXJnZXRzPy5sZW5ndGgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBbGxUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBBVkFJTEFCTEVfVEFSR0VUUy5jb25jYXQoKVxuICAgICAgZGVidWcoJ0VuYWJsZSBhbGwgdGFyZ2V0cycpXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVuYWJsZURlZmF1bHRUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBERUZBVUxUX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgZGVmYXVsdCB0YXJnZXRzJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdGFyZ2V0IG11c3QgYmUgZW5hYmxlZCcpXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBvcHRpb25zLnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJylcbiAgKSB7XG4gICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYHJ1c3R1cCB0YXJnZXQgbGlzdGAsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgfSlcbiAgICBpZiAob3V0LmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gb3B0aW9ucy50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PlxuICAgICAgICB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJ1xuICAgICAgICAgID8gJ3dhc20zMi13YXNpcDEtdGhyZWFkcydcbiAgICAgICAgICA6IHRhcmdldCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zKSBhcyBOZXdPcHRpb25zXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdQcm9qZWN0KHVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdXaWxsIGNyZWF0ZSBuYXBpLXJzIHByb2plY3Qgd2l0aCBnaXZlbiBvcHRpb25zOicpXG4gIGRlYnVnKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBkZWJ1ZygnVGFyZ2V0cyB0byBiZSBlbmFibGVkOicpXG4gIGRlYnVnKG9wdGlvbnMudGFyZ2V0cylcblxuICAvLyBDaGVjayBpZiBnaXQgaXMgYXZhaWxhYmxlXG4gIGlmICghKGF3YWl0IGNoZWNrR2l0Q29tbWFuZCgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHaXQgaXMgbm90IGluc3RhbGxlZCBvciBub3QgYXZhaWxhYmxlIGluIFBBVEguIFBsZWFzZSBpbnN0YWxsIEdpdCB0byBjb250aW51ZS4nLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VNYW5hZ2VyID0gb3B0aW9ucy5wYWNrYWdlTWFuYWdlciBhcyBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlclxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cyBhbmQgaXMgZW1wdHlcbiAgYXdhaXQgZW5zdXJlUGF0aChvcHRpb25zLnBhdGgsIG9wdGlvbnMuZHJ5UnVuKVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgLy8gRG93bmxvYWQgb3IgdXBkYXRlIHRlbXBsYXRlXG4gICAgICBjb25zdCBjYWNoZURpciA9IGF3YWl0IGVuc3VyZUNhY2hlRGlyKHBhY2thZ2VNYW5hZ2VyKVxuICAgICAgYXdhaXQgZG93bmxvYWRUZW1wbGF0ZShwYWNrYWdlTWFuYWdlciwgY2FjaGVEaXIpXG5cbiAgICAgIC8vIENvcHkgdGVtcGxhdGUgZmlsZXMgdG8gdGFyZ2V0IGRpcmVjdG9yeVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG4gICAgICBhd2FpdCBjb3B5RGlyZWN0b3J5KFxuICAgICAgICB0ZW1wbGF0ZVBhdGgsXG4gICAgICAgIG9wdGlvbnMucGF0aCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSxcbiAgICAgIClcblxuICAgICAgLy8gUmVuYW1lIHByb2plY3QgdXNpbmcgdGhlIHJlbmFtZSBBUElcbiAgICAgIGF3YWl0IHJlbmFtZVByb2plY3Qoe1xuICAgICAgICBjd2Q6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICBiaW5hcnlOYW1lOiBnZXRCaW5hcnlOYW1lKG9wdGlvbnMubmFtZSksXG4gICAgICB9KVxuXG4gICAgICAvLyBGaWx0ZXIgdGFyZ2V0cyBpbiBwYWNrYWdlLmpzb25cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICdwYWNrYWdlLmpzb24nKVxuICAgICAgaWYgKGV4aXN0c1N5bmMocGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgICBhd2FpdCBmaWx0ZXJUYXJnZXRzSW5QYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gR2l0SHViIEFjdGlvbnMgQ0lcbiAgICAgIGNvbnN0IGNpUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICcuZ2l0aHViJywgJ3dvcmtmbG93cycsICdDSS55bWwnKVxuICAgICAgaWYgKGV4aXN0c1N5bmMoY2lQYXRoKSAmJiBvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luR2l0aHViQWN0aW9ucyhjaVBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMgJiZcbiAgICAgICAgZXhpc3RzU3luYyhwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFJlbW92ZSAuZ2l0aHViIGRpcmVjdG9yeSBpZiBHaXRIdWIgQWN0aW9ucyBpcyBub3QgZW5hYmxlZFxuICAgICAgICBhd2FpdCBmcy5ybShwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpLCB7XG4gICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGFja2FnZS5qc29uIHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uc1xuICAgICAgY29uc3QgcGtnSnNvbkNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShwYWNrYWdlSnNvblBhdGgsICd1dGYtOCcpXG4gICAgICBjb25zdCBwa2dKc29uID0gSlNPTi5wYXJzZShwa2dKc29uQ29udGVudClcblxuICAgICAgLy8gVXBkYXRlIGVuZ2luZSByZXF1aXJlbWVudFxuICAgICAgaWYgKCFwa2dKc29uLmVuZ2luZXMpIHtcbiAgICAgICAgcGtnSnNvbi5lbmdpbmVzID0ge31cbiAgICAgIH1cbiAgICAgIHBrZ0pzb24uZW5naW5lcy5ub2RlID0gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG9wdGlvbnMubWluTm9kZUFwaVZlcnNpb24pXG5cbiAgICAgIC8vIFVwZGF0ZSBsaWNlbnNlIGlmIGRpZmZlcmVudCBmcm9tIHRlbXBsYXRlXG4gICAgICBpZiAob3B0aW9ucy5saWNlbnNlICYmIHBrZ0pzb24ubGljZW5zZSAhPT0gb3B0aW9ucy5saWNlbnNlKSB7XG4gICAgICAgIHBrZ0pzb24ubGljZW5zZSA9IG9wdGlvbnMubGljZW5zZVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGVzdCBmcmFtZXdvcmsgaWYgbmVlZGVkXG4gICAgICBpZiAob3B0aW9ucy50ZXN0RnJhbWV3b3JrICE9PSAnYXZhJykge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IGxvZ2ljIHRvIHVwZGF0ZSB0ZXN0IHNjcmlwdHMgYW5kIGRlcGVuZGVuY2llc1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgVGVzdCBmcmFtZXdvcmsgJHtvcHRpb25zLnRlc3RGcmFtZXdvcmt9IHJlcXVlc3RlZCBidXQgbm90IHlldCBpbXBsZW1lbnRlZGAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHBrZ0pzb24sIG51bGwsIDIpICsgJ1xcbicsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBwcm9qZWN0OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG5cbiAgZGVidWcoYFByb2plY3QgY3JlYXRlZCBhdDogJHtvcHRpb25zLnBhdGh9YClcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGF0aChwYXRoOiBzdHJpbmcsIGRyeVJ1biA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0QXN5bmMocGF0aCwge30pLmNhdGNoKCgpID0+IHVuZGVmaW5lZClcblxuICAvLyBmaWxlIGRlc2NyaXB0b3IgZXhpc3RzXG4gIGlmIChzdGF0KSB7XG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhdGggJHtwYXRofSBmb3IgY3JlYXRpbmcgbmV3IG5hcGktcnMgcHJvamVjdCBhbHJlYWR5IGV4aXN0cyBhbmQgaXQncyBub3QgYSBkaXJlY3RvcnkuYCxcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocGF0aClcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGVtcHR5LmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWRyeVJ1bikge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSB0YXJnZXQgZGlyZWN0b3J5OiAke3BhdGh9YClcbiAgICAgIGlmICghZHJ5UnVuKSB7XG4gICAgICAgIGF3YWl0IG1rZGlyQXN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lLnNwbGl0KCcvJykucG9wKCkhXG59XG5cbmV4cG9ydCB7IE5ld09wdGlvbnMgfVxuIiwiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBpbnB1dCwgc2VsZWN0LCBjaGVja2JveCwgY29uZmlybSB9IGZyb20gJ0BpbnF1aXJlci9wcm9tcHRzJ1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5pbXBvcnQgeyBuZXdQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL25ldy5qcydcbmltcG9ydCB7IEJhc2VOZXdDb21tYW5kIH0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgVGFyZ2V0VHJpcGxlLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG5leHBvcnQgY2xhc3MgTmV3Q29tbWFuZCBleHRlbmRzIEJhc2VOZXdDb21tYW5kIHtcbiAgaW50ZXJhY3RpdmUgPSBPcHRpb24uQm9vbGVhbignLS1pbnRlcmFjdGl2ZSwtaScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBc2sgcHJvamVjdCBiYXNpYyBpbmZvcm1hdGlvbiBpbnRlcmFjdGl2ZWx5IHdpdGhvdXQganVzdCB1c2luZyB0aGUgZGVmYXVsdC4nLFxuICB9KVxuXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmZldGNoT3B0aW9ucygpXG4gICAgICBhd2FpdCBuZXdQcm9qZWN0KG9wdGlvbnMpXG4gICAgICByZXR1cm4gMFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdGYWlsZWQgdG8gY3JlYXRlIG5ldyBwcm9qZWN0JylcbiAgICAgIGRlYnVnLmVycm9yKGUpXG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hPcHRpb25zKCkge1xuICAgIGNvbnN0IGNtZE9wdGlvbnMgPSBzdXBlci5nZXRPcHRpb25zKClcblxuICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICBjb25zdCB0YXJnZXRQYXRoOiBzdHJpbmcgPSBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgPyBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgOiBhd2FpdCBpbnF1aXJlclByb2plY3RQYXRoKClcbiAgICAgIGNtZE9wdGlvbnMucGF0aCA9IHRhcmdldFBhdGhcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNtZE9wdGlvbnMsXG4gICAgICAgIG5hbWU6IGF3YWl0IHRoaXMuZmV0Y2hOYW1lKHBhdGgucGFyc2UodGFyZ2V0UGF0aCkuYmFzZSksXG4gICAgICAgIG1pbk5vZGVBcGlWZXJzaW9uOiBhd2FpdCB0aGlzLmZldGNoTmFwaVZlcnNpb24oKSxcbiAgICAgICAgdGFyZ2V0czogYXdhaXQgdGhpcy5mZXRjaFRhcmdldHMoKSxcbiAgICAgICAgbGljZW5zZTogYXdhaXQgdGhpcy5mZXRjaExpY2Vuc2UoKSxcbiAgICAgICAgZW5hYmxlVHlwZURlZjogYXdhaXQgdGhpcy5mZXRjaFR5cGVEZWYoKSxcbiAgICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogYXdhaXQgdGhpcy5mZXRjaEdpdGh1YkFjdGlvbnMoKSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21kT3B0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaE5hbWUoZGVmYXVsdE5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuJCRuYW1lID8/XG4gICAgICBpbnB1dCh7XG4gICAgICAgIG1lc3NhZ2U6ICdQYWNrYWdlIG5hbWUgKHRoZSBuYW1lIGZpZWxkIGluIHlvdXIgcGFja2FnZS5qc29uIGZpbGUpJyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdE5hbWUsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hMaWNlbnNlKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGlucHV0KHtcbiAgICAgIG1lc3NhZ2U6ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gICAgICBkZWZhdWx0OiB0aGlzLmxpY2Vuc2UsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hOYXBpVmVyc2lvbigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBzZWxlY3Qoe1xuICAgICAgbWVzc2FnZTogJ01pbmltdW0gbm9kZS1hcGkgdmVyc2lvbiAod2l0aCBub2RlIHZlcnNpb24gcmVxdWlyZW1lbnQpJyxcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgY2hvaWNlczogQXJyYXkuZnJvbSh7IGxlbmd0aDogOCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgbmFtZTogYG5hcGkke2kgKyAxfSAoJHtuYXBpRW5naW5lUmVxdWlyZW1lbnQoaSArIDEpfSlgLFxuICAgICAgICB2YWx1ZTogaSArIDEsXG4gICAgICB9KSksXG4gICAgICAvLyBjaG9pY2UgaW5kZXhcbiAgICAgIGRlZmF1bHQ6IHRoaXMubWluTm9kZUFwaVZlcnNpb24gLSAxLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVGFyZ2V0cygpOiBQcm9taXNlPFRhcmdldFRyaXBsZVtdPiB7XG4gICAgaWYgKHRoaXMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgcmV0dXJuIEFWQUlMQUJMRV9UQVJHRVRTLmNvbmNhdCgpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IGF3YWl0IGNoZWNrYm94KHtcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0Nob29zZSB0YXJnZXQocykgeW91ciBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIHRvJyxcbiAgICAgIGNob2ljZXM6IEFWQUlMQUJMRV9UQVJHRVRTLm1hcCgodGFyZ2V0KSA9PiAoe1xuICAgICAgICBuYW1lOiB0YXJnZXQsXG4gICAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY2hlY2tlZDogREVGQVVMVF9UQVJHRVRTLmluY2x1ZGVzKHRhcmdldCksXG4gICAgICB9KSksXG4gICAgfSlcblxuICAgIHJldHVybiB0YXJnZXRzXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVHlwZURlZigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbmFibGVUeXBlRGVmID0gYXdhaXQgY29uZmlybSh7XG4gICAgICBtZXNzYWdlOiAnRW5hYmxlIHR5cGUgZGVmaW5pdGlvbiBhdXRvLWdlbmVyYXRpb24nLFxuICAgICAgZGVmYXVsdDogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZW5hYmxlVHlwZURlZlxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaEdpdGh1YkFjdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW5hYmxlR2l0aHViQWN0aW9ucyA9IGF3YWl0IGNvbmZpcm0oe1xuICAgICAgbWVzc2FnZTogJ0VuYWJsZSBHaXRodWIgQWN0aW9ucyBDSScsXG4gICAgICBkZWZhdWx0OiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgfSlcblxuICAgIHJldHVybiBlbmFibGVHaXRodWJBY3Rpb25zXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5xdWlyZXJQcm9qZWN0UGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gaW5wdXQoe1xuICAgIG1lc3NhZ2U6ICdUYXJnZXQgcGF0aCB0byBjcmVhdGUgdGhlIHByb2plY3QsIHJlbGF0aXZlIHRvIGN3ZC4nLFxuICB9KS50aGVuKChwYXRoKSA9PiB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gaW5xdWlyZXJQcm9qZWN0UGF0aCgpXG4gICAgfVxuICAgIHJldHVybiBwYXRoXG4gIH0pXG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3ByZS1wdWJsaXNoJ10sIFsncHJlcHVibGlzaCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1VwZGF0ZSBwYWNrYWdlLmpzb24gYW5kIGNvcHkgYWRkb25zIGludG8gcGVyIHBsYXRmb3JtIHBhY2thZ2VzJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXIsLXAnLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICB0YWdTdHlsZSA9IE9wdGlvbi5TdHJpbmcoJy0tdGFnLXN0eWxlLC0tdGFnc3R5bGUsLXQnLCAnbGVybmEnLCB7XG4gICAgZGVzY3JpcHRpb246ICdnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgJyxcbiAgfSlcblxuICBnaFJlbGVhc2UgPSBPcHRpb24uQm9vbGVhbignLS1naC1yZWxlYXNlJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBjcmVhdGUgR2l0SHViIHJlbGVhc2UnLFxuICB9KVxuXG4gIGdoUmVsZWFzZU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWdoLXJlbGVhc2UtbmFtZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0dpdEh1YiByZWxlYXNlIG5hbWUnLFxuICB9KVxuXG4gIGdoUmVsZWFzZUlkPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1naC1yZWxlYXNlLWlkJywge1xuICAgIGRlc2NyaXB0aW9uOiAnRXhpc3RpbmcgR2l0SHViIHJlbGVhc2UgaWQnLFxuICB9KVxuXG4gIHNraXBPcHRpb25hbFB1Ymxpc2ggPSBPcHRpb24uQm9vbGVhbignLS1za2lwLW9wdGlvbmFsLXB1Ymxpc2gnLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBza2lwIG9wdGlvbmFsRGVwZW5kZW5jaWVzIHBhY2thZ2VzIHB1Ymxpc2gnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICB0YWdTdHlsZTogdGhpcy50YWdTdHlsZSxcbiAgICAgIGdoUmVsZWFzZTogdGhpcy5naFJlbGVhc2UsXG4gICAgICBnaFJlbGVhc2VOYW1lOiB0aGlzLmdoUmVsZWFzZU5hbWUsXG4gICAgICBnaFJlbGVhc2VJZDogdGhpcy5naFJlbGVhc2VJZCxcbiAgICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IHRoaXMuc2tpcE9wdGlvbmFsUHVibGlzaCxcbiAgICAgIGRyeVJ1bjogdGhpcy5kcnlSdW4sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHBhY2thZ2UuanNvbiBhbmQgY29weSBhZGRvbnMgaW50byBwZXIgcGxhdGZvcm0gcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVQdWJsaXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgXG4gICAqXG4gICAqIEBkZWZhdWx0ICdsZXJuYSdcbiAgICovXG4gIHRhZ1N0eWxlPzogJ25wbScgfCAnbGVybmEnXG4gIC8qKlxuICAgKiBXaGV0aGVyIGNyZWF0ZSBHaXRIdWIgcmVsZWFzZVxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnaFJlbGVhc2U/OiBib29sZWFuXG4gIC8qKlxuICAgKiBHaXRIdWIgcmVsZWFzZSBuYW1lXG4gICAqL1xuICBnaFJlbGVhc2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBFeGlzdGluZyBHaXRIdWIgcmVsZWFzZSBpZFxuICAgKi9cbiAgZ2hSZWxlYXNlSWQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgc2tpcCBvcHRpb25hbERlcGVuZGVuY2llcyBwYWNrYWdlcyBwdWJsaXNoXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBza2lwT3B0aW9uYWxQdWJsaXNoPzogYm9vbGVhblxuICAvKipcbiAgICogRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyhvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgdGFnU3R5bGU6ICdsZXJuYScsXG4gICAgZ2hSZWxlYXNlOiB0cnVlLFxuICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IGZhbHNlLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VWZXJzaW9uQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyd2ZXJzaW9uJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdVcGRhdGUgdmVyc2lvbiBpbiBjcmVhdGVkIG5wbSBwYWNrYWdlcycsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSB2ZXJzaW9uIGluIGNyZWF0ZWQgbnBtIHBhY2thZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnMob3B0aW9uczogVmVyc2lvbk9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zLCBWZXJzaW9uT3B0aW9ucyB9IGZyb20gJy4uL2RlZi92ZXJzaW9uLmpzJ1xuaW1wb3J0IHtcbiAgcmVhZE5hcGlDb25maWcsXG4gIGRlYnVnRmFjdG9yeSxcbiAgdXBkYXRlUGFja2FnZUpzb24sXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndmVyc2lvbicpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJzaW9uKHVzZXJPcHRpb25zOiBWZXJzaW9uT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnModXNlck9wdGlvbnMpXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgY29uZmlnLnRhcmdldHMpIHtcbiAgICBjb25zdCBwa2dEaXIgPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpciwgdGFyZ2V0LnBsYXRmb3JtQXJjaEFCSSlcblxuICAgIGRlYnVnKGBVcGRhdGUgdmVyc2lvbiB0byAlaSBpbiBbJWldYCwgY29uZmlnLnBhY2thZ2VKc29uLnZlcnNpb24sIHBrZ0RpcilcbiAgICBhd2FpdCB1cGRhdGVQYWNrYWdlSnNvbihqb2luKHBrZ0RpciwgJ3BhY2thZ2UuanNvbicpLCB7XG4gICAgICB2ZXJzaW9uOiBjb25maWcucGFja2FnZUpzb24udmVyc2lvbixcbiAgICB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGV4aXN0c1N5bmMsIHN0YXRTeW5jIH0gZnJvbSAnbm9kZTpmcydcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IE9jdG9raXQgfSBmcm9tICdAb2N0b2tpdC9yZXN0J1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyxcbiAgUHJlUHVibGlzaE9wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7XG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHVwZGF0ZVBhY2thZ2VKc29uLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3ByZS1wdWJsaXNoJylcblxuaW50ZXJmYWNlIFBhY2thZ2VJbmZvIHtcbiAgbmFtZTogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICB0YWc6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlUHVibGlzaCh1c2VyT3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMpIHtcbiAgZGVidWcoJ1JlY2VpdmUgcHJlLXB1Ymxpc2ggb3B0aW9uczonKVxuICBkZWJ1ZygnICAlTycsIHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCB7IHBhY2thZ2VKc29uLCB0YXJnZXRzLCBwYWNrYWdlTmFtZSwgYmluYXJ5TmFtZSwgbnBtQ2xpZW50IH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgICApXG5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2hSZWxlYXNlKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGlmICghb3B0aW9ucy5naFJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHJlcG8sIG93bmVyLCBwa2dJbmZvLCBvY3Rva2l0IH0gPSBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZSwgdmVyc2lvbilcblxuICAgIGlmICghcmVwbyB8fCAhb3duZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9jdG9raXQucmVwb3MuY3JlYXRlUmVsZWFzZSh7XG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgcmVwbyxcbiAgICAgICAgICB0YWdfbmFtZTogcGtnSW5mby50YWcsXG4gICAgICAgICAgbmFtZTogb3B0aW9ucy5naFJlbGVhc2VOYW1lLFxuICAgICAgICAgIHByZXJlbGVhc2U6XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdhbHBoYScpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdiZXRhJykgfHxcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ3JjJyksXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIGBQYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWdfbmFtZTogcGtnSW5mby50YWcgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGNvbnN0IGhlYWRDb21taXQgPSBleGVjU3luYygnZ2l0IGxvZyAtMSAtLXByZXR0eT0lQicsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIH0pLnRyaW0oKVxuXG4gICAgY29uc3QgeyBHSVRIVUJfUkVQT1NJVE9SWSB9ID0gcHJvY2Vzcy5lbnZcbiAgICBpZiAoIUdJVEhVQl9SRVBPU0lUT1JZKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoYEdpdGh1YiByZXBvc2l0b3J5OiAke0dJVEhVQl9SRVBPU0lUT1JZfWApXG4gICAgY29uc3QgW293bmVyLCByZXBvXSA9IEdJVEhVQl9SRVBPU0lUT1JZLnNwbGl0KCcvJylcbiAgICBjb25zdCBvY3Rva2l0ID0gbmV3IE9jdG9raXQoe1xuICAgICAgYXV0aDogcHJvY2Vzcy5lbnYuR0lUSFVCX1RPS0VOLFxuICAgIH0pXG4gICAgbGV0IHBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkXG4gICAgaWYgKG9wdGlvbnMudGFnU3R5bGUgPT09ICdsZXJuYScpIHtcbiAgICAgIGNvbnN0IHBhY2thZ2VzVG9QdWJsaXNoID0gaGVhZENvbW1pdFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lLCBpbmRleCkgPT4gbGluZS5sZW5ndGggJiYgaW5kZXgpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3Vic3RyaW5nKDIpKVxuICAgICAgICAubWFwKHBhcnNlVGFnKVxuXG4gICAgICBwa2dJbmZvID0gcGFja2FnZXNUb1B1Ymxpc2guZmluZChcbiAgICAgICAgKHBrZ0luZm8pID0+IHBrZ0luZm8ubmFtZSA9PT0gcGFja2FnZU5hbWUsXG4gICAgICApXG5cbiAgICAgIGlmICghcGtnSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBObyByZWxlYXNlIGNvbW1pdCBmb3VuZCB3aXRoICR7cGFja2FnZU5hbWV9LCBvcmlnaW5hbCBjb21taXQgaW5mbzogJHtoZWFkQ29tbWl0fWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGtnSW5mbyA9IHtcbiAgICAgICAgdGFnOiBgdiR7dmVyc2lvbn1gLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBuYW1lOiBwYWNrYWdlTmFtZSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgIGF3YWl0IHZlcnNpb24odXNlck9wdGlvbnMpXG4gICAgYXdhaXQgdXBkYXRlUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCB7XG4gICAgICBvcHRpb25hbERlcGVuZGVuY2llczogdGFyZ2V0cy5yZWR1Y2UoXG4gICAgICAgIChkZXBzLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICBkZXBzW2Ake3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YF0gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbiAgICAgICAgICByZXR1cm4gZGVwc1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgICAgKSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgeyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9ID0gb3B0aW9ucy5naFJlbGVhc2VJZFxuICAgID8gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG4gICAgOiBhd2FpdCBjcmVhdGVHaFJlbGVhc2UocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUoXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgYCR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgIClcbiAgICBjb25zdCBleHQgPVxuICAgICAgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbScgPyAnd2FzbScgOiAnbm9kZSdcbiAgICBjb25zdCBmaWxlbmFtZSA9IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0uJHtleHR9YFxuICAgIGNvbnN0IGRzdFBhdGggPSBqb2luKHBrZ0RpciwgZmlsZW5hbWUpXG5cbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICBpZiAoIWV4aXN0c1N5bmMoZHN0UGF0aCkpIHtcbiAgICAgICAgZGVidWcud2FybihgJXMgZG9lc24ndCBleGlzdGAsIGRzdFBhdGgpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5za2lwT3B0aW9uYWxQdWJsaXNoKSB7XG4gICAgICAgIGV4ZWNTeW5jKGAke25wbUNsaWVudH0gcHVibGlzaGAsIHtcbiAgICAgICAgICBjd2Q6IHBrZ0RpcixcbiAgICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5naFJlbGVhc2UgJiYgcmVwbyAmJiBvd25lcikge1xuICAgICAgICBkZWJ1Zy5pbmZvKGBDcmVhdGluZyBHaXRIdWIgcmVsZWFzZSAke3BrZ0luZm8udGFnfWApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVsZWFzZUlkID0gb3B0aW9ucy5naFJlbGVhc2VJZFxuICAgICAgICAgICAgPyBOdW1iZXIob3B0aW9ucy5naFJlbGVhc2VJZClcbiAgICAgICAgICAgIDogKFxuICAgICAgICAgICAgICAgIGF3YWl0IG9jdG9raXQhLnJlcG9zLmdldFJlbGVhc2VCeVRhZyh7XG4gICAgICAgICAgICAgICAgICByZXBvOiByZXBvLFxuICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgICAgICAgdGFnOiBwa2dJbmZvLnRhZyxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApLmRhdGEuaWRcbiAgICAgICAgICBjb25zdCBkc3RGaWxlU3RhdHMgPSBzdGF0U3luYyhkc3RQYXRoKVxuICAgICAgICAgIGNvbnN0IGFzc2V0SW5mbyA9IGF3YWl0IG9jdG9raXQhLnJlcG9zLnVwbG9hZFJlbGVhc2VBc3NldCh7XG4gICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICByZXBvOiByZXBvLFxuICAgICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICByZWxlYXNlX2lkOiByZWxlYXNlSWQsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHsgZm9ybWF0OiAncmF3JyB9LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnY29udGVudC1sZW5ndGgnOiBkc3RGaWxlU3RhdHMuc2l6ZSxcbiAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igb2N0b2tpdCB0eXBlcyBhcmUgd3JvbmdcbiAgICAgICAgICAgIGRhdGE6IGF3YWl0IHJlYWRGaWxlQXN5bmMoZHN0UGF0aCksXG4gICAgICAgICAgfSlcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBHaXRIdWIgcmVsZWFzZSBjcmVhdGVkYClcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBEb3dubG9hZCBVUkw6ICVzYCwgYXNzZXRJbmZvLmRhdGEuYnJvd3Nlcl9kb3dubG9hZF91cmwpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihcbiAgICAgICAgICAgIGBQYXJhbTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgeyBvd25lciwgcmVwbywgdGFnOiBwa2dJbmZvLnRhZywgZmlsZW5hbWU6IGRzdFBhdGggfSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRhZyh0YWc6IHN0cmluZykge1xuICBjb25zdCBzZWdtZW50cyA9IHRhZy5zcGxpdCgnQCcpXG4gIGNvbnN0IHZlcnNpb24gPSBzZWdtZW50cy5wb3AoKSFcbiAgY29uc3QgbmFtZSA9IHNlZ21lbnRzLmpvaW4oJ0AnKVxuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICB2ZXJzaW9uLFxuICAgIHRhZyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4uL2FwaS9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IEJhc2VQcmVQdWJsaXNoQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcblxuZXhwb3J0IGNsYXNzIFByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQmFzZVByZVB1Ymxpc2hDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNvbnN0ICducG0nIHwgJ2xlcm5hJyB0byBzdHJpbmdcbiAgICBhd2FpdCBwcmVQdWJsaXNoKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IEJhc2VSZW5hbWVDb21tYW5kIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcblxuZXhwb3J0IGNsYXNzIFJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBCYXNlUmVuYW1lQ29tbWFuZCB7XG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgYXdhaXQgcmVuYW1lUHJvamVjdCh0aGlzLmdldE9wdGlvbnMoKSlcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VVbml2ZXJzYWxpemVDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3VuaXZlcnNhbGl6ZSddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ29tYmlsZSBidWlsdCBiaW5hcmllcyBpbnRvIG9uZSB1bml2ZXJzYWwgYmluYXJ5JyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBvdXRwdXREaXIgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8nLCAnLi8nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tYmlsZSBidWlsdCBiaW5hcmllcyBpbnRvIG9uZSB1bml2ZXJzYWwgYmluYXJ5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5pdmVyc2FsaXplT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZFxuICAgKlxuICAgKiBAZGVmYXVsdCAnLi8nXG4gICAqL1xuICBvdXRwdXREaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnMob3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG91dHB1dERpcjogJy4vJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgeyBzcGF3blN5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zLFxuICBVbml2ZXJzYWxpemVPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuLi91dGlscy9jb25maWcuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9sb2cuanMnXG5pbXBvcnQgeyBmaWxlRXhpc3RzIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy5qcydcbmltcG9ydCB7IFVuaUFyY2hzQnlQbGF0Zm9ybSB9IGZyb20gJy4uL3V0aWxzL3RhcmdldC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3VuaXZlcnNhbGl6ZScpXG5cbmNvbnN0IHVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+ID0ge1xuICBkYXJ3aW46IChpbnB1dHMsIG91dHB1dCkgPT4ge1xuICAgIHNwYXduU3luYygnbGlwbycsIFsnLWNyZWF0ZScsICctb3V0cHV0Jywgb3V0cHV0LCAuLi5pbnB1dHNdLCB7XG4gICAgICBzdGRpbzogJ2luaGVyaXQnLFxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bml2ZXJzYWxpemVCaW5hcmllcyh1c2VyT3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IHRhcmdldCA9IGNvbmZpZy50YXJnZXRzLmZpbmQoXG4gICAgKHQpID0+IHQucGxhdGZvcm0gPT09IHByb2Nlc3MucGxhdGZvcm0gJiYgdC5hcmNoID09PSAndW5pdmVyc2FsJyxcbiAgKVxuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3QgZm91bmQgaW4gY29uZmlnIWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgc3JjRmlsZXMgPSBVbmlBcmNoc0J5UGxhdGZvcm1bcHJvY2Vzcy5wbGF0Zm9ybV0/Lm1hcCgoYXJjaCkgPT5cbiAgICByZXNvbHZlKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICAgIGAke2NvbmZpZy5iaW5hcnlOYW1lfS4ke3Byb2Nlc3MucGxhdGZvcm19LSR7YXJjaH0ubm9kZWAsXG4gICAgKSxcbiAgKVxuXG4gIGlmICghc3JjRmlsZXMgfHwgIXVuaXZlcnNhbGl6ZXJzW3Byb2Nlc3MucGxhdGZvcm1dKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3Qgc3VwcG9ydGVkLmAsXG4gICAgKVxuICB9XG5cbiAgZGVidWcoYExvb2tpbmcgdXAgc291cmNlIGJpbmFyaWVzIHRvIGNvbWJpbmU6IGApXG4gIGRlYnVnKCcgICVPJywgc3JjRmlsZXMpXG5cbiAgY29uc3Qgc3JjRmlsZUxvb2t1cCA9IGF3YWl0IFByb21pc2UuYWxsKHNyY0ZpbGVzLm1hcCgoZikgPT4gZmlsZUV4aXN0cyhmKSkpXG5cbiAgY29uc3Qgbm90Rm91bmRGaWxlcyA9IHNyY0ZpbGVzLmZpbHRlcigoXywgaSkgPT4gIXNyY0ZpbGVMb29rdXBbaV0pXG5cbiAgaWYgKG5vdEZvdW5kRmlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFNvbWUgYmluYXJ5IGZpbGVzIHdlcmUgbm90IGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KG5vdEZvdW5kRmlsZXMpfWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gcmVzb2x2ZShcbiAgICBvcHRpb25zLmN3ZCxcbiAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICBgJHtjb25maWcuYmluYXJ5TmFtZX0uJHtwcm9jZXNzLnBsYXRmb3JtfS11bml2ZXJzYWwubm9kZWAsXG4gIClcblxuICB1bml2ZXJzYWxpemVyc1twcm9jZXNzLnBsYXRmb3JtXT8uKHNyY0ZpbGVzLCBvdXRwdXQpXG5cbiAgZGVidWcoYFByb2R1Y2VkIHVuaXZlcnNhbCBiaW5hcnk6ICR7b3V0cHV0fWApXG59XG4iLCJpbXBvcnQgeyB1bml2ZXJzYWxpemVCaW5hcmllcyB9IGZyb20gJy4uL2FwaS91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyBCYXNlVW5pdmVyc2FsaXplQ29tbWFuZCB9IGZyb20gJy4uL2RlZi91bml2ZXJzYWxpemUuanMnXG5cbmV4cG9ydCBjbGFzcyBVbml2ZXJzYWxpemVDb21tYW5kIGV4dGVuZHMgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQge1xuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IHVuaXZlcnNhbGl6ZUJpbmFyaWVzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vYXBpL3ZlcnNpb24uanMnXG5pbXBvcnQgeyBCYXNlVmVyc2lvbkNvbW1hbmQgfSBmcm9tICcuLi9kZWYvdmVyc2lvbi5qcydcblxuZXhwb3J0IGNsYXNzIFZlcnNpb25Db21tYW5kIGV4dGVuZHMgQmFzZVZlcnNpb25Db21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCB2ZXJzaW9uKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCIjIS91c3IvYmluL2VudiBub2RlXG5cbmltcG9ydCB7IENsaSB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgQXJ0aWZhY3RzQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHsgQnVpbGRDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9idWlsZC5qcydcbmltcG9ydCB7IENyZWF0ZU5wbURpcnNDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBIZWxwQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvaGVscC5qcydcbmltcG9ydCB7IE5ld0NvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL25ldy5qcydcbmltcG9ydCB7IFByZVB1Ymxpc2hDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IFJlbmFtZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3JlbmFtZS5qcydcbmltcG9ydCB7IFVuaXZlcnNhbGl6ZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IFZlcnNpb25Db21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgQ0xJX1ZFUlNJT04gfSBmcm9tICcuL3V0aWxzL21pc2MuanMnXG5cbmNvbnN0IGNsaSA9IG5ldyBDbGkoe1xuICBiaW5hcnlOYW1lOiAnbmFwaScsXG4gIGJpbmFyeVZlcnNpb246IENMSV9WRVJTSU9OLFxufSlcblxuY2xpLnJlZ2lzdGVyKE5ld0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoQnVpbGRDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKENyZWF0ZU5wbURpcnNDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKEFydGlmYWN0c0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoVW5pdmVyc2FsaXplQ29tbWFuZClcbmNsaS5yZWdpc3RlcihSZW5hbWVDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFByZVB1Ymxpc2hDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFZlcnNpb25Db21tYW5kKVxuY2xpLnJlZ2lzdGVyKEhlbHBDb21tYW5kKVxuXG52b2lkIGNsaS5ydW5FeGl0KHByb2Nlc3MuYXJndi5zbGljZSgyKSlcbiJdLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOF0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBQUEsU0FBU0EsVUFBUSxHQUFHO0FBQ2xCO0FBRUEsU0FBTyxPQUFPLFVBQVVBLFlBQVUscUJBQXFCLFVBQVUsbUJBQW1CLE9BQU8sV0FBVyxTQUFVQyxLQUFHO0FBQ2pILGlCQUFjQTtFQUNmLElBQUcsU0FBVUEsS0FBRztBQUNmLFVBQU9BLE9BQUsscUJBQXFCLFVBQVVBLElBQUUsZ0JBQWdCLFVBQVVBLFFBQU0sT0FBTyxZQUFZLGtCQUFrQkE7RUFDbkgsR0FBRSxPQUFPLFFBQVEsYUFBYSxNQUFNLE9BQU8sUUFBUSxhQUFhLE9BQU8sU0FBUyxVQUFRLEVBQUU7Q0FDNUY7QUFDRCxRQUFPLFVBQVVELFdBQVMsT0FBTyxRQUFRLGFBQWEsTUFBTSxPQUFPLFFBQVEsYUFBYSxPQUFPOzs7Ozs7Q0NUL0YsSUFBSUUsNkJBQWlDO0NBQ3JDLFNBQVNDLGNBQVksR0FBRyxHQUFHO0FBQ3pCLE1BQUksWUFBWSxVQUFRLEVBQUUsS0FBSyxFQUFHLFFBQU87RUFDekMsSUFBSSxJQUFJLEVBQUUsT0FBTztBQUNqQixXQUFTLE1BQU0sR0FBRztHQUNoQixJQUFJLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxVQUFVO0FBQ2pDLE9BQUksWUFBWSxVQUFR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