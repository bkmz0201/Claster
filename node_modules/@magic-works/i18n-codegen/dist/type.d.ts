import type { JsonSourceFile } from 'typescript';
import type { Position } from './utils/position.js';
import type { JSONNode } from './utils/parseJSON.js';
import type { GeneratorList, ParserList } from './json-schema.js';
export { GeneratorList, ParserList } from './json-schema.js';
export interface PluginConfig {
    input: string;
    output: string;
    parser: ParserList;
    generator: GeneratorList;
    generatorOptions?: object;
    parserOptions?: object;
}
export type Parser = (input: ParserInput<any>) => ParseNode<any>;
/** Result is a Map<absolute path, file content> */
export type Generator = (input: GeneratorInput<any, any>) => Map<string, GeneratorResult>;
export type GeneratorResult = string;
export declare class ParserInput<Options> {
    sourceFile: JsonSourceFile;
    readonly originalFile: string;
    readonly parserOptions?: Options | undefined;
    private constructor();
    readonly jsonNode: JSONNode;
    static fromFileSystem<T>(path: string, parserOptions?: T): ParserInput<T>;
}
export declare class GeneratorInput<R extends object, Options> {
    parseResult: R;
    inputPath: string;
    outputBase: string;
    generatorOptions?: Options | undefined;
    constructor(parseResult: R, inputPath: string, outputBase: string, generatorOptions?: Options | undefined);
    relativeToInput(x: string): string;
    relativeToOutput(x: string): string;
    get outputRelativePathToInput(): string;
}
export type StringParseNode<T extends object> = {
    type: 'key';
    position: Position;
    value: string;
    value_position: Position;
} & T;
export type MapParseNode<T extends object> = {
    type: 'object';
    position: Position;
    items: Map<string, ParseNode<T>>;
};
export type ArrayParseNode<T extends object> = {
    type: 'array';
    position: Position;
    items: ParseNode<T>[];
};
export type ParseNode<T extends object> = MapParseNode<T> | ArrayParseNode<T> | StringParseNode<T>;
//# sourceMappingURL=type.d.ts.map